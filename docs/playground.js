var Playground = (function (exports) {
    'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    var StateHistory = /** @class */ (function () {
        function StateHistory(initial, listener) {
            this.history = [];
            this.lastStatus = { canUndo: false, canRedo: false };
            this.history.push(initial);
            this.index = 0;
            this.listener = listener;
        }
        Object.defineProperty(StateHistory.prototype, "canUndo", {
            get: function () {
                return this.index > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StateHistory.prototype, "canRedo", {
            get: function () {
                return this.index < this.history.length - 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StateHistory.prototype, "current", {
            get: function () {
                return this.history[this.index];
            },
            enumerable: false,
            configurable: true
        });
        StateHistory.prototype.push = function (entry) {
            if (entry.text !== this.current.text) {
                this.history.splice(this.index + 1);
                this.history.push(entry);
                this.index = this.history.length - 1;
                this.notify();
            }
            else {
                this.replace(entry);
            }
        };
        StateHistory.prototype.replace = function (entry) {
            this.current.text = entry.text;
            this.current.selectionStart = entry.selectionStart;
            this.current.selectionEnd = entry.selectionEnd;
            this.notify();
        };
        StateHistory.prototype.undo = function () {
            if (!this.canUndo)
                throw new Error('Cannot undo');
            this.index -= 1;
            this.notify();
            return this.history[this.index];
        };
        StateHistory.prototype.redo = function () {
            if (!this.canRedo)
                throw new Error('Cannot redo');
            this.index += 1;
            this.notify();
            return this.current;
        };
        StateHistory.prototype.peek = function () {
            return this.current;
        };
        StateHistory.prototype.reset = function (initialState) {
            this.history = [initialState];
            this.index = 0;
            this.notify();
        };
        StateHistory.prototype.notify = function () {
            var _this = this;
            var status = { canUndo: this.canUndo, canRedo: this.canRedo };
            if (status.canUndo !== this.lastStatus.canUndo || status.canRedo !== this.lastStatus.canRedo) {
                this.lastStatus = status;
                setTimeout(function () { return _this.listener(status); }, 0);
            }
        };
        return StateHistory;
    }());

    var defaultState = {
        'playground-height': 350,
        'resize-divider-1-percent': 20,
        'resize-divider-2-percent': 60,
        'context': '',
        'context-scroll-top': 0,
        'context-selection-start': 0,
        'context-selection-end': 0,
        'lits-code': '',
        'lits-code-scroll-top': 0,
        'lits-code-selection-start': 0,
        'lits-code-selection-end': 0,
        'output': '',
        'output-scroll-top': 0,
        'new-context-name': '',
        'new-context-value': '',
        'debug': false,
        'focused-panel': null,
    };
    var contextHistoryListener;
    var litsCodeHistoryListener;
    var state = __assign({}, defaultState);
    Object.keys(defaultState).forEach(function (key) {
        var value = localStorage.getItem(getStorageKey(key));
        state[key] = typeof value === 'string' ? JSON.parse(value) : defaultState[key];
    });
    var contextHistory = new StateHistory(createContextHistoryEntry(), function (status) {
        contextHistoryListener === null || contextHistoryListener === void 0 ? void 0 : contextHistoryListener(status);
    });
    var litsCodeHistory = new StateHistory(createLitsCodeHistoryEntry(), function (status) {
        litsCodeHistoryListener === null || litsCodeHistoryListener === void 0 ? void 0 : litsCodeHistoryListener(status);
    });
    function createContextHistoryEntry() {
        return {
            text: state.context,
            selectionStart: state['context-selection-start'],
            selectionEnd: state['context-selection-end'],
        };
    }
    function createLitsCodeHistoryEntry() {
        return {
            text: state['lits-code'],
            selectionStart: state['lits-code-selection-start'],
            selectionEnd: state['lits-code-selection-end'],
        };
    }
    function pushHistory() {
        contextHistory.push(createContextHistoryEntry());
        litsCodeHistory.push(createLitsCodeHistoryEntry());
    }
    function setContextHistoryListener(listener) {
        contextHistoryListener = listener;
    }
    function setLitsCodeHistoryListener(listener) {
        litsCodeHistoryListener = listener;
    }
    function saveState(newState, pushToHistory) {
        if (pushToHistory === void 0) { pushToHistory = true; }
        Object.entries(newState).forEach(function (entry) {
            var key = entry[0];
            var value = entry[1];
            setState(key, value);
            localStorage.setItem(getStorageKey(key), JSON.stringify(value));
        });
        if (pushToHistory) {
            pushHistory();
        }
    }
    function setState(key, value) {
        state[key] = value;
    }
    function clearAllStates() {
        localStorage.clear();
        Object.assign(state, defaultState);
        litsCodeHistory.reset(createLitsCodeHistoryEntry());
        contextHistory.reset(createContextHistoryEntry());
    }
    function clearState() {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        keys.forEach(function (key) {
            localStorage.removeItem(getStorageKey(key));
            state[key] = defaultState[key];
        });
        pushHistory();
    }
    function getState(key) {
        return state[key];
    }
    function encodeState() {
        var sharedState = {
            'lits-code': state['lits-code'],
            'context': state.context,
        };
        return btoa(encodeURIComponent(JSON.stringify(sharedState)));
    }
    function applyEncodedState(encodedState) {
        try {
            saveState(JSON.parse(decodeURIComponent(atob(encodedState))), true);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    function undoContext() {
        try {
            var historyEntry = contextHistory.undo();
            saveState({
                'context': historyEntry.text,
                'context-selection-start': historyEntry.selectionStart,
                'context-selection-end': historyEntry.selectionEnd,
            }, false);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function redoContext() {
        try {
            var historyEntry = contextHistory.redo();
            saveState({
                'context': historyEntry.text,
                'context-selection-start': historyEntry.selectionStart,
                'context-selection-end': historyEntry.selectionEnd,
            }, false);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function undoLitsCode() {
        try {
            var historyEntry = litsCodeHistory.undo();
            saveState({
                'lits-code': historyEntry.text,
                'lits-code-selection-start': historyEntry.selectionStart,
                'lits-code-selection-end': historyEntry.selectionEnd,
            }, false);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function redoLitsCode() {
        try {
            var historyEntry = litsCodeHistory.redo();
            saveState({
                'lits-code': historyEntry.text,
                'lits-code-selection-start': historyEntry.selectionStart,
                'lits-code-selection-end': historyEntry.selectionEnd,
            }, false);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function getStorageKey(key) {
        return "playground-".concat(key);
    }

    function isNotNull(value) {
        return value !== null && value !== undefined;
    }
    function assertNotNull(value) {
        if (!isNotNull(value))
            throw new Error('Value is null or undefined');
    }
    function asNotNull(value) {
        assertNotNull(value);
        return value;
    }
    function throttle(func) {
        var openForBusiness = true;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (openForBusiness) {
                requestAnimationFrame(function () { return openForBusiness = true; });
                openForBusiness = false;
                func.apply(this, args);
            }
        };
    }
    function isMac() {
        return navigator.platform.includes('Mac');
    }

    var ctrlKeyTimer = 0;
    var ctrlKeyStarted = null;
    var selectedIndex = null;
    var onCloseCallback = null;
    var previouslyFocusedPanel = getState('focused-panel');
    var searchInput = asNotNull(document.getElementById('search-input'));
    var searchResult = asNotNull(document.getElementById('search-result'));
    var noSearchResult = asNotNull(document.getElementById('no-search-result'));
    var searchOverlay = asNotNull(document.getElementById('search-dialog-overlay'));
    var searchDialog = asNotNull(document.getElementById('search-dialog'));
    searchInput.addEventListener('input', onSearch);
    searchOverlay.addEventListener('click', closeSearch);
    searchDialog.addEventListener('click', function (event) {
        searchInput.focus();
        event.stopPropagation();
    });
    function onClose(callback) {
        onCloseCallback = callback;
    }
    function handleKeyDown(event) {
        var _a;
        if (event.key === 'Control')
            handleCtrlKey();
        if (isOpen()) {
            switch (event.key) {
                case 'Escape':
                    event.preventDefault();
                    if (selectedIndex !== null && selectedIndex > 0)
                        resetSelection();
                    else if (((_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('#search-input')) && searchInput.value)
                        clearSearch();
                    else
                        closeSearch();
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    selectNext();
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    selectPrevious();
                    break;
                case 'PageDown':
                    event.preventDefault();
                    selectPageDown();
                    break;
                case 'PageUp':
                    event.preventDefault();
                    selectPageUp();
                    break;
                case 'Home':
                    event.preventDefault();
                    selectFirst();
                    break;
                case 'End':
                    event.preventDefault();
                    selectLast();
                    break;
                case 'Enter':
                    event.preventDefault();
                    if (typeof selectedIndex === 'number') {
                        var x = searchResult.children[selectedIndex];
                        x === null || x === void 0 ? void 0 : x.click();
                    }
                    break;
                case 'k':
                case 'K':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        openSearch();
                    }
                    break;
                case 'F3':
                    event.preventDefault();
                    openSearch();
                    break;
            }
            return 'stop';
        }
        else {
            switch (event.key) {
                case 'k':
                case 'K':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        openSearch();
                    }
                    break;
                case 'F3':
                    event.preventDefault();
                    openSearch();
                    break;
            }
        }
    }
    function handleCtrlKey() {
        if (ctrlKeyStarted === null) {
            ctrlKeyStarted = Date.now();
            ctrlKeyTimer = window.setTimeout(resetCtrlKey, 400);
        }
        else {
            resetCtrlKey();
            if (isOpen())
                closeSearch();
            else
                openSearch();
        }
    }
    function resetCtrlKey() {
        window.clearTimeout(ctrlKeyTimer);
        ctrlKeyStarted = null;
        ctrlKeyTimer = 0;
    }
    function openSearch() {
        previouslyFocusedPanel = getState('focused-panel');
        searchOverlay.style.display = 'block';
        if (searchResult.children.length === 0)
            updateSearchResult(searchInput.value);
        searchInput.focus();
    }
    function closeSearch() {
        if (searchOverlay.style.display === 'block') {
            searchOverlay.style.display = 'none';
            saveState({ 'focused-panel': previouslyFocusedPanel });
            onCloseCallback === null || onCloseCallback === void 0 ? void 0 : onCloseCallback();
        }
    }
    function isOpen() {
        return searchOverlay.style.display === 'block';
    }
    function clearSearch() {
        searchInput.value = '';
        updateSearchResult('');
    }
    function resetSelection() {
        if (searchInput.value)
            selectedIndex = 0;
        else
            selectedIndex = null;
        updateSelection();
        searchResult.scrollTo(0, 0);
    }
    function updateSelection() {
        Array.from(searchResult.getElementsByClassName('selected'))
            .forEach(function (el) { return el.classList.remove('selected'); });
        if (selectedIndex !== null) {
            var count = searchResult.children.length;
            if (count) {
                if (selectedIndex >= count)
                    selectedIndex = count - 1;
                else if (selectedIndex < 0)
                    selectedIndex = 0;
                var element = searchResult.children[selectedIndex];
                element.classList.add('selected');
                element.scrollIntoView({ block: 'center' });
            }
            else {
                selectedIndex = null;
            }
        }
    }
    function selectPrevious() {
        if (selectedIndex !== null)
            selectedIndex -= 1;
        updateSelection();
    }
    function selectNext() {
        if (selectedIndex !== null)
            selectedIndex += 1;
        else
            selectedIndex = 0;
        updateSelection();
    }
    function selectPageUp() {
        if (selectedIndex !== null)
            selectedIndex -= 10;
        updateSelection();
    }
    function selectPageDown() {
        if (selectedIndex !== null)
            selectedIndex += 10;
        else
            selectedIndex = 10;
        updateSelection();
    }
    function selectFirst() {
        selectedIndex = 0;
        updateSelection();
    }
    function selectLast() {
        selectedIndex = searchResult.children.length - 1;
        updateSelection();
    }
    function onSearch(event) {
        var _a;
        var target = event.target;
        var searchString = (_a = target === null || target === void 0 ? void 0 : target.value) !== null && _a !== void 0 ? _a : '';
        updateSearchResult(searchString);
    }
    function updateSearchResult(searchString) {
        searchResult.style.display = 'none';
        noSearchResult.style.display = 'none';
        searchResult.innerHTML = '';
        // eslint-disable-next-line ts/no-unsafe-member-access
        var searchResults = window.Playground.allSearchResultEntries.filter(function (entry) { return entry.search.toLowerCase().includes(searchString.toLowerCase()); });
        if (searchResults.length === 0) {
            noSearchResult.style.display = 'flex';
        }
        else {
            searchResult.style.display = 'flex';
            searchResult.innerHTML = searchResults.map(function (entry) { return entry.html; }).join('');
        }
        resetSelection();
    }
    var Search = {
        openSearch: openSearch,
        closeSearch: closeSearch,
        clearSearch: clearSearch,
        handleKeyDown: handleKeyDown,
        onClose: onClose,
    };

    function getCodeMarker(sourceCodeInfo) {
        if (!sourceCodeInfo.position || !sourceCodeInfo.code)
            return '';
        var leftPadding = sourceCodeInfo.position.column - 1;
        var rightPadding = sourceCodeInfo.code.length - leftPadding - 1;
        return "".concat(' '.repeat(Math.max(leftPadding, 0)), "^").concat(' '.repeat(Math.max(rightPadding, 0)));
    }

    function getLitsErrorMessage(message, sourceCodeInfo) {
        if (!sourceCodeInfo) {
            return message;
        }
        var location = "".concat(sourceCodeInfo.position.line, ":").concat(sourceCodeInfo.position.column);
        var filePathLine = sourceCodeInfo.filePath
            ? "\n".concat(sourceCodeInfo.filePath, ":").concat(location)
            : "\nLocation ".concat(location);
        var codeLine = "\n".concat(sourceCodeInfo.code);
        var codeMarker = "\n".concat(getCodeMarker(sourceCodeInfo));
        return "".concat(message).concat(filePathLine).concat(codeLine).concat(codeMarker);
    }
    var RecurSignal = /** @class */ (function (_super) {
        __extends(RecurSignal, _super);
        function RecurSignal(params) {
            var _this = _super.call(this, "recur, params: ".concat(params)) || this;
            Object.setPrototypeOf(_this, RecurSignal.prototype);
            _this.name = 'RecurSignal';
            _this.params = params;
            return _this;
        }
        return RecurSignal;
    }(Error));
    var LitsError = /** @class */ (function (_super) {
        __extends(LitsError, _super);
        function LitsError(err, sourceCodeInfo) {
            var _this = this;
            var message = err instanceof Error
                ? err.message
                : "".concat(err);
            _this = _super.call(this, getLitsErrorMessage(message, sourceCodeInfo)) || this;
            _this.shortMessage = message;
            _this.sourceCodeInfo = sourceCodeInfo;
            Object.setPrototypeOf(_this, LitsError.prototype);
            _this.name = 'LitsError';
            return _this;
        }
        LitsError.prototype.getCodeMarker = function () {
            return this.sourceCodeInfo && getCodeMarker(this.sourceCodeInfo);
        };
        return LitsError;
    }(Error));
    var UserDefinedError = /** @class */ (function (_super) {
        __extends(UserDefinedError, _super);
        function UserDefinedError(message, sourceCodeInfo) {
            var _this = _super.call(this, message, sourceCodeInfo) || this;
            _this.userMessage = message;
            Object.setPrototypeOf(_this, UserDefinedError.prototype);
            _this.name = 'UserDefinedError';
            return _this;
        }
        return UserDefinedError;
    }(LitsError));
    var AssertionError = /** @class */ (function (_super) {
        __extends(AssertionError, _super);
        function AssertionError(message, sourceCodeInfo) {
            var _this = _super.call(this, message, sourceCodeInfo) || this;
            Object.setPrototypeOf(_this, AssertionError.prototype);
            _this.name = 'AssertionError';
            return _this;
        }
        return AssertionError;
    }(LitsError));
    var UndefinedSymbolError = /** @class */ (function (_super) {
        __extends(UndefinedSymbolError, _super);
        function UndefinedSymbolError(symbolName, sourceCodeInfo) {
            var _this = this;
            var message = "Undefined symbol '".concat(symbolName, "'.");
            _this = _super.call(this, message, sourceCodeInfo) || this;
            _this.symbol = symbolName;
            Object.setPrototypeOf(_this, UndefinedSymbolError.prototype);
            _this.name = 'UndefinedSymbolError';
            return _this;
        }
        return UndefinedSymbolError;
    }(LitsError));

    var NodeTypes = {
        Number: 1,
        String: 2,
        NormalExpression: 3,
        SpecialExpression: 4,
        UserDefinedSymbol: 5,
        NormalBuiltinSymbol: 6,
        SpecialBuiltinSymbol: 7,
        ReservedSymbol: 8,
        Binding: 9,
        Spread: 10,
    };
    var NodeTypesSet = new Set(Object.values(NodeTypes));
    function getNodeTypeName(type) {
        return Object.keys(NodeTypes).find(function (key) { return NodeTypes[key] === type; });
    }
    // TODO, is this needed?
    function isNodeType(type) {
        return typeof type === 'number' && NodeTypesSet.has(type);
    }
    var functionTypes = [
        'UserDefined',
        'Partial',
        'Comp',
        'Constantly',
        'Juxt',
        'Complement',
        'EveryPred',
        'SomePred',
        'Fnull',
        'Builtin',
        'SpecialBuiltin',
        'NativeJsFunction',
        'Namespace',
    ];
    var functionTypeSet = new Set(functionTypes);
    function isFunctionType(type) {
        return typeof type === 'string' && functionTypeSet.has(type);
    }

    var FUNCTION_SYMBOL = '^^fn^^';
    var REGEXP_SYMBOL = '^^re^^';

    function isLitsFunction$1(func) {
        if (func === null || typeof func !== 'object')
            return false;
        return FUNCTION_SYMBOL in func && 'functionType' in func && isFunctionType(func.functionType);
    }
    function isNode(value) {
        if (!Array.isArray(value) || value.length < 2)
            return false;
        return isNodeType(value[0]);
    }
    function valueToString(value) {
        if (isLitsFunction$1(value))
            // eslint-disable-next-line ts/no-unsafe-member-access
            return "<function ".concat(value.name || '\u03BB', ">");
        if (isNode(value))
            return "".concat(getNodeTypeName(value[0]), "-node");
        if (value === null)
            return 'null';
        if (typeof value === 'object' && value instanceof RegExp)
            return "".concat(value);
        if (typeof value === 'object' && value instanceof Error)
            return value.toString();
        return JSON.stringify(value);
    }

    function getSourceCodeInfo(anyValue, sourceCodeInfo) {
        var _a;
        // eslint-disable-next-line ts/no-unsafe-return, ts/no-unsafe-member-access
        return (_a = anyValue === null || anyValue === void 0 ? void 0 : anyValue.sourceCodeInfo) !== null && _a !== void 0 ? _a : sourceCodeInfo;
    }

    function getAssertionError(typeName, value, sourceCodeInfo) {
        return new LitsError("Expected ".concat(typeName, ", got ").concat(valueToString(value), "."), getSourceCodeInfo(value, sourceCodeInfo));
    }

    function isNonUndefined(value) {
        return value !== undefined;
    }
    function asNonUndefined(value, sourceCodeInfo) {
        assertNonUndefined(value, sourceCodeInfo);
        return value;
    }
    function assertNonUndefined(value, sourceCodeInfo) {
        if (!isNonUndefined(value))
            throw new LitsError('Unexpected undefined', getSourceCodeInfo(value, sourceCodeInfo));
    }
    function isUnknownRecord(value) {
        return value !== null && typeof value === 'object' && !Array.isArray(value);
    }
    function assertUnknownRecord(value, sourceCodeInfo) {
        if (!isUnknownRecord(value)) {
            throw new LitsError("Expected ".concat('UnknownRecord', ", got ").concat(valueToString(value), "."), getSourceCodeInfo(value, sourceCodeInfo));
        }
    }
    function asUnknownRecord(value, sourceCodeInfo) {
        assertUnknownRecord(value, sourceCodeInfo);
        return value;
    }

    function isLitsFunction(value) {
        if (value === null || typeof value !== 'object')
            return false;
        return !!value[FUNCTION_SYMBOL];
    }

    function isAny(value) {
        // TODO weak test
        return value !== undefined;
    }
    function asAny(value, sourceCodeInfo) {
        assertAny(value, sourceCodeInfo);
        return value;
    }
    function assertAny(value, sourceCodeInfo) {
        if (!isAny(value))
            throw getAssertionError('not undefined', value, sourceCodeInfo);
    }
    function isSeq(value) {
        return Array.isArray(value) || typeof value === 'string';
    }
    function asSeq(value, sourceCodeInfo) {
        assertSeq(value, sourceCodeInfo);
        return value;
    }
    function assertSeq(value, sourceCodeInfo) {
        if (!isSeq(value))
            throw getAssertionError('string or array', value, sourceCodeInfo);
    }
    function isObj(value) {
        return !(value === null
            || typeof value !== 'object'
            || Array.isArray(value)
            || value instanceof RegExp
            || isLitsFunction(value)
            || isRegularExpression(value));
    }
    function assertObj(value, sourceCodeInfo) {
        if (!isObj(value))
            throw getAssertionError('object', value, sourceCodeInfo);
    }
    function isColl(value) {
        return isSeq(value) || isObj(value);
    }
    function asColl(value, sourceCodeInfo) {
        assertColl(value, sourceCodeInfo);
        return value;
    }
    function assertColl(value, sourceCodeInfo) {
        if (!isColl(value))
            throw getAssertionError('string, array or object', value, sourceCodeInfo);
    }
    function isRegularExpression(regexp) {
        if (regexp === null || typeof regexp !== 'object')
            return false;
        return !!regexp[REGEXP_SYMBOL];
    }
    function assertRegularExpression(value, sourceCodeInfo) {
        if (!isRegularExpression(value))
            throw getAssertionError('RegularExpression', value, sourceCodeInfo);
    }
    function isStringOrRegularExpression(value) {
        return isRegularExpression(value) || typeof value === 'string';
    }
    function assertStringOrRegularExpression(value, sourceCodeInfo) {
        if (!isStringOrRegularExpression(value))
            throw getAssertionError('string or RegularExpression', value, sourceCodeInfo);
    }
    function isFunctionLike(value) {
        if (typeof value === 'number')
            return true;
        if (isColl(value))
            return true;
        if (isLitsFunction(value))
            return true;
        return false;
    }
    function asFunctionLike(value, sourceCodeInfo) {
        assertFunctionLike(value, sourceCodeInfo);
        return value;
    }
    function assertFunctionLike(value, sourceCodeInfo) {
        if (!isFunctionLike(value))
            throw getAssertionError('FunctionLike', value, sourceCodeInfo);
    }

    function getRangeString(options) {
        var hasUpperAndLowerBound = (typeof options.gt === 'number' || typeof options.gte === 'number')
            && (typeof options.lt === 'number' || typeof options.lte === 'number');
        if (hasUpperAndLowerBound) {
            return "".concat(typeof options.gt === 'number' ? "".concat(options.gt, " < n ") : "".concat(options.gte, " <= n ")).concat(typeof options.lt === 'number' ? "< ".concat(options.lt) : "<= ".concat(options.lte));
        }
        else if (typeof options.gt === 'number' || typeof options.gte === 'number') {
            return "".concat(typeof options.gt === 'number' ? "n > ".concat(options.gt) : "n >= ".concat(options.gte));
        }
        else if (typeof options.lt === 'number' || typeof options.lte === 'number') {
            return "".concat(typeof options.lt === 'number' ? "n < ".concat(options.lt) : "n <= ".concat(options.lte));
        }
        else {
            return '';
        }
    }
    function getSignString(options) {
        return options.positive
            ? 'positive'
            : options.negative
                ? 'negative'
                : options.nonNegative
                    ? 'non negative'
                    : options.nonPositive
                        ? 'non positive'
                        : options.nonZero
                            ? 'non zero'
                            : '';
    }
    function getNumberTypeName(options) {
        if (options.zero)
            return 'zero';
        var sign = getSignString(options);
        var numberType = options.integer ? 'integer' : 'number';
        var finite = options.finite ? 'finite' : '';
        var range = getRangeString(options);
        return [sign, finite, numberType, range].filter(function (x) { return !!x; }).join(' ');
    }
    function isNumber(value, options) {
        if (options === void 0) { options = {}; }
        if (typeof value !== 'number')
            return false;
        if (Number.isNaN(value))
            return false;
        if (options.integer && !Number.isInteger(value))
            return false;
        if (options.finite && !Number.isFinite(value))
            return false;
        if (options.zero && value !== 0)
            return false;
        if (options.nonZero && value === 0)
            return false;
        if (options.positive && value <= 0)
            return false;
        if (options.negative && value >= 0)
            return false;
        if (options.nonPositive && value > 0)
            return false;
        if (options.nonNegative && value < 0)
            return false;
        if (typeof options.gt === 'number' && value <= options.gt)
            return false;
        if (typeof options.gte === 'number' && value < options.gte)
            return false;
        if (typeof options.lt === 'number' && value >= options.lt)
            return false;
        if (typeof options.lte === 'number' && value > options.lte)
            return false;
        return true;
    }
    function assertNumber(value, sourceCodeInfo, options) {
        if (options === void 0) { options = {}; }
        if (!isNumber(value, options)) {
            throw new LitsError("Expected ".concat(getNumberTypeName(options), ", got ").concat(valueToString(value), "."), getSourceCodeInfo(value, sourceCodeInfo));
        }
    }
    function asNumber(value, sourceCodeInfo, options) {
        if (options === void 0) { options = {}; }
        assertNumber(value, sourceCodeInfo, options);
        return value;
    }

    var annotatedArrays = new WeakSet();
    var vectors = new WeakSet();
    var matrices = new WeakSet();
    var grids = new WeakSet();
    function annotate(value) {
        if (!Array.isArray(value)) {
            return value;
        }
        if (annotatedArrays.has(value)) {
            return value;
        }
        isVector(value);
        if (!isMatrix(value)) {
            isGrid(value);
        }
        return value;
    }
    function isVector(vector) {
        if (!Array.isArray(vector)) {
            return false;
        }
        if (vectors.has(vector)) {
            return true;
        }
        if (vector.every(function (elem) { return isNumber(elem); })) {
            annotatedArrays.add(vector);
            vectors.add(vector);
            return true;
        }
        return false;
    }
    function assertVector(vector, sourceCodeInfo) {
        if (!isVector(vector)) {
            throw new LitsError("Expected a vector, but got ".concat(vector), sourceCodeInfo);
        }
    }
    function is2dVector(vector) {
        if (!isVector(vector)) {
            return false;
        }
        return vector.length === 2;
    }
    function assert2dVector(vector, sourceCodeInfo) {
        if (!is2dVector(vector)) {
            throw new LitsError("Expected a 2d vector, but got ".concat(vector), sourceCodeInfo);
        }
    }
    function is3dVector(vector) {
        if (!isVector(vector)) {
            return false;
        }
        return vector.length === 3;
    }
    function assert3dVector(vector, sourceCodeInfo) {
        if (!is3dVector(vector)) {
            throw new LitsError("Expected a 3d vector, but got ".concat(vector), sourceCodeInfo);
        }
    }
    function assertNonEmptyVector(vector, sourceCodeInfo) {
        assertVector(vector, sourceCodeInfo);
        if (vector.length === 0) {
            throw new LitsError("Expected a non empty vector, but got ".concat(vector), sourceCodeInfo);
        }
    }
    function isGrid(grid) {
        var e_1, _a;
        if (!Array.isArray(grid)) {
            return false;
        }
        if (grids.has(grid)) {
            return true;
        }
        if (grid.length === 0) {
            return false;
        }
        if (!Array.isArray(grid[0])) {
            return false;
        }
        var nbrOfCols = grid[0].length;
        try {
            for (var _b = __values(grid.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                if (!Array.isArray(row)) {
                    return false;
                }
                if (row.length !== nbrOfCols) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        annotatedArrays.add(grid);
        grids.add(grid);
        return true;
    }
    function assertGrid(grid, sourceCodeInfo) {
        if (!isGrid(grid)) {
            throw new LitsError("Expected a grid, but got ".concat(grid), sourceCodeInfo);
        }
    }
    function isMatrix(matrix) {
        var e_2, _a;
        if (!Array.isArray(matrix)) {
            return false;
        }
        if (matrices.has(matrix)) {
            return true;
        }
        if (matrix.length === 0) {
            return false;
        }
        if (!Array.isArray(matrix[0])) {
            return false;
        }
        if (matrix[0].length === 0) {
            return false;
        }
        var nbrOfCols = matrix[0].length;
        try {
            for (var _b = __values(matrix.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                if (!Array.isArray(row)) {
                    return false;
                }
                if (row.length !== nbrOfCols) {
                    return false;
                }
                if (row.some(function (cell) { return !isNumber(cell); })) {
                    return false;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        annotatedArrays.add(matrix);
        grids.add(matrix);
        matrices.add(matrix);
        return true;
    }
    function assertMatrix(matrix, sourceCodeInfo) {
        if (!isMatrix(matrix)) {
            throw new LitsError("Expected a matrix, but got ".concat(matrix), sourceCodeInfo);
        }
    }
    function assertSquareMatrix(matrix, sourceCodeInfo) {
        if (!isMatrix(matrix)) {
            throw new LitsError("Expected a matrix, but got ".concat(matrix), sourceCodeInfo);
        }
        if (matrix.length !== matrix[0].length) {
            throw new LitsError("Expected square matrix, but got ".concat(matrix.length, " and ").concat(matrix[0].length), sourceCodeInfo);
        }
    }
    function isSquareMatrix(matrix) {
        if (!isMatrix(matrix)) {
            return false;
        }
        if (matrix.length !== matrix[0].length) {
            return false;
        }
        return true;
    }

    function stringifyValue(value, html) {
        var _a;
        var gt = '>';
        var lt = '<';
        if (isLitsFunction(value)) {
            if (value.functionType === 'Builtin')
                return "".concat(lt, "builtin function ").concat(value.normalBuitinSymbolType).concat(gt);
            else
                return "".concat(lt, "function ").concat((_a = value.n) !== null && _a !== void 0 ? _a : '\u03BB').concat(gt);
        }
        if (value === null)
            return 'null';
        if (typeof value === 'object' && value instanceof Error)
            return value.toString();
        if (typeof value === 'object' && value instanceof RegExp)
            return "".concat(value);
        if (typeof value === 'number') {
            return "".concat(value);
        }
        if (isRegularExpression(value))
            return "/".concat(value.s, "/").concat(value.f);
        if (typeof value === 'string')
            return "\"".concat(value, "\"");
        if (Array.isArray(value) && isMatrix(value))
            return stringifyMatrix(value);
        if (Array.isArray(value) && isVector(value)) {
            if (value.length === 0)
                return '[]';
            if (value.length > 8) {
                return "[\n  ".concat(value.map(function (cell) {
                    return cell;
                }).join(',\n  '), "\n]");
            }
            else {
                return "[".concat(value.map(function (cell) {
                    return cell;
                }).join(', '), "]");
            }
        }
        return JSON.stringify(replaceInfinities(value), null, 2);
    }
    function replaceInfinities(value) {
        var e_1, _a;
        if (value === Number.POSITIVE_INFINITY) {
            return '∞';
        }
        if (value === Number.NEGATIVE_INFINITY) {
            return '-∞';
        }
        if (Array.isArray(value)) {
            return value.map(replaceInfinities);
        }
        if (typeof value === 'object' && value !== null) {
            var result = {};
            try {
                for (var _b = __values(Object.entries(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), key = _d[0], val = _d[1];
                    result[key] = replaceInfinities(val);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        }
        return value;
    }
    function stringifyMatrix(matrix) {
        var padding = matrix.flat().reduce(function (max, cell) { return Math.max(max, "".concat(cell).length); }, 0) + 1;
        var rows = matrix.map(function (row) { return "[".concat(row.map(function (cell) { return "".concat(cell).padStart(padding); }).join(' '), " ]"); });
        return rows.join('\n');
    }

    var specialExpressionTypes = {
        '??': 0,
        '&&': 1,
        '||': 2,
        'array': 3,
        'cond': 4,
        '0_def': 5,
        'defined?': 6,
        // '0_defn': 7,
        'block': 7,
        'doseq': 8,
        '0_lambda': 9,
        'for': 10,
        // 'function': 10,
        'if': 11,
        'let': 12,
        'loop': 13,
        'object': 14,
        'recur': 15,
        'switch': 16,
        'throw': 17,
        'try': 18,
        'unless': 19,
    };

    function isSymbolNode(node) {
        var nodeType = node[0];
        return NodeTypes.UserDefinedSymbol === nodeType
            || NodeTypes.NormalBuiltinSymbol === nodeType
            || NodeTypes.SpecialBuiltinSymbol === nodeType;
    }
    function assertSymbolNode(node, sourceCodeInfo) {
        if (!isSymbolNode(node))
            throw getAssertionError('SymbolNode', node, sourceCodeInfo);
    }
    function isUserDefinedSymbolNode(node) {
        return NodeTypes.UserDefinedSymbol === node[0];
    }
    function asUserDefinedSymbolNode(node, sourceCodeInfo) {
        assertUserDefinedSymbolNode(node, sourceCodeInfo);
        return node;
    }
    function assertUserDefinedSymbolNode(node, sourceCodeInfo) {
        if (!isUserDefinedSymbolNode(node))
            throw getAssertionError('UserDefinedSymbolNode', node, sourceCodeInfo);
    }
    function isNormalBuiltinSymbolNode(node) {
        return NodeTypes.NormalBuiltinSymbol === node[0];
    }
    function isSpecialBuiltinSymbolNode(node) {
        return NodeTypes.SpecialBuiltinSymbol === node[0];
    }
    function isNormalExpressionNode(node) {
        return node[0] === NodeTypes.NormalExpression;
    }
    function isNormalExpressionNodeWithName(node) {
        if (!isNormalExpressionNode(node)) {
            return false;
        }
        return isSymbolNode(node[1][0]);
    }
    function isSpreadNode(node) {
        return node[0] === NodeTypes.Spread;
    }

    var getUndefinedSymbols = function (ast, contextStack, builtin, evaluateNode) {
        var e_1, _a;
        var _b;
        var nodes = Array.isArray(ast)
            ? ast
            : [[NodeTypes.SpecialExpression, [specialExpressionTypes.block, ast.body]]];
        var unresolvedSymbols = new Set();
        try {
            for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
                var subNode = nodes_1_1.value;
                (_b = findUnresolvedSymbolsInNode(subNode, contextStack, builtin, evaluateNode)) === null || _b === void 0 ? void 0 : _b.forEach(function (symbol) { return unresolvedSymbols.add(symbol); });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return unresolvedSymbols;
    };
    function findUnresolvedSymbolsInNode(node, contextStack, builtin, evaluateNode) {
        var e_2, _a;
        var _b, _c;
        var nodeType = node[0];
        switch (nodeType) {
            case NodeTypes.UserDefinedSymbol: {
                var symbolNode = node;
                var lookUpResult = contextStack.lookUp(symbolNode);
                if (lookUpResult === null)
                    return new Set([symbolNode[1]]);
                return null;
            }
            case NodeTypes.NormalBuiltinSymbol:
            case NodeTypes.SpecialBuiltinSymbol:
            case NodeTypes.String:
            case NodeTypes.Number:
            case NodeTypes.ReservedSymbol:
            case NodeTypes.Binding:
                return null;
            case NodeTypes.NormalExpression: {
                var normalExpressionNode = node;
                var unresolvedSymbols_1 = new Set();
                if (isNormalExpressionNodeWithName(normalExpressionNode)) {
                    var _d = __read(normalExpressionNode, 2), _e = __read(_d[1], 1), symbolNode = _e[0];
                    if (isUserDefinedSymbolNode(symbolNode)) {
                        var lookUpResult = contextStack.lookUp(symbolNode);
                        if (lookUpResult === null)
                            unresolvedSymbols_1.add(symbolNode[1]);
                    }
                }
                else {
                    var _f = __read(normalExpressionNode, 2), _g = __read(_f[1], 1), expressionNode = _g[0];
                    (_b = findUnresolvedSymbolsInNode(expressionNode, contextStack, builtin, evaluateNode)) === null || _b === void 0 ? void 0 : _b.forEach(function (symbol) { return unresolvedSymbols_1.add(symbol); });
                }
                try {
                    for (var _h = __values(normalExpressionNode[1][1]), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var subNode = _j.value;
                        (_c = findUnresolvedSymbolsInNode(subNode, contextStack, builtin, evaluateNode)) === null || _c === void 0 ? void 0 : _c.forEach(function (symbol) { return unresolvedSymbols_1.add(symbol); });
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_a = _h.return)) _a.call(_h);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return unresolvedSymbols_1;
            }
            case NodeTypes.SpecialExpression: {
                var specialExpressionNode = node;
                var specialExpressionType = specialExpressionNode[1][0];
                var specialExpression = builtin.specialExpressions[specialExpressionType];
                var castedGetUndefinedSymbols = specialExpression.getUndefinedSymbols;
                return castedGetUndefinedSymbols(specialExpressionNode, contextStack, {
                    getUndefinedSymbols: getUndefinedSymbols,
                    builtin: builtin,
                    evaluateNode: evaluateNode,
                });
            }
            case NodeTypes.Spread:
                return findUnresolvedSymbolsInNode(node[1], contextStack, builtin, evaluateNode);
            /* v8 ignore next 2 */
            default:
                throw new LitsError("Unhandled node type: ".concat(nodeType), node[2]);
        }
    }

    function arityAcceptsMin(arity, nbrOfParams) {
        var min = arity.min;
        if (typeof min === 'number' && nbrOfParams < min) {
            return false;
        }
        return true;
    }
    function getCommonArityFromFunctions(params) {
        return params.reduce(function (acc, param) {
            if (acc === null) {
                return null;
            }
            var arity = (typeof param === 'number' || isColl(param)) ? toFixedArity(1) : param.arity;
            var aMin = arity.min, aMax = arity.max;
            var bMin = acc.min, bMax = acc.max;
            var min = typeof aMin === 'number' && typeof bMin === 'number'
                ? Math.max(aMin, bMin)
                : typeof aMin === 'number' ? aMin : typeof bMin === 'number' ? bMin : undefined;
            var max = typeof aMax === 'number' && typeof bMax === 'number'
                ? Math.min(aMax, bMax)
                : typeof aMax === 'number' ? aMax : typeof bMax === 'number' ? bMax : undefined;
            if (typeof min === 'number' && typeof max === 'number' && min > max) {
                return null;
            }
            return { min: min, max: max };
        }, {});
    }
    function getArityFromFunction(param) {
        return (typeof param === 'number' || isColl(param)) ? toFixedArity(1) : param.arity;
    }
    function assertNumberOfParams(arity, length, sourceCodeInfo) {
        var min = arity.min, max = arity.max;
        if (typeof min === 'number' && length < min) {
            throw new LitsError("Wrong number of arguments, expected at least ".concat(min, ", got ").concat(valueToString(length), "."), sourceCodeInfo);
        }
        if (typeof max === 'number' && length > max) {
            throw new LitsError("Wrong number of arguments, expected at most ".concat(max, ", got ").concat(valueToString(length), "."), sourceCodeInfo);
        }
    }
    function canBeOperator(count) {
        if (typeof count.max === 'number' && count.max < 2) {
            return false;
        }
        if (typeof count.min === 'number' && count.min > 2) {
            return false;
        }
        return true;
    }
    function toFixedArity(arity) {
        return { min: arity, max: arity };
    }

    function getOperatorArgs(a, b) {
        return { a: { type: a }, b: { type: b } };
    }
    var bitwiseNormalExpression = {
        '<<': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], count = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                return num << count;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign({}, getOperatorArgs('integer', 'integer')),
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Shifts $a arithmetically left by $b bit positions.',
                examples: [
                    '1 << 10',
                    '<<(1, 10)',
                    '<<(-4, 2)',
                ],
            },
        },
        '>>': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], count = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                return num >> count;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign({}, getOperatorArgs('integer', 'integer')),
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Shifts $a arithmetically right by $b bit positions.',
                examples: [
                    '2048 >> 10',
                    '>>(2048, 10)',
                    '>>>(-16, 2)',
                    '>>(4, 10)',
                ],
            },
        },
        '>>>': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], count = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                return num >>> count;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign({}, getOperatorArgs('integer', 'integer')),
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Shifts $a arithmetically right by $b bit positions without sign extension.',
                examples: [
                    '-16 >>> 2',
                    '>>>(2048, 10)',
                    '>>>(-16, 2)',
                    '>>>(4, 10)',
                    '>>>(-1, 10)',
                ],
            },
        },
        'bit-not': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), num = _b[0];
                assertNumber(num, sourceCodeInfo, { integer: true });
                return ~num;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: { a: { type: 'integer' } },
                variants: [{ argumentNames: ['a'] }],
                description: 'Returns bitwise `not` of $a.',
                examples: [
                    'bit-not(0)',
                    'bit-not(255)',
                ],
            },
        },
        '&': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo, { integer: true });
                return rest.reduce(function (result, value) {
                    assertNumber(value, sourceCodeInfo, { integer: true });
                    return result & value;
                }, first);
            },
            arity: { min: 2 },
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign(__assign({}, getOperatorArgs('integer', 'integer')), { c: { type: 'integer', rest: true } }),
                variants: [
                    { argumentNames: ['a', 'b'] },
                    { argumentNames: ['a', 'b', 'c'] },
                ],
                description: 'Returns bitwise `and` of all arguments.',
                examples: [
                    '0b0011 & 0b0110',
                    '&(0b0011, 0b0110)',
                    '&(0b0011, 0b0110, 0b1001)',
                ],
            },
        },
        'bit-and-not': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo, { integer: true });
                return rest.reduce(function (result, value) {
                    assertNumber(value, sourceCodeInfo, { integer: true });
                    return result & ~value;
                }, first);
            },
            arity: { min: 2 },
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign(__assign({}, getOperatorArgs('integer', 'integer')), { c: { type: 'integer', rest: true } }),
                variants: [
                    { argumentNames: ['a', 'b'] },
                    { argumentNames: ['a', 'b', 'c'] },
                ],
                description: 'Returns bitwise `and` with complement.',
                examples: [
                    '0b0011 bit-and-not 0b0110',
                    'bit-and-not(0b0011, 0b0110)',
                    'bit-and-not(0b0011, 0b0110, 0b1001)',
                ],
            },
        },
        '|': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo, { integer: true });
                return rest.reduce(function (result, value) {
                    assertNumber(value, sourceCodeInfo, { integer: true });
                    return result | value;
                }, first);
            },
            arity: { min: 2 },
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign(__assign({}, getOperatorArgs('integer', 'integer')), { c: { type: 'integer', rest: true } }),
                variants: [
                    { argumentNames: ['a', 'b'] },
                    { argumentNames: ['a', 'b', 'c'] },
                ],
                description: 'Returns bitwise `or` of all arguments.',
                examples: [
                    '0b0011 | 0b0110',
                    '|(0b0011, 0b0110)',
                    '|(0b1000, 0b0100, 0b0010)',
                ],
            },
        },
        'xor': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo, { integer: true });
                return rest.reduce(function (result, value) {
                    assertNumber(value, sourceCodeInfo, { integer: true });
                    return result ^ value;
                }, first);
            },
            arity: { min: 2 },
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign(__assign({}, getOperatorArgs('integer', 'integer')), { c: { type: 'integer', rest: true } }),
                variants: [
                    { argumentNames: ['a', 'b'] },
                    { argumentNames: ['a', 'b', 'c'] },
                ],
                description: 'Returns bitwise `xor` of all arguments.',
                examples: [
                    '0b0011 xor 0b0110',
                    'xor(0b0011, 0b0110)',
                    'xor(0b11110000, 0b00111100, 0b10101010)',
                ],
            },
        },
        'bit-flip': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], index = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
                var mask = 1 << index;
                return (num ^= mask);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign({}, getOperatorArgs('integer', 'integer')),
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Flips bit number $b.',
                examples: [
                    '0b0011 bit-flip 1',
                    'bit-flip(0b0011, 1)',
                    'bit-flip(0b1100, 1)',
                ],
            },
        },
        'bit-set': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], index = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
                var mask = 1 << index;
                return (num |= mask);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign({}, getOperatorArgs('integer', 'integer')),
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Sets bit number $b.',
                examples: [
                    '0b0010 bit-set 1',
                    'bit-set(0b0011, 1)',
                    'bit-set(0b1100, 1)',
                ],
            },
        },
        'bit-clear': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], index = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
                var mask = 1 << index;
                return (num &= ~mask);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Bitwise',
                returns: { type: 'integer' },
                args: __assign({}, getOperatorArgs('integer', 'integer')),
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Clears bit number $b.',
                examples: [
                    '0b0011 bit-clear 1',
                    'bit-clear(0b0011, 1)',
                    'bit-clear(0b1100, 1)',
                ],
            },
        },
        'bit-test': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], index = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
                var mask = 1 << index;
                return !!(num & mask);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Bitwise',
                returns: { type: 'boolean' },
                args: __assign({}, getOperatorArgs('integer', 'integer')),
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Checks if bit number $b is set.',
                examples: [
                    '0b0011 bit-test 1',
                    'bit-test(0b0011, 1)',
                    'bit-test(0b1100, 1)',
                ],
            },
        },
    };

    function isString(value, options) {
        if (options === void 0) { options = {}; }
        if (typeof value !== 'string')
            return false;
        if (options.nonEmpty && value.length === 0)
            return false;
        if (options.char && value.length !== 1)
            return false;
        return true;
    }
    function assertString(value, sourceCodeInfo, options) {
        if (options === void 0) { options = {}; }
        if (!isString(value, options)) {
            throw getAssertionError("".concat(options.nonEmpty ? 'non empty string' : options.char ? 'character' : 'string'), value, sourceCodeInfo);
        }
    }
    function asString(value, sourceCodeInfo, options) {
        if (options === void 0) { options = {}; }
        assertString(value, sourceCodeInfo, options);
        return value;
    }
    function isStringOrNumber(value) {
        return typeof value === 'string' || typeof value === 'number';
    }
    function asStringOrNumber(value, sourceCodeInfo) {
        assertStringOrNumber(value, sourceCodeInfo);
        return value;
    }
    function assertStringOrNumber(value, sourceCodeInfo) {
        if (!isStringOrNumber(value))
            throw getAssertionError('string or number', value, sourceCodeInfo);
    }

    function collHasKey(coll, key) {
        if (!isColl(coll))
            return false;
        if (typeof coll === 'string' || Array.isArray(coll)) {
            if (!isNumber(key, { integer: true }))
                return false;
            return key >= 0 && key < coll.length;
        }
        return !!Object.getOwnPropertyDescriptor(coll, key);
    }
    function compare(a, b, sourceCodeInfo) {
        assertStringOrNumber(a, sourceCodeInfo);
        assertStringOrNumber(b, sourceCodeInfo);
        if (typeof a === 'string' && typeof b === 'string') {
            return a < b ? -1 : a > b ? 1 : 0;
        }
        if (typeof a === 'number' && typeof b === 'number') {
            return Math.sign((a) - (b));
        }
        throw new LitsError("Cannot compare values of different types: ".concat(typeof a, " and ").concat(typeof b), sourceCodeInfo);
    }
    function deepEqual(a, b, sourceCodeInfo) {
        if (a === b)
            return true;
        if (typeof a === 'number' && typeof b === 'number')
            return approxEqual(a, b);
        if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length)
                return false;
            for (var i = 0; i < a.length; i += 1) {
                if (!deepEqual(asAny(a[i], sourceCodeInfo), asAny(b[i], sourceCodeInfo), sourceCodeInfo))
                    return false;
            }
            return true;
        }
        if (isRegularExpression(a) && isRegularExpression(b))
            return a.s === b.s && a.f === b.f;
        if (isUnknownRecord(a) && isUnknownRecord(b)) {
            var aKeys = Object.keys(a);
            var bKeys = Object.keys(b);
            if (aKeys.length !== bKeys.length)
                return false;
            for (var i = 0; i < aKeys.length; i += 1) {
                var key = asString(aKeys[i], sourceCodeInfo);
                if (!deepEqual(a[key], b[key], sourceCodeInfo))
                    return false;
            }
            return true;
        }
        return false;
    }
    function toNonNegativeInteger(num) {
        return Math.max(0, Math.ceil(num));
    }
    function toAny(value) {
        return (value !== null && value !== void 0 ? value : null);
    }
    function clone(value) {
        if (isObj(value)) {
            return Object.entries(value).reduce(function (result, entry) {
                var _a = __read(entry, 2), key = _a[0], val = _a[1];
                result[key] = clone(val);
                return result;
            }, {});
        }
        if (Array.isArray(value))
            // eslint-disable-next-line ts/no-unsafe-return
            return value.map(function (item) { return clone(item); });
        return value;
    }
    function cloneColl(value) {
        return clone(value);
    }
    function joinSets() {
        var e_1, _a;
        var results = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            results[_i] = arguments[_i];
        }
        var result = new Set();
        try {
            for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
                var symbols = results_1_1.value;
                symbols.forEach(function (symbol) { return result.add(symbol); });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    function addToSet(target, source) {
        source.forEach(function (symbol) { return target.add(symbol); });
    }
    var EPSILON = 1e-10;
    function approxEqual(a, b, epsilon) {
        if (epsilon === void 0) { epsilon = EPSILON; }
        if (a === b) {
            return true;
        }
        var diff = Math.abs(a - b);
        if (a === 0 || b === 0 || diff < epsilon) {
            // Use absolute error for values near zero
            return diff < epsilon;
        }
        var absA = Math.abs(a);
        var absB = Math.abs(b);
        // Use relative error for larger values
        return diff / (absA + absB) < epsilon;
    }
    function approxZero(value) {
        return Math.abs(value) < EPSILON;
    }
    function smartTrim(str, minIndent) {
        var _a, _b;
        if (minIndent === void 0) { minIndent = 0; }
        var lines = str.split('\n');
        while ((_a = lines[0]) === null || _a === void 0 ? void 0 : _a.match(/^\s*$/)) {
            lines.shift(); // Remove leading empty lines
        }
        while ((_b = lines[lines.length - 1]) === null || _b === void 0 ? void 0 : _b.match(/^\s*$/)) {
            lines.pop(); // Remove trailing empty lines
        }
        var indent = lines.reduce(function (acc, line) {
            if (line.match(/^\s*$/))
                return acc; // Skip empty lines
            var lineIndent = line.match(/^\s*/)[0].length;
            return Math.min(acc, lineIndent);
        }, Infinity);
        return lines.map(function (line) { return ' '.repeat(minIndent) + line.slice(indent); }).join('\n').trimEnd();
    }

    // isArray not needed, use Array.isArary
    function asArray(value, sourceCodeInfo) {
        assertArray(value, sourceCodeInfo);
        return value;
    }
    function assertArray(value, sourceCodeInfo) {
        if (!Array.isArray(value))
            throw getAssertionError('array', value, sourceCodeInfo);
    }
    function isStringArray(value) {
        return Array.isArray(value) && value.every(function (v) { return typeof v === 'string'; });
    }
    function assertStringArray(value, sourceCodeInfo) {
        if (!isStringArray(value))
            throw getAssertionError('array of strings', value, sourceCodeInfo);
    }
    function isCharArray(value) {
        return Array.isArray(value) && value.every(function (v) { return typeof v === 'string' && v.length === 1; });
    }
    function assertCharArray(value, sourceCodeInfo) {
        if (!isCharArray(value))
            throw getAssertionError('array of strings', value, sourceCodeInfo);
    }

    function mapObjects(_a) {
        var colls = _a.colls, contextStack = _a.contextStack, executeFunction = _a.executeFunction, fn = _a.fn, sourceCodeInfo = _a.sourceCodeInfo;
        assertObj(colls[0], sourceCodeInfo);
        var keys = Object.keys(colls[0]);
        var params = {};
        colls.forEach(function (obj) {
            assertObj(obj, sourceCodeInfo);
            var objKeys = Object.keys(obj);
            if (objKeys.length !== keys.length) {
                throw new LitsError("All objects must have the same keys. Expected: ".concat(keys.join(', '), ". Found: ").concat(objKeys.join(', ')), sourceCodeInfo);
            }
            if (!objKeys.every(function (key) { return keys.includes(key); })) {
                throw new LitsError("All objects must have the same keys. Expected: ".concat(keys.join(', '), ". Found: ").concat(objKeys.join(', ')), sourceCodeInfo);
            }
            Object.entries(obj).forEach(function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                if (!params[key])
                    params[key] = [];
                params[key].push(value);
            });
        });
        return keys.reduce(function (result, key) {
            result[key] = executeFunction(fn, params[key], contextStack, sourceCodeInfo);
            return result;
        }, {});
    }
    function cloneAndGetMeta(originalColl, keys, sourceCodeInfo) {
        var coll = cloneColl(originalColl);
        var butLastKeys = keys.slice(0, keys.length - 1);
        var innerCollMeta = butLastKeys.reduce(function (result, key) {
            var resultColl = result.coll;
            var newResultColl;
            if (Array.isArray(resultColl)) {
                assertNumber(key, sourceCodeInfo);
                newResultColl = asColl(resultColl[key], sourceCodeInfo);
            }
            else {
                assertObj(resultColl, sourceCodeInfo);
                assertString(key, sourceCodeInfo);
                if (!collHasKey(result.coll, key))
                    resultColl[key] = {};
                newResultColl = asColl(resultColl[key], sourceCodeInfo);
            }
            return { coll: newResultColl, parent: resultColl };
        }, { coll: coll, parent: {} });
        return { coll: coll, innerCollMeta: innerCollMeta };
    }
    function get(coll, key) {
        if (isObj(coll)) {
            if (typeof key === 'string' && collHasKey(coll, key))
                return toAny(coll[key]);
        }
        else {
            if (isNumber(key, { nonNegative: true, integer: true }) && key >= 0 && key < coll.length)
                return toAny(coll[key]);
        }
        return undefined;
    }
    function update(coll, key, fn, params, contextStack, executeFunction, sourceCodeInfo) {
        if (isObj(coll)) {
            assertString(key, sourceCodeInfo);
            var result = __assign({}, coll);
            result[key] = executeFunction(fn, __spreadArray([result[key]], __read(params), false), contextStack, sourceCodeInfo);
            return result;
        }
        else {
            assertNumber(key, sourceCodeInfo);
            var intKey_1 = toNonNegativeInteger(key);
            assertNumber(intKey_1, sourceCodeInfo, { lte: coll.length });
            if (Array.isArray(coll)) {
                var result = coll.map(function (elem, index) {
                    if (intKey_1 === index)
                        return executeFunction(fn, __spreadArray([elem], __read(params), false), contextStack, sourceCodeInfo);
                    return elem;
                });
                if (intKey_1 === coll.length)
                    result[intKey_1] = executeFunction(fn, __spreadArray([undefined], __read(params), false), contextStack, sourceCodeInfo);
                return result;
            }
            else {
                var result = coll.split('').map(function (elem, index) {
                    if (intKey_1 === index) {
                        return asString(executeFunction(fn, __spreadArray([elem], __read(params), false), contextStack, sourceCodeInfo), sourceCodeInfo, {
                            char: true,
                        });
                    }
                    return elem;
                });
                if (intKey_1 === coll.length) {
                    result[intKey_1] = asString(executeFunction(fn, __spreadArray([undefined], __read(params), false), contextStack, sourceCodeInfo), sourceCodeInfo, {
                        char: true,
                    });
                }
                return result.join('');
            }
        }
    }
    function assoc(coll, key, value, sourceCodeInfo) {
        assertColl(coll, sourceCodeInfo);
        assertStringOrNumber(key, sourceCodeInfo);
        if (Array.isArray(coll) || typeof coll === 'string') {
            assertNumber(key, sourceCodeInfo, { integer: true });
            assertNumber(key, sourceCodeInfo, { gte: 0 });
            assertNumber(key, sourceCodeInfo, { lte: coll.length });
            if (typeof coll === 'string') {
                assertString(value, sourceCodeInfo, { char: true });
                return "".concat(coll.slice(0, key)).concat(value).concat(coll.slice(key + 1));
            }
            var copy_1 = __spreadArray([], __read(coll), false);
            copy_1[key] = value;
            return copy_1;
        }
        assertString(key, sourceCodeInfo);
        var copy = __assign({}, coll);
        copy[key] = value;
        return copy;
    }
    var collectionNormalExpression = {
        'filter': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(coll)) {
                    var result = coll.filter(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                    return result;
                }
                if (isString(coll)) {
                    return coll
                        .split('')
                        .filter(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); })
                        .join('');
                }
                return Object.entries(coll)
                    .filter(function (_a) {
                    var _b = __read(_a, 2), value = _b[1];
                    return executeFunction(fn, [value], contextStack, sourceCodeInfo);
                })
                    .reduce(function (result, _a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    result[key] = value;
                    return result;
                }, {});
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Collection',
                returns: { type: 'collection' },
                args: {
                    a: { type: 'collection' },
                    b: { type: 'function' },
                    coll: { type: 'collection' },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['coll', 'fun'] }],
                description: 'Creates a new collection with all elements that pass the test implemented by $fun.',
                examples: [
                    "\nfilter(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                    "\nfilter(\n  [5, 10, 15, 20],\n  -> $ > 10\n)",
                    "\nfilter(\n  { a: 1, b: 2 },\n  odd?\n)",
                ],
            },
        },
        'filteri': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(coll)) {
                    var result = coll.filter(function (elem, index) { return executeFunction(fn, [elem, index], contextStack, sourceCodeInfo); });
                    return result;
                }
                if (isString(coll)) {
                    return coll
                        .split('')
                        .filter(function (elem, index) { return executeFunction(fn, [elem, index], contextStack, sourceCodeInfo); })
                        .join('');
                }
                return Object.entries(coll)
                    .filter(function (_a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    return executeFunction(fn, [value, key], contextStack, sourceCodeInfo);
                })
                    .reduce(function (result, _a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    result[key] = value;
                    return result;
                }, {});
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Collection',
                returns: { type: 'collection' },
                args: {
                    a: { type: 'collection' },
                    b: {
                        type: 'function',
                        description: 'The function to call for each element in the collection. The function should take two arguments: the element itself and the index.',
                    },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Creates a new collection with all elements that pass the test implemented by $b. The function is called for each element in the collection, and it should take two arguments: the element itself and the index.',
                examples: [
                    'filteri([1, 2, 3], (x, i) -> i % 2 == 0)',
                    'filteri([1, 2, 3], (x, i) -> x % 2 == 0)',
                    'filteri([1, 2, 3], (x, i) -> x + i > 3)',
                ],
            },
        },
        'map': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var fn = asFunctionLike(params.at(-1), sourceCodeInfo);
                if (isObj(params[0])) {
                    return mapObjects({
                        colls: params.slice(0, -1),
                        fn: fn,
                        sourceCodeInfo: sourceCodeInfo,
                        contextStack: contextStack,
                        executeFunction: executeFunction,
                    });
                }
                var seqs = params.slice(0, -1);
                assertSeq(seqs[0], sourceCodeInfo);
                var isStr = typeof seqs[0] === 'string';
                var len = seqs[0].length;
                seqs.slice(1).forEach(function (seq) {
                    if (isStr) {
                        assertString(seq, sourceCodeInfo);
                    }
                    else {
                        assertArray(seq, sourceCodeInfo);
                    }
                    len = Math.min(len, seq.length);
                });
                var paramArray = [];
                var _loop_1 = function (i) {
                    paramArray.push(seqs.map(function (seq) { return seq[i]; }));
                };
                for (var i = 0; i < len; i++) {
                    _loop_1(i);
                }
                var mapped = paramArray.map(function (p) { return executeFunction(fn, p, contextStack, sourceCodeInfo); });
                if (!isStr) {
                    return mapped;
                }
                mapped.forEach(function (char) { return assertString(char, sourceCodeInfo); });
                return mapped.join('');
            },
            arity: { min: 2 },
            docs: {
                category: 'Collection',
                returns: { type: 'collection' },
                args: {
                    a: { type: 'collection' },
                    b: { type: 'function' },
                    colls: { type: 'collection', rest: true, description: 'At least one.' },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['colls', 'fun'] }],
                description: 'Creates a new collection populated with the results of calling $fun on every element in $colls.',
                examples: [
                    '[1, 2, 3] map -',
                    '[1, 2, 3] map -> -($)',
                    'map(["Albert", "Mojir", 42], str)',
                    'map([1, 2, 3], inc)',
                    'map([1, 2, 3], [1, 10, 100], *)',
                    'map({ a: 1, b: 2 }, inc)',
                    'map({ a: 1, b: 2 }, { a: 10, b: 20 }, +)',
                ],
            },
        },
        'mapi': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(coll)) {
                    return coll.map(function (elem, index) { return executeFunction(fn, [elem, index], contextStack, sourceCodeInfo); });
                }
                if (isString(coll)) {
                    return coll
                        .split('')
                        .map(function (elem, index) { return executeFunction(fn, [elem, index], contextStack, sourceCodeInfo); })
                        .join('');
                }
                return Object.entries(coll)
                    .reduce(function (acc, _a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    acc[key] = executeFunction(fn, [value, key], contextStack, sourceCodeInfo);
                    return acc;
                }, {});
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Collection',
                returns: { type: 'collection' },
                args: {
                    a: { type: 'collection' },
                    b: {
                        type: 'function',
                        description: 'The function to call for each element in the collection. The function should take two arguments: the element itself and the index.',
                    },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Creates a new collection populated with the results of calling $b on every element in $a. The function is called for each element in the collection, and it should take two arguments: the element itself and the index.',
                examples: [
                    'mapi([1, 2, 3], (x, i) -> x + i)',
                    'mapi([1, 2, 3], (x, i) -> x * i)',
                    'mapi([1, 2, 3], (x, i) -> x - i)',
                    'mapi([1, 2, 3], (x, i) -> x / i)',
                    'mapi([1, 2, 3], (x, i) -> x % inc(i))',
                ],
            },
        },
        'reduce': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    assertString(initial, sourceCodeInfo);
                    if (coll.length === 0)
                        return initial;
                    return coll.split('').reduce(function (result, elem) {
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return initial;
                    return coll.reduce(function (result, elem) {
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return initial;
                    return Object.entries(coll).reduce(function (result, _a) {
                        var _b = __read(_a, 2), elem = _b[1];
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Collection',
                returns: { type: 'any' },
                args: {
                    fun: { type: 'function' },
                    coll: { type: 'collection' },
                    initial: { type: 'any' },
                },
                variants: [{ argumentNames: ['coll', 'fun', 'initial'] }],
                description: 'Runs $fun function on each element of the $coll, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value.',
                examples: [
                    'reduce([1, 2, 3], +, 0)',
                    'reduce([], +, 0)',
                    'reduce({ a: 1, b: 2 }, +, 0)',
                    "\nreduce(\n  [1, 2, 3, 4, 5, 6, 7, 8, 9],\n  (result, value) -> result + (even?(value) ? value : 0),\n  0)",
                ],
            },
        },
        'reducei': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    assertString(initial, sourceCodeInfo);
                    if (coll.length === 0)
                        return initial;
                    return coll.split('').reduce(function (result, elem, index) {
                        return executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return initial;
                    return coll.reduce(function (result, elem, index) {
                        return executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return initial;
                    return Object.entries(coll).reduce(function (result, _a) {
                        var _b = __read(_a, 2), key = _b[0], elem = _b[1];
                        return executeFunction(fn, [result, elem, key], contextStack, sourceCodeInfo);
                    }, initial);
                }
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Collection',
                returns: { type: 'any' },
                args: {
                    coll: { type: 'collection' },
                    fun: {
                        type: 'function',
                        description: 'The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index.',
                    },
                    initial: {
                        type: 'any',
                        description: 'The initial value to use as the accumulator.',
                    },
                },
                variants: [{ argumentNames: ['coll', 'fun', 'initial'] }],
                description: 'Runs $fun function on each element of the $coll, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.',
                examples: [
                    'reducei([1, 2, 3], (acc, x, i) -> acc + x + i, 0)',
                    'reducei("Albert", (acc, x, i) -> acc ++ x ++ i, "")',
                    'reducei({ a: 1, b: 2 }, -> $1 ++ $3, "")',
                ],
            },
        },
        'reduce-right': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    if (coll.length === 0)
                        return initial;
                    return coll.split('').reduceRight(function (result, elem) {
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return initial;
                    return coll.reduceRight(function (result, elem) {
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return initial;
                    return Object.entries(coll).reduceRight(function (result, _a) {
                        var _b = __read(_a, 2), elem = _b[1];
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Collection',
                returns: { type: 'any' },
                args: {
                    fun: { type: 'function' },
                    coll: { type: 'collection' },
                    initial: { type: 'any' },
                },
                variants: [{ argumentNames: ['coll', 'fun', 'initial'] }],
                description: 'Runs $fun function on each element of the $coll (starting from the last item), passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value.',
                examples: [
                    'reduce-right(["A", "B", "C"], str, "")',
                    'reduce-right({ a: 1, b: 2 }, +, 0)',
                ],
            },
        },
        'reducei-right': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    if (coll.length === 0)
                        return initial;
                    return coll.split('').reduceRight(function (result, elem, index) {
                        return executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return initial;
                    return coll.reduceRight(function (result, elem, index) {
                        return executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return initial;
                    return Object.entries(coll).reduceRight(function (result, _a) {
                        var _b = __read(_a, 2), key = _b[0], elem = _b[1];
                        return executeFunction(fn, [result, elem, key], contextStack, sourceCodeInfo);
                    }, initial);
                }
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Collection',
                returns: { type: 'any' },
                args: {
                    coll: { type: 'collection' },
                    fun: {
                        type: 'function',
                        description: 'The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index.',
                    },
                    initial: {
                        type: 'any',
                        description: 'The initial value to use as the accumulator.',
                    },
                },
                variants: [{ argumentNames: ['coll', 'fun', 'initial'] }],
                description: 'Runs $fun function on each element of the $coll (starting from the last item), passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.',
                examples: [
                    'reducei-right([1, 2, 3], (acc, x, i) -> acc + x + i, 0)',
                    'reducei-right("Albert", (acc, x, i) -> acc ++ x ++ i, "")',
                    'reducei-right({ a: 1, b: 2 }, -> $1 ++ $3, "")',
                ],
            },
        },
        'reductions': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    assertString(initial, sourceCodeInfo);
                    if (coll.length === 0)
                        return [initial];
                    var resultArray_1 = [initial];
                    coll.split('').reduce(function (result, elem) {
                        var newVal = executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                        resultArray_1.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_1;
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return [initial];
                    var resultArray_2 = [initial];
                    coll.reduce(function (result, elem) {
                        var newVal = executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                        resultArray_2.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_2;
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return [initial];
                    var resultArray_3 = [initial];
                    Object.entries(coll).reduce(function (result, _a) {
                        var _b = __read(_a, 2), elem = _b[1];
                        var newVal = executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                        resultArray_3.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_3;
                }
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Collection',
                returns: { type: 'any', array: true },
                args: {
                    fun: { type: 'function' },
                    coll: { type: 'collection' },
                    initial: { type: 'any' },
                },
                variants: [{ argumentNames: ['coll', 'fun', 'initial'] }],
                description: 'Returns an array of the intermediate values of the reduction (see `reduce`) of $coll by $fun.',
                examples: [
                    'reductions([1, 2, 3], +, 0)',
                    'reductions([1, 2, 3], +, 10)',
                    'reductions([], +, 0)',
                    'reductions({ a: 1, b: 2 }, +, 0)',
                    "\nreductions(\n  [1, 2, 3, 4, 5, 6, 7, 8, 9],\n  (result, value) -> result + (even?(value) ? value : 0),\n  0\n)",
                ],
            },
        },
        'reductionsi': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    assertString(initial, sourceCodeInfo);
                    if (coll.length === 0)
                        return [initial];
                    var resultArray_4 = [initial];
                    coll.split('').reduce(function (result, elem, index) {
                        var newVal = executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                        resultArray_4.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_4;
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return [initial];
                    var resultArray_5 = [initial];
                    coll.reduce(function (result, elem, index) {
                        var newVal = executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                        resultArray_5.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_5;
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return [initial];
                    var resultArray_6 = [initial];
                    Object.entries(coll).reduce(function (result, _a) {
                        var _b = __read(_a, 2), key = _b[0], elem = _b[1];
                        var newVal = executeFunction(fn, [result, elem, key], contextStack, sourceCodeInfo);
                        resultArray_6.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_6;
                }
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Collection',
                returns: { type: 'any', array: true },
                args: {
                    coll: { type: 'collection' },
                    fun: {
                        type: 'function',
                        description: 'The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index.',
                    },
                    initial: {
                        type: 'any',
                        description: 'The initial value to use as the accumulator.',
                    },
                },
                variants: [{ argumentNames: ['coll', 'fun', 'initial'] }],
                description: 'Returns an array of the intermediate values of the reduction (see `reduce`) of $coll by $fun. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.',
                examples: [
                    'reductionsi([1, 2, 3], (acc, x, i) -> acc + x + i, 0)',
                    'reductionsi("Albert", (acc, x, i) -> acc ++ x ++ i, "")',
                    'reductionsi({ a: 1, b: 2 }, -> $1 ++ $3, "")',
                ],
            },
        },
        'get': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params, 2), coll = _a[0], key = _a[1];
                var defaultValue = toAny(params[2]);
                assertStringOrNumber(key, sourceCodeInfo);
                if (coll === null)
                    return defaultValue;
                assertColl(coll, sourceCodeInfo);
                var result = get(coll, key);
                return result === undefined ? defaultValue : result;
            },
            arity: { min: 2, max: 3 },
            docs: {
                category: 'Collection',
                returns: { type: 'any' },
                args: {
                    'a': { type: 'collection' },
                    'b': { type: ['string', 'integer'] },
                    'not-found': { type: 'any', description: 'Default value to return if $b is not found.' },
                },
                variants: [
                    { argumentNames: ['a', 'b'] },
                    { argumentNames: ['a', 'b', 'not-found'] },
                ],
                description: 'Returns value in $a mapped at $b.',
                examples: [
                    '[1, 2, 3] get 1',
                    '{ a: 1 } get "a"',
                    '"Albert" get "3"',
                    "\nget(\n  [1, 2, 3],\n  1, // Optional comma after last argument\n)",
                    "\nget(\n  [],\n  1\n)",
                    "\nget(\n  [],\n  1,\n  \"default\"\n)",
                    "\nget(\n  { a: 1 },\n  \"a\"\n)",
                    "\nget(\n  { a: 1 },\n  \"b\"\n)",
                    "\nget(\n  { a: 1 },\n  \"b\",\n  \"default\"\n)",
                    "\nget(\n  null,\n  \"a\"\n)",
                    "\nget(\n  null,\n  \"b\",\n  \"default\"\n)",
                ],
            },
        },
        'get-in': {
            evaluate: function (params, sourceCodeInfo) {
                var e_1, _a;
                var _b;
                var coll = toAny(params[0]);
                var keys = (_b = params[1]) !== null && _b !== void 0 ? _b : []; // null behaves as empty array
                var defaultValue = toAny(params[2]);
                assertArray(keys, sourceCodeInfo);
                try {
                    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                        var key = keys_1_1.value;
                        assertStringOrNumber(key, sourceCodeInfo);
                        if (isColl(coll)) {
                            var nextValue = get(coll, key);
                            if (nextValue !== undefined)
                                coll = nextValue;
                            else
                                return defaultValue;
                        }
                        else {
                            return defaultValue;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return coll;
            },
            arity: { min: 2, max: 3 },
            docs: {
                category: 'Collection',
                returns: { type: 'any' },
                args: {
                    'a': { type: 'collection' },
                    'b': { type: 'array' },
                    'not-found': { type: 'any' },
                },
                variants: [
                    { argumentNames: ['a', 'b'] },
                    { argumentNames: ['a', 'b', 'not-found'] },
                ],
                description: 'Returns the value in a nested collection, where $b is an array of keys. Returns $not-found if the key is not present. If $not-found is not set, `null` is returned.',
                examples: [
                    "\nget-in(\n  [[1, 2, 3], [4, { a: \"Kalle\" }, 6]],\n  [1, 1, \"a\", 0]\n)",
                    "\nget-in(\n  [[1, 2, 3], [4, { a: \"Kalle\" }, 6]],\n  [1, 1, \"b\", 0]\n)",
                    "\nget-in(\n  [[1, 2, 3], [4, { a: \"Kalle\" }, 6]],\n  [1, 1, \"b\", 0],\n  \"Lisa\"\n)",
                ],
            },
        },
        'count': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), coll = _b[0];
                if (coll === null)
                    return 0;
                if (typeof coll === 'string')
                    return coll.length;
                assertColl(coll, sourceCodeInfo);
                if (Array.isArray(coll))
                    return coll.length;
                return Object.keys(coll).length;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Collection',
                returns: { type: 'number' },
                args: {
                    coll: { type: ['collection', 'null'] },
                },
                variants: [{ argumentNames: ['coll'] }],
                description: 'Returns number of elements in $coll.',
                examples: [
                    'count([1, 2, 3])',
                    'count([])',
                    'count({ a: 1 })',
                    'count("")',
                    'count("Albert")',
                    'count(null)',
                ],
            },
        },
        'contains?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), coll = _b[0], key = _b[1];
                if (coll === null)
                    return false;
                assertColl(coll, sourceCodeInfo);
                if (isString(coll)) {
                    assertString(key, sourceCodeInfo);
                    return coll.includes(key);
                }
                if (isSeq(coll)) {
                    assertAny(key, sourceCodeInfo);
                    return !!coll.find(function (elem) { return deepEqual(asAny(elem), key, sourceCodeInfo); });
                }
                assertString(key, sourceCodeInfo);
                return key in coll;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Collection',
                returns: { type: 'boolean' },
                args: {
                    a: { type: ['collection', 'null'] },
                    b: { type: ['string', 'integer'] },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns `true` if $a contains $b, otherwise returns `false`. For strings, it checks if substring is included.',
                examples: [
                    '[1, 2, 3] contains? 1',
                    'null contains? 1',
                    '{ a: 1, b: 2 } contains? "a"',
                    "\ncontains?(\n  [],\n  1\n)",
                    "\ncontains?(\n  [1],\n  1\n)",
                    "\ncontains?(\n  [1, 2, 3],\n  1\n)",
                    "\ncontains?(\n  {},\n  \"a\"\n)",
                    "\ncontains?(\n  { a: 1, b: 2 },\n  \"a\"\n)",
                ],
            },
        },
        'assoc': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), coll = _b[0], key = _b[1], value = _b[2];
                assertColl(coll, sourceCodeInfo);
                assertStringOrNumber(key, sourceCodeInfo);
                assertAny(value, sourceCodeInfo);
                return assoc(coll, key, value, sourceCodeInfo);
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Collection',
                returns: { type: 'collection' },
                args: {
                    coll: { type: 'collection' },
                    key: { type: ['string', 'number'] },
                    value: { type: 'any' },
                    kvs: { type: 'any', description: 'Key-value pairs to associate.', rest: true },
                },
                variants: [
                    { argumentNames: ['coll', 'key', 'value'] },
                    { argumentNames: ['coll', 'key', 'value', 'kvs'] },
                ],
                description: "\nAdd or replace the value of element $key to $value in $coll. Repeated for all key-value pairs in $kvs.\nIf $coll is an 'array', $key must be `number` satisfying `0 <=` $key `<= length`.",
                examples: [
                    "\nassoc(\n  [1, 2, 3],\n  1,\n  \"Two\"\n)",
                    "\nassoc(\n  [1, 2, 3],\n  3,\n  \"Four\"\n)",
                    "\nassoc(\n  { a: 1, b: 2 },\n  \"a\",\n  \"One\")",
                    "\nassoc(\n  { a: 1, b: 2 },\n  \"c\",\n  \"Three\")",
                    "\nassoc(\n  \"Albert\",\n  6,\n  \"a\")",
                ],
            },
        },
        'assoc-in': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), originalColl = _b[0], keys = _b[1], value = _b[2];
                assertColl(originalColl, sourceCodeInfo);
                assertArray(keys, sourceCodeInfo);
                assertAny(value, sourceCodeInfo);
                if (keys.length === 1) {
                    assertStringOrNumber(keys[0], sourceCodeInfo);
                    return assoc(originalColl, keys[0], value, sourceCodeInfo);
                }
                var _c = cloneAndGetMeta(originalColl, keys, sourceCodeInfo), coll = _c.coll, innerCollMeta = _c.innerCollMeta;
                var lastKey = asStringOrNumber(keys[keys.length - 1], sourceCodeInfo);
                var parentKey = asStringOrNumber(keys[keys.length - 2], sourceCodeInfo);
                if (Array.isArray(innerCollMeta.parent)) {
                    assertNumber(parentKey, sourceCodeInfo);
                    innerCollMeta.parent[parentKey] = assoc(innerCollMeta.coll, lastKey, value, sourceCodeInfo);
                }
                else {
                    assertString(parentKey, sourceCodeInfo);
                    innerCollMeta.parent[parentKey] = assoc(innerCollMeta.coll, lastKey, value, sourceCodeInfo);
                }
                return coll;
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Collection',
                returns: { type: 'collection' },
                args: {
                    coll: { type: 'collection' },
                    ks: { type: ['number', 'string'], array: true },
                    value: { type: 'any' },
                },
                variants: [{ argumentNames: ['coll', 'ks', 'value'] }],
                description: "\nAssociates a value in the nested collection $coll, where $ks is an array of keys and $value is the new value.\n\nIf any levels do not exist, objects will be created - and the corresponding keys must be of type string.",
                examples: [
                    "\nassoc-in(\n  {},\n  [\"a\", \"b\", \"c\"],\n  \"Albert\"\n)",
                    "\nassoc-in(\n  [1, 2, [1, 2, 3]],\n  [2, 1],\n  \"Albert\"\n)",
                    "\nassoc-in(\n  [1, 2, { name: \"albert\" }],\n  [2, \"name\", 0],\n  \"A\"\n)",
                ],
            },
        },
        'update': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a), coll = _c[0], key = _c[1], fn = _c[2], params = _c.slice(3);
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertStringOrNumber(key, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                return update(coll, key, fn, params, contextStack, executeFunction, sourceCodeInfo);
            },
            arity: { min: 3 },
            docs: {
                category: 'Collection',
                returns: { type: 'collection' },
                args: {
                    'coll': { type: 'collection' },
                    'key': { type: ['string', 'number'] },
                    'fun': { type: 'function' },
                    'fun-args': { type: 'any', rest: true },
                },
                variants: [
                    { argumentNames: ['coll', 'value', 'fun'] },
                    { argumentNames: ['coll', 'value', 'fun', 'fun-args'] },
                ],
                description: "\nUpdates a value in the $coll collection, where $key is a key. $fun is a function\nthat will take the old value and any supplied $fun-args and\nreturn the new value.\nIf the key does not exist, `null` is passed as the old value.",
                examples: [
                    "\nlet x = { a: 1, b: 2 };\nupdate(x, \"a\", inc)",
                    "\nlet x = { a: 1, b: 2 };\nupdate(\n  x,\n  \"c\",\n  val -> null?(val) ? 0 : inc(val)\n)",
                ],
            },
        },
        'update-in': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a), originalColl = _c[0], keys = _c[1], fn = _c[2], params = _c.slice(3);
                var executeFunction = _b.executeFunction;
                assertColl(originalColl, sourceCodeInfo);
                assertArray(keys, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (keys.length === 1) {
                    assertStringOrNumber(keys[0], sourceCodeInfo);
                    return update(originalColl, keys[0], fn, params, contextStack, executeFunction, sourceCodeInfo);
                }
                var _d = cloneAndGetMeta(originalColl, keys, sourceCodeInfo), coll = _d.coll, innerCollMeta = _d.innerCollMeta;
                var lastKey = asStringOrNumber(keys[keys.length - 1], sourceCodeInfo);
                var parentKey = asStringOrNumber(keys[keys.length - 2], sourceCodeInfo);
                if (Array.isArray(innerCollMeta.parent)) {
                    assertNumber(parentKey, sourceCodeInfo);
                    innerCollMeta.parent[parentKey] = update(innerCollMeta.coll, lastKey, fn, params, contextStack, executeFunction, sourceCodeInfo);
                }
                else {
                    assertString(parentKey, sourceCodeInfo);
                    innerCollMeta.parent[parentKey] = update(innerCollMeta.coll, lastKey, fn, params, contextStack, executeFunction, sourceCodeInfo);
                }
                return coll;
            },
            arity: { min: 3 },
            docs: {
                category: 'Collection',
                returns: { type: 'collection' },
                args: {
                    'coll': { type: 'collection' },
                    'ks': { type: 'array' },
                    'fun': { type: 'function' },
                    'fun-args': { type: 'any', rest: true },
                },
                variants: [
                    { argumentNames: ['coll', 'ks', 'fun'] },
                    { argumentNames: ['coll', 'ks', 'fun', 'fun-args'] },
                ],
                description: "Updates a value in the $coll collection, where $ks is an array of\nkeys and $fun is a function that will take the old value and\nany supplied $fun-args and return the new value. If any levels do not exist,\nobjects will be created - and the corresponding keys must be of type string.",
                examples: [
                    "\nupdate-in(\n  { a: [1, 2, 3] },\n  [\"a\", 1],\n  -> null?($) ? 0 : inc($)\n)",
                    "\nupdate-in(\n  { a: { foo: \"bar\"} },\n  [\"a\", \"foo\"],\n  -> null?($) ? \"?\" : \"!\"\n)",
                    "\nupdate-in(\n  { a: { foo: \"bar\"} },\n  [\"a\", \"baz\"],\n  -> null?($) ? \"?\" : \"!\"\n)",
                    "\nupdate-in(\n  { a: [1, 2, 3] },\n  [\"a\", 1],\n  *,\n  10,\n  10,\n  10,\n)",
                ],
            },
        },
        '++': {
            evaluate: function (params, sourceCodeInfo) {
                if (!isNumber(params[0])) {
                    assertColl(params[0], sourceCodeInfo);
                }
                if (Array.isArray(params[0])) {
                    return params.reduce(function (result, arr) {
                        assertArray(arr, sourceCodeInfo);
                        return result.concat(arr);
                    }, []);
                }
                else if (isStringOrNumber(params[0])) {
                    return params.reduce(function (result, s) {
                        assertStringOrNumber(s, sourceCodeInfo);
                        return "".concat(result).concat(s);
                    }, '');
                }
                else {
                    return params.reduce(function (result, obj) {
                        assertObj(obj, sourceCodeInfo);
                        return Object.assign(result, obj);
                    }, {});
                }
            },
            arity: { min: 1 },
            docs: {
                category: 'Collection',
                returns: { type: 'collection' },
                args: {
                    a: { type: 'collection' },
                    b: { type: 'collection' },
                    colls: { type: 'collection', rest: true },
                },
                variants: [
                    { argumentNames: ['a'] },
                    { argumentNames: ['a', 'colls'] },
                ],
                description: 'Concatenates collections into one collection.',
                examples: [
                    '"Albert" ++ " " ++ "Mojir"',
                    '"Albert" ++ "Mojir"',
                    '++("Albert", "-", "Mojir")',
                    '++("Albert")',
                    '++("A", "l", "b", "e", "r", "t")',
                    '++([1, 2], [3, 4])',
                    '++([], [3, 4])',
                    '++([1, 2], [])',
                    '++([1, 2], [3, 4], [5, 6])',
                    '++([])',
                    '++({ a: 1, b: 2 }, { b: 1, c: 2 })',
                    '++({}, { a: 1 })',
                ],
            },
        },
        'not-empty': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), coll = _b[0];
                if (coll === null)
                    return null;
                assertColl(coll, sourceCodeInfo);
                if (typeof coll === 'string')
                    return coll.length > 0 ? coll : null;
                if (Array.isArray(coll))
                    return coll.length > 0 ? coll : null;
                return Object.keys(coll).length > 0 ? coll : null;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Collection',
                returns: { type: 'boolean' },
                args: {
                    coll: { type: ['collection', 'null'] },
                },
                variants: [{ argumentNames: ['coll'] }],
                description: 'Returns `null` if $coll is empty or `null`, otherwise $coll.',
                examples: [
                    'not-empty([])',
                    'not-empty([1, 2, 3])',
                    'not-empty({})',
                    'not-empty({ a: 2 })',
                    'not-empty("")',
                    'not-empty("Albert")',
                    'not-empty(null)',
                ],
            },
        },
        'every?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(coll))
                    return coll.every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (typeof coll === 'string')
                    return coll.split('').every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return Object.entries(coll).every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Collection',
                returns: { type: 'boolean' },
                args: {
                    a: { type: 'collection' },
                    b: { type: 'function' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns `true` if all entries in $a pass the test implemented by $b, otherwise returns `false`.',
                examples: [
                    '[1, 2, 3] every? number?',
                    '[1, 2, 3] every? even?',
                    "\nevery?(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?,\n)",
                    "\nevery?(\n  [50, 100, 150, 200],\n  -> $ > 10,\n)",
                    "\nevery?(\n  [],\n  number?\n)",
                    "\nevery?(\n  \"\",\n  number?\n)",
                    "\nevery?(\n  {},\n  number?\n)",
                    "\nevery?(\n  { a: 2, b: 4},\n  -> even?(second($))\n)",
                    "\nevery?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)",
                ],
            },
        },
        'any?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertColl(coll, sourceCodeInfo);
                if (Array.isArray(coll))
                    return coll.some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (typeof coll === 'string')
                    return coll.split('').some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return Object.entries(coll).some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Collection',
                returns: { type: 'boolean' },
                args: {
                    a: { type: 'collection' },
                    b: { type: 'function' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns `true` if any element in $a pass the test implemented by $b, otherwise returns `false`.',
                examples: [
                    "\nany?(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                    "\nany?(\n  [50, 100, 150, 200],\n  x -> x > 10\n)",
                    "\nany?(\n  [],\n  number?\n)",
                    "\nany?(\n  \"\",\n  number?\n)",
                    "\nany?(\n  {},\n  number?\n)",
                    "\nany?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)",
                    "\nany?(\n  { a: 1, b: 3 },\n  -> even?(second($))\n)",
                ],
            },
        },
        'not-any?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertColl(coll, sourceCodeInfo);
                if (Array.isArray(coll))
                    return !coll.some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (typeof coll === 'string')
                    return !coll.split('').some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return !Object.entries(coll).some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Collection',
                returns: { type: 'boolean' },
                args: {
                    a: { type: 'collection' },
                    b: { type: 'function' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns `false` if any element in $a pass the test implemented by $b, otherwise returns `true`.',
                examples: [
                    "\nnot-any?(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                    "\nnot-any?(\n  [50, 100, 150, 200],\n  x -> x > 10\n)",
                    "\nnot-any?(\n  [],\n  number?\n)",
                    "\nnot-any?(\n  \"\",\n  number?\n)",
                    "\nnot-any?(\n  {},\n  number?\n)",
                    "\nnot-any?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)",
                    "\nnot-any?(\n  { a: 1, b: 3 },\n  -> even?(second($))\n)",
                ],
            },
        },
        'not-every?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertColl(coll, sourceCodeInfo);
                if (Array.isArray(coll))
                    return !coll.every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (typeof coll === 'string')
                    return !coll.split('').every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return !Object.entries(coll).every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Collection',
                returns: { type: 'boolean' },
                args: {
                    a: { type: 'collection' },
                    b: { type: 'function' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns `true` if at least one element in $a does not pass the test implemented by $b, otherwise returns `false`.',
                examples: [
                    "\nnot-every?(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                    "\nnot-every?(\n  [50, 100, 150, 200],\n  x -> x > 10\n)",
                    "\nnot-every?(\n  [],\n  number?\n)",
                    "\nnot-every?(\n  \"\",\n  number?\n)",
                    "\nnot-every?(\n  {},\n  number?\n)",
                    "\nnot-every?(\n  { a: 2, b: 4 },\n  -> even?(second($))\n)",
                    "\nnot-every?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)",
                ],
            },
        },
    };

    var arrayNormalExpression = {
        'range': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params, 3), first = _a[0], second = _a[1], third = _a[2];
                var from;
                var to;
                var step;
                assertNumber(first, sourceCodeInfo, { finite: true });
                if (params.length === 1) {
                    from = 0;
                    to = first;
                    step = to >= 0 ? 1 : -1;
                }
                else if (params.length === 2) {
                    assertNumber(second, sourceCodeInfo, { finite: true });
                    from = first;
                    to = second;
                    step = to >= from ? 1 : -1;
                }
                else {
                    assertNumber(second, sourceCodeInfo, { finite: true });
                    assertNumber(third, sourceCodeInfo, { finite: true });
                    from = first;
                    to = second;
                    step = third;
                    if (to > from)
                        assertNumber(step, sourceCodeInfo, { positive: true });
                    else if (to < from)
                        assertNumber(step, sourceCodeInfo, { negative: true });
                    else
                        assertNumber(step, sourceCodeInfo, { nonZero: true });
                }
                var result = [];
                for (var i = from; step < 0 ? i > to : i < to; i += step)
                    result.push(i);
                return result;
            },
            arity: { min: 1, max: 3 },
            docs: {
                category: 'Array',
                returns: { type: 'number', array: true },
                args: {
                    a: { type: 'number' },
                    b: { type: 'number' },
                    step: { type: 'number' },
                },
                variants: [
                    { argumentNames: ['b'] },
                    { argumentNames: ['a', 'b'] },
                    { argumentNames: ['a', 'b', 'step'] },
                ],
                description: "$range creates an array with a range of numbers from $a to $b (exclusive), by $step.\n\n$a defaults to 0.\n$step defaults to 1.",
                examples: [
                    'range(4)',
                    'range(1, 4)',
                    '1 range 10',
                    'range(0.4, 4.9)',
                    "\nrange(\n  0.25, // start value\n  1,    // end value (exclusive)\n  0.25, // step value\n)",
                ],
            },
        },
        'repeat': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), value = _b[0], count = _b[1];
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                var result = [];
                for (var i = 0; i < count; i += 1)
                    result.push(value);
                return result;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Array',
                returns: { type: 'any', array: true },
                args: {
                    a: { type: 'any' },
                    b: { type: 'integer' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns an array with $a repeated $b times.',
                examples: [
                    'repeat(10, 3)',
                    'repeat(10, 0)',
                    '"Albert" repeat 5',
                ],
            },
        },
        'flatten': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], depth = _b[1];
                assertArray(seq, sourceCodeInfo);
                var actualDepth = depth === undefined || depth === Number.POSITIVE_INFINITY
                    ? Number.POSITIVE_INFINITY
                    : asNumber(depth, sourceCodeInfo, { integer: true, nonNegative: true });
                return seq.flat(actualDepth);
            },
            arity: { min: 1, max: 2 },
            docs: {
                category: 'Array',
                returns: { type: 'any', array: true },
                args: {
                    x: { type: ['array', 'any'], description: 'If $x is not an array, `[ ]` is returned.' },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'Takes a nested array $x and flattens it.',
                examples: [
                    'flatten([1, 2, [3, 4], 5])',
                    "\nlet foo = \"bar\";\nflatten([\n  1,\n  \" 2 A \",\n  [foo, [4, [\"ABC\"]]],\n  6,\n])",
                ],
                hideOperatorForm: true,
            },
        },
        'mapcat': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), arr = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertArray(arr, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                return arr.map(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); }).flat(1);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Array',
                returns: { type: 'collection' },
                args: {
                    a: { type: 'collection' },
                    b: { type: 'function' },
                    colls: { type: 'collection', array: true },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['colls', 'fun'] }],
                description: 'Returns the result of applying concat to the result of applying map to $fun and $colls.',
                examples: [
                    '[[3, 2, 1, 0], [6, 5, 4], [9, 8, 7]] mapcat reverse',
                    'mapcat([[3, 2, 1, 0], [6, 5, 4], [9, 8, 7]], reverse)',
                    '[[3, 2, 1, 0,], [6, 5, 4,], [9, 8, 7]] mapcat reverse',
                    "\nlet foo = (n) -> {\n  [n - 1, n, n + 1]\n};\n[1, 2, 3] mapcat foo",
                    "\nmapcat(\n  [[1, 2], [2, 2], [2, 3]],\n  -> $ remove even?\n)",
                ],
            },
        },
        'moving-fn': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), arr = _c[0], windowSize = _c[1], fn = _c[2];
                var executeFunction = _b.executeFunction;
                assertArray(arr, sourceCodeInfo);
                assertNumber(windowSize, sourceCodeInfo, { integer: true, lte: arr.length });
                assertFunctionLike(fn, sourceCodeInfo);
                var result = [];
                for (var i = 0; i <= arr.length - windowSize; i++) {
                    var window_1 = arr.slice(i, i + windowSize);
                    var value = executeFunction(fn, [window_1], contextStack, sourceCodeInfo);
                    result.push(value);
                }
                return result;
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Array',
                returns: { type: 'array' },
                args: {
                    arr: { type: 'array' },
                    windowSize: { type: 'number', description: 'The size of the moving window.' },
                    fn: { type: 'function' },
                },
                variants: [{ argumentNames: ['arr', 'windowSize', 'fn'] }],
                description: 'Returns the result of applying $fn to each moving window of size $windowSize in $arr.',
                examples: [
                    'let v = import("Vector"); moving-fn([1, 2, 3], 2, v.sum)',
                    'let v = import("Vector"); moving-fn([1, 2, 3], 1, v.sum)',
                    'let v = import("Vector"); moving-fn([1, 2, 3], 3, v.sum)',
                ],
            },
        },
        'running-fn': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), arr = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertArray(arr, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var result = [];
                for (var i = 0; i < arr.length; i += 1) {
                    var subArr = arr.slice(0, i + 1);
                    result.push(executeFunction(fn, [subArr], contextStack, sourceCodeInfo));
                }
                return result;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Array',
                returns: { type: 'array' },
                args: {
                    a: { type: 'array' },
                    b: { type: 'function' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns the result of applying $b to each element of $a.',
                examples: [
                    'let v = import("Vector"); running-fn([1, 2, 3], v.sum)',
                    'let v = import("Vector"); running-fn([1, 2, 3], v.max)',
                    'let v = import("Vector"); running-fn([1, 2, 3], v.min)',
                ],
            },
        },
    };

    var sequenceNormalExpression = {
        'nth': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params, 2), seq = _a[0], i = _a[1];
                var defaultValue = toAny(params[2]);
                assertNumber(i, sourceCodeInfo, { integer: true });
                if (seq === null)
                    return defaultValue;
                assertSeq(seq, sourceCodeInfo);
                if (i >= 0 && i < seq.length) {
                    var result = toAny(seq[i]);
                    return result;
                }
                else {
                    return defaultValue;
                }
            },
            arity: { min: 2, max: 3 },
            docs: {
                category: 'Sequence',
                returns: { type: 'any' },
                args: {
                    'a': { type: 'sequence' },
                    'b': { type: 'integer' },
                    'seq': { type: ['sequence', 'null'] },
                    'n': { type: 'integer' },
                    'not-found': { type: 'any' },
                },
                variants: [
                    { argumentNames: ['seq', 'n'] },
                    { argumentNames: ['seq', 'n', 'not-found'] },
                ],
                description: 'Accesses element $n of $seq. Accessing out-of-bounds indices returns $not-found, if present, else `null`.',
                examples: [
                    '[1, 2, 3] nth 1',
                    '"A string" nth 3',
                    'nth([1, 2, 3], 1)',
                    'nth([1, 2, 3], 3)',
                    'nth([1, 2, 3], -1)',
                    'nth([1, 2, 3], 3, 99)',
                    'nth("A string", 1)',
                    'nth("A string", 3)',
                    'nth("A string", -3)',
                    'nth("A string", 30, "X")',
                    'nth(null, 1)',
                    'nth(null, 1, "Default value")',
                ],
            },
        },
        'first': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), array = _b[0];
                if (array === null)
                    return null;
                assertSeq(array, sourceCodeInfo);
                var result = toAny(array[0]);
                return result;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: 'any' },
                args: { seq: { type: ['sequence', 'null'] } },
                variants: [{ argumentNames: ['seq'] }],
                description: 'Returns the first element of $seq. If $seq is empty or `null`, `null` is returned.',
                examples: [
                    'first(["Albert", "Mojir", 160, [1, 2]])',
                    'first([])',
                    'first(null)',
                ],
            },
        },
        'last': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), array = _b[0];
                if (array === null)
                    return null;
                assertSeq(array, sourceCodeInfo);
                var result = toAny(array.at(-1));
                return result;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: 'any' },
                args: { seq: { type: ['sequence', 'null'] } },
                variants: [{ argumentNames: ['seq'] }],
                description: 'Returns the last element of $seq. If $seq is empty, `null` is returned.',
                examples: [
                    'last(["Albert", "Mojir", 160, [1, 2]])',
                    'last([1, 2])',
                    'last([1])',
                    'last([])',
                    'last(null)',
                ],
            },
        },
        'pop': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    return seq.substring(0, seq.length - 1);
                }
                return seq.slice(0, seq.length - 1);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: ['sequence', 'null'], rest: true },
                args: { seq: { type: 'sequence' } },
                variants: [{ argumentNames: ['seq'] }],
                description: 'Returns a copy of $seq with last element removed. If $seq is empty `null` is returned.',
                examples: [
                    'pop([1, 2, 3])',
                    'pop([])',
                ],
            },
        },
        'position': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    var index = seq.split('').findIndex(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                    return index !== -1 ? index : null;
                }
                else {
                    var index = seq.findIndex(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                    return index !== -1 ? index : null;
                }
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: ['number', 'null'] },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: ['sequence', 'null'] },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['seq', 'fun'] }],
                description: 'Returns the index of the first elements that passes the test implemented by $fun. If no element was found, `null` is returned.',
                examples: [
                    "\nposition(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                    "\nposition(\n  [5, 10, 15, 20],\n  -> $ > 10\n)",
                    "\nposition(\n  [5, 10, 15, 20],\n  -> $ > 100\n)",
                    "\nposition(\n  null,\n  -> $ > 100\n)",
                ],
            },
        },
        'index-of': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], value = _b[1];
                assertAny(value, sourceCodeInfo);
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertString(value, sourceCodeInfo);
                    var index = seq.indexOf(value);
                    return index !== -1 ? index : null;
                }
                else {
                    var index = seq.findIndex(function (item) { return deepEqual(asAny(item, sourceCodeInfo), value); }, sourceCodeInfo);
                    return index !== -1 ? index : null;
                }
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: ['number', 'null'] },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'any' },
                    seq: { type: ['sequence', 'null'] },
                    x: { type: 'any' },
                },
                variants: [{ argumentNames: ['seq', 'x'] }],
                description: 'Returns the index of $x in $seq. If element is not present in $seq `null` is returned.',
                examples: [
                    '[[1], [2], [1], [2]] index-of [1]',
                    'index-of(["Albert", "Mojir", 160, [1, 2]], "Mojir")',
                    'index-of([5, 10, 15, 20], 15)',
                    'index-of([5, 10, 15, 20], 1)',
                    'index-of(null, 1)',
                ],
            },
        },
        'last-index-of': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], value = _b[1];
                assertAny(value, sourceCodeInfo);
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertString(value, sourceCodeInfo);
                    var index = seq.lastIndexOf(value);
                    return index !== -1 ? index : null;
                }
                else {
                    var index = seq.findLastIndex(function (item) { return deepEqual(asAny(item, sourceCodeInfo), value); }, sourceCodeInfo);
                    return index !== -1 ? index : null;
                }
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: ['number', 'null'] },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'any' },
                    seq: { type: ['sequence', 'null'] },
                    x: { type: 'any' },
                },
                variants: [{ argumentNames: ['seq', 'x'] }],
                description: 'Returns the last index of $x in $seq. If element is not present in $seq `null` is returned.',
                examples: [
                    '[[1], [2], [1], [2]] last-index-of [1]',
                    'last-index-of(["Albert", "Mojir", 160, [1, 2]], "Mojir")',
                    'last-index-of([5, 10, 15, 20, 15], 15)',
                    'last-index-of([5, 10, 15, 20], 1)',
                    'last-index-of(null, 1)',
                ],
            },
        },
        'push': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), seq = _b[0], values = _b.slice(1);
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertCharArray(values, sourceCodeInfo);
                    return __spreadArray([seq], __read(values), false).join('');
                }
                else {
                    return __spreadArray(__spreadArray([], __read(seq), false), __read(values), false);
                }
            },
            arity: { min: 2 },
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'any' },
                    seq: { type: 'sequence' },
                    values: { type: 'any', rest: true, description: 'At least one.' },
                },
                variants: [{ argumentNames: ['seq', 'values'] }],
                description: 'Returns copy of $seq with $values added to the end of it.',
                examples: [
                    '[1, 2, 3] push 4',
                    '"Albert" push "!"',
                    'push([1, 2, 3], 4)',
                    'push([1, 2, 3], 4, 5, 6)',
                    "\nlet l = [1, 2, 3];\npush(l, 4);\nl",
                ],
            },
        },
        'rest': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                if (Array.isArray(seq)) {
                    if (seq.length <= 1)
                        return [];
                    return seq.slice(1);
                }
                return seq.substring(1);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: ['sequence', 'null'] },
                args: { seq: { type: 'sequence' } },
                variants: [{ argumentNames: ['seq'] }],
                description: "If $seq is an array, returns a new array with all but the first element from $seq.\nIf $seq has less than two elements, an empty array is returned.\nFor string $seq returns all but the first characters in $seq.",
                examples: [
                    'rest(["Albert", "Mojir", 160, [1, 2]])',
                    'rest(["Albert"])',
                    'rest([])',
                    'rest("Albert")',
                    'rest("A",)',
                    'rest("")',
                ],
            },
        },
        'next': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                if (Array.isArray(seq)) {
                    if (seq.length <= 1)
                        return null;
                    return seq.slice(1);
                }
                if (seq.length <= 1)
                    return null;
                return seq.substring(1);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: ['sequence', 'null'] },
                args: { seq: { type: 'sequence' } },
                variants: [{ argumentNames: ['seq'] }],
                description: 'If $seq is an array, returns a new array with all but the first element from $seq. If $seq has less than two elements, `null` is returned. For string $seq returns all but the first characters in $seq. If length of string $seq is less than two, `null` is returned.',
                examples: [
                    'next(["Albert", "Mojir", 160, [1, 2]])',
                    'next(["Albert"])',
                    'next([])',
                    'next("Albert")',
                    'next("A",)',
                    'next("")',
                ],
            },
        },
        'reverse': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (Array.isArray(seq)) {
                    return __spreadArray([], __read(seq), false).reverse();
                }
                return seq.split('').reverse().join('');
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: ['sequence', 'null'] },
                args: { seq: { type: ['sequence', 'null'] } },
                variants: [{ argumentNames: ['seq'] }],
                description: 'If $seq is an array, creates a new array with the elements from $seq in reversed order. If $seq is a string, returns new reversed string.',
                examples: [
                    'reverse(["Albert", "Mojir", 160, [1, 2]])',
                    'reverse([])',
                    'reverse("Albert")',
                    'reverse(null)',
                ],
            },
        },
        'second': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                return toAny(seq[1]);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: 'any' },
                args: { seq: { type: ['sequence', 'null'] } },
                variants: [{ argumentNames: ['seq'] }],
                description: 'Returns the second element of $seq. If $seq has less than two elements or is `null`, `null` is returned.',
                examples: [
                    'second(["Albert", "Mojir", 160, [1, 2]])',
                    'second([1])',
                    'second([])',
                    'second(null)',
                ],
            },
        },
        'shift': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string')
                    return seq.substring(1);
                var copy = __spreadArray([], __read(seq), false);
                copy.shift();
                return copy;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: ['sequence', 'null'] },
                args: { seq: { type: 'sequence' } },
                variants: [{ argumentNames: ['seq'] }],
                description: 'Returns a copy of $seq with first element removed. If $seq is empty `null` is returned.',
                examples: [
                    'shift([1, 2, 3])',
                    'shift([])',
                ],
            },
        },
        'slice': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params, 3), seq = _a[0], from = _a[1], to = _a[2];
                assertSeq(seq, sourceCodeInfo);
                assertNumber(from, sourceCodeInfo, { integer: true });
                if (params.length === 2) {
                    if (Array.isArray(seq)) {
                        return seq.slice(from);
                    }
                    return seq.slice(from);
                }
                assertNumber(to, sourceCodeInfo, { integer: true });
                if (Array.isArray(seq)) {
                    return seq.slice(from, to);
                }
                return seq.slice(from, to);
            },
            arity: { min: 2, max: 3 },
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'integer' },
                    seq: { type: 'sequence', rest: true },
                    start: { type: 'integer', description: 'Defaults to `0`.' },
                    stop: { type: 'integer', description: 'Defaults lenght of sequence + 1.' },
                },
                variants: [
                    { argumentNames: ['seq'] },
                    { argumentNames: ['seq', 'start'] },
                    { argumentNames: ['seq', 'start', 'stop'] },
                ],
                description: 'Returns a copy of a portion of $seq from index $start (inclusive) to $stop (exclusive).',
                examples: [
                    '[1, 2, 3, 4, 5] slice 2',
                    'slice([1, 2, 3, 4, 5], 2, 4)',
                    'slice([1, 2, 3, 4, 5], 2)',
                ],
            },
        },
        'splice': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params), seq = _a[0], start = _a[1], deleteCount = _a[2], rest = _a.slice(3);
                assertSeq(seq, sourceCodeInfo);
                assertNumber(start, sourceCodeInfo, { integer: true });
                assertNumber(deleteCount, sourceCodeInfo, { integer: true, nonNegative: true });
                var from = start < 0 ? seq.length + start : start;
                if (Array.isArray(seq)) {
                    return __spreadArray(__spreadArray(__spreadArray([], __read(seq.slice(0, from)), false), __read(rest), false), __read(seq.slice(from + deleteCount)), false);
                }
                rest.forEach(function (elem) { return assertString(elem, sourceCodeInfo); });
                return "".concat(seq.substring(0, from)).concat(rest.join('')).concat(seq.substring(from + deleteCount));
            },
            arity: { min: 3 },
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    seq: { type: 'sequence', rest: true },
                    start: { type: 'integer' },
                    deleteCount: { type: 'integer' },
                    items: { type: 'any', rest: true },
                },
                variants: [
                    { argumentNames: ['seq', 'start', 'deleteCount'] },
                    { argumentNames: ['seq', 'start', 'deleteCount', 'items'] },
                ],
                description: 'Returns a a spliced array. Removes $deleteCount elements from $seq starting at $start and replaces them with $items. If $start is negative, it is counting from the end of the array.',
                examples: [
                    'splice([1, 2, 3, 4, 5], 2, 2, "x")',
                    'splice([1, 2, 3, 4, 5], -2, 1, "x")',
                    'splice("Albert", 2, 2, "fo")',
                ],
            },
        },
        'some': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c;
                var _d = __read(_a, 2), seq = _d[0], fn = _d[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (seq.length === 0)
                    return null;
                if (typeof seq === 'string')
                    return (_c = seq.split('').find(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); })) !== null && _c !== void 0 ? _c : null;
                return toAny(seq.find(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); }));
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'any' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: ['sequence', 'null'] },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['seq', 'fun'] }],
                description: 'Returns the first element that passes the test implemented by $fun. I no element was found, `null` is returned.',
                examples: [
                    "\nsome(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                    "\nsome(\n  [5, 10, 15, 20],\n  -> $ > 10\n)",
                    "\nsome(\n  [1, 2, 3, 4],\n  -> $ > 10\n)",
                    "\nsome(\n  [],\n  -> $ > 10\n)",
                    "\nsome(\n  null,\n  -> $ > 10\n)",
                ],
            },
        },
        'sort': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var _b = __read(params, 1), seq = _b[0];
                var defaultComparer = params.length === 1;
                var comparer = defaultComparer ? null : params[1];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    var result_1 = seq.split('');
                    if (defaultComparer) {
                        result_1.sort(function (a, b) { return compare(a, b, sourceCodeInfo); });
                    }
                    else {
                        assertFunctionLike(comparer, sourceCodeInfo);
                        result_1.sort(function (a, b) {
                            var compareValue = executeFunction(comparer, [a, b], contextStack, sourceCodeInfo);
                            assertNumber(compareValue, sourceCodeInfo, { finite: true });
                            return compareValue;
                        });
                    }
                    return result_1.join('');
                }
                var result = __spreadArray([], __read(seq), false);
                if (defaultComparer) {
                    result.sort(function (a, b) {
                        assertStringOrNumber(a, sourceCodeInfo);
                        assertStringOrNumber(b, sourceCodeInfo);
                        return compare(a, b, sourceCodeInfo);
                    });
                }
                else {
                    result.sort(function (a, b) {
                        assertFunctionLike(comparer, sourceCodeInfo);
                        var compareValue = executeFunction(comparer, [a, b], contextStack, sourceCodeInfo);
                        assertNumber(compareValue, sourceCodeInfo, { finite: true });
                        return compareValue;
                    });
                }
                return result;
            },
            arity: { min: 1, max: 2 },
            docs: {
                category: 'Sequence',
                returns: { type: 'any', rest: true },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: 'sequence' },
                    fun: { type: 'function' },
                },
                variants: [
                    { argumentNames: ['seq'] },
                    { argumentNames: ['seq', 'fun'] },
                ],
                description: 'Returns a new sequence with the elements from $seq sorted according to $fun. If no $fun is supplied, builtin `compare` will be used.',
                examples: [
                    '[3, 1, 2] sort (a, b) -> b - a',
                    'sort([3, 1, 2])',
                    "\nsort(\n  [3, 1, 2],\n  (a, b) -> cond case a < b then -1 case a > b then 1 case true then -1 end\n)",
                    "\nsort(\n  [3, 1, 2],\n  (a, b) -> cond case a > b then -1 case a < b then 1 case true then -1 end\n)",
                ],
            },
        },
        'sort-by': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var _b = __read(params, 2), seq = _b[0], keyfn = _b[1];
                var defaultComparer = params.length === 2;
                assertSeq(seq, sourceCodeInfo);
                assertFunctionLike(keyfn, sourceCodeInfo);
                var comparer = defaultComparer ? null : params[2];
                if (typeof seq === 'string') {
                    var result_2 = seq.split('');
                    if (defaultComparer) {
                        result_2.sort(function (a, b) {
                            var aKey = executeFunction(keyfn, [a], contextStack, sourceCodeInfo);
                            assertStringOrNumber(aKey, sourceCodeInfo);
                            var bKey = executeFunction(keyfn, [b], contextStack, sourceCodeInfo);
                            assertStringOrNumber(bKey, sourceCodeInfo);
                            return compare(aKey, bKey, sourceCodeInfo);
                        });
                    }
                    else {
                        assertFunctionLike(comparer, sourceCodeInfo);
                        result_2.sort(function (a, b) {
                            var aKey = executeFunction(keyfn, [a], contextStack, sourceCodeInfo);
                            var bKey = executeFunction(keyfn, [b], contextStack, sourceCodeInfo);
                            var compareValue = executeFunction(comparer, [aKey, bKey], contextStack, sourceCodeInfo);
                            assertNumber(compareValue, sourceCodeInfo, { finite: true });
                            return compareValue;
                        });
                    }
                    return result_2.join('');
                }
                var result = __spreadArray([], __read(seq), false);
                if (defaultComparer) {
                    result.sort(function (a, b) {
                        var aKey = executeFunction(keyfn, [a], contextStack, sourceCodeInfo);
                        assertStringOrNumber(aKey, sourceCodeInfo);
                        var bKey = executeFunction(keyfn, [b], contextStack, sourceCodeInfo);
                        assertStringOrNumber(bKey, sourceCodeInfo);
                        return compare(aKey, bKey, sourceCodeInfo);
                    });
                }
                else {
                    assertFunctionLike(comparer, sourceCodeInfo);
                    result.sort(function (a, b) {
                        var aKey = executeFunction(keyfn, [a], contextStack, sourceCodeInfo);
                        var bKey = executeFunction(keyfn, [b], contextStack, sourceCodeInfo);
                        var compareValue = executeFunction(comparer, [aKey, bKey], contextStack, sourceCodeInfo);
                        assertNumber(compareValue, sourceCodeInfo, { finite: true });
                        return compareValue;
                    });
                }
                return result;
            },
            arity: { min: 2, max: 3 },
            docs: {
                category: 'Sequence',
                returns: { type: 'any', rest: true },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: 'sequence' },
                    keyfn: { type: 'function' },
                    comparer: { type: 'function' },
                },
                variants: [
                    { argumentNames: ['seq', 'keyfn'] },
                    { argumentNames: ['seq', 'keyfn', 'comparer'] },
                ],
                description: 'Returns a sorted sequence of the items in $seq, where the sort order is determined by comparing `(keyfn item)`. If no $comparer is supplied, uses builtin `compare`.',
                examples: [
                    '["Albert", "Mojir", "Nina"] sort-by count',
                    'sort-by(["Albert", "Mojir", "Nina"], count)',
                    'sort-by("Albert", lower-case, -> $2 compare $1)',
                ],
            },
        },
        'take': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), input = _b[0], n = _b[1];
                assertNumber(n, sourceCodeInfo);
                assertSeq(input, sourceCodeInfo);
                var num = Math.max(Math.ceil(n), 0);
                return input.slice(0, num);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'integer' },
                    n: { type: 'integer' },
                    seq: { type: 'sequence' },
                },
                variants: [{ argumentNames: ['seq', 'n'] }],
                description: 'Constructs a new array/string with the $n first elements from $seq.',
                examples: [
                    '[1, 2, 3, 4, 5] take 3',
                    'take([1, 2, 3, 4, 5], 3)',
                    'take([1, 2, 3, 4, 5], 0)',
                    'take("Albert", 2)',
                    'take("Albert", 50)',
                ],
            },
        },
        'take-last': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], n = _b[1];
                assertSeq(array, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo);
                var num = Math.max(Math.ceil(n), 0);
                var from = array.length - num;
                return array.slice(from);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'integer' },
                    n: { type: 'integer' },
                    seq: { type: 'sequence' },
                },
                variants: [{ argumentNames: ['n', 'seq'] }],
                description: 'Constructs a new array with the $n last elements from $seq.',
                examples: [
                    '[1, 2, 3, 4, 5] take-last 3',
                    'take-last([1, 2, 3, 4, 5], 3)',
                    'take-last([1, 2, 3, 4, 5], 0)',
                ],
            },
        },
        'take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_1, _c;
                var _d = __read(_a, 2), seq = _d[0], fn = _d[1];
                var executeFunction = _b.executeFunction;
                assertSeq(seq, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var result = [];
                try {
                    for (var seq_1 = __values(seq), seq_1_1 = seq_1.next(); !seq_1_1.done; seq_1_1 = seq_1.next()) {
                        var item = seq_1_1.value;
                        if (executeFunction(fn, [item], contextStack, sourceCodeInfo))
                            result.push(item);
                        else
                            break;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (seq_1_1 && !seq_1_1.done && (_c = seq_1.return)) _c.call(seq_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return typeof seq === 'string' ? result.join('') : result;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: 'sequence' },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['seq', 'fun'] }],
                description: 'Returns the members of $seq in order, stopping before the first one for which `predicate` returns a falsy value.',
                examples: [
                    "\ntake-while(\n  [1, 2, 3, 2, 1],\n  -> $ < 3\n)",
                    "\ntake-while(\n  [1, 2, 3, 2, 1],\n  -> $ > 3\n)",
                ],
            },
        },
        'drop': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), input = _b[0], n = _b[1];
                assertNumber(n, sourceCodeInfo);
                var num = Math.max(Math.ceil(n), 0);
                assertSeq(input, sourceCodeInfo);
                return input.slice(num);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'integer' },
                    seq: { type: 'sequence' },
                    n: { type: 'integer' },
                },
                variants: [{ argumentNames: ['seq', 'n'] }],
                description: 'Constructs a new array/string with the $n first elements dropped from $seq.',
                examples: [
                    'drop([1, 2, 3, 4, 5], 3)',
                    'drop([1, 2, 3, 4, 5], 0)',
                    'drop("Albert", 2)',
                    'drop("Albert", 50)',
                ],
            },
        },
        'drop-last': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], n = _b[1];
                assertSeq(array, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo);
                var num = Math.max(Math.ceil(n), 0);
                var from = array.length - num;
                return array.slice(0, from);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'integer' },
                    seq: { type: 'sequence' },
                    n: { type: 'integer' },
                },
                variants: [{ argumentNames: ['seq', 'n'] }],
                description: 'Constructs a new array with the $n last elements dropped from $seq.',
                examples: [
                    '[1, 2, 3, 4, 5] drop-last 3',
                    'drop-last([1, 2, 3, 4, 5], 3)',
                    'drop-last([1, 2, 3, 4, 5], 0)',
                ],
            },
        },
        'drop-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertSeq(seq, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(seq)) {
                    var from_1 = seq.findIndex(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                    return seq.slice(from_1);
                }
                var charArray = seq.split('');
                var from = charArray.findIndex(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return charArray.slice(from).join('');
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: 'sequence' },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['seq', 'fun'] }],
                description: 'Returns the members of $seq in order, skipping the fist elements for witch the `predicate` returns a truethy value.',
                examples: [
                    "\ndrop-while(\n  [1, 2, 3, 2, 1],\n  -> $ < 3\n)",
                    "\ndrop-while(\n  [1, 2, 3, 2, 1],\n  -> $ > 3\n)",
                ],
            },
        },
        'unshift': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), seq = _b[0], values = _b.slice(1);
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertCharArray(values, sourceCodeInfo);
                    return __spreadArray(__spreadArray([], __read(values), false), [seq], false).join('');
                }
                var copy = __spreadArray([], __read(seq), false);
                copy.unshift.apply(copy, __spreadArray([], __read(values), false));
                return copy;
            },
            arity: { min: 2 },
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'any' },
                    seq: { type: 'sequence' },
                    values: { type: 'any', rest: true },
                },
                variants: [{ argumentNames: ['seq', 'values'] }],
                description: 'Returns copy of $seq with $values added to the beginning.',
                examples: [
                    '[1, 2, 3] unshift 4',
                    'unshift([1, 2, 3], 4)',
                    'unshift([1, 2, 3], 4, 5, 6)',
                    "\nlet l = [1, 2, 3];\nunshift(l, 4);\nl",
                ],
            },
        },
        'distinct': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_2, _b;
                var _c = __read(_a, 1), input = _c[0];
                assertSeq(input, sourceCodeInfo);
                if (Array.isArray(input)) {
                    var result = [];
                    var _loop_1 = function (item) {
                        assertAny(item, sourceCodeInfo);
                        if (!result.some(function (existingItem) { return deepEqual(existingItem, item, sourceCodeInfo); })) {
                            result.push(item);
                        }
                    };
                    try {
                        for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
                            var item = input_1_1.value;
                            _loop_1(item);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (input_1_1 && !input_1_1.done && (_b = input_1.return)) _b.call(input_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    return result;
                }
                return Array.from(new Set(input.split(''))).join('');
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: { seq: { type: 'sequence' } },
                variants: [{ argumentNames: ['seq'] }],
                description: 'Returns a copy of $seq with no duplicates.',
                examples: [
                    'distinct([[1], [2], [3], [1], [3], [5]])',
                    'distinct([1, 2, 3, 1, 3, 5])',
                    'distinct("Albert Mojir")',
                    'distinct([])',
                    'distinct("")',
                ],
            },
        },
        'remove': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), input = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertSeq(input, sourceCodeInfo);
                if (Array.isArray(input))
                    return input.filter(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return input
                    .split('')
                    .filter(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); })
                    .join('');
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: 'sequence' },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['seq', 'fun'] }],
                description: 'Returns a new sequence of items in $seq for witch `pred(item)` returns a falsy value.',
                examples: [
                    '[1, 2, 3, 1, 3, 5] remove odd?',
                    'remove([1, 2, 3, 1, 3, 5], even?)',
                    'remove("Albert Mojir", -> "aoueiyAOUEIY" contains? $)',
                ],
            },
        },
        'remove-at': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), input = _b[0], index = _b[1];
                assertNumber(index, sourceCodeInfo, { integer: true });
                assertSeq(input, sourceCodeInfo);
                var at = index < 0 ? input.length + index : index;
                if (at < 0 || at >= input.length)
                    return input;
                if (Array.isArray(input)) {
                    return input.filter(function (_, i) { return i !== at; });
                }
                return "".concat(input.substring(0, at)).concat(input.substring(at + 1));
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'integer' },
                    seq: { type: 'sequence' },
                    n: { type: 'number' },
                },
                variants: [{ argumentNames: ['seq', 'n'] }],
                description: 'Returns a new sequence of all items in $seq except item at position $n. If $n is negative, it is counting from the end of the sequence.',
                examples: [
                    '[1, 2, 3, 1, 3, 5] remove-at 2',
                    '"Albert" remove-at -2',
                    'remove-at([1, 2, 3, 1, 3, 5], 0)',
                    'remove-at([1, 2, 3, 1, 3, 5], -1)',
                    'remove-at("Albert Mojir", 6)',
                ],
            },
        },
        'split-at': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], pos = _b[1];
                assertNumber(pos, sourceCodeInfo, { integer: true });
                assertSeq(seq, sourceCodeInfo);
                var at = pos < 0 ? seq.length + pos : pos;
                return [seq.slice(0, at), seq.slice(at)];
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'integer' },
                    seq: { type: 'sequence' },
                    n: { type: 'number' },
                },
                variants: [{ argumentNames: ['seq', 'n'] }],
                description: 'Returns a pair of sequence `[take(pos input), drop(pos input)]`.',
                examples: [
                    '[1, 2, 3, 4, 5] split-at 2',
                    '"Albert" split-at -2',
                    'split-at([1, 2, 3, 4, 5], -2)',
                    'split-at("Albert", 2)',
                ],
            },
        },
        'split-with': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertSeq(seq, sourceCodeInfo);
                var seqIsArray = Array.isArray(seq);
                var arr = seqIsArray ? seq : seq.split('');
                var index = arr.findIndex(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (index === -1)
                    return [seq, seqIsArray ? [] : ''];
                return [seq.slice(0, index), seq.slice(index)];
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: 'sequence' },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['seq', 'fun'] }],
                description: 'Returns a pair of sequences `[take-while(input, fun), drop-while(input, fun)]`.',
                examples: [
                    '[1, 2, 3, 4, 5] split-with odd?',
                    'split-with([1, 2, 3, 4, 5], -> $ > 3)',
                    'split-with("Albert", -> $ <= "o")',
                ],
            },
        },
        'frequencies': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                var arr = typeof seq === 'string' ? seq.split('') : seq;
                return arr.reduce(function (result, val) {
                    assertString(val, sourceCodeInfo);
                    if (collHasKey(result, val))
                        result[val] = result[val] + 1;
                    else
                        result[val] = 1;
                    return result;
                }, {});
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Sequence',
                returns: { type: 'object' },
                args: { seq: { type: 'sequence' } },
                variants: [{ argumentNames: ['seq'] }],
                description: 'Returns an object from distinct items in $seq to the number of times they appear. Note that all items in $seq must be valid object keys i.e. strings.',
                examples: [
                    'frequencies(["Albert", "Mojir", "Nina", "Mojir"])',
                    'frequencies("Pneumonoultramicroscopicsilicovolcanoconiosis")',
                ],
            },
        },
        'group-by': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertSeq(seq, sourceCodeInfo);
                var arr = Array.isArray(seq) ? seq : seq.split('');
                return arr.reduce(function (result, val) {
                    var key = executeFunction(fn, [val], contextStack, sourceCodeInfo);
                    assertString(key, sourceCodeInfo);
                    if (!collHasKey(result, key))
                        result[key] = [];
                    result[key].push(val);
                    return result;
                }, {});
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'object' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: 'sequence' },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['seq', 'fun'] }],
                description: 'Returns an object of the elements of $seq keyed by the result of $fun on each element. The value at each key will be an array of the corresponding elements.',
                examples: [
                    '[{ name: "Albert" }, { name: "Albert" }, { name: "Mojir" }] group-by "name"',
                    'group-by([{name: "Albert"}, {name: "Albert"}, {name: "Mojir"}], "name")',
                    'group-by("Albert Mojir", -> "aoueiAOUEI" contains? $ ? "vowel" : "other")',
                ],
            },
        },
        'partition': {
            evaluate: function (params, sourceCodeInfo) {
                var seq = asSeq(params[0], sourceCodeInfo);
                var n = toNonNegativeInteger(asNumber(params[1], sourceCodeInfo));
                var step = params.length >= 3 ? toNonNegativeInteger(asNumber(params[2], sourceCodeInfo)) : n;
                var pad = params.length === 4
                    ? params[3] === null ? [] : asArray(params[3], sourceCodeInfo)
                    : undefined;
                return partition(n, step, seq, pad, sourceCodeInfo);
            },
            arity: { min: 2, max: 4 },
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'number' },
                    seq: { type: 'sequence' },
                    n: { type: 'number' },
                    step: { type: 'number' },
                    pad: { type: 'array' },
                },
                variants: [
                    { argumentNames: ['seq', 'n'] },
                    { argumentNames: ['seq', 'n', 'step'] },
                    { argumentNames: ['seq', 'n', 'step', 'pad'] },
                ],
                description: 'Returns an array of sequences of $n items each, at offsets $step apart. If $step is not supplied, defaults to $n. If a $pad array is supplied, use its elements as necessary to complete last partition upto $n items. In case there are not enough padding elements, return a partition with less than $n items.',
                examples: [
                    'range(20) partition 4',
                    'partition(range(20), 4)',
                    'partition(range(22), 4)',
                    'partition(range(20), 4, 6)',
                    'partition(range(20), 4, 3)',
                    'partition(range(20), 3, 6, ["a"])',
                    'partition(range(20), 4, 6, ["a"])',
                    'partition(range(20), 4, 6, ["a", "b", "c", "d"])',
                    'partition(["a", "b", "c", "d", "e", "f"], 3, 1)',
                    'partition([1, 2, 3, 4], 10)',
                    'partition([1, 2, 3, 4], 10, 10)',
                    'partition([1, 2, 3, 4], 10, 10, [])',
                    'partition([1, 2, 3, 4], 10, 10, null)',
                    'partition("superfragilistic", 5)',
                    'partition("superfragilistic", 5, 5, null)',
                    'let foo = [5, 6, 7, 8]; partition(foo, 2, 1, foo)',
                ],
            },
        },
        'partition-all': {
            evaluate: function (params, sourceCodeInfo) {
                var seq = asSeq(params[0], sourceCodeInfo);
                var n = toNonNegativeInteger(asNumber(params[1], sourceCodeInfo));
                var step = params.length === 3 ? toNonNegativeInteger(asNumber(params[2], sourceCodeInfo)) : n;
                return partition(n, step, seq, [], sourceCodeInfo);
            },
            arity: { min: 2, max: 3 },
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'number' },
                    seq: { type: 'sequence' },
                    n: { type: 'number' },
                    step: { type: 'number' },
                },
                variants: [
                    { argumentNames: ['seq', 'n'] },
                    { argumentNames: ['seq', 'n', 'step'] },
                ],
                description: 'Returns an array of sequences like partition, but may include partitions with fewer than n items at the end.',
                examples: [
                    '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] partition-all 4',
                    'partition-all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4)',
                    'partition([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4)',
                    'partition-all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 2, 4)',
                ],
            },
        },
        'partition-by': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertSeq(seq, sourceCodeInfo);
                var isStringSeq = typeof seq === 'string';
                var oldValue;
                var result = (isStringSeq ? seq.split('') : seq).reduce(function (acc, elem) {
                    var value = executeFunction(fn, [elem], contextStack, sourceCodeInfo);
                    if (value !== oldValue) {
                        acc.push([]);
                        oldValue = value;
                    }
                    acc[acc.length - 1].push(elem);
                    return acc;
                }, []);
                return isStringSeq ? result.map(function (elem) { return elem.join(''); }) : result;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'function' },
                    seq: { type: 'sequence' },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['seq', 'fun'] }],
                description: 'Applies $fun to each value in $seq, splitting it each time $fun returns a new value. Returns an array of sequences.',
                examples: [
                    '[1, 2, 3, 4, 5] partition-by odd?',
                    'partition-by([1, 2, 3, 4, 5], -> $ == 3)',
                    'partition-by([1, 1, 1, 2, 2, 3, 3], odd?)',
                    'partition-by("Leeeeeerrroyyy", identity)',
                ],
            },
        },
        'ends-with?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), str = _b[0], search = _b[1];
                assertSeq(str, sourceCodeInfo);
                if (typeof str === 'string') {
                    assertString(search, sourceCodeInfo);
                    return str.endsWith(search);
                }
                return deepEqual(asAny(str.at(-1), sourceCodeInfo), asAny(search, sourceCodeInfo), sourceCodeInfo);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'boolean' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'sequence' },
                    seq: { type: 'sequence' },
                    suffix: { type: 'sequence' },
                },
                variants: [{ argumentNames: ['seq', 'suffix'] }],
                description: 'Returns `true` if $seq ends with $suffix, otherwise `false`.',
                examples: [
                    '[[1], [2], [3], [4], [5]] starts-with? [5]',
                    '[[1], [2], [3], [4], [5]] starts-with? 5',
                    'ends-with?([1, 2, 3, 4, 5], 5)',
                    'ends-with?([1, 2, 3, 4, 5], [5])',
                    'ends-with?("Albert", "rt")',
                    'ends-with?("Albert", "RT")',
                ],
            },
        },
        'starts-with?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], search = _b[1];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertString(search, sourceCodeInfo);
                    return seq.startsWith(search);
                }
                return deepEqual(asAny(seq[0], sourceCodeInfo), asAny(search, sourceCodeInfo), sourceCodeInfo);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'boolean' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'sequence' },
                    seq: { type: 'sequence' },
                    prefix: { type: 'sequence' },
                },
                variants: [{ argumentNames: ['seq', 'prefix'] }],
                description: 'Returns `true` if $seq starts with $prefix, otherwise `false`.',
                examples: [
                    '[[1], [2], [3], [4], [5]] starts-with? [1]',
                    'starts-with?([1, 2, 3, 4, 5], 1)',
                    'starts-with?([1, 2, 3, 4, 5], [1])',
                    'starts-with?("Albert", "Al")',
                    'starts-with?("Albert", "al")',
                ],
            },
        },
        'interleave': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_3, _b;
                var _c = __read(_a), seqs = _c.slice(0);
                var isStringSeq = typeof seqs[0] === 'string';
                var seqsArr = isStringSeq
                    ? seqs.map(function (seq) {
                        assertString(seq, sourceCodeInfo);
                        return seq.split('');
                    })
                    : seqs.map(function (seq) {
                        assertArray(seq, sourceCodeInfo);
                        return seq;
                    });
                var maxLength = Math.min.apply(Math, __spreadArray([], __read(seqsArr.map(function (seq) { return seq.length; })), false));
                var result = [];
                for (var i = 0; i < maxLength; i += 1) {
                    try {
                        for (var seqsArr_1 = (e_3 = void 0, __values(seqsArr)), seqsArr_1_1 = seqsArr_1.next(); !seqsArr_1_1.done; seqsArr_1_1 = seqsArr_1.next()) {
                            var seq = seqsArr_1_1.value;
                            if (i < seq.length)
                                result.push(seq[i]);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (seqsArr_1_1 && !seqsArr_1_1.done && (_b = seqsArr_1.return)) _b.call(seqsArr_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
                return isStringSeq ? result.join('') : result;
            },
            arity: { min: 1 },
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'sequence' },
                    seqs: { type: 'sequence', rest: true },
                },
                variants: [{ argumentNames: ['seqs'] }],
                description: 'Returns a sequence of the first item from each of the $seqs, then the second item from each of the $seqs, until all items from the shortest seq are exhausted.',
                examples: [
                    '[1, 2, 3] interleave [4, 5, 6]',
                    '"Albert" interleave ".,.,.,"',
                    'interleave([1, 2, 3], [4, 5, 6])',
                    'interleave([1, 2, 3], [4, 5, 6], [7, 8, 9])',
                    'interleave([1, 2, 3], [4, 5, 6], [7, 8])',
                    'interleave([1, 2, 3], [4, 5, 6], [7])',
                    'interleave([1, 2, 3], [4, 5, 6], [])',
                    'interleave([1, 2, 3], [])',
                    'interleave([])',
                ],
            },
        },
        'interpose': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], separator = _b[1];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertString(separator, sourceCodeInfo);
                    return seq.split('').join(separator);
                }
                if (seq.length === 0)
                    return [];
                var result = [];
                for (var i = 0; i < seq.length - 1; i += 1) {
                    result.push(seq[i], separator);
                }
                result.push(seq[seq.length - 1]);
                return result;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Sequence',
                returns: { type: 'sequence' },
                args: {
                    a: { type: 'sequence' },
                    b: { type: 'any' },
                    seq: { type: 'sequence' },
                    separator: { type: 'any' },
                },
                variants: [{ argumentNames: ['seq', 'separator'] }],
                description: 'Returns a sequence of the elements of $seq separated by $separator. If $seq is a string, the separator must be a string.',
                examples: [
                    '"Albert" interpose "-"',
                    'interpose([1, 2, 3, 4, 5], "a")',
                    'interpose(["Albert", "Mojir", "Nina"], ", ")',
                    'interpose("Albert", ".")',
                ],
            },
        },
    };
    function partition(n, step, seq, pad, sourceCodeInfo) {
        assertNumber(step, sourceCodeInfo, { positive: true });
        var isStringSeq = typeof seq === 'string';
        var result = [];
        var start = 0;
        outer: while (start < seq.length) {
            var innerArr = [];
            for (var i = start; i < start + n; i += 1) {
                if (i >= seq.length) {
                    var padIndex = i - seq.length;
                    if (!pad) {
                        start += step;
                        continue outer;
                    }
                    if (padIndex >= pad.length)
                        break;
                    innerArr.push(pad[padIndex]);
                }
                else {
                    innerArr.push(seq[i]);
                }
            }
            result.push(innerArr);
            start += step;
        }
        return isStringSeq ? result.map(function (x) { return x.join(''); }) : result;
    }

    function getNumberVectorOrMatrixOperation(params, sourceCodeInfo) {
        var e_1, _a, e_2, _b, e_3, _c;
        var hasVector = false;
        var hasMatrix = false;
        try {
            for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                var param = params_1_1.value;
                if (isVector(param)) {
                    hasVector = true;
                }
                else if (isMatrix(param)) {
                    hasMatrix = true;
                }
                else if (!isNumber(param)) {
                    throw new LitsError("Invalid parameter type: ".concat(typeof param), sourceCodeInfo);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (hasMatrix) {
            if (hasVector) {
                throw new LitsError('Cannot mix vector and matrix types', sourceCodeInfo);
            }
            var rows_1 = null;
            var cold_1 = null;
            try {
                for (var params_2 = __values(params), params_2_1 = params_2.next(); !params_2_1.done; params_2_1 = params_2.next()) {
                    var param = params_2_1.value;
                    if (isMatrix(param)) {
                        if (rows_1 === null) {
                            rows_1 = param.length;
                            cold_1 = param[0].length;
                        }
                        else {
                            if (param.length !== rows_1 || param[0].length !== cold_1) {
                                throw new LitsError('Matrix dimensions do not match', sourceCodeInfo);
                            }
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (params_2_1 && !params_2_1.done && (_b = params_2.return)) _b.call(params_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var matrices = params.map(function (param) {
                if (isMatrix(param)) {
                    return param;
                }
                return Array.from({ length: rows_1 }, function () { return Array.from({ length: cold_1 }, function () { return param; }); });
            });
            return ['matrix', matrices];
        }
        if (hasVector) {
            var length_1 = null;
            try {
                for (var params_3 = __values(params), params_3_1 = params_3.next(); !params_3_1.done; params_3_1 = params_3.next()) {
                    var param = params_3_1.value;
                    if (isVector(param)) {
                        if (length_1 === null) {
                            length_1 = param.length;
                        }
                        else {
                            if (param.length !== length_1) {
                                throw new LitsError('Vector lengths do not match', sourceCodeInfo);
                            }
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (params_3_1 && !params_3_1.done && (_c = params_3.return)) _c.call(params_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
            var vectors = params.map(function (param) {
                if (isVector(param)) {
                    return param;
                }
                return Array.from({ length: length_1 }, function () { return param; });
            });
            return ['vector', vectors];
        }
        return ['number', params];
    }
    var mathNormalExpression = {
        'inc': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands[0] + 1;
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    return firstVector.map(function (val) { return val + 1; });
                }
                else {
                    var firstMatrix = operands[0];
                    return firstMatrix.map(function (row) { return row.map(function (val) { return val + 1; }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: 'number' },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `inc` function increments its argument by 1, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it increases each element by 1 while preserving the original structure.',
                examples: [
                    'inc(0)',
                    'inc(1)',
                    'inc(100.1)',
                    'inc([1, 2, 3])',
                    'inc([[1, 2], [3, 4]])',
                ],
            },
        },
        'dec': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands[0] - 1;
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    return firstVector.map(function (val) { return val - 1; });
                }
                else {
                    var firstMatrix = operands[0];
                    return firstMatrix.map(function (row) { return row.map(function (val) { return val - 1; }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `dec` function decrements its argument by 1, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it decreases each element by 1 while preserving the original structure.',
                examples: [
                    'dec(0)',
                    'dec(1)',
                    'dec(100.1)',
                    'dec([1, 2, 3])',
                    'dec([[1, 2], [3, 4]])',
                ],
            },
        },
        '+': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0) {
                    return 0;
                }
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands.reduce(function (result, param) { return result + (param); }, 0);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var restVectors = operands.slice(1);
                    return restVectors.reduce(function (acc, vector) { return acc.map(function (val, i) { return val + vector[i]; }); }, firstVector);
                }
                else {
                    var firstMatrix = operands[0];
                    var restMatrices = operands.slice(1);
                    return restMatrices.reduce(function (acc, matrix) { return acc.map(function (row, i) { return row.map(function (val, j) { return val + matrix[i][j]; }); }); }, firstMatrix);
                }
            },
            arity: {},
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    a: { type: ['number', 'vector', 'matrix'] },
                    b: { type: ['number', 'vector', 'matrix'] },
                    xs: { type: ['number', 'vector', 'matrix'], rest: true },
                },
                variants: [{ argumentNames: ['xs'] }],
                description: 'The `+` function performs addition of numbers and element-wise addition of `vectors` and `matrices` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it adds the scalar to each element of the collection.',
                examples: [
                    '1 + 2',
                    '1 + 20 + 30',
                    '+(1, 2, 3, 4)',
                    '+()',
                    '+(1)',
                    '[1, 2, 3] + 2',
                    '[1, 2, 3] + [4, 5, 6]',
                    '[[1, 2, 3], [4, 5, 6]] + [[7, 8, 9], [10, 11, 12]]',
                    '[[1, 2, 3], [4, 5, 6]] + 2',
                ],
            },
        },
        '*': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0) {
                    return 1;
                }
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands.reduce(function (result, param) { return result * (param); }, 1);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var restVectors = operands.slice(1);
                    return restVectors.reduce(function (acc, vector) { return acc.map(function (val, i) { return val * vector[i]; }); }, firstVector);
                }
                else {
                    var firstMatrix = operands[0];
                    var restMatrices = operands.slice(1);
                    return restMatrices.reduce(function (acc, matrix) { return acc.map(function (row, i) { return row.map(function (val, j) { return val * matrix[i][j]; }); }); }, firstMatrix);
                }
            },
            arity: {},
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    a: { type: ['number', 'vector', 'matrix'] },
                    b: { type: ['number', 'vector', 'matrix'] },
                    xs: { type: ['number', 'vector', 'matrix'], rest: true },
                },
                variants: [{ argumentNames: ['xs'] }],
                description: 'The `*` function performs multiplication of `numbers` and element-wise multiplication of `vectors` and `matrices` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it multiplies each element of the collection by the scalar.',
                examples: [
                    '6 * 7',
                    '-1 * 4',
                    '*(4, 7)',
                    '*(1, 2, 3, 4, 5)',
                    '*()',
                    '*(8)',
                    '[1, 2, 3] * 2',
                    '[1, 2, 3] * [4, 5, 6]',
                    '[[1, 2, 3], [4, 5, 6]] * [[7, 8, 9], [10, 11, 12]]',
                    '[[1, 2, 3], [4, 5, 6]] * 2',
                ],
            },
        },
        '/': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0) {
                    return 1;
                }
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    var _b = __read(operands), first = _b[0], rest = _b.slice(1);
                    if (rest.length === 0) {
                        return 1 / first;
                    }
                    return rest.reduce(function (result, param) {
                        return result / param;
                    }, first);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var restVectors = operands.slice(1);
                    return restVectors.reduce(function (acc, vector) { return acc.map(function (val, i) { return val / vector[i]; }); }, firstVector);
                }
                else {
                    var firstMatrix = operands[0];
                    var restMatrices = operands.slice(1);
                    return restMatrices.reduce(function (acc, matrix) { return acc.map(function (row, i) { return row.map(function (val, j) { return val / matrix[i][j]; }); }); }, firstMatrix);
                }
            },
            arity: {},
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    a: { type: ['number', 'vector', 'matrix'] },
                    b: { type: ['number', 'vector', 'matrix'] },
                    xs: { type: ['number', 'vector', 'matrix'], rest: true },
                },
                variants: [{ argumentNames: ['xs'] }],
                description: 'The `/` function performs division of `numbers` and element-wise division of `vectors` and `matrices` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it divides each element of the collection by the scalar.',
                examples: [
                    '12 / 100',
                    '-1 / 4',
                    '/(7, 4)',
                    '/(1, 2, 4, 8)',
                    '/()',
                    '/(8)',
                    '[1, 2, 3] / 2',
                    '[1, 2, 3] / [4, 5, 6]',
                    '[[1, 2, 3], [4, 5, 6]] / [[7, 8, 9], [10, 11, 12]]',
                    '[[1, 2, 3], [4, 5, 6]] / 2',
                ],
            },
        },
        '-': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0) {
                    return 0;
                }
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    var _b = __read(operands), first = _b[0], rest = _b.slice(1);
                    if (rest.length === 0)
                        return -first;
                    return rest.reduce(function (result, param) {
                        return result - param;
                    }, first);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var restVectors = operands.slice(1);
                    return restVectors.reduce(function (acc, vector) { return acc.map(function (val, i) { return val - vector[i]; }); }, firstVector);
                }
                else {
                    var firstMatrix = operands[0];
                    var restMatrices = operands.slice(1);
                    return restMatrices.reduce(function (acc, matrix) { return acc.map(function (row, i) { return row.map(function (val, j) { return val - matrix[i][j]; }); }); }, firstMatrix);
                }
            },
            arity: {},
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    a: { type: ['number', 'vector', 'matrix'] },
                    b: { type: ['number', 'vector', 'matrix'] },
                    xs: { type: ['number', 'vector', 'matrix'], rest: true },
                },
                variants: [{ argumentNames: ['xs'] }],
                description: 'Computes difference between first value and sum of the rest. When called with only one argument, it does negation.',
                examples: [
                    '50 - 8',
                    '1 - 1 - 1',
                    '-()',
                    '-(4, 2)',
                    '-(4, 3, 2, 1,)',
                    '[1, 2, 3] - 2',
                    '[1, 2, 3] - [4, 5, 6]',
                    '[[1, 2, 3], [4, 5, 6]] - [[7, 8, 9], [10, 11, 12]]',
                    '[[1, 2, 3], [4, 5, 6]] - 2',
                ],
            },
        },
        'quot': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.trunc(operands[0] / operands[1]);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var secondVector_1 = operands[1];
                    return firstVector.map(function (val, i) { return Math.trunc(val / secondVector_1[i]); });
                }
                else {
                    var firstMatrix = operands[0];
                    var secondMatrix_1 = operands[1];
                    return firstMatrix.map(function (row, i) { return row.map(function (val, j) { return Math.trunc(val / secondMatrix_1[i][j]); }); });
                }
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    a: { type: ['number', 'vector', 'matrix'] },
                    b: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'The `quot` function performs integer division truncated toward zero, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies integer division between each element of the collection and the scalar.',
                examples: [
                    'quot(5, 3)',
                    'quot(5.2, 3.1)',
                    'quot(-5, 3)',
                    '5 quot -3',
                    '-5 quot -3',
                    'quot(5, 0)',
                    'quot(0, 5)',
                    '[1, 2, 3] quot 2',
                    '2 quot [1, 2, 3]',
                    'quot([1, 2, 3], [4, 5, 6])',
                    '[[1, 2, 3], [4, 5, 6]] quot [[7, 8, 9], [10, 11, 12]]',
                    'quot([[1, 2, 3], [4, 5, 6]], 2)',
                    '[[1, 2, 3], [4, 5, 6]] quot [[7, 8, 9], [10, 11, 12]]',
                ],
            },
        },
        'mod': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    var quotient = Math.floor(operands[0] / operands[1]);
                    return operands[0] - operands[1] * quotient;
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var secondVector_2 = operands[1];
                    return firstVector.map(function (dividend, i) {
                        var divisor = secondVector_2[i];
                        var quotient = Math.floor(dividend / divisor);
                        return dividend - divisor * quotient;
                    });
                }
                else {
                    var firstMatrix = operands[0];
                    var secondMatrix_2 = operands[1];
                    return firstMatrix.map(function (row, i) { return row.map(function (val, j) {
                        var quotient = Math.floor(val / secondMatrix_2[i][j]);
                        return val - secondMatrix_2[i][j] * quotient;
                    }); });
                }
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    a: { type: ['number', 'vector', 'matrix'] },
                    b: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'The `mod` function computes the modulo of division with the same sign as the divisor, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies the modulo operation between each element of the collection and the scalar.',
                examples: [
                    'mod(5, 3)',
                    'mod(5.2, 3.1)',
                    'mod(-5, 3)',
                    '5 mod -3',
                    '-5 mod -3',
                    '[1, 2, 3] mod 2',
                    '2 mod [1, 2, 3]',
                    'mod([1, 2, 3], [4, 5, 6])',
                    '[[1, 2, 3], [4, 5, 6]] mod [[7, 8, 9], [10, 11, 12]]',
                    'mod([[1, 2, 3], [4, 5, 6]], 2)',
                ],
            },
        },
        '%': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands[0] % operands[1];
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var secondVector_3 = operands[1];
                    return firstVector.map(function (dividend, i) { return dividend % secondVector_3[i]; });
                }
                else {
                    var firstMatrix = operands[0];
                    var secondMatrix_3 = operands[1];
                    return firstMatrix.map(function (row, i) { return row.map(function (dividend, j) { return dividend % secondMatrix_3[i][j]; }); });
                }
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    a: { type: ['number', 'vector', 'matrix'] },
                    b: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'The `%` function computes the remainder of division with the same sign as the dividend, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies the remainder operation between each element of the collection and the scalar.',
                examples: [
                    '5 % 3',
                    '5.2 % 3.1',
                    '-5 % 3',
                    '%(5, -3)',
                    '%(-5, -3)',
                    '[1, 2, 3] % 2',
                    '2 % [1, 2, 3]',
                    '%([1, 2, 3], [4, 5, 6])',
                    '[[1, 2, 3], [4, 5, 6]] % [[7, 8, 9], [10, 11, 12]]',
                    '%([[1, 2, 3], [4, 5, 6]], 2)',
                ],
            },
        },
        'sqrt': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.sqrt(operands[0]);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    return firstVector.map(function (val) { return Math.sqrt(val); });
                }
                else {
                    var firstMatrix = operands[0];
                    return firstMatrix.map(function (row) { return row.map(function (val) { return Math.sqrt(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `sqrt` function calculates the square root of `numbers` and computes element-wise square roots of `vectors` and `matrices`. When applied to collections, it returns the square root of each element while preserving the original structure.',
                examples: [
                    'sqrt(0)',
                    'sqrt(9)',
                    'sqrt(2)',
                    'sqrt(0)',
                    'sqrt(9)',
                    'sqrt(2)',
                    'sqrt([1, 4, 9])',
                    'sqrt([[1, 4], [9, 16]])',
                ],
            },
        },
        'cbrt': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.cbrt(operands[0]);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    return firstVector.map(function (val) { return Math.cbrt(val); });
                }
                else {
                    var firstMatrix = operands[0];
                    return firstMatrix.map(function (row) { return row.map(function (val) { return Math.cbrt(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `cbrt` function calculates the cube root of `numbers` and computes element-wise cube roots of `vectors` and `matrices`. When applied to collections, it returns the cube root of each element while preserving the original structure.',
                examples: [
                    'cbrt(0)',
                    'cbrt(27)',
                    'cbrt(2)',
                    'cbrt(1)',
                    'cbrt(0)',
                    'cbrt(27)',
                    'cbrt(2)',
                    'cbrt(1)',
                    'cbrt([1, 8, 27])',
                    'cbrt([[1, 8], [27, 64]])',
                ],
            },
        },
        '^': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.pow(operands[0], operands[1]);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var secondVector_4 = operands[1];
                    return firstVector.map(function (base, i) { return Math.pow(base, secondVector_4[i]); });
                }
                else {
                    var firstMatrix = operands[0];
                    var secondMatrix_4 = operands[1];
                    return firstMatrix.map(function (row, i) { return row.map(function (base, j) { return Math.pow(base, secondMatrix_4[i][j]); }); });
                }
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    a: { type: ['number', 'vector', 'matrix'] },
                    b: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'The ^ function computes exponentiation, raising the first argument to the power of the second, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies the power operation between each element of the collection and the scalar.',
                examples: [
                    '2 ^ 3',
                    '2 ^ 0',
                    '2 ^ -3',
                    '^(-2, 3)',
                    '^(-2, -3)',
                    '[1, 2, 3] ^ 2',
                    '2 ^ [1, 2, 3]',
                    '^([1, 2, 3], [4, 5, 6])',
                    '[[1, 2, 3], [4, 5, 6]] ^ [[7, 8, 9], [10, 11, 12]]',
                    '^([[1, 2, 3], [4, 5, 6]], 2)',
                ],
            },
        },
        'round': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), value = _b[0], decimals = _b[1];
                var _c = __read(getNumberVectorOrMatrixOperation([value], sourceCodeInfo), 2), operation = _c[0], operands = _c[1];
                if (operation === 'number') {
                    if (decimals === undefined || decimals === 0) {
                        return Math.round(operands[0]);
                    }
                    else {
                        assertNumber(decimals, sourceCodeInfo, { integer: true, positive: true });
                        var factor = Math.pow(10, decimals);
                        return Math.round(operands[0] * factor) / factor;
                    }
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    if (decimals === undefined || decimals === 0) {
                        return vector.map(function (val) { return Math.round(val); });
                    }
                    else {
                        assertNumber(decimals, sourceCodeInfo, { integer: true, positive: true });
                        var factor_1 = Math.pow(10, decimals);
                        return vector.map(function (val) { return Math.round(val * factor_1) / factor_1; });
                    }
                }
                else {
                    var matrix = operands[0];
                    if (decimals === undefined || decimals === 0) {
                        return matrix.map(function (row) { return row.map(function (val) { return Math.round(val); }); });
                    }
                    else {
                        assertNumber(decimals, sourceCodeInfo, { integer: true, positive: true });
                        var factor_2 = Math.pow(10, decimals);
                        return matrix.map(function (row) { return row.map(function (val) { return Math.round(val * factor_2) / factor_2; }); });
                    }
                }
            },
            arity: { min: 1, max: 2 },
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    a: { type: ['number', 'vector', 'matrix'] },
                    b: { type: 'integer' },
                },
                variants: [
                    { argumentNames: ['a'] },
                    { argumentNames: ['a', 'b'] },
                ],
                description: 'The `round` function rounds a `number` to the nearest `integer` or to a specified number of `decimal` places, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it rounds each element while preserving the original structure.',
                examples: [
                    'round(2)',
                    'round(2.49)',
                    'round(2.5)',
                    'round(-2.49)',
                    'round(-2.5)',
                    'round(-2.501)',
                    'round(1.23456789, 4)',
                    '1.123456789 round 2',
                    'round([1.23456789, 2.3456789], 1)',
                    '[1.23456789, 2.3456789] round 4',
                    '[[1.23456789, 2.3456789], [3.456789, 4.56789]] round 4',
                    'round([[1.23456789, 2.3456789], [3.456789, 4.56789]], 2)',
                ],
            },
        },
        'trunc': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.trunc(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.trunc(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.trunc(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['integer', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `trunc` function truncates `numbers` toward zero (removing decimal portions without rounding), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it truncates each element while preserving the original structure.',
                examples: [
                    'trunc(2)',
                    'trunc(2.49)',
                    'trunc(2.5)',
                    'trunc(-2.49)',
                    'trunc(-2.5)',
                    'trunc(-2.501)',
                    'trunc([1.23456789, 2.3456789])',
                    'trunc([[1.23456789, 2.3456789], [3.456789, 4.56789]])',
                ],
            },
        },
        'floor': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.floor(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.floor(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.floor(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['integer', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `floor` function returns the largest `integer` less than or equal to a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the floor of each element while preserving the original structure.',
                examples: [
                    'floor(2)',
                    'floor(2.49)',
                    'floor(2.5)',
                    'floor(-2.49)',
                    'floor(-2.5)',
                    'floor(-2.501)',
                    'floor([1.23456789, 2.3456789])',
                    'floor([[1.23456789, 2.3456789], [3.456789, 4.56789]])',
                ],
            },
        },
        'ceil': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.ceil(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.ceil(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.ceil(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['integer', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `ceil` function returns the smallest `integer` greater than or equal to a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the ceiling of each element while preserving the original structure.',
                examples: [
                    'ceil(2)',
                    'ceil(2.49)',
                    'ceil(2.5)',
                    'ceil(-2.49)',
                    'ceil(-2.5)',
                    'ceil(-2.501)',
                    'ceil([1.23456789, 2.3456789])',
                    'ceil([[1.23456789, 2.3456789], [3.456789, 4.56789]])',
                ],
            },
        },
        'min': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo);
                if (rest.length === 0)
                    return first;
                return rest.reduce(function (min, value) {
                    assertNumber(value, sourceCodeInfo);
                    return Math.min(min, value);
                }, first);
            },
            arity: { min: 1 },
            docs: {
                category: 'Math',
                returns: { type: 'number' },
                args: {
                    a: { type: 'number' },
                    b: { type: 'number' },
                    xs: { type: 'number', rest: true },
                },
                variants: [{ argumentNames: ['xs'] }],
                description: 'Returns the smallest number of the arguments.',
                examples: [
                    '2 min 3',
                    'min(2, 0, 1)',
                    'min(2, -1, 1)',
                    'min(2.5)',
                    '12 min 14',
                ],
            },
        },
        'max': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo);
                if (rest.length === 0)
                    return first;
                return rest.reduce(function (min, value) {
                    assertNumber(value, sourceCodeInfo);
                    return Math.max(min, value);
                }, first);
            },
            arity: { min: 1 },
            docs: {
                category: 'Math',
                returns: { type: 'number' },
                args: {
                    a: { type: 'number' },
                    b: { type: 'number' },
                    xs: { type: 'number', rest: true },
                },
                variants: [{ argumentNames: ['xs'] }],
                description: 'Returns the largest number of the arguments.',
                examples: [
                    ' 2 max 3',
                    'max(2, 0, 1)',
                    'max(2, -1, 1)',
                    'max(2, 0.5)',
                    '4 max 2',
                ],
            },
        },
        'abs': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.abs(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.abs(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.abs(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The abs function returns the absolute value (magnitude) of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the absolute value of each element while preserving the original structure.',
                examples: [
                    'abs(-2.3)',
                    'abs(0)',
                    'abs(2.5)',
                    'abs([1, -2, 3])',
                    'abs([[1, -2], [3, -4]])',
                ],
            },
        },
        'sign': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.sign(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.sign(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.sign(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `sign` function returns the `sign** of a **number` (-1 for negative, 0 for zero, 1 for positive), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the sign of each element while preserving the original structure.',
                examples: [
                    'sign(-2.3)',
                    'sign(-0)',
                    'sign(0)',
                    'sign(12312)',
                    'sign([1, -2, 3])',
                    'sign([[1, -2], [3, -4]])',
                ],
            },
        },
        'ln': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.log(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.log(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.log(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `ln` function computes the natural logarithm (base `e`) of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the natural logarithm of each element while preserving the original structure.',
                examples: [
                    'ln(0.01)',
                    'ln(2.5)',
                    'ln(E)',
                    'ln([1, 2, 3])',
                    'ln([[1, 2], [3, 4]])',
                ],
            },
        },
        'log2': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.log2(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.log2(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.log2(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `log2` function computes the base `2` logarithm of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the base-2 logarithm of each element while preserving the original structure.',
                examples: [
                    'log2(0.01)',
                    'log2(2 ^ 12)',
                    'log2(2.5)',
                    'log2([1, 2, 3])',
                    'log2([[1, 2], [3, 4]])',
                ],
            },
        },
        'log10': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.log10(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.log10(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.log10(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `log10` function computes the base `10` logarithm of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the base-10 logarithm of each element while preserving the original structure.',
                examples: [
                    'log10(0.01)',
                    'log10(10 ^ 12)',
                    'log10(2.5)',
                    'log10([1, 2, 3])',
                    'log10([[1, 2], [3, 4]])',
                ],
            },
        },
        'sin': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.sin(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.sin(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.sin(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `sin` function computes the sine of an angle (in radians), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the sine of each element while preserving the original structure.',
                examples: [
                    'sin(0)',
                    'sin(1)',
                    'sin(PI)',
                    'sin(-0.5)',
                    'sin([1, 2, 3])',
                    'sin([[1, 2], [3, 4]])',
                ],
            },
        },
        'asin': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.asin(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.asin(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.asin(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `asin` function computes the arcsine (inverse sine) of a `number` in radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the arcsine of each element while preserving the original structure.',
                examples: [
                    'asin(0)',
                    'asin(1)',
                    'asin(-0.5)',
                    'asin([1, 2, 3])',
                    'asin([[1, 2], [3, 4]])',
                ],
            },
        },
        'sinh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.sinh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.sinh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.sinh(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `sinh` function computes the hyperbolic sine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the hyperbolic sine of each element while preserving the original structure.',
                examples: [
                    'sinh(0)',
                    'sinh(1)',
                    'sinh(-0.5)',
                    'sinh([0.1, 0.2, 0.3])',
                    'sinh([[0.1, 0.2], [0.3, 0.4]])',
                ],
            },
        },
        'asinh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.asinh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.asinh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.asinh(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `asinh` function computes the inverse hyperbolic sine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the inverse hyperbolic sine of each element while preserving the original structure.',
                examples: [
                    'asinh(10)',
                    'asinh(90)',
                    'asinh (50)',
                    'asinh([10, 20, 30])',
                    'asinh([[10, 20], [30, 40]])',
                ],
            },
        },
        'cos': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.cos(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.cos(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.cos(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `cos` function computes the cosine of an angle (in radians), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the cosine of each element while preserving the original structure.',
                examples: [
                    'cos(0)',
                    'cos(1)',
                    'cos(PI)',
                    'cos(-0.5)',
                    'cos([1, 2, 3])',
                    'cos([[1, 2], [3, 4]])',
                ],
            },
        },
        'acos': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.acos(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.acos(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.acos(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `acos` function computes the arccosine (inverse cosine) of a `number` in radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the arccosine of each element while preserving the original structure.',
                examples: [
                    'acos(0)',
                    'acos(1)',
                    'acos(-0.5)',
                    'acos([0.1, 0.2, 0.3])',
                    'acos([[0.1, 0.2], [0.3, 0.4]])',
                ],
            },
        },
        'cosh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.cosh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.cosh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.cosh(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `cosh` function computes the hyperbolic cosine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the hyperbolic cosine of each element while preserving the original structure.',
                examples: [
                    'cosh(0)',
                    'cosh(1)',
                    'cosh(-0.5)',
                    'cosh([0.1, 0.2, 0.3])',
                    'cosh([[0.1, 0.2], [0.3, 0.4]])',
                ],
            },
        },
        'acosh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.acosh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.acosh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.acosh(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `acosh` function computes the inverse hyperbolic cosine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the inverse hyperbolic cosine of each element while preserving the original structure.',
                examples: [
                    'acosh(1)',
                    'acosh(2)',
                    'acosh(100)',
                    'acosh(50)',
                    'acosh([1, 2, 3])',
                    'acosh([[1, 2], [3, 4]])',
                ],
            },
        },
        'tan': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.tan(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.tan(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.tan(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `tan` function computes the tangent of an angle (in radians), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the tangent of each element while preserving the original structure.',
                examples: [
                    'tan(0)',
                    'tan(1)',
                    'tan(PI)',
                    'tan(-0.5)',
                    'tan([1, 2, 3])',
                    'tan([[1, 2], [3, 4]])',
                ],
            },
        },
        'atan': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.atan(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.atan(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.atan(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `atan` function computes the arctangent (inverse tangent) of a `number` in radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the arctangent of each element while preserving the original structure.',
                examples: [
                    'atan(0)',
                    'atan(1)',
                    'atan(-0.5)',
                    'atan([0.1, 0.2, 0.3])',
                    'atan([[0.1, 0.2], [0.3, 0.4]])',
                ],
            },
        },
        'tanh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.tanh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.tanh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.tanh(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `tanh` function computes the hyperbolic tangent of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the hyperbolic tangent of each element while preserving the original structure.',
                examples: ['tanh(0)', 'tanh(1)', 'tanh(-0.5)', 'tanh(50)'],
            },
        },
        'atanh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.atanh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.atanh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.atanh(val); }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `atanh` function computes the inverse hyperbolic tangent of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the inverse hyperbolic tangent of each element while preserving the original structure.',
                examples: [
                    'atanh(0)',
                    'atanh(0.9)',
                    'atanh(-0.5)',
                    'atanh([0.1, 0.2, 0.3])',
                    'atanh([[0.1, 0.2], [0.3, 0.4]])',
                ],
            },
        },
        'to-rad': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return (operands[0] * Math.PI) / 180;
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return (val * Math.PI) / 180; });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return (val * Math.PI) / 180; }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `to-rad` function converts an angle from degrees to radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it converts each element while preserving the original structure.',
                examples: [
                    'to-rad(0)',
                    'to-rad(90)',
                    'to-rad(180)',
                    'to-rad(360)',
                    'to-rad([0, 90, 180])',
                    'to-rad([[0, 90], [180, 360]])',
                ],
            },
        },
        'to-deg': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return (operands[0] * 180) / Math.PI;
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return (val * 180) / Math.PI; });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return (val * 180) / Math.PI; }); });
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Math',
                returns: { type: ['number', 'vector', 'matrix'] },
                args: {
                    x: { type: ['number', 'vector', 'matrix'] },
                },
                variants: [{ argumentNames: ['x'] }],
                description: 'The `to-deg` function converts an angle from radians to degrees, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it converts each element while preserving the original structure.',
                examples: [
                    'to-deg(0)',
                    'to-deg(PI)',
                    'to-deg(PI / 2)',
                    'to-deg(3 * PI / 2)',
                    'to-deg([0, PI, PI / 2])',
                    'to-deg([[0, PI], [PI / 2, 3 * PI / 2]])',
                ],
            },
        },
    };

    function isEqual(_a, sourceCodeInfo) {
        var e_1, _b;
        var _c = __read(_a), first = _c[0], rest = _c.slice(1);
        var firstAny = asAny(first, sourceCodeInfo);
        try {
            for (var rest_1 = __values(rest), rest_1_1 = rest_1.next(); !rest_1_1.done; rest_1_1 = rest_1.next()) {
                var param = rest_1_1.value;
                if (!deepEqual(firstAny, asAny(param, sourceCodeInfo), sourceCodeInfo))
                    return false;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (rest_1_1 && !rest_1_1.done && (_b = rest_1.return)) _b.call(rest_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    }
    function isIdentical(_a) {
        var e_2, _b;
        var _c = __read(_a), first = _c[0], rest = _c.slice(1);
        try {
            for (var rest_2 = __values(rest), rest_2_1 = rest_2.next(); !rest_2_1.done; rest_2_1 = rest_2.next()) {
                var param = rest_2_1.value;
                if (param !== first)
                    return false;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (rest_2_1 && !rest_2_1.done && (_b = rest_2.return)) _b.call(rest_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return true;
    }
    var miscNormalExpression = {
        '==': {
            evaluate: function (params, sourceCodeInfo) {
                return isEqual(params, sourceCodeInfo);
            },
            arity: { min: 1 },
            docs: {
                category: 'Misc',
                returns: { type: 'boolean' },
                args: {
                    a: { type: 'any' },
                    b: { type: 'any' },
                    x: { type: 'any' },
                    ys: { type: 'any', rest: true },
                },
                variants: [
                    { argumentNames: ['x'] },
                    { argumentNames: ['x', 'ys'] },
                ],
                description: 'Returns `true` if all `values` are structaul equal to each other, otherwise result is `false`.',
                examples: [
                    '1 == 1',
                    '[1, 2] == [1, 2]',
                    "\n{\n a: 1,\n b: 2,\n} == {\n b: 2,\n a: 1,\n}",
                    '==(1, 1)',
                    '==(1.01, 1)',
                    '==("1", 1)',
                    '==("2", "2", "2", "2")',
                    '==(2, 2, 1, 2)',
                    '==([1, 2], [1, 2])',
                    '==({ a: 1, b: 2 }, { b: 2, a: 1 })',
                ],
            },
        },
        '≠': {
            evaluate: function (params, sourceCodeInfo) {
                return !isEqual(params, sourceCodeInfo);
            },
            arity: { min: 1 },
            docs: {
                category: 'Misc',
                returns: { type: 'boolean' },
                args: {
                    a: { type: 'any' },
                    b: { type: 'any' },
                    x: { type: 'any' },
                    ys: { type: 'any', rest: true },
                },
                variants: [
                    { argumentNames: ['x'] },
                    { argumentNames: ['x', 'ys'] },
                ],
                description: 'Returns `true` if all `values` are not equal to each other, otherwise result is `false`. `(≠ a b c)` is same as `(! (== a b c))`.',
                examples: [
                    '1 ≠ 2',
                    '3 ≠ 3',
                    '≠(3)',
                    '≠(3, 3, 2)',
                    '≠("3", "2", "1", "0",)',
                    '≠(0, -0)',
                ],
            },
        },
        'identical?': {
            evaluate: function (params) {
                return isIdentical(params);
            },
            arity: { min: 1 },
            docs: {
                category: 'Misc',
                returns: { type: 'boolean' },
                args: {
                    a: { type: 'any' },
                    b: { type: 'any' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns true if $a and $b are referential equal.',
                examples: [
                    'identical?({ a: 10, b: 20 }, { b: 20, a: 10 })',
                    'identical?([1, true, null], [1, true, null])',
                    'identical?(0.3, 0.1 + 0.2)',
                ],
            },
        },
        '>': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_3, _b;
                var _c = __read(_a), first = _c[0], rest = _c.slice(1);
                var currentValue = asStringOrNumber(first);
                try {
                    for (var rest_3 = __values(rest), rest_3_1 = rest_3.next(); !rest_3_1.done; rest_3_1 = rest_3.next()) {
                        var param = rest_3_1.value;
                        if (compare(currentValue, asStringOrNumber(param), sourceCodeInfo) <= 0)
                            return false;
                        currentValue = asStringOrNumber(param);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (rest_3_1 && !rest_3_1.done && (_b = rest_3.return)) _b.call(rest_3);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return true;
            },
            arity: { min: 1 },
            docs: {
                category: 'Misc',
                returns: { type: 'boolean' },
                args: {
                    a: { type: ['number', 'string'] },
                    b: { type: ['number', 'string'] },
                    x: { type: ['number', 'string'] },
                    ys: { type: ['number', 'string'], rest: true },
                },
                variants: [
                    { argumentNames: ['x'] },
                    { argumentNames: ['x', 'ys'] },
                ],
                description: 'Returns `true` if $x and $ys are in decreasing order, `false` otherwise.',
                examples: [
                    '>(1, 0)',
                    '>(1.01, 1)',
                    '>(1, 1)',
                    '>(4, 3, 2, 1)',
                    '>(3, 2, 2, 1)',
                ],
            },
        },
        '<': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_4, _b;
                var _c = __read(_a), first = _c[0], rest = _c.slice(1);
                var currentValue = asStringOrNumber(first);
                try {
                    for (var rest_4 = __values(rest), rest_4_1 = rest_4.next(); !rest_4_1.done; rest_4_1 = rest_4.next()) {
                        var param = rest_4_1.value;
                        if (compare(currentValue, asStringOrNumber(param), sourceCodeInfo) >= 0)
                            return false;
                        currentValue = asStringOrNumber(param);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (rest_4_1 && !rest_4_1.done && (_b = rest_4.return)) _b.call(rest_4);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                return true;
            },
            arity: { min: 1 },
            docs: {
                category: 'Misc',
                returns: { type: 'boolean' },
                args: {
                    a: { type: ['number', 'string'] },
                    b: { type: ['number', 'string'] },
                    x: { type: ['number', 'string'] },
                    ys: { type: ['number', 'string'], rest: true },
                },
                variants: [
                    { argumentNames: ['x'] },
                    { argumentNames: ['x', 'ys'] },
                ],
                description: 'Returns `true` if $x and $ys are in increasing order, `false` otherwise.',
                examples: [
                    '<(0, 1)',
                    '<(1, 1.01)',
                    '<(1, 1)',
                    '<(1, 2, 2, 3)',
                    '<("a", "b")',
                ],
            },
        },
        '>=': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_5, _b;
                var _c = __read(_a), first = _c[0], rest = _c.slice(1);
                var currentValue = asStringOrNumber(first);
                try {
                    for (var rest_5 = __values(rest), rest_5_1 = rest_5.next(); !rest_5_1.done; rest_5_1 = rest_5.next()) {
                        var param = rest_5_1.value;
                        if (compare(currentValue, asStringOrNumber(param), sourceCodeInfo) < 0)
                            return false;
                        currentValue = asStringOrNumber(param);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (rest_5_1 && !rest_5_1.done && (_b = rest_5.return)) _b.call(rest_5);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                return true;
            },
            arity: { min: 1 },
            docs: {
                category: 'Misc',
                returns: { type: 'boolean' },
                args: {
                    a: { type: ['number', 'string'] },
                    b: { type: ['number', 'string'] },
                    x: { type: ['number', 'string'] },
                    ys: { type: ['number', 'string'], rest: true },
                },
                variants: [
                    { argumentNames: ['x'] },
                    { argumentNames: ['x', 'ys'] },
                ],
                description: 'Returns `true` if $x and $ys are in non increasing order, `false` otherwise.',
                examples: [
                    '1 >= 1',
                    '0 >= 1',
                    '>=(1, 0)',
                    '>=(1.01, 1)',
                    '>=(1, 1)',
                    '>=(4, 3, 2, 1)',
                    '>=(3, 2, 2, 1)',
                ],
            },
        },
        '<=': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_6, _b;
                var _c = __read(_a), first = _c[0], rest = _c.slice(1);
                var currentValue = asStringOrNumber(first);
                try {
                    for (var rest_6 = __values(rest), rest_6_1 = rest_6.next(); !rest_6_1.done; rest_6_1 = rest_6.next()) {
                        var param = rest_6_1.value;
                        if (compare(currentValue, asStringOrNumber(param), sourceCodeInfo) > 0)
                            return false;
                        currentValue = asStringOrNumber(param);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (rest_6_1 && !rest_6_1.done && (_b = rest_6.return)) _b.call(rest_6);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                return true;
            },
            arity: { min: 1 },
            docs: {
                category: 'Misc',
                returns: { type: 'boolean' },
                args: {
                    a: { type: ['number', 'string'] },
                    b: { type: ['number', 'string'] },
                    x: { type: ['number', 'string'] },
                    ys: { type: ['number', 'string'], rest: true },
                },
                variants: [
                    { argumentNames: ['x'] },
                    { argumentNames: ['x', 'ys'] },
                ],
                description: 'Returns `true` if $x and $ys are in non decreasing order, `false` otherwise.',
                examples: [
                    '1 <= 1',
                    '<=(0, 1)',
                    '<=(1, 1.01)',
                    '<=(1, 1)',
                    '<=(1, 2, 3, 4)',
                    '<=(1, 2, 2, 3)',
                ],
            },
        },
        '!': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return !first;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Misc',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Computes logical negation. Note that any other $x than `false`, `0`, `null` and `\'\'` is truthy.',
                examples: [
                    '!(3)',
                    '!(true)',
                    '!("A string")',
                    '!(0)',
                    '!(false)',
                    '!(null)',
                    '!("")',
                ],
            },
        },
        'epoch->iso-date': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), ms = _b[0];
                assertNumber(ms, sourceCodeInfo);
                return new Date(ms).toISOString();
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Misc',
                returns: { type: 'string' },
                args: { ms: { type: 'number' } },
                variants: [{ argumentNames: ['ms'] }],
                description: 'Returns IOS date time string from `ms` (milliseconds elapsed since the UNIX epoch).',
                examples: [
                    'epoch->iso-date(1649756230899)',
                    'epoch->iso-date(0)',
                ],
            },
        },
        'iso-date->epoch': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), dateTime = _b[0];
                assertString(dateTime, sourceCodeInfo);
                var ms = new Date(dateTime).valueOf();
                assertNumber(ms, sourceCodeInfo, { finite: true });
                return ms;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Misc',
                returns: { type: 'number' },
                args: { iso: { type: 'string' } },
                variants: [{ argumentNames: ['iso'] }],
                description: 'Returns milliseconds elapsed since the UNIX epoch to `iso`.',
                examples: [
                    'iso-date->epoch("2022-04-12T09:37:10.899Z")',
                    'iso-date->epoch("1980-01-01")',
                ],
            },
        },
        'write!': {
            evaluate: function (params, sourceCodeInfo) {
                // eslint-disable-next-line no-console
                console.log.apply(console, __spreadArray([], __read(params), false));
                if (params.length > 0)
                    return asAny(params[params.length - 1], sourceCodeInfo);
                return null;
            },
            arity: {},
            docs: {
                category: 'Misc',
                returns: { type: 'any' },
                args: { values: { type: 'any', rest: true } },
                variants: [{ argumentNames: ['values'] }],
                description: 'It logs the $values and then returns the last argument. If called with no arguments `null` is returned.',
                examples: [
                    'write!("A string")',
                    'write!(100, "items")',
                    'write!(object("a", 10))',
                    'write!(["a", "b", "c"])',
                    'write!(#"^start")',
                    'write!(null, true, false)',
                ],
                hideOperatorForm: true,
            },
        },
        'boolean': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return !!value;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Misc',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Coerces $x to boolean.',
                examples: [
                    'boolean(0)',
                    'boolean(1)',
                    'boolean(null)',
                    'boolean("Albert")',
                ],
            },
        },
        'compare': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertStringOrNumber(a, sourceCodeInfo);
                assertStringOrNumber(b, sourceCodeInfo);
                return compare(a, b, sourceCodeInfo);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Misc',
                returns: { type: 'number' },
                args: {
                    a: { type: ['number', 'string'] },
                    b: { type: ['number', 'string'] },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Compares two values. Returns `-1` if $a < $b, `1` if $a > $b and `0` if $a and $b have the same sort order.',
                examples: [
                    'compare(0, 1)',
                    'compare(0, 0)',
                    'compare(1, 0)',
                    'compare("Albert", "Mojir")',
                ],
            },
        },
        'json-parse': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertString(first, sourceCodeInfo);
                // eslint-disable-next-line ts/no-unsafe-return
                return JSON.parse(first);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Misc',
                returns: { type: 'any' },
                args: { x: { type: 'string' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `JSON.parse(`$x`)`.',
                examples: [
                    'json-parse("[1, 2, 3]")',
                ],
            },
        },
        'json-stringify': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], second = _b[1];
                assertAny(first, sourceCodeInfo);
                if (second === undefined)
                    return JSON.stringify(first);
                assertNumber(second, sourceCodeInfo);
                return JSON.stringify(first, null, second);
            },
            arity: { min: 1, max: 2 },
            docs: {
                category: 'Misc',
                returns: { type: 'string' },
                args: {
                    x: { type: 'any' },
                    indent: { type: 'integer', description: 'Number of spaces to use for indentation.' },
                },
                variants: [
                    { argumentNames: ['x'] },
                    { argumentNames: ['x', 'indent'] },
                ],
                description: 'Returns `JSON.stringify(`$x`)`. If second argument is provided, returns `JSON.stringify(`$x`, null, `$indent`)`.',
                examples: [
                    'json-stringify([1, 2, 3])',
                    'json-stringify({ a: { b: 10 }}, 2)',
                ],
                hideOperatorForm: true,
            },
        },
        'import': {
            evaluate: function (_a, sourceCodeInfo, contextStack) {
                var _b, e_7, _c, _d;
                var _e = __read(_a, 1), importPath = _e[0];
                assertString(importPath, sourceCodeInfo);
                // Check if importing a specific function (e.g., "Grid.row")
                var dotIndex = importPath.indexOf('.');
                if (dotIndex !== -1) {
                    var namespaceName_1 = importPath.substring(0, dotIndex);
                    var functionName = importPath.substring(dotIndex + 1);
                    var namespace_1 = contextStack.getNamespace(namespaceName_1);
                    if (!namespace_1) {
                        throw new LitsError("Unknown namespace: '".concat(namespaceName_1, "'"), sourceCodeInfo);
                    }
                    var expression = namespace_1.functions[functionName];
                    if (!expression) {
                        throw new LitsError("Function '".concat(functionName, "' not found in namespace '").concat(namespaceName_1, "'"), sourceCodeInfo);
                    }
                    return _b = {},
                        _b[FUNCTION_SYMBOL] = true,
                        _b.sourceCodeInfo = sourceCodeInfo,
                        _b.functionType = 'Namespace',
                        _b.namespaceName = namespaceName_1,
                        _b.functionName = functionName,
                        _b.arity = expression.arity,
                        _b;
                }
                // Import entire namespace
                var namespaceName = importPath;
                var namespace = contextStack.getNamespace(namespaceName);
                if (!namespace) {
                    throw new LitsError("Unknown namespace: '".concat(namespaceName, "'"), sourceCodeInfo);
                }
                // Create an object where each key is a function name and value is a NamespaceFunction
                var result = {};
                try {
                    for (var _f = __values(Object.entries(namespace.functions)), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var _h = __read(_g.value, 2), functionName = _h[0], expression = _h[1];
                        result[functionName] = (_d = {},
                            _d[FUNCTION_SYMBOL] = true,
                            _d.sourceCodeInfo = sourceCodeInfo,
                            _d.functionType = 'Namespace',
                            _d.namespaceName = namespaceName,
                            _d.functionName = functionName,
                            _d.arity = expression.arity,
                            _d);
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                return result;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Misc',
                returns: { type: 'any' },
                args: {
                    path: {
                        type: 'string',
                        description: 'The namespace path to import. Can be a namespace name (e.g., "Vector", "Grid") or a fully qualified function name (e.g., "Vector.mean", "Grid.row").',
                    },
                },
                variants: [{ argumentNames: ['path'] }],
                description: 'Imports namespace functions. Use a namespace name (e.g., "Vector") to import all functions as an object, or a fully qualified name (e.g., "Vector.mean") to import a single function directly.',
                examples: [
                    'let v = import("Vector"); v.mean([1, 2, 3, 4])',
                    'let sum = import("Vector.sum"); sum([1, 2, 3])',
                    'let g = import("Grid"); g.row([[1, 2], [3, 4]], 0)',
                ],
            },
        },
    };

    var objectNormalExpression = {
        'keys': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), obj = _b[0];
                assertObj(obj, sourceCodeInfo);
                return Object.keys(obj);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Object',
                returns: { type: 'any', array: true },
                args: { obj: { type: 'object' } },
                variants: [{ argumentNames: ['obj'] }],
                description: 'Returns array of all keys in $obj.',
                examples: [
                    'keys({})',
                    'keys({ x: 10, y: true, z: "A string" })',
                    'keys(object("x", 10, "y", true, "z", "A string"))',
                ],
            },
        },
        'vals': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), obj = _b[0];
                assertObj(obj, sourceCodeInfo);
                return Object.values(obj);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Object',
                returns: { type: 'any', array: true },
                args: { obj: { type: 'object' } },
                variants: [{ argumentNames: ['obj'] }],
                description: 'Returns array of all values in $obj.',
                examples: [
                    'vals({})',
                    'vals({ x: 10, y: true, z: "A string" })',
                    'vals(object("x", 10, "y", true, "z", "A string"))',
                ],
            },
        },
        'entries': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), obj = _b[0];
                assertObj(obj, sourceCodeInfo);
                return Object.entries(obj);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Object',
                returns: { type: 'array' },
                args: { obj: { type: 'object' } },
                variants: [{ argumentNames: ['obj'] }],
                description: 'Returns nested array of all key - value pairs in $obj.',
                examples: [
                    'entries({})',
                    'entries({ x: 10, y: true, z: "A string" })',
                    'entries(object("x", 10, "y", true, "z", "A string"))',
                ],
            },
        },
        'find': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), obj = _b[0], key = _b[1];
                assertObj(obj, sourceCodeInfo);
                assertString(key, sourceCodeInfo);
                if (collHasKey(obj, key))
                    return [key, obj[key]];
                return null;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Object',
                returns: { type: ['array', 'null'] },
                args: {
                    a: { type: 'object' },
                    b: { type: 'string' },
                    obj: { type: 'object' },
                    key: { type: 'string' },
                },
                variants: [{ argumentNames: ['obj', 'key'] }],
                description: 'Returns entry (key-value pair) for $key, or `null` if $key not present in $obj.',
                examples: [
                    '{ a: 1, "b": 2 } find "a"',
                    'find(object("a", 1, "b", 2), "b")',
                    'find(object("a", 1, "b", 2), "c")',
                ],
            },
        },
        'dissoc': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), obj = _b[0], key = _b[1];
                assertObj(obj, sourceCodeInfo);
                assertString(key, sourceCodeInfo);
                var newObj = __assign({}, obj);
                delete newObj[key];
                return newObj;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Object',
                returns: { type: 'object' },
                args: {
                    a: { type: 'object' },
                    b: { type: 'string' },
                    obj: { type: 'object' },
                    key: { type: 'string' },
                },
                variants: [{ argumentNames: ['obj', 'key'] }],
                description: 'Return shallow copy of $obj with $key deleted.',
                examples: [
                    '{ x: 10, y: 20 } dissoc "y"',
                    'dissoc({ x: 10, y: 20 }, "x")',
                    'dissoc({ x: 10 }, "y")',
                    "\nlet o = { a: 5 };\ndissoc(o, \"a\");\no",
                ],
            },
        },
        'merge': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0)
                    return null;
                var _a = __read(params), first = _a[0], rest = _a.slice(1);
                assertObj(first, sourceCodeInfo);
                return rest.reduce(function (result, obj) {
                    assertObj(obj, sourceCodeInfo);
                    return __assign(__assign({}, result), obj);
                }, __assign({}, first));
            },
            arity: { min: 0 },
            docs: {
                category: 'Object',
                returns: { type: 'object' },
                args: {
                    a: { type: 'object' },
                    b: { type: 'object' },
                    objs: { type: 'object', rest: true },
                },
                variants: [{ argumentNames: ['objs'] }],
                description: "Returns a new object created by merging together all arguments.\n\nIf two keys appears in more than one object the value from the last object is used.\nIf no arguments are provided `null` is returned.",
                examples: [
                    '{ x: 10 } merge { y: 20 }',
                    'merge(object("x", 10), object("y", 20))',
                    'merge(object("x", 10), object("x", 15, "y", 20))',
                ],
            },
        },
        'merge-with': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var first = params[0];
                var fn = params.at(-1);
                var rest = params.slice(1, -1);
                assertObj(first, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                return rest.reduce(function (result, obj) {
                    assertObj(obj, sourceCodeInfo);
                    Object.entries(obj).forEach(function (entry) {
                        var key = asString(entry[0], sourceCodeInfo);
                        var val = toAny(entry[1]);
                        if (collHasKey(result, key))
                            result[key] = executeFunction(fn, [result[key], val], contextStack, sourceCodeInfo);
                        else
                            result[key] = val;
                    });
                    return result;
                }, __assign({}, first));
            },
            arity: { min: 2 },
            docs: {
                category: 'Object',
                returns: { type: 'object' },
                args: {
                    objs: { type: 'object', rest: true },
                    fun: { type: 'function' },
                },
                variants: [{ argumentNames: ['objs', 'fun'] }],
                description: "\nReturns a new object created by merging together all arguments.\nIf two keys appears in more than one object $fun is used to calculate the new value.\n\nIf no arguments are provided `null` is returned.",
                examples: [
                    'merge-with(object("x", 10), object("y", 20), +)',
                    'merge-with(object("x", 10), object("x", 15, "y", 20), +)',
                    'merge-with({ x: 10 }, { x: 20 }, { x: 30 }, { x: 40 }, -)',
                ],
                hideOperatorForm: true,
            },
        },
        'zipmap': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), keys = _b[0], values = _b[1];
                assertStringArray(keys, sourceCodeInfo);
                assertArray(values, sourceCodeInfo);
                var length = Math.min(keys.length, values.length);
                var result = {};
                for (var i = 0; i < length; i += 1) {
                    var key = asString(keys[i], sourceCodeInfo);
                    result[key] = toAny(values[i]);
                }
                return result;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Object',
                returns: { type: 'object' },
                args: {
                    a: { type: 'array' },
                    b: { type: 'array' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns a new object created by mapping $a to $b.',
                examples: [
                    '["a", "b", "c"] zipmap [1, 2, 3]',
                    'zipmap(["a", "b", "c"], [10, null, [1, 2, 3]])',
                    'zipmap(["a", "b", "c"], [1])',
                    'zipmap([], [10, null, [1, 2, 3]])',
                ],
            },
        },
        'select-keys': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), obj = _b[0], keys = _b[1];
                assertStringArray(keys, sourceCodeInfo);
                assertObj(obj, sourceCodeInfo);
                return keys.reduce(function (result, key) {
                    if (collHasKey(obj, key))
                        result[key] = toAny(obj[key]);
                    return result;
                }, {});
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Object',
                returns: { type: 'object' },
                args: {
                    a: { type: 'object' },
                    b: { type: 'array' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Returns an object containing only those entries in $a whose key is in $b.',
                examples: [
                    '{ a: 1, b: 2, c: 3 } select-keys ["a", "b"]',
                    'select-keys({ a: 1, b: 2, c: 3 }, ["a", "b"])',
                    'select-keys({ a: 1 }, ["a", "b"])',
                ],
            },
        },
    };

    var predicatesNormalExpression = {
        'function?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return isLitsFunction(first);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is a function, otherwise `false`.',
                examples: [
                    'function?(+)',
                    'function?(/)',
                    'function?((x, y) -> x + y)',
                    'function?(false)',
                    'function?("false")',
                    'function?([1, 2, 3])',
                ],
            },
        },
        'string?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return typeof first === 'string';
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is a string, otherwise `false`.',
                examples: [
                    'string?("")',
                    'string?("A string")',
                    'string?(true ? "A string" : false)',
                    'string?(false)',
                    'string?([1, 2, 3])',
                    'string?(100)',
                ],
            },
        },
        'number?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return typeof first === 'number';
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is a number, otherwise `false`.',
                examples: [
                    'number?(0)',
                    'number?(2)',
                    'number?(-0.12)',
                    'number?(false)',
                    'number?([1, 2, 3])',
                    'number?("A string")',
                ],
            },
        },
        'integer?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return typeof first === 'number' && isNumber(first, { integer: true });
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is an integer, otherwise `false`.',
                examples: [
                    'integer?(0)',
                    'integer?(-12)',
                    'integer?(42)',
                    'integer?(10.1)',
                    'integer?((x, y) -> x + y)',
                    'integer?(false)',
                    'integer?("false")',
                    'integer?([1, 2, 3])',
                ],
            },
        },
        'boolean?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return typeof first === 'boolean';
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is a `boolean`, otherwise `false`.',
                examples: [
                    'boolean?(true)',
                    'boolean?(false)',
                    'boolean?([1, 2, 3])',
                    'boolean?(0)',
                    'boolean?("A string")',
                ],
            },
        },
        'null?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return first === null || first === undefined;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is `null`, otherwise `false`.',
                examples: [
                    'null?(null)',
                    'null?(false)',
                    'null?([1, 2, 3])',
                    'null?(0)',
                    'null?("A string")',
                ],
            },
        },
        'zero?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertNumber(value, sourceCodeInfo, { finite: true });
                return Math.abs(value) < EPSILON;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'number' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is `0`, otherwise `false`.',
                examples: [
                    'zero?(0)',
                    'zero?(-0.0)',
                    'zero?(1)',
                    'zero?(0.1)',
                ],
            },
        },
        'pos?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertNumber(first, sourceCodeInfo, { finite: true });
                return first > 0;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'number' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is greater than `0`, otherwise `false`.',
                examples: [
                    'pos?(0)',
                    'pos?(-0.0)',
                    'pos?(1)',
                    'pos?(-0.1)',
                ],
            },
        },
        'neg?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertNumber(first, sourceCodeInfo, { finite: true });
                return first < 0;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'number' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is less than `0`, otherwise `false`.',
                examples: [
                    'neg?(0)',
                    'neg?(-0.0)',
                    'neg?(1)',
                    'neg?(-0.1)',
                ],
            },
        },
        'even?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertNumber(first, sourceCodeInfo, { finite: true });
                return first % 2 === 0;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'number' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is even, otherwise `false`.',
                examples: [
                    'even?(0)',
                    'even?(-0.0)',
                    'even?(-1)',
                    'even?(2.1)',
                ],
            },
        },
        'odd?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertNumber(first, sourceCodeInfo, { finite: true });
                return isNumber(first, { integer: true }) && first % 2 !== 0;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'number' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is odd, otherwise `false`.',
                examples: [
                    'odd?(1.0)',
                    'odd?(1.001)',
                    'odd?(-1)',
                    'odd?(2.1)',
                ],
            },
        },
        'array?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return Array.isArray(first);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is an array, otherwise `false`.',
                examples: [
                    'array?([])',
                    'array?([1, 2, 3])',
                    'array?(object("a", 10))',
                    'array?(42)',
                    'array?(10.1)',
                    'array?((x, y) -> x + y)',
                ],
            },
        },
        'coll?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return isColl(first);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is a Coll i.e. an array, an object or a string, otherwise `false`.',
                examples: [
                    'coll?([])',
                    'coll?([1, 2, 3])',
                    'coll?(object("a", 10))',
                    'coll?("Albert")',
                    'coll?(42)',
                    'coll?(10.1)',
                    'coll?((x, y) -> x + y)',
                ],
            },
        },
        'seq?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return isSeq(first);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is a Seq i.e. an array or a string, otherwise `false`.',
                examples: [
                    'seq?([])',
                    'seq?([1, 2, 3])',
                    'seq?(object("a", 10))',
                    'seq?("Albert")',
                    'seq?(42)',
                    'seq?(10.1)',
                    'seq?((x, y) -> x + y)',
                ],
            },
        },
        'object?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return isObj(first);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is an object, otherwise `false`.',
                examples: [
                    'object?(object("a", 10))',
                    'object?(42)',
                    'object?(10.1)',
                    'object?((x, y) -> x + y)',
                    'object?(#"^start")',
                    'object?("false")',
                    'object?([1, 2, 3])',
                ],
            },
        },
        'regexp?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return isRegularExpression(value);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is a regexp, otherwise `false`.',
                examples: [
                    'regexp?(regexp("^start"))',
                    'regexp?(#"^start")',
                    'regexp?(-12)',
                    'regexp?({})',
                    'regexp?(10.1)',
                    'regexp?((x, y) -> x + y)',
                    'regexp?(false)',
                    'regexp?("false")',
                    'regexp?([1, 2, 3])',
                ],
            },
        },
        'finite?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertNumber(value, sourceCodeInfo);
                return Number.isFinite(value);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'number' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is finite, otherwise `false`.',
                examples: [
                    'finite?(1.0)',
                    'finite?(1 / 0)',
                    'finite?(-1 / 0)',
                ],
            },
        },
        'positive-infinity?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertNumber(value, sourceCodeInfo);
                return value === Number.POSITIVE_INFINITY;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'number' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x equals positive infinity, otherwise `false`.',
                examples: [
                    'positive-infinity?(1.0)',
                    'positive-infinity?(1 / 0)',
                    'positive-infinity?(-1 / 0)',
                ],
            },
        },
        'negative-infinity?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertNumber(value, sourceCodeInfo);
                return value === Number.NEGATIVE_INFINITY;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'number' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x equals negative infinity, otherwise `false`.',
                examples: [
                    'negative-infinity?(1.0)',
                    'negative-infinity?(1 / 0)',
                    'negative-infinity?(-1 / 0)',
                ],
            },
        },
        'true?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return value === true;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is `true`, otherwise `false`.',
                examples: [
                    'true?(false)',
                    'true?(true)',
                    'true?(1)',
                    'true?(0)',
                ],
            },
        },
        'false?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return value === false;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is `true`, otherwise `false`.',
                examples: [
                    'false?(false)',
                    'false?(true)',
                    'false?(1)',
                    'false?(0)',
                ],
            },
        },
        'empty?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), coll = _b[0];
                if (coll === null)
                    return true;
                assertColl(coll, sourceCodeInfo);
                if (typeof coll === 'string')
                    return coll.length === 0;
                if (Array.isArray(coll))
                    return coll.length === 0;
                return Object.keys(coll).length === 0;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: ['collection', 'string', 'null'] } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `true` if $x is empty or `null`, otherwise `false`.',
                examples: [
                    'empty?([])',
                    'empty?([1, 2, 3])',
                    'empty?({})',
                    'empty?({ a: 2 })',
                    'empty?("")',
                    'empty?("Albert")',
                    'empty?(null)',
                ],
            },
        },
        'not-empty?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), coll = _b[0];
                if (coll === null)
                    return false;
                assertColl(coll, sourceCodeInfo);
                if (typeof coll === 'string')
                    return coll.length > 0;
                if (Array.isArray(coll))
                    return coll.length > 0;
                return Object.keys(coll).length > 0;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                returns: { type: 'boolean' },
                args: { x: { type: ['collection', 'string', 'null'] } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns `false` if $x is empty or `null`, otherwise `true`.',
                examples: [
                    'not-empty?([])',
                    'not-empty?([1, 2, 3])',
                    'not-empty?({})',
                    'not-empty?({ a: 2 })',
                    'not-empty?("")',
                    'not-empty?("Albert")',
                    'not-empty?(null)',
                ],
            },
        },
        'vector?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), vector = _b[0];
                return isVector(vector);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                description: 'Checks if a value is a `vector`. A `vector` is an array of `numbers`.',
                returns: { type: 'boolean' },
                args: { value: { type: 'any', description: 'The value to check.' } },
                variants: [{ argumentNames: ['value'] }],
                examples: [
                    'vector?(1)',
                    'vector?([1, 2, 3])',
                    'vector?([1, 2, "3"])',
                ],
            },
        },
        'matrix?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), matrix = _b[0];
                return isMatrix(matrix);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                description: 'Checks if a value is a `matrix`. A `matrix` is an array of arrays of `numbers`.',
                returns: { type: 'boolean' },
                args: { value: { type: 'any', description: 'The value to check.' } },
                variants: [{ argumentNames: ['value'] }],
                examples: [
                    'matrix?(1)',
                    'matrix?([1, 2, 3])',
                    'matrix?([[1, 2], [3, 4]])',
                    'matrix?([[1, 2], [3, "4"]])',
                    'matrix?([[1, 2], [3]])',
                ],
            },
        },
        'grid?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), table = _b[0];
                return isGrid(table);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Predicate',
                description: 'Checks if a `value` is a `grid`. A `grid` is an `array` of `arrays` where all inner `arrays` have the same length.',
                returns: { type: 'boolean' },
                args: { value: { type: 'any', description: 'The value to check.' } },
                variants: [{ argumentNames: ['value'] }],
                examples: [
                    'grid?("1")',
                    'grid?(["1", 2, 3])',
                    'grid?([["1", 2], [3, 4]])',
                    'grid?([["1", 2], [3, "4"]])',
                    'grid?([["1", 2], [3]])',
                ],
            },
        },
    };

    var regexpNormalExpression = {
        'regexp': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a, 2), sourceArg = _c[0], flagsArg = _c[1];
                assertString(sourceArg, sourceCodeInfo);
                var source = sourceArg || '(?:)';
                var flags = typeof flagsArg === 'string' ? flagsArg : '';
                try {
                    // eslint-disable-next-line no-new
                    new RegExp(source, flags); // Throws if invalid regexp
                }
                catch (e) {
                    throw new LitsError("Invalid regular expression: ".concat(source, " ").concat(flags), sourceCodeInfo);
                }
                return _b = {},
                    _b[REGEXP_SYMBOL] = true,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b.s = source,
                    _b.f = flags,
                    _b;
            },
            arity: { min: 1, max: 2 },
            docs: {
                category: 'Regular expression',
                returns: { type: 'regexp' },
                args: {
                    pattern: { type: 'string' },
                    flags: { type: 'string', description: 'Optional flags for the regular expression. Possible values are the same as Javascript RegExp takes.' },
                },
                variants: [
                    { argumentNames: ['pattern'] },
                    { argumentNames: ['pattern', 'flags'] },
                ],
                description: 'Creates a RegExp from $pattern and $flags.',
                examples: [
                    'regexp("^\\s*(.*)$")',
                    '#"^\\s*(.*)$"',
                    'regexp("albert", "ig")',
                    '#"albert"ig',
                ],
                hideOperatorForm: true,
            },
        },
        'match': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), text = _b[0], regexp = _b[1];
                assertRegularExpression(regexp, sourceCodeInfo);
                if (!isString(text))
                    return null;
                var regExp = new RegExp(regexp.s, regexp.f);
                var match = regExp.exec(text);
                if (match)
                    return __spreadArray([], __read(match), false);
                return null;
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Regular expression',
                returns: { type: 'any', array: true },
                args: {
                    a: { type: 'regexp' },
                    b: { type: 'string' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: "Matches $b against regular expression $a.\nIf $b is a string and matches the regular expression, a `match`-array is returned, otherwise `null` is returned.",
                examples: [
                    'match("  A string", regexp("^\\\\s*(.*)$"))',
                    'match("  A string", #"^\\s*(.*)$")',
                    'match("My name is Albert", #"albert"i)',
                    'match("My name is Ben", #"albert"i)',
                    'match(null, #"albert"i)',
                    'match(1, #"albert"i)',
                    'match({}, #"albert"i)',
                ],
            },
        },
        'replace': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], regexp = _b[1], value = _b[2];
                assertString(str, sourceCodeInfo);
                assertStringOrRegularExpression(regexp, sourceCodeInfo);
                assertString(value, sourceCodeInfo);
                var matcher = isRegularExpression(regexp) ? new RegExp(regexp.s, "".concat(regexp.f)) : regexp;
                return str.replace(matcher, value);
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Regular expression',
                returns: { type: 'any', array: true },
                args: {
                    a: { type: 'string' },
                    b: { type: ['regexp', 'string'] },
                    x: { type: 'string' },
                },
                variants: [{ argumentNames: ['a', 'b', 'x'] }],
                description: 'Returns a new string with first match of regular expression $b replaced by $x.',
                examples: [
                    'replace("Duck duck", "u", "i")',
                    'replace("Duck duck", #"u", "i")',
                    'replace("abcABC", regexp("a", "i"), "-")',
                    'replace("abcABC", regexp("a", "gi"), "-")',
                    'replace("abcABC", #"a"i, "-")',
                    'replace("abcABC", #"a"gi, "-")',
                ],
            },
        },
        'replace-all': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], regexp = _b[1], value = _b[2];
                assertString(str, sourceCodeInfo);
                assertStringOrRegularExpression(regexp, sourceCodeInfo);
                assertString(value, sourceCodeInfo);
                var matcher = isRegularExpression(regexp) ? new RegExp(regexp.s, "".concat(regexp.f.includes('g') ? regexp.f : "".concat(regexp.f, "g"))) : regexp;
                return str.replaceAll(matcher, value);
            },
            arity: toFixedArity(3),
            docs: {
                category: 'Regular expression',
                returns: { type: 'any', array: true },
                args: {
                    a: { type: 'string' },
                    b: { type: ['regexp', 'string'] },
                    x: { type: 'string' },
                },
                variants: [{ argumentNames: ['a', 'b', 'x'] }],
                description: 'Returns a new string with all matches of regular expression $b replaced by $x.',
                examples: [
                    'replace-all("Duck duck", "u", "i")',
                    'replace-all("Duck duck", regexp("u"), "i")',
                    'replace-all("abcABC", regexp("a", "i"), "-")',
                    'replace-all("abcABC", regexp("a", "gi"), "-")',
                    'replace-all("abcABC", #"a"i, "-")',
                    'replace-all("abcABC", #"a"gi, "-")',
                ],
            },
        },
    };

    var blankRegexp = /^\s*$/;
    var stringNormalExpression = {
        'string-repeat': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), str = _b[0], count = _b[1];
                assertString(str, sourceCodeInfo);
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                return str.repeat(count);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'String',
                returns: { type: 'number' },
                args: {
                    a: { type: 'string' },
                    b: { type: 'integer' },
                    s: { type: 'string' },
                    n: { type: 'integer' },
                },
                variants: [{ argumentNames: ['s', 'n'] }],
                description: 'Repeates $s $n times.',
                examples: [
                    '"*" string-repeat 10',
                    'string-repeat("*", 10)',
                    'string-repeat("***", 0)',
                ],
            },
        },
        'str': {
            evaluate: function (params) {
                return params.reduce(function (result, param) {
                    var paramStr = param === undefined || param === null
                        ? ''
                        : isObj(param)
                            ? JSON.stringify(param)
                            : Array.isArray(param)
                                ? JSON.stringify(param)
                                : "".concat(param);
                    return result + paramStr;
                }, '');
            },
            arity: {},
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { values: { type: 'any', rest: true } },
                variants: [{ argumentNames: ['values'] }],
                description: 'Concatenats $values into one string. If `value` equals `null` empty string is returned.',
                examples: [
                    'str("A string", ", and another string", " ...and more")',
                    'str("Just one string")',
                    'str()',
                    'str(0, false, true, null, #"^kalle", [1, 2, 3], {a: "a"})',
                ],
                hideOperatorForm: true,
            },
        },
        'number': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                var number = Number(str);
                if (Number.isNaN(number))
                    throw new LitsError("Could not convert '".concat(str, "' to a number."), sourceCodeInfo);
                return number;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'number' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Parses $s to a number.',
                examples: [
                    'number("10")',
                    'number("010")',
                    'number("-1.01")',
                ],
            },
        },
        'from-char-code': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), num = _b[0];
                assertNumber(num, sourceCodeInfo, { finite: true });
                var int = toNonNegativeInteger(num);
                try {
                    return String.fromCodePoint(int);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { code: { type: 'number' } },
                variants: [{ argumentNames: ['code'] }],
                description: 'Return character for code point $code.',
                examples: [
                    'from-char-code(65)',
                    'from-char-code(0)',
                ],
            },
        },
        'to-char-code': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo, { nonEmpty: true });
                return asNonUndefined(str.codePointAt(0), sourceCodeInfo);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'number' },
                args: { c: { type: 'string' } },
                variants: [{ argumentNames: ['c'] }],
                description: 'Return code point for first character in $c.',
                examples: [
                    'to-char-code("A")',
                    'to-char-code("Albert")',
                ],
            },
        },
        'lower-case': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.toLowerCase();
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns $s converted to lower case.',
                examples: [
                    'lower-case("Albert")',
                    'lower-case("")',
                ],
            },
        },
        'upper-case': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.toUpperCase();
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns $s converted to upper case.',
                examples: [
                    'upper-case("Albert")',
                    'upper-case("")',
                ],
            },
        },
        'trim': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.trim();
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns a new string with leading and trailing whitespaces removed.',
                examples: [
                    'trim("  Albert  ")',
                    'trim("   ")',
                    'trim("")',
                ],
            },
        },
        'trim-left': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.replace(/^\s+/, '');
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns a new string with leading whitespaces removed.',
                examples: [
                    'trim-left("  Albert  ")',
                    'trim-left("   ")',
                    'trim-left("")',
                ],
            },
        },
        'trim-right': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.replace(/\s+$/, '');
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns a new string with trailing whitespaces removed.',
                examples: [
                    'trim-right("  Albert  ")',
                    'trim-right("   ")',
                    'trim-right("")',
                ],
            },
        },
        'join': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), stringList = _b[0], delimiter = _b[1];
                assertArray(stringList, sourceCodeInfo);
                stringList.forEach(function (str) { return assertStringOrNumber(str, sourceCodeInfo); });
                assertString(delimiter, sourceCodeInfo);
                return stringList.join(delimiter);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: {
                    a: { type: 'array' },
                    b: { type: 'string' },
                    arr: { type: 'array' },
                    delimiter: { type: 'string' },
                },
                variants: [{ argumentNames: ['arr', 'delimiter'] }],
                description: 'Returns a new string by concatenating all of the elements in $arr, separated by $delimiter.',
                examples: [
                    'map([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], str) join ", "',
                    '([0, 1, 2, 3, 4, 5, 6, 7, 8, 9] map str) join ", "',
                    'join(["Albert", 10], ", ")',
                    'join(["Albert", "Mojir"], " ")',
                    'join(map([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], str), ", ")',
                ],
            },
        },
        'split': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], stringOrRegExpValue = _b[1], limit = _b[2];
                assertString(str, sourceCodeInfo);
                assertStringOrRegularExpression(stringOrRegExpValue, sourceCodeInfo);
                if (limit !== undefined)
                    assertNumber(limit, sourceCodeInfo, { integer: true, nonNegative: true });
                var delimiter = typeof stringOrRegExpValue === 'string'
                    ? stringOrRegExpValue
                    : new RegExp(stringOrRegExpValue.s, stringOrRegExpValue.f);
                return str.split(delimiter, limit);
            },
            arity: { min: 2, max: 3 },
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: {
                    a: { type: 'string' },
                    b: { type: 'string' },
                    s: { type: 'string' },
                    delimiter: { type: 'string' },
                    limit: { type: 'integer' },
                },
                variants: [
                    { argumentNames: ['s', 'delimiter'] },
                    { argumentNames: ['s', 'delimiter', 'limit'] },
                ],
                description: 'Divides $s into an array of substrings. The division is done by searching for `delimiter`. If `limit` as provided, at most `limit` number of substrings are returned.',
                examples: [
                    '"Albert Mojir" split " "',
                    'split("Albert Mojir", " ")',
                    'split("abcdefghijklmnopqrstuvw", #"[aoueiy]")',
                    'split("0123456789", "")',
                    'split("0123456789", "", 5) map number',
                ],
            },
        },
        'split-lines': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.split((/\r\n|\n|\r/)).filter(function (line) { return line !== ''; });
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Divides $s into an array of substrings, each representing a line.',
                examples: [
                    'split-lines("Albert\nMojir\n")',
                    'split-lines("Albert\n\nMojir")',
                    'split-lines("Albert\nMojir\n\n")',
                    'split-lines("")',
                ],
            },
        },
        'pad-left': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], length = _b[1], padString = _b[2];
                assertString(str, sourceCodeInfo);
                assertNumber(length, sourceCodeInfo, { integer: true });
                if (padString !== undefined)
                    assertString(padString, sourceCodeInfo);
                return str.padStart(length, padString);
            },
            arity: { min: 2, max: 3 },
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: {
                    a: { type: 'string' },
                    b: { type: 'integer' },
                    s: { type: 'string' },
                    length: { type: 'integer' },
                    padString: { type: 'string' },
                },
                variants: [
                    { argumentNames: ['s', 'length'] },
                    { argumentNames: ['s', 'length', 'padString'] },
                ],
                description: 'Pads from the start of $s with `padString` (multiple times, if needed) until the resulting string reaches the given $length.',
                examples: [
                    '"Albert" pad-left 20',
                    'pad-left("Albert", 20)',
                    'pad-left("Albert", 20, "-*-")',
                    'pad-left("Albert", 5)',
                    'pad-left("Albert", -1)',
                ],
            },
        },
        'pad-right': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], length = _b[1], padString = _b[2];
                assertString(str, sourceCodeInfo);
                assertNumber(length, sourceCodeInfo, { integer: true });
                if (padString !== undefined)
                    assertString(padString, sourceCodeInfo);
                return str.padEnd(length, padString);
            },
            arity: { min: 2, max: 3 },
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: {
                    a: { type: 'string' },
                    b: { type: 'integer' },
                    s: { type: 'string' },
                    length: { type: 'integer' },
                    padString: { type: 'string' },
                },
                variants: [
                    { argumentNames: ['s', 'length'] },
                    { argumentNames: ['s', 'length', 'padString'] },
                ],
                description: 'Pads from the start of $s with `padString` (multiple times, if needed) until the resulting string reaches the given `length`.',
                examples: [
                    '"Albert" pad-right 20',
                    'pad-right("Albert", 20)',
                    'pad-right("Albert", 20, "-*-")',
                    'pad-right("Albert", 5)',
                    'pad-right("Albert", -1)',
                ],
            },
        },
        'template': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), templateString = _b[0], placeholders = _b.slice(1);
                assertString(templateString, sourceCodeInfo);
                assertArray(placeholders, sourceCodeInfo);
                var templateStrings = templateString.split('||||');
                if (templateStrings.length <= 1) {
                    return applyPlaceholders(templateStrings[0], placeholders, sourceCodeInfo);
                }
                else {
                    // Pluralisation
                    var count = placeholders[0];
                    assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                    var stringPlaceholders = __spreadArray(["".concat(count)], __read(placeholders.slice(1)), false);
                    if (templateStrings.length === 2) {
                        // Exactly two valiants.
                        // First variant (singular) for count = 1, Second variant (plural) for count = 0 or count > 1
                        var placehoder = templateStrings[count === 1 ? 0 : 1];
                        return applyPlaceholders(placehoder, stringPlaceholders, sourceCodeInfo);
                    }
                    else {
                        // More than two variant:
                        // Use count as index
                        // If count >= number of variants, use last variant
                        var placehoder = templateStrings[Math.min(count, templateStrings.length - 1)];
                        return applyPlaceholders(placehoder, stringPlaceholders, sourceCodeInfo);
                    }
                }
            },
            arity: { min: 1, max: 10 },
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: {
                    s: { type: 'string' },
                    params: { type: 'any', rest: true },
                },
                variants: [{ argumentNames: ['s', 'params'] }],
                description: 'Applies placeholders to a string. Support for basic pluralization - see examples. If pluralization is used, first placeholder must be a number.',
                examples: [
                    'template("Hi, $1 and $2", "Carl", "Larry")',
                    'template("Hi $1, $2, $3, $4, $5, $6, $7, $8 and $9", "A", "B", "C", "D", "E", "F", "G", "H", "I")',
                    'template("$1 book||||$1 books", 0)',
                    'template("$1 book||||$1 books", 1)',
                    'template("$1 book||||$1 books", 2)',
                    'template("No book||||$1 book||||$1 books", 0)',
                    'template("No book||||$1 book||||$1 books", 1)',
                    'template("No book||||$1 book||||$1 books", 10)',
                    'template("No book||||One book||||Two books||||Three books||||$1 books", 0)',
                    'template("No book||||One book||||Two books||||Three books||||$1 books", 1)',
                    'template("No book||||One book||||Two books||||Three books||||$1 books", 2)',
                    'template("No book||||One book||||Two books||||Three books||||$1 books", 3)',
                    'template("No book||||One book||||Two books||||Three books||||$1 books", 4)',
                ],
                hideOperatorForm: true,
            },
        },
        'encode-base64': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertString(value, sourceCodeInfo);
                return btoa(encodeURIComponent(value).replace(/%([0-9A-F]{2})/g, function (_match, p1) {
                    // eslint-disable-next-line ts/no-unsafe-argument
                    return String.fromCharCode(Number.parseInt(p1, 16));
                }));
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns a Base64 encoded string from $s.',
                examples: [
                    'encode-base64("Albert")',
                ],
            },
        },
        'decode-base64': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertString(value, sourceCodeInfo);
                try {
                    return decodeURIComponent(Array.prototype.map
                        .call(atob(value), function (c) {
                        // eslint-disable-next-line ts/no-unsafe-call, ts/no-unsafe-member-access
                        return "%".concat(("00".concat(c.charCodeAt(0).toString(16))).slice(-2));
                    })
                        .join(''));
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { base64string: { type: 'string' } },
                variants: [{ argumentNames: ['base64string'] }],
                description: 'Returns a Base64 decoded string from $base64string.',
                examples: [
                    'decode-base64("QWxiZXJ0IPCfkLs=")',
                ],
            },
        },
        'encode-uri-component': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertString(value, sourceCodeInfo);
                return encodeURIComponent(value);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns an escaped `URI` string.',
                examples: [
                    'encode-uri-component("Hi everyone!?")',
                ],
            },
        },
        'decode-uri-component': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertString(value, sourceCodeInfo);
                try {
                    return decodeURIComponent(value);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns an un-escaped `URI` string.',
                examples: [
                    'decode-uri-component("Hi%20everyone!%3F%20%F0%9F%91%8D")',
                ],
            },
        },
        'capitalize': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'string' },
                args: { s: { type: 'string' } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns $s with the first character converted to uppercase and the rest to lowercase.',
                examples: [
                    'capitalize("albert")',
                    'capitalize("ALBERT")',
                    'capitalize("aLBERT")',
                    'capitalize("")',
                ],
            },
        },
        'blank?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                if (value === null) {
                    return true;
                }
                assertString(value, sourceCodeInfo);
                return blankRegexp.test(value);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'String',
                returns: { type: 'boolean' },
                args: { s: { type: ['string', 'null'] } },
                variants: [{ argumentNames: ['s'] }],
                description: 'Returns true if $s is null or only contains whitespace characters.',
                examples: [
                    'blank?("")',
                    'blank?(null)',
                    'blank?("\n")',
                    'blank?(" ")',
                    'blank?(".")',
                ],
            },
        },
    };
    var doubleDollarRegexp = /\$\$/g;
    function applyPlaceholders(templateString, placeholders, sourceCodeInfo) {
        for (var i = 0; i < 9; i += 1) {
            // Matches $1, $2, ..., $9
            // Does not match $$1
            // But does match $$$1, (since the two first '$' will later be raplaced with a single '$'
            var re = new RegExp("(\\$\\$|[^$]|^)\\$".concat(i + 1), 'g');
            if (re.test(templateString)) {
                var placeHolder = asStringOrNumber(placeholders[i], sourceCodeInfo);
                templateString = templateString.replace(re, "$1".concat(placeHolder));
            }
        }
        templateString = templateString.replace(doubleDollarRegexp, '$');
        return templateString;
    }

    var functionalNormalExpression = {
        '|>': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), value = _c[0], func = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(func, sourceCodeInfo);
                return executeFunction(func, [value], contextStack, sourceCodeInfo);
            },
            arity: toFixedArity(2),
            docs: {
                category: 'Functional',
                returns: { type: 'any' },
                args: {
                    a: { type: 'any' },
                    b: { type: 'function' },
                },
                variants: [{ argumentNames: ['a', 'b'] }],
                description: 'Takes a value $a and a function $b, and returns the result of applying $b to $a.',
                examples: [
                    "\n1 |> inc |> inc",
                    "range(10)\n  |> map(_, -> $ ^ 2) // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n  |> filter(_, odd?)  // [1, 9, 25, 49, 81]\n  |> reduce(_, +, 0)  // 165\n  |> sqrt             // 12.84523257866513\n  |> round(_, 2)",
                ],
            },
        },
        'apply': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a), func = _c[0], params = _c.slice(1);
                var executeFunction = _b.executeFunction;
                assertFunctionLike(func, sourceCodeInfo);
                var paramsLength = params.length;
                var last = params[paramsLength - 1];
                assertArray(last, sourceCodeInfo);
                var applyArray = __spreadArray(__spreadArray([], __read(params.slice(0, -1)), false), __read(last), false);
                return executeFunction(func, applyArray, contextStack, sourceCodeInfo);
            },
            arity: { min: 2 },
            docs: {
                category: 'Functional',
                returns: { type: 'any' },
                args: {
                    a: { type: 'function' },
                    b: { type: 'array' },
                    fun: { type: 'function' },
                    args: { type: 'array' },
                },
                variants: [{ argumentNames: ['fun', 'args'] }],
                description: 'Call supplied function $fun with specified arguments $args.',
                examples: [
                    "\napply(+, [1, 2, 3])",
                    "\napply(\n  (x, y) -> sqrt(x ^ 2 + y ^ 2),\n  [3, 4]\n)",
                    "\n(x, y) -> sqrt(x ^ 2 + y ^ 2) apply [3, 4]",
                ],
            },
        },
        'identity': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return toAny(value);
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Functional',
                returns: { type: 'any' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns $x.',
                examples: ['identity(1)', 'identity("Albert")', 'identity({ a: 1 })', 'identity(null)'],
            },
        },
        'comp': {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                params.forEach(function (param) { return assertFunctionLike(param, sourceCodeInfo); });
                return _a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a.functionType = 'Comp',
                    _a.params = params,
                    _a.arity = params.length > 0 ? getArityFromFunction(params.at(-1)) : { min: 1, max: 1 },
                    _a;
            },
            arity: {},
            docs: {
                category: 'Functional',
                returns: { type: 'function' },
                args: {
                    a: { type: 'function' },
                    b: { type: 'function' },
                    fns: { type: 'function', rest: true },
                },
                variants: [{ argumentNames: ['fns'] }],
                description: "Takes a variable number of functions and returns a function that is the composition of those.\n\n  The returned function takes a variable number of arguments,\n  applies the rightmost function to the args,\n  the next function (right-to-left) to the result, etc.",
                examples: [
                    "\nlet negative-quotient = comp(-, /);\nnegative-quotient(9, 3)",
                    "\nlet x = { bar: { foo: 42 } };\ncomp(\"foo\", \"bar\")(x)",
                ],
            },
        },
        'constantly': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a, 1), value = _c[0];
                return _b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b.functionType = 'Constantly',
                    _b.value = toAny(value),
                    _b.arity = {},
                    _b;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Functional',
                returns: { type: 'function' },
                args: { x: { type: 'any' } },
                variants: [{ argumentNames: ['x'] }],
                description: 'Returns a function that takes any number of arguments and always returns $x.',
                examples: [
                    "\nlet always-true = constantly(true);\nalways-true(9, 3)",
                ],
            },
        },
        'juxt': {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                params.forEach(function (param) { return assertFunctionLike(param, sourceCodeInfo); });
                var arity = getCommonArityFromFunctions(params);
                if (arity === null) {
                    throw new LitsError('All functions must accept the same number of arguments', sourceCodeInfo);
                }
                return _a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a.functionType = 'Juxt',
                    _a.params = params,
                    _a.arity = arity,
                    _a;
            },
            arity: { min: 1 },
            docs: {
                category: 'Functional',
                returns: { type: 'function' },
                args: {
                    a: { type: 'function' },
                    b: { type: 'function' },
                    fun: { type: 'function' },
                    fns: { type: 'function', rest: true },
                },
                variants: [
                    { argumentNames: ['fun'] },
                    { argumentNames: ['fun', 'fns'] },
                ],
                description: "Takes one or many function and returns a function that is the juxtaposition of those functions.\nThe returned function takes a variable number of args,\nand returns a vector containing the result of applying each function to the args (left-to-right).",
                examples: [
                    "\njuxt(+, *, min, max)(\n  3,\n  4,\n  6,\n)",
                    "\njuxt(\"a\", \"b\")(\n  {\n    a: 1,\n    b: 2,\n    c: 3,\n    d: 4\n  }\n)",
                    "\njuxt(+, *, min, max) apply range(1, 11)",
                ],
            },
        },
        'complement': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a, 1), fn = _c[0];
                var fun = asFunctionLike(fn, sourceCodeInfo);
                return _b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b.functionType = 'Complement',
                    _b.function = fun,
                    _b.arity = getArityFromFunction(fun),
                    _b;
            },
            arity: toFixedArity(1),
            docs: {
                category: 'Functional',
                returns: { type: 'function' },
                args: { fun: { type: 'function' } },
                variants: [{ argumentNames: ['fun'] }],
                description: 'Takes a function $fun and returns a new function that takes the same arguments as f, has the same effects, if any, and returns the opposite truth value.',
                examples: [
                    'complement(>)(1, 3)',
                    'complement(<)(1, 3)',
                    'complement(+)(1, 3)',
                    'complement(+)(0, 0)',
                ],
            },
        },
        'every-pred': {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                return _a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a.functionType = 'EveryPred',
                    _a.params = params,
                    _a.arity = { min: 1, max: 1 },
                    _a;
            },
            arity: { min: 1 },
            docs: {
                category: 'Functional',
                returns: { type: 'function' },
                args: {
                    fun: { type: 'function' },
                    fns: { type: 'function', rest: true },
                },
                variants: [
                    { argumentNames: ['fun'] },
                    { argumentNames: ['fun', 'fns'] },
                ],
                description: "\nTakes a number of predicates and returns a function that returns `true` if all predicates\nreturn a truthy value against all of its arguments, else it returns `false`.",
                examples: [
                    "\nevery-pred(string?, -> count($) > 3)(\n  \"Albert\",\n  \"Mojir\"\n)",
                    "\n(string? every-pred -> count($) > 3)(\n  \"Albert\",\n  \"M\"\n)",
                ],
                hideOperatorForm: true,
            },
        },
        'some-pred': {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                return _a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a.functionType = 'SomePred',
                    _a.params = params,
                    _a.arity = { min: 1, max: 1 },
                    _a;
            },
            arity: { min: 1 },
            docs: {
                category: 'Functional',
                returns: { type: 'function' },
                args: {
                    fun: { type: 'function' },
                    fns: { type: 'function', rest: true },
                },
                variants: [
                    { argumentNames: ['fun'] },
                    { argumentNames: ['fun', 'fns'] },
                ],
                description: 'Takes a number of `predicates` and returns a function that returns `true` if at least one of the `predicates` return a truthy `true` value against at least one of its arguments, else it returns `false`.',
                examples: [
                    'some-pred(string?, -> count($) > 3)("Albert", "Mojir")',
                    'some-pred(string?, -> count($) > 3)("a", "M")',
                    'some-pred(string?, -> count($) > 3)("a", [1, 2, 3])',
                    'some-pred(string?, -> count($) > 3)([1, 2, 3], [2])',
                ],
                hideOperatorForm: true,
            },
        },
        'fnull': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a), fn = _c[0], params = _c.slice(1);
                var fun = asFunctionLike(fn, sourceCodeInfo);
                return _b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b.functionType = 'Fnull',
                    _b.function = fun,
                    _b.params = params,
                    _b.arity = getArityFromFunction(fun),
                    _b;
            },
            arity: { min: 2 },
            docs: {
                category: 'Functional',
                returns: { type: 'function' },
                args: {
                    a: { type: 'function' },
                    b: { type: 'any' },
                    fun: { type: 'function' },
                    arg: { type: 'any' },
                    args: { type: 'any', rest: true },
                },
                variants: [
                    { argumentNames: ['fun', 'arg'] },
                    { argumentNames: ['fun', 'arg', 'args'] },
                ],
                description: 'Takes a function $fun, and returns a function that calls $fun, replacing a null argument to the corresponding argument.',
                examples: [
                    'fnull(inc, 0)(1)',
                    'fnull(inc, 0)(null)',
                    '(inc fnull 0)(null)',
                    'fnull(+, 1, 2)(null, 0)',
                    'fnull(+, 1, 2)(0, null)',
                    'fnull(+, 1, 2)(null, null)',
                    'fnull(+, 1, 2)(null, null, 3, 4)',
                ],
            },
        },
    };

    function generateDocString(reference) {
        return smartTrim("\n    ".concat(reference.title, "\n\n    ").concat(reference.description
            .replace(/`(.+?)`/g, '$1')
            .replace(/\$(\w+)/g, '$1')
            .replace(/\*\*\*(.+)\*\*\*/g, '$1')
            .replace(/\*\*(.+)\*\*/g, '$1'), "\n\n    Signature:\n    ").concat(signature(reference).join('\n    '), "\n\n    Arguments:\n      ").concat(argStrings(reference).join('\n      '), "\n\n    Examples:\n").concat(reference.examples.map(function (example) { return smartTrim(example, 4); }).join('\n\n')));
    }
    function signature(_a) {
        var title = _a.title, variants = _a.variants, args = _a.args, returns = _a.returns, _isOperator = _a._isOperator;
        var functionForms = variants.map(function (variant) {
            var form = "  ".concat(title, "(").concat(variant.argumentNames.map(function (argName) {
                var result = '';
                var arg = args[argName];
                if (arg.rest) {
                    result += '...';
                }
                result += argName;
                return result;
            }).join(', '), ")");
            return "".concat(form, " -> ").concat(type(returns));
        });
        var operatorForm = _isOperator ? ['', 'Operator:', "  a ".concat(title, " b -> ").concat(type(returns))] : [];
        return __spreadArray(__spreadArray([], __read(functionForms), false), __read(operatorForm), false);
    }
    function type(arg) {
        var argType = arg.type;
        var types = Array.isArray(argType) ? argType : [argType];
        var typeString = types.join(' | ');
        return arg.array || arg.rest ? "Array<".concat(typeString, ">") : typeString;
    }
    function argStrings(reference) {
        return Object.entries(reference.args).map(function (_a) {
            var _b = __read(_a, 2), argName = _b[0], arg = _b[1];
            return "".concat(argName, ": ").concat(type(arg));
        });
    }

    function getMetaNormalExpression(normalExpressionReference) {
        return {
            doc: {
                evaluate: function (_a, sourceCodeInfo) {
                    var _b = __read(_a, 1), fn = _b[0];
                    assertNonUndefined(normalExpressionReference);
                    assertFunctionLike(fn, sourceCodeInfo);
                    if (!isLitsFunction(fn)) {
                        return '';
                    }
                    if (fn.functionType === 'Builtin') {
                        var reference = normalExpressionReference[fn.name];
                        return reference ? generateDocString(reference) : '';
                    }
                    if (fn.functionType === 'UserDefined' || fn.functionType === 'NativeJsFunction') {
                        return fn.docString;
                    }
                    return '';
                },
                arity: toFixedArity(1),
                docs: {
                    category: 'Meta',
                    returns: { type: 'string' },
                    args: { fun: { type: 'function' } },
                    variants: [{ argumentNames: ['fun'] }],
                    description: 'Returns documentation string of the $fun.',
                    examples: [
                        'doc(+)',
                        "\nlet add = (x, y) -> {\n  \"\"\"\n  Adds two numbers.\n  Args:\n    x: First number.\n    y: Second number.\n  Returns:\n    Sum of x and y.\n  \"\"\"\n  x + y;\n};\n\ndoc(add)",
                    ],
                },
            },
            arity: {
                evaluate: function (_a, sourceCodeInfo) {
                    var _b = __read(_a, 1), fn = _b[0];
                    assertFunctionLike(fn, sourceCodeInfo);
                    return isLitsFunction(fn) ? fn.arity : toFixedArity(1);
                },
                arity: toFixedArity(1),
                docs: {
                    category: 'Meta',
                    returns: { type: 'object' },
                    args: { fun: { type: 'function' } },
                    variants: [{ argumentNames: ['fun'] }],
                    description: 'Returns arity of the $fun. The arity is an object with the properties: `min` and `max`. If the function has fixed arity, `min` and `max` are equal to the number of required parameters. If no restrictions apply, empty object is returned.',
                    examples: [
                        'arity(+)',
                        'arity(defined?)',
                        "\nlet add = (x, y = 0) -> {\n  x + y;\n};\n\narity(add)",
                        "\nlet foo = (k, ...x) -> {\n  k + x;\n};\n  arity(foo)",
                    ],
                },
            },
        };
    }

    var normalExpressionReference$1 = {};
    function setNormalExpressionReference(reference) {
        Object.assign(normalExpressionReference$1, reference);
    }
    var expressions = __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, bitwiseNormalExpression), collectionNormalExpression), arrayNormalExpression), sequenceNormalExpression), mathNormalExpression), getMetaNormalExpression(normalExpressionReference$1)), miscNormalExpression), objectNormalExpression), predicatesNormalExpression), regexpNormalExpression), stringNormalExpression), functionalNormalExpression);
    Object.entries(expressions).forEach(function (_a) {
        var _b = __read(_a, 2), name = _b[0], expression = _b[1];
        expression.name = name;
    });
    var normalExpressions = __assign({}, expressions);
    var normalExpressionTypes = {};
    var allNormalExpressions = [];
    Object.entries(normalExpressions).forEach(function (_a, index) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        normalExpressionTypes[key] = index;
        allNormalExpressions.push(value);
    });

    var docs$j = {
        category: 'Special expression',
        returns: {
            type: 'any',
        },
        args: {
            a: { type: 'any' },
            b: { type: 'any' },
            c: {
                type: 'any',
                rest: true,
            },
        },
        variants: [
            { argumentNames: ['a', 'b'] },
            { argumentNames: ['a', 'b', 'c'] },
        ],
        description: "\nComputes logical `and`. Evaluation of expressions starts from left.\nAs soon as an `expression` evaluates to a falsy value, the result is returned.\n\nIf all expressions evaluate to truthy values, the value of the last expression is returned.",
        examples: [
            'true && 1',
            '&&(1, 1)',
            '&&(3 > 2, "string")',
            '&&(3 < 2, "string")',
            '&&(true, true, true, true)',
            '&&(true, true, 0, true)',
        ],
    };
    var andSpecialExpression = {
        arity: {},
        docs: docs$j,
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var value = true;
            try {
                for (var _c = __values(node[1][1]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var param = _d.value;
                    value = evaluateNode(param, contextStack);
                    if (!value)
                        break;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return value;
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var e_2, _a;
            var value = true;
            try {
                for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                    var param = params_1_1.value;
                    value = asAny(param, sourceCodeInfo);
                    if (!value)
                        break;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return value;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var docs$i = {
        category: 'Special expression',
        customVariants: ['cond cond-branch cond-branch ... end'],
        details: [
            ['cond-branch', 'case test then body', 'A branch of the cond expression.'],
            ['test', 'expression', 'The condition to test.'],
            ['body', 'expressions', 'The expressions to evaluate if the test is truthy.'],
        ],
        description: 'Used for branching. `cond-branches` are tested sequentially from the top. If no branch is tested truthy, `null` is returned.',
        examples: [
            "\ncond\n  case false then write!(\"FALSE\")\n  case true then write!(\"TRUE\")\nend",
            "\ncond\n  case false then write!(\"FALSE\")\n  case null then write!(\"null\")\nend ?? write!(\"TRUE\")",
            "\ncond\n  case false then write!(\"FALSE\")\n  case null then write!(\"null\")\nend ?? write!(\"TRUE\")",
        ],
    };
    var condSpecialExpression = {
        arity: {},
        docs: docs$i,
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var params = node[1][1];
            try {
                for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                    var _c = __read(params_1_1.value, 2), test = _c[0], form = _c[1];
                    var value = evaluateNode(test, contextStack);
                    if (!value)
                        continue;
                    return evaluateNode(form, contextStack);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (params_1_1 && !params_1_1.done && (_b = params_1.return)) _b.call(params_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1].flat(), contextStack, builtin, evaluateNode);
        },
    };

    var docs$h = {
        category: 'Special expression',
        customVariants: ['switch value switch-branch switch-branch ... end'],
        details: [
            ['value', 'any', 'The value to test.'],
            ['switch-branch', 'case test then body', 'A branch of the switch expression.'],
            ['test', 'expression', 'The condition to test.'],
            ['body', 'expressions', 'The expressions to evaluate if the test is truthy.'],
        ],
        description: 'Used for branching. `switch-branches` are tested sequentially from the top against `value`. If no branch is tested truthy, `null` is returned.',
        examples: [
            "\nswitch 1\n  case 1 then write!(\"One\")\n  case 2 then write!(\"Two\")\nend",
            "\nswitch 2\n  case 1 then write!(\"One\")\n  case 2 then write!(\"Two\")\nend",
            "\nswitch 3\n  case 1 then write!(\"One\")\n  case 2 then write!(\"Two\")\nend",
        ],
    };
    var switchSpecialExpression = {
        arity: {},
        docs: docs$h,
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var _c = __read(node[1], 3), switchValueNode = _c[1], cases = _c[2];
            var switchValue = evaluateNode(switchValueNode, contextStack);
            try {
                for (var cases_1 = __values(cases), cases_1_1 = cases_1.next(); !cases_1_1.done; cases_1_1 = cases_1.next()) {
                    var _d = __read(cases_1_1.value, 2), test = _d[0], form = _d[1];
                    var value = evaluateNode(test, contextStack);
                    if (value === switchValue) {
                        return evaluateNode(form, contextStack);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (cases_1_1 && !cases_1_1.done && (_b = cases_1.return)) _b.call(cases_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(__spreadArray([node[1][1]], __read(node[1][2].flat()), false), contextStack, builtin, evaluateNode);
        },
    };

    var definedSpecialExpression = {
        arity: toFixedArity(1),
        evaluate: function (node, contextStack) {
            var symbolNode = node[1][1];
            assertSymbolNode(symbolNode);
            if (!isUserDefinedSymbolNode(symbolNode)) {
                return true; // If the symbol is not a user defined symbol, it is defined. normal or special builtin
            }
            var lookUpResult = contextStack.lookUp(symbolNode);
            return lookUpResult !== null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols([node[1][1]], contextStack, builtin, evaluateNode);
        },
    };

    function isJsFunction(fn) {
        return typeof fn === 'object' && fn !== null && 'fn' in fn && typeof fn.fn === 'function';
    }
    function assertJsFunction(fn) {
        if (!isJsFunction(fn)) {
            throw new TypeError('Expected a NativeJsFunction');
        }
    }
    var bindingTargetTypes = {
        symbol: 11,
        rest: 12,
        object: 13,
        array: 14,
    };

    function walkDefaults(bindingTarget, onDefault) {
        var _a;
        if (bindingTarget[0] === bindingTargetTypes.object) {
            Object.values(bindingTarget[1][0]).forEach(function (element) {
                if (element[1][1]) {
                    onDefault(element[1][1]);
                }
                walkDefaults(element, onDefault);
            });
        }
        else if (bindingTarget[0] === bindingTargetTypes.array) {
            for (var index = 0; index < bindingTarget[1][0].length; index += 1) {
                var element = (_a = bindingTarget[1][0][index]) !== null && _a !== void 0 ? _a : null;
                if (element === null) {
                    continue;
                }
                if (element[1][1]) {
                    onDefault(element[1][1]);
                }
                walkDefaults(element, onDefault);
            }
        }
    }
    function evalueateBindingNodeValues(target, value, evaluate) {
        var sourceCodeInfo = target[2];
        var record = {};
        createRecord(target, value, evaluate, sourceCodeInfo, record);
        return record;
    }
    function createRecord(bindingTarget, value, evaluate, sourceCodeInfo, record) {
        var _a, _b;
        if (bindingTarget[0] === bindingTargetTypes.object) {
            assertUnknownRecord(value, sourceCodeInfo);
            var capturedKeys_1 = new Set();
            var restElement_1;
            Object.entries(bindingTarget[1][0]).forEach(function (_a) {
                var _b;
                var _c = __read(_a, 2), key = _c[0], element = _c[1];
                if (element[0] === bindingTargetTypes.rest) {
                    restElement_1 = element;
                    return;
                }
                capturedKeys_1.add(key);
                var val = (_b = (value[key] !== undefined ? value[key] : element[1][1] && evaluate(element[1][1]))) !== null && _b !== void 0 ? _b : null;
                assertAny(val, sourceCodeInfo);
                createRecord(element, val, evaluate, sourceCodeInfo, record);
            });
            if (restElement_1) {
                var restValues = Object.entries(value)
                    .filter(function (_a) {
                    var _b = __read(_a, 1), key = _b[0];
                    return !capturedKeys_1.has(key);
                })
                    .reduce(function (acc, _a) {
                    var _b = __read(_a, 2), key = _b[0], val = _b[1];
                    acc[key] = asAny(val);
                    return acc;
                }, {});
                record[restElement_1[1][0]] = restValues;
            }
        }
        else if (bindingTarget[0] === bindingTargetTypes.array) {
            var restIndex = null;
            assertArray(value, sourceCodeInfo);
            for (var index = 0; index < bindingTarget[1][0].length; index += 1) {
                var element = (_a = bindingTarget[1][0][index]) !== null && _a !== void 0 ? _a : null;
                if (element === null) {
                    continue;
                }
                if (element[0] === bindingTargetTypes.rest) {
                    restIndex = index;
                    break;
                }
                var val = (_b = (value[index] !== undefined ? value[index] : element[1][1] && evaluate(element[1][1]))) !== null && _b !== void 0 ? _b : null;
                assertAny(val, sourceCodeInfo);
                createRecord(element, val, evaluate, sourceCodeInfo, record);
            }
            if (restIndex !== null) {
                var restValues = value.slice(restIndex);
                var restElement = bindingTarget[1][0][restIndex];
                record[restElement[1][0]] = restValues;
            }
        }
        else if (bindingTarget[0] === bindingTargetTypes.rest) {
            record[bindingTarget[1][0]] = asAny(value);
        }
        else {
            record[bindingTarget[1][0][1]] = asAny(value);
        }
    }
    function getAllBindingTargetNames(bindingTarget) {
        var names = {};
        getNamesFromBindingTarget(bindingTarget, names);
        return names;
    }
    function getNamesFromBindingTarget(target, names) {
        var e_1, _a, e_2, _b;
        if (target === null) {
            return;
        }
        if (target[0] === bindingTargetTypes.array) {
            try {
                for (var _c = __values(target[1][0]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var element = _d.value;
                    getNamesFromBindingTarget(element, names);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else if (target[0] === bindingTargetTypes.object) {
            try {
                for (var _e = __values(Object.values(target[1][0])), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var element = _f.value;
                    getNamesFromBindingTarget(element, names);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        else if (target[0] === bindingTargetTypes.rest) {
            if (names[target[1][0]]) {
                throw new LitsError("Duplicate binding name: ".concat(target[1][0]), target[2]);
            }
            names[target[1][0]] = true;
        }
        else {
            if (names[target[1][0][1]]) {
                throw new LitsError("Duplicate binding name: ".concat(target[1][0]), target[2]);
            }
            names[target[1][0][1]] = true;
        }
    }

    var defSpecialExpression = {
        arity: {},
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var bindingNode = node[1][1];
            var target = bindingNode[1][0];
            var value = bindingNode[1][1];
            var bindingValue = evaluateNode(value, contextStack);
            var values = evalueateBindingNodeValues(target, bindingValue, function (Node) { return evaluateNode(Node, contextStack); });
            contextStack.exportValues(values, target[2]);
            return bindingValue;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var bindingNode = node[1][1];
            var target = bindingNode[1][0];
            var value = bindingNode[1][1];
            var bindingResult = getUndefinedSymbols([value], contextStack, builtin, evaluateNode);
            walkDefaults(target, function (defaultNode) {
                addToSet(bindingResult, getUndefinedSymbols([defaultNode], contextStack, builtin, evaluateNode));
            });
            contextStack.addValues(getAllBindingTargetNames(target), target[2]);
            return bindingResult;
        },
    };

    var docs$g = {
        category: 'Special expression',
        customVariants: ['{ body }'],
        details: [
            ['body', 'expressions', 'The expressions to evaluate.'],
        ],
        description: 'Evaluates `body`. Resulting value is the value of the last expression.',
        examples: [
            "\n{\n  let a = 1 + 2 + 3 + 4;\n  let b = -> $ * ( $ + 1 );\n  b(a)\n}",
        ],
    };
    var doSpecialExpression = {
        arity: {},
        docs: docs$g,
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var newContext = {};
            var newContextStack = contextStack.create(newContext);
            var result = null;
            try {
                for (var _c = __values(node[1][1]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var form = _d.value;
                    result = evaluateNode(form, newContextStack);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack.create({}), builtin, evaluateNode);
        },
    };

    var lambdaSpecialExpression = {
        arity: {},
        evaluate: function (node, contextStack, _a) {
            var _b;
            var builtin = _a.builtin, getUndefinedSymbols = _a.getUndefinedSymbols, evaluateNode = _a.evaluateNode;
            var fn = node[1][1];
            var docString = node[1][2];
            var evaluatedFunction = evaluateFunction(fn, contextStack, builtin, getUndefinedSymbols, evaluateNode);
            var min = evaluatedFunction[0].filter(function (arg) { return arg[0] !== bindingTargetTypes.rest && arg[1][1] === undefined; }).length;
            var max = evaluatedFunction[0].some(function (arg) { return arg[0] === bindingTargetTypes.rest; }) ? undefined : evaluatedFunction[0].length;
            var arity = { min: min > 0 ? min : undefined, max: max };
            var litsFunction = (_b = {},
                _b[FUNCTION_SYMBOL] = true,
                _b.sourceCodeInfo = node[2],
                _b.functionType = 'UserDefined',
                _b.name = undefined,
                _b.evaluatedfunction = evaluatedFunction,
                _b.arity = arity,
                _b.docString = docString,
                _b);
            return litsFunction;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var fn = node[1][1];
            return getFunctionUnresolvedSymbols(fn, contextStack, getUndefinedSymbols, builtin, evaluateNode);
        },
    };
    function evaluateFunction(fn, contextStack, builtin, getUndefinedSymbols, evaluateNode) {
        var functionContext = {};
        var context = fn[0].reduce(function (ctx, arg) {
            Object.keys(getAllBindingTargetNames(arg)).forEach(function (name) {
                ctx[name] = { value: null };
            });
            return ctx;
        }, {});
        var undefinedSymbols = getUndefinedSymbols(fn[1], contextStack.new(context), builtin, evaluateNode);
        undefinedSymbols.forEach(function (name) {
            var value = contextStack.getValue(name);
            if (isAny(value)) {
                functionContext[name] = { value: value };
            }
        });
        var evaluatedFunction = [
            fn[0],
            fn[1],
            functionContext,
        ];
        return evaluatedFunction;
    }
    function getFunctionUnresolvedSymbols(fn, contextStack, getUndefinedSymbols, builtin, evaluateNode) {
        var result = new Set();
        var newContext = { self: { value: null } };
        fn[0].forEach(function (arg) {
            Object.assign(newContext, getAllBindingTargetNames(arg));
            walkDefaults(arg, function (defaultNode) {
                addToSet(result, getUndefinedSymbols([defaultNode], contextStack, builtin, evaluateNode));
            });
        });
        var newContextStack = contextStack.create(newContext);
        var overloadResult = getUndefinedSymbols(fn[1], newContextStack, builtin, evaluateNode);
        addToSet(result, overloadResult);
        return result;
    }

    var docs$f = {
        category: 'Special expression',
        customVariants: ['if test then true-expr else false-expr', 'if test then true-expr'],
        details: [
            ['test', 'expression', 'The condition to test.'],
            ['true-expr', 'expression', 'The expression to evaluate if the test is truthy.'],
            ['false-expr', 'expression', 'The expression to evaluate if the test is falsy.'],
        ],
        description: 'Either `true-expr` or `false-expr` branch is taken. `true-expr` is selected when $test is truthy. If $test is falsy `false-expr` is executed, if no `false-expr` exists, `null` is returned.',
        examples: [
            "\nif true then\n  write!(\"TRUE\")\nelse\n  write!(\"FALSE\")\nend",
            'if false then write!("TRUE") else write!("FALSE") end',
            'if true then write!("TRUE") end',
            'if false then write!("TRUE") end',
        ],
    };
    var ifSpecialExpression = {
        arity: { min: 2, max: 3 },
        docs: docs$f,
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var _b = __read(node[1][1], 3), conditionNode = _b[0], trueNode = _b[1], falseNode = _b[2];
            if (evaluateNode(conditionNode, contextStack)) {
                return evaluateNode(trueNode, contextStack);
            }
            else if (falseNode) {
                return evaluateNode(falseNode, contextStack);
            }
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1].filter(function (n) { return !!n; }), contextStack, builtin, evaluateNode);
        },
    };

    var docs$e = {
        category: 'Special expression',
        customVariants: ['unless test then true-expr else false-expr end', 'unless test true-expr end'],
        details: [
            ['test', 'expression', 'The condition to test.'],
            ['true-expr', 'expression', 'The expressions to evaluate if the test is falsy.'],
            ['false-expr', 'expression', 'The expressions to evaluate if the test is truthy.'],
        ],
        description: 'Either `true-expr` or `false-expr` branch is taken. `true-expr` is selected when $test is falsy. If $test is truthy `false-expr` is executed, if no `false-expr` exists, `null` is returned.',
        examples: [
            "\nunless true then\n  write!(\"TRUE\")\nelse\n  write!(\"FALSE\")\nend",
            'unless false then write!("TRUE") else write!("FALSE") end',
            'unless true then write!("TRUE") end',
            'unless false then write!("TRUE") end',
        ],
    };
    var unlessSpecialExpression = {
        arity: {},
        docs: docs$e,
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var _b = __read(node[1][1], 3), conditionNode = _b[0], trueNode = _b[1], falseNode = _b[2];
            if (!evaluateNode(conditionNode, contextStack)) {
                return evaluateNode(trueNode, contextStack);
            }
            else if (falseNode) {
                return evaluateNode(falseNode, contextStack);
            }
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1].filter(function (n) { return !!n; }), contextStack, builtin, evaluateNode);
        },
    };

    var docs$d = {
        category: 'Special expression',
        customVariants: ['let s = value;'],
        details: [
            ['s', 'symbol', 'The name of the variable to bind.'],
            ['value', 'any', 'The value to bind to the variable.'],
        ],
        description: "\n  Binds local variables s to `value`. `value` can be any expression. The scope of the variables is the body of the let expression.",
        examples: ["\nlet a = 1 + 2 + 3 + 4;\nlet b = -> $ * ( $ + 1 );\nwrite!(\"a\", a, \"b\", b)"],
    };
    var letSpecialExpression = {
        arity: toFixedArity(0),
        docs: docs$d,
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var bindingNode = node[1][1];
            var target = bindingNode[1][0];
            var value = bindingNode[1][1];
            var bindingValue = evaluateNode(value, contextStack);
            var values = evalueateBindingNodeValues(target, bindingValue, function (Node) { return evaluateNode(Node, contextStack); });
            contextStack.addValues(values, target[2]);
            return bindingValue;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var bindingNode = node[1][1];
            var target = bindingNode[1][0];
            var value = bindingNode[1][1];
            var bindingResult = getUndefinedSymbols([value], contextStack, builtin, evaluateNode);
            walkDefaults(target, function (defaultNode) {
                addToSet(bindingResult, getUndefinedSymbols([defaultNode], contextStack, builtin, evaluateNode));
            });
            contextStack.addValues(getAllBindingTargetNames(target), target[2]);
            return bindingResult;
        },
    };

    var loopSpecialExpression = {
        arity: {},
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var bindingNodes = node[1][1];
            var bindingContext = bindingNodes.reduce(function (result, bindingNode) {
                var val = evaluateNode(bindingNode[1][1], contextStack.create(result));
                var valueRecord = evalueateBindingNodeValues(bindingNode[1][0], val, function (Node) { return evaluateNode(Node, contextStack); });
                Object.entries(valueRecord).forEach(function (_a) {
                    var _b = __read(_a, 2), name = _b[0], value = _b[1];
                    result[name] = { value: value };
                });
                return result;
            }, {});
            var newContextStack = contextStack.create(bindingContext);
            var body = node[1][2];
            var _loop_1 = function () {
                var result = null;
                try {
                    result = evaluateNode(body, newContextStack);
                }
                catch (error) {
                    if (error instanceof RecurSignal) {
                        var params_1 = error.params;
                        if (params_1.length !== bindingNodes.length) {
                            throw new LitsError("recur expected ".concat(bindingNodes.length, " parameters, got ").concat(valueToString(params_1.length)), node[2]);
                        }
                        bindingNodes.forEach(function (bindingNode, index) {
                            var e_1, _a;
                            var valueRecord = evalueateBindingNodeValues(bindingNode[1][0], asAny(params_1[index]), function (Node) { return evaluateNode(Node, contextStack); });
                            try {
                                for (var _b = (e_1 = void 0, __values(Object.entries(valueRecord))), _c = _b.next(); !_c.done; _c = _b.next()) {
                                    var _d = __read(_c.value, 2), name_1 = _d[0], value = _d[1];
                                    bindingContext[name_1].value = value;
                                }
                            }
                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                }
                                finally { if (e_1) throw e_1.error; }
                            }
                        });
                        return "continue";
                    }
                    throw error;
                }
                return { value: result };
            };
            for (;;) {
                var state_1 = _loop_1();
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var bindingNodes = node[1][1];
            var newContext = bindingNodes
                .reduce(function (context, bindingNode) {
                var names = getAllBindingTargetNames(bindingNode[1][0]);
                Object.keys(names).forEach(function (name) {
                    context[name] = { value: true };
                });
                return context;
            }, {});
            var bindingValueNodes = bindingNodes.map(function (bindingNode) { return bindingNode[1][1]; });
            var bindingsResult = getUndefinedSymbols(bindingValueNodes, contextStack, builtin, evaluateNode);
            var paramsResult = getUndefinedSymbols([node[1][2]], contextStack.create(newContext), builtin, evaluateNode);
            return joinSets(bindingsResult, paramsResult);
        },
    };

    function addToContext(bindings, context, contextStack, evaluateNode) {
        var e_1, _a;
        try {
            for (var bindings_1 = __values(bindings), bindings_1_1 = bindings_1.next(); !bindings_1_1.done; bindings_1_1 = bindings_1.next()) {
                var bindingNode = bindings_1_1.value;
                var _b = __read(bindingNode[1], 2), target = _b[0], bindingValue = _b[1];
                var val = evaluateNode(bindingValue, contextStack);
                var valueRecord = evalueateBindingNodeValues(target, val, function (Node) { return evaluateNode(Node, contextStack); });
                Object.entries(valueRecord).forEach(function (_a) {
                    var _b = __read(_a, 2), name = _b[0], value = _b[1];
                    context[name] = { value: value };
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (bindings_1_1 && !bindings_1_1.done && (_a = bindings_1.return)) _a.call(bindings_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    function evaluateLoop(returnResult, loopNode, contextStack, evaluateNode) {
        var sourceCodeInfo = loopNode[2];
        var _a = __read(loopNode[1], 3), loopBindings = _a[1], body = _a[2];
        var result = [];
        var bindingIndices = loopBindings.map(function () { return 0; });
        var abort = false;
        var _loop_1 = function () {
            var context = {};
            var newContextStack = contextStack.create(context);
            var skip = false;
            bindingsLoop: for (var bindingIndex = 0; bindingIndex < loopBindings.length; bindingIndex += 1) {
                var _b = __read(loopBindings[bindingIndex], 4), bindingNode = _b[0], letBindings = _b[1], whenNode = _b[2], whileNode = _b[3];
                var _c = __read(bindingNode[1], 2), targetNode = _c[0], valueNode = _c[1];
                var coll = asColl(evaluateNode(valueNode, newContextStack), sourceCodeInfo);
                var seq = isSeq(coll) ? coll : Object.entries(coll);
                if (seq.length === 0) {
                    skip = true;
                    abort = true;
                    break;
                }
                var index = asNonUndefined(bindingIndices[bindingIndex], sourceCodeInfo);
                if (index >= seq.length) {
                    skip = true;
                    if (bindingIndex === 0) {
                        abort = true;
                        break;
                    }
                    bindingIndices[bindingIndex] = 0;
                    bindingIndices[bindingIndex - 1] = asNonUndefined(bindingIndices[bindingIndex - 1], sourceCodeInfo) + 1;
                    break;
                }
                var val = asAny(seq[index], sourceCodeInfo);
                var valueRecord = evalueateBindingNodeValues(targetNode, val, function (Node) { return evaluateNode(Node, newContextStack); });
                Object.entries(valueRecord).forEach(function (_a) {
                    var _b = __read(_a, 2), name = _b[0], value = _b[1];
                    context[name] = { value: value };
                });
                if (letBindings) {
                    addToContext(letBindings, context, newContextStack, evaluateNode);
                }
                if (whenNode && !evaluateNode(whenNode, newContextStack)) {
                    bindingIndices[bindingIndex] = asNonUndefined(bindingIndices[bindingIndex], sourceCodeInfo) + 1;
                    skip = true;
                    break bindingsLoop;
                }
                if (whileNode && !evaluateNode(whileNode, newContextStack)) {
                    bindingIndices[bindingIndex] = Number.POSITIVE_INFINITY;
                    skip = true;
                    break bindingsLoop;
                }
            }
            if (!skip) {
                var value = evaluateNode(body, newContextStack);
                if (returnResult)
                    result.push(value);
                if (bindingIndices.length > 0)
                    bindingIndices[bindingIndices.length - 1] += 1;
            }
        };
        while (!abort) {
            _loop_1();
        }
        return returnResult ? result : null;
    }
    function analyze$1(loopNode, contextStack, getUndefinedSymbols, builtin, evaluateNode) {
        var result = new Set();
        var newContext = {};
        var _a = __read(loopNode[1], 3), loopBindings = _a[1], body = _a[2];
        loopBindings.forEach(function (loopBindingNode) {
            var _a = __read(loopBindingNode, 4), bindingNode = _a[0], letBindings = _a[1], whenNode = _a[2], whileNode = _a[3];
            var _b = __read(bindingNode[1], 2), target = _b[0], value = _b[1];
            getUndefinedSymbols([value], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
                return result.add(symbol);
            });
            Object.assign(newContext, getAllBindingTargetNames(target));
            if (letBindings) {
                letBindings.forEach(function (letBindingNode) {
                    var _a = __read(letBindingNode[1], 2), letTarget = _a[0], letValue = _a[1];
                    getUndefinedSymbols([letValue], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
                        return result.add(symbol);
                    });
                    Object.assign(newContext, getAllBindingTargetNames(letTarget));
                });
            }
            if (whenNode) {
                getUndefinedSymbols([whenNode], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
                    return result.add(symbol);
                });
            }
            if (whileNode) {
                getUndefinedSymbols([whileNode], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
                    return result.add(symbol);
                });
            }
        });
        getUndefinedSymbols([body], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
            return result.add(symbol);
        });
        return result;
    }
    var forDocs = {
        category: 'Special expression',
        customVariants: ['for (...binding) -> body'],
        details: [
            ['binding', 'loop-var in collection [...let-binding] [where whereExpr] [while whileExp]', 'A for loop binding'],
            ['loop-var', 'symbol', 'The name of the loop variable.'],
            ['collection', 'any', 'The collection to iterate over.'],
            ['let-binding', 'let binding', 'A let binding to create a local variable.'],
            ['whereExpr', 'expression', 'An expression that must evaluate to truthy for the loop body to be executed.'],
            ['whileExp', 'expression', 'An expression that must evaluate to truthy for the loop to continue.'],
            ['body', 'expressions', 'The expressions to evaluate for each iteration of the loop.'],
        ],
        returns: {
            type: 'any',
            array: true,
        },
        description: 'Iterates over `bindings`, evaluates `body` for each `binding` and returns an `array` of results.',
        examples: [
            "\nfor (i in [1, 2, 3]) -> i * 2\n      ",
            "\nfor (\n  i in range(10) let ii = i ^ 2 while ii < 40 when ii % 3 == 0,\n  j in range(10) when j % 2 == 1\n) -> ii + j\n      ",
        ],
    };
    var forSpecialExpression = {
        arity: toFixedArity(1),
        docs: forDocs,
        evaluate: function (node, contextStack, helpers) { return evaluateLoop(true, node, contextStack, helpers.evaluateNode); },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return analyze$1(node, contextStack, getUndefinedSymbols, builtin, evaluateNode);
        },
    };
    var doseqDocs = {
        category: 'Special expression',
        customVariants: ['doseq (...binding) -> body'],
        details: [
            ['binding', 'loop-var in collection [...let-binding] [where whereExpr] [while whileExp]', 'A doseq loop binding'],
            ['loop-var', 'symbol', 'The name of the loop variable.'],
            ['collection', 'any', 'The collection to iterate over.'],
            ['let-binding', 'let binding', 'A let binding to create a local variable.'],
            ['whereExpr', 'expression', 'An expression that must evaluate to truthy for the loop body to be executed.'],
            ['whileExp', 'expression', 'An expression that must evaluate to truthy for the loop to continue.'],
            ['body', 'expressions', 'The expressions to evaluate for each iteration of the loop.'],
        ],
        returns: {
            type: 'null',
        },
        description: 'Iterates over `bindings`, evaluates `body` for each `binding` and returns `null`. This is useful for side effects.',
        examples: [
            "\ndoseq (i in [1, 2, 3]) -> write!(i * 2)\n      ",
        ],
    };
    var doseqSpecialExpression = {
        arity: toFixedArity(1),
        docs: doseqDocs,
        evaluate: function (node, contextStack, helpers) {
            evaluateLoop(false, node, contextStack, helpers.evaluateNode);
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return analyze$1(node, contextStack, getUndefinedSymbols, builtin, evaluateNode);
        },
    };

    var docs$c = {
        category: 'Special expression',
        returns: {
            type: 'boolean',
        },
        args: {
            a: { type: 'any' },
            b: { type: 'any' },
            c: {
                type: 'any',
                rest: true,
            },
        },
        variants: [
            { argumentNames: ['a', 'b'] },
            { argumentNames: ['a', 'b', 'c'] },
        ],
        description: "\n  Computes logical `or`. Evaluation of expressions evaluation starts from left.\n  As soon as a `expression` evaluates to a truthy value, the result is returned.\n\n  If all expressions evaluate to falsy values, the value of the last expression is returned.",
        examples: [
            'false || 1',
            '||(1, 1)',
            '||(3 > 2, "string")',
            '||(3 < 2, "string")',
            '||(false, false, false, true)',
            '||(1, 2, 3, 4)',
        ],
    };
    var orSpecialExpression = {
        arity: {},
        docs: docs$c,
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var value = false;
            try {
                for (var _c = __values(node[1][1]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var param = _d.value;
                    value = evaluateNode(param, contextStack);
                    if (value)
                        break;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return value;
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var e_2, _a;
            var value = false;
            try {
                for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                    var param = params_1_1.value;
                    value = asAny(param, sourceCodeInfo);
                    if (value)
                        break;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return value;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var qqSpecialExpression = {
        arity: { min: 1, max: 2 },
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var _b = __read(node[1][1], 2), firstNode = _b[0], secondNode = _b[1];
            if (isUserDefinedSymbolNode(firstNode) && contextStack.lookUp(firstNode) === null) {
                return secondNode ? evaluateNode(secondNode, contextStack) : null;
            }
            assertAny(firstNode, node[2]);
            var firstResult = evaluateNode(firstNode, contextStack);
            return firstResult !== null && firstResult !== void 0 ? firstResult : (secondNode ? evaluateNode(secondNode, contextStack) : null);
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var firstParam = asAny(params[0], sourceCodeInfo);
            var secondParam = params[1] !== undefined ? asAny(params[1], sourceCodeInfo) : null;
            return firstParam !== null && firstParam !== void 0 ? firstParam : secondParam;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1].filter(function (n) { return !!n; }), contextStack, builtin, evaluateNode);
        },
    };

    var docs$b = {
        category: 'Special expression',
        customVariants: ['recur(...recur-args)'],
        description: 'Recursevly calls enclosing function or loop with its evaluated `recur-args`.',
        examples: [
            "\nlet foo = (n) -> {\n  write!(n);\n  if !(zero?(n)) then\n    recur(n - 1)\n  end\n};\nfoo(3)",
            "\n(n -> {\n  write!(n);\n  if !(zero?(n)) then\n    recur(n - 1)\n  end\n})(3)",
            "\nloop (n = 3) -> {\n  write!(n);\n  if !(zero?(n)) then\n    recur(n - 1)\n  end\n}",
        ],
    };
    var recurSpecialExpression = {
        arity: {},
        docs: docs$b,
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var params = node[1][1];
            var evaluatedParams = params.map(function (paramNode) { return evaluateNode(paramNode, contextStack); });
            throw new RecurSignal(evaluatedParams);
        },
        evaluateAsNormalExpression: function (params) {
            throw new RecurSignal(params);
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var docs$a = {
        category: 'Special expression',
        returns: {
            type: 'never',
        },
        args: {
            expr: {
                type: 'any',
            },
        },
        variants: [
            { argumentNames: ['expr'] },
        ],
        description: 'Throws `UserDefinedError` with message set to $expr evaluated. $expr must evaluate to a string.',
        examples: [
            'try throw("You shall not pass!") catch(error) "Error: " ++ error.message end',
            'try throw(slice("You shall not pass!", 0, 3)) catch(error) "Error: " ++ error.message end',
        ],
    };
    var throwSpecialExpression = {
        arity: toFixedArity(1),
        docs: docs$a,
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var message = asString(evaluateNode(node[1][1], contextStack), node[2], {
                nonEmpty: true,
            });
            throw new UserDefinedError(message, node[2]);
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var message = asString(params[0], sourceCodeInfo, {
                nonEmpty: true,
            });
            throw new UserDefinedError(message, undefined);
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols([node[1][1]], contextStack, builtin, evaluateNode);
        },
    };

    var docs$9 = {
        category: 'Special expression',
        customVariants: ['try { try-body } catch { catch-body }', 'try { try-body } catch(error) { catch-body }'],
        details: [
            ['try-body', 'expressions', 'The expressions to try.'],
            ['error', 'symbol', 'The error variable to bind.'],
            ['catch-body', 'expression', 'The expressions to evaluate if the try-body throws an error.'],
        ],
        description: 'Executes `try-body`. If that throws, the `catch-body` gets executed. See examples for details.',
        examples: [
            "\ntry\n  2 / 4\ncatch\n  \"Oops!\"\nend",
            "\ntry\n  foo()\ncatch(error)\n  \"Error: \" ++ error.message\nend",
            "\ntry\n  foo()\ncatch\n  42\nend",
        ],
    };
    var trySpecialExpression = {
        arity: {},
        docs: docs$9,
        evaluate: function (node, contextStack, _a) {
            var _b;
            var evaluateNode = _a.evaluateNode;
            var _c = __read(node[1], 4), tryExpression = _c[1], errorSymbol = _c[2], catchExpression = _c[3];
            try {
                return evaluateNode(tryExpression, contextStack);
            }
            catch (error) {
                var newContext = errorSymbol
                    ? (_b = {},
                        _b[errorSymbol[1]] = { value: error },
                        _b) : {};
                return evaluateNode(catchExpression, contextStack.create(newContext));
            }
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var _b;
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var _c = __read(node[1], 4), tryExpression = _c[1], errorSymbol = _c[2], catchExpression = _c[3];
            var tryResult = getUndefinedSymbols([tryExpression], contextStack, builtin, evaluateNode);
            var newContext = errorSymbol
                ? (_b = {},
                    _b[errorSymbol[1]] = { value: true },
                    _b) : {};
            var catchResult = getUndefinedSymbols([catchExpression], contextStack.create(newContext), builtin, evaluateNode);
            return joinSets(tryResult, catchResult);
        },
    };

    var docs$8 = {
        category: 'Special expression',
        returns: {
            type: 'any',
            array: true,
        },
        args: {
            values: {
                type: 'any',
                rest: true,
            },
        },
        variants: [
            { argumentNames: ['values'] },
        ],
        description: 'Makes new array from $values.',
        examples: [
            'array(1, 2, 3)',
            'array(array(null, false, true))',
            '[]',
            '[1, 2, 3]',
            '[1, 2, ...[3, 4, 5], 6]',
            '[[null, false, true]]',
            '[1, 2, 3][1]',
        ],
        hideOperatorForm: true,
    };
    var arraySpecialExpression = {
        arity: {},
        docs: docs$8,
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var result = [];
            try {
                for (var _c = __values(node[1][1]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var param = _d.value;
                    if (isSpreadNode(param)) {
                        var spreadValue = evaluateNode(param[1], contextStack);
                        if (!Array.isArray(spreadValue)) {
                            throw new LitsError('Spread value is not an array', param[2]);
                        }
                        result.push.apply(result, __spreadArray([], __read(spreadValue), false));
                    }
                    else {
                        result.push(evaluateNode(param, contextStack));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var e_2, _a;
            var result = [];
            try {
                for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                    var param = params_1_1.value;
                    result.push(asAny(param, sourceCodeInfo));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var docs$7 = {
        category: 'Special expression',
        returns: {
            type: 'object',
        },
        args: {
            kvps: {
                type: 'any',
                rest: true,
                description: 'key - value pairs, where key is a string',
            },
        },
        variants: [
            { argumentNames: ['kvps'] },
        ],
        description: 'Constructs a new object. Object members are created from the $kvps key-value pairs. Requires an even number of arguments.',
        examples: [
            'object()',
            "\nlet default = {\n  type: \"Person\",\n  name: \"John Doe\",\n  age: 42\n};\n\n{\n  ...default,\n  name: \"Lisa\"\n}",
            'object("x", 10, "y", true, "z", "A string")',
            '{}',
            '{ a: 1, b: 2 }',
        ],
        hideOperatorForm: true,
    };
    var objectSpecialExpression = {
        arity: {},
        docs: docs$7,
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var result = {};
            var params = node[1][1];
            for (var i = 0; i < params.length; i += 2) {
                var keyNode = params[i];
                if (isSpreadNode(keyNode)) {
                    var spreadObject = evaluateNode(keyNode[1], contextStack);
                    if (!isUnknownRecord(spreadObject)) {
                        throw new LitsError('Spread value is not an object', keyNode[2]);
                    }
                    Object.assign(result, spreadObject);
                    i -= 1;
                }
                else {
                    var key = evaluateNode(keyNode, contextStack);
                    var valueNode = params[i + 1];
                    if (valueNode === undefined) {
                        throw new LitsError('Missing value for key', keyNode[2]);
                    }
                    var value = evaluateNode(valueNode, contextStack);
                    assertString(key, keyNode[2]);
                    result[key] = value;
                }
            }
            return result;
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var result = {};
            for (var i = 0; i < params.length; i += 2) {
                var key = params[i];
                var value = params[i + 1];
                assertString(key, sourceCodeInfo);
                result[key] = value !== null && value !== void 0 ? value : null;
            }
            return result;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var specialExpressions = [
        qqSpecialExpression,
        andSpecialExpression,
        orSpecialExpression,
        arraySpecialExpression,
        condSpecialExpression,
        defSpecialExpression,
        definedSpecialExpression,
        // defnSpecialExpression,
        doSpecialExpression,
        doseqSpecialExpression,
        lambdaSpecialExpression,
        forSpecialExpression,
        // functionSpecialExpression,
        ifSpecialExpression,
        letSpecialExpression,
        loopSpecialExpression,
        objectSpecialExpression,
        recurSpecialExpression,
        switchSpecialExpression,
        throwSpecialExpression,
        trySpecialExpression,
        unlessSpecialExpression,
    ];
    var builtin = {
        normalExpressions: normalExpressions,
        specialExpressions: specialExpressions,
        allNormalExpressions: allNormalExpressions,
    };
    var normalExpressionKeys = Object.keys(normalExpressions);
    var specialExpressionKeys = Object.keys(specialExpressionTypes);
    new Set(specialExpressionKeys);

    var nonNumberReservedSymbolRecord = {
        true: true,
        false: false,
        null: null,
        else: null,
        case: null,
        each: null,
        in: null,
        when: null,
        while: null,
        catch: null,
        function: null,
        export: null,
        as: null,
        then: null,
        end: null,
        _: null,
    };
    var phi = (1 + Math.sqrt(5)) / 2;
    var numberReservedSymbolRecord = {
        'E': Math.E,
        '-E': -Math.E,
        'ε': Math.E,
        '-ε': -Math.E,
        'PI': Math.PI,
        '-PI': -Math.PI,
        'π': Math.PI,
        '-π': -Math.PI,
        'PHI': phi,
        '-PHI': -phi,
        'φ': phi,
        '-φ': -phi,
        'POSITIVE_INFINITY': Number.POSITIVE_INFINITY,
        '∞': Number.POSITIVE_INFINITY,
        'NEGATIVE_INFINITY': Number.NEGATIVE_INFINITY,
        '-∞': Number.NEGATIVE_INFINITY,
        'MAX_SAFE_INTEGER': Number.MAX_SAFE_INTEGER,
        'MIN_SAFE_INTEGER': Number.MIN_SAFE_INTEGER,
        'MAX_VALUE': Number.MAX_VALUE,
        'MIN_VALUE': Number.MIN_VALUE,
        'NaN': Number.NaN,
    };
    var reservedSymbolRecord = __assign(__assign({}, nonNumberReservedSymbolRecord), numberReservedSymbolRecord);
    function isNumberReservedSymbol(symbol) {
        return symbol in numberReservedSymbolRecord;
    }

    var functionExecutors = {
        NativeJsFunction: function (fn, params, sourceCodeInfo) {
            var _a;
            try {
                return toAny((_a = fn.nativeFn).fn.apply(_a, __spreadArray([], __read(params), false)));
            }
            catch (error) {
                var message = typeof error === 'string'
                    ? error
                    : isUnknownRecord(error) && typeof error.message === 'string'
                        ? error.message
                        : '<no message>';
                throw new LitsError("Native function throwed: \"".concat(message, "\""), sourceCodeInfo);
            }
        },
        UserDefined: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var _loop_1 = function () {
                var e_1, _b;
                if (!arityAcceptsMin(fn.arity, params.length)) {
                    throw new LitsError("Expected ".concat(fn.arity, " arguments, got ").concat(params.length, "."), sourceCodeInfo);
                }
                // checkParams(fn.evaluatedfunction, params.length, sourceCodeInfo)
                var evaluatedFunction = fn.evaluatedfunction;
                var args = evaluatedFunction[0];
                var nbrOfNonRestArgs = args.filter(function (arg) { return arg[0] !== bindingTargetTypes.rest; }).length;
                var newContextStack = contextStack.create(fn.evaluatedfunction[2]);
                var newContext = { self: { value: fn } };
                var rest = [];
                for (var i = 0; i < params.length; i += 1) {
                    if (i < nbrOfNonRestArgs) {
                        var param = toAny(params[i]);
                        var valueRecord = evalueateBindingNodeValues(args[i], param, function (node) {
                            return evaluateNode(node, newContextStack.create(newContext));
                        });
                        Object.entries(valueRecord).forEach(function (_a) {
                            var _b = __read(_a, 2), key = _b[0], value = _b[1];
                            newContext[key] = { value: value };
                        });
                    }
                    else {
                        rest.push(toAny(params[i]));
                    }
                }
                for (var i = params.length; i < nbrOfNonRestArgs; i++) {
                    var arg = args[i];
                    var defaultValue = evaluateNode(arg[1][1], contextStack.create(newContext));
                    var valueRecord = evalueateBindingNodeValues(arg, defaultValue, function (node) {
                        return evaluateNode(node, contextStack.create(newContext));
                    });
                    Object.entries(valueRecord).forEach(function (_a) {
                        var _b = __read(_a, 2), key = _b[0], value = _b[1];
                        newContext[key] = { value: value };
                    });
                }
                var restArgument = args.find(function (arg) { return arg[0] === bindingTargetTypes.rest; });
                if (restArgument !== undefined) {
                    var valueRecord = evalueateBindingNodeValues(restArgument, rest, function (node) { return evaluateNode(node, contextStack.create(newContext)); });
                    Object.entries(valueRecord).forEach(function (_a) {
                        var _b = __read(_a, 2), key = _b[0], value = _b[1];
                        newContext[key] = { value: value };
                    });
                }
                try {
                    var result = null;
                    var newContextStack2 = newContextStack.create(newContext);
                    try {
                        for (var _c = (e_1 = void 0, __values(evaluatedFunction[1])), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var node = _d.value;
                            result = evaluateNode(node, newContextStack2);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    return { value: result };
                }
                catch (error) {
                    if (error instanceof RecurSignal) {
                        params = error.params;
                        return "continue";
                    }
                    throw error;
                }
            };
            for (;;) {
                var state_1 = _loop_1();
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        },
        Partial: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var e_2, _b;
            var executeFunction = _a.executeFunction;
            var actualParams = __spreadArray([], __read(fn.params), false);
            if (params.length !== fn.placeholders.length) {
                throw new LitsError("(partial) expects ".concat(fn.placeholders.length, " arguments, got ").concat(params.length, "."), sourceCodeInfo);
            }
            var paramsCopy = __spreadArray([], __read(params), false);
            try {
                for (var _c = __values(fn.placeholders), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var placeholderIndex = _d.value;
                    actualParams.splice(placeholderIndex, 0, paramsCopy.shift());
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return executeFunction(fn.function, actualParams, contextStack, sourceCodeInfo);
        },
        Comp: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            var f = fn.params;
            if (f.length === 0) {
                if (params.length !== 1)
                    throw new LitsError("(comp) expects one argument, got ".concat(valueToString(params.length), "."), sourceCodeInfo);
                return asAny(params[0], sourceCodeInfo);
            }
            return asAny(f.reduceRight(function (result, fun) {
                return [executeFunction(asFunctionLike(fun, sourceCodeInfo), result, contextStack, sourceCodeInfo)];
            }, params)[0], sourceCodeInfo);
        },
        Constantly: function (fn) {
            return fn.value;
        },
        Juxt: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            return fn.params.map(function (fun) { return executeFunction(asFunctionLike(fun, sourceCodeInfo), params, contextStack, sourceCodeInfo); });
        },
        Complement: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            return !executeFunction(fn.function, params, contextStack, sourceCodeInfo);
        },
        EveryPred: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var e_3, _b, e_4, _c;
            var executeFunction = _a.executeFunction;
            try {
                for (var _d = __values(fn.params), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var f = _e.value;
                    try {
                        for (var params_1 = (e_4 = void 0, __values(params)), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                            var param = params_1_1.value;
                            var result = executeFunction(asFunctionLike(f, sourceCodeInfo), [param], contextStack, sourceCodeInfo);
                            if (!result)
                                return false;
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (params_1_1 && !params_1_1.done && (_c = params_1.return)) _c.call(params_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return true;
        },
        SomePred: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var e_5, _b, e_6, _c;
            var executeFunction = _a.executeFunction;
            try {
                for (var _d = __values(fn.params), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var f = _e.value;
                    try {
                        for (var params_2 = (e_6 = void 0, __values(params)), params_2_1 = params_2.next(); !params_2_1.done; params_2_1 = params_2.next()) {
                            var param = params_2_1.value;
                            var result = executeFunction(asFunctionLike(f, sourceCodeInfo), [param], contextStack, sourceCodeInfo);
                            if (result)
                                return true;
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (params_2_1 && !params_2_1.done && (_c = params_2.return)) _c.call(params_2);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_5) throw e_5.error; }
            }
            return false;
        },
        Fnull: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            var fnulledParams = params.map(function (param, index) { return (param === null ? toAny(fn.params[index]) : param); });
            return executeFunction(asFunctionLike(fn.function, sourceCodeInfo), fnulledParams, contextStack, sourceCodeInfo);
        },
        Builtin: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            var normalExpression = asNonUndefined(allNormalExpressions[fn.normalBuitinSymbolType], sourceCodeInfo);
            return normalExpression.evaluate(params, sourceCodeInfo, contextStack, { executeFunction: executeFunction });
        },
        SpecialBuiltin: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            var specialExpression = asNonUndefined(specialExpressions[fn.specialBuiltinSymbolType], sourceCodeInfo);
            if (specialExpression.evaluateAsNormalExpression) {
                return specialExpression.evaluateAsNormalExpression(params, sourceCodeInfo, contextStack, { executeFunction: executeFunction });
            }
            else {
                throw new LitsError("Special builtin function ".concat(fn.specialBuiltinSymbolType, " is not supported as normal expression."), sourceCodeInfo);
            }
        },
        Namespace: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            var namespace = contextStack.getNamespace(fn.namespaceName);
            if (!namespace) {
                throw new LitsError("Namespace '".concat(fn.namespaceName, "' not found."), sourceCodeInfo);
            }
            var expression = namespace.functions[fn.functionName];
            if (!expression) {
                throw new LitsError("Function '".concat(fn.functionName, "' not found in namespace '").concat(fn.namespaceName, "'."), sourceCodeInfo);
            }
            assertNumberOfParams(expression.arity, params.length, sourceCodeInfo);
            return expression.evaluate(params, sourceCodeInfo, contextStack, { executeFunction: executeFunction });
        },
    };

    function evaluate(ast, contextStack) {
        var e_1, _a;
        var result = null;
        try {
            for (var _b = __values(ast.body), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                result = evaluateNode(node, contextStack);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    function evaluateNode(node, contextStack) {
        switch (node[0]) {
            case NodeTypes.Number:
                return evaluateNumber(node);
            case NodeTypes.String:
                return evaluateString(node);
            case NodeTypes.NormalBuiltinSymbol:
            case NodeTypes.SpecialBuiltinSymbol:
            case NodeTypes.UserDefinedSymbol:
                return contextStack.evaluateSymbol(node);
            case NodeTypes.ReservedSymbol:
                return evaluateReservedSymbol(node);
            case NodeTypes.NormalExpression: {
                var result = evaluateNormalExpression(node, contextStack);
                if (typeof result === 'number' && Number.isNaN(result)) {
                    throw new LitsError('Number is NaN', node[2]);
                }
                return annotate(result);
            }
            case NodeTypes.SpecialExpression:
                return annotate(evaluateSpecialExpression(node, contextStack));
            /* v8 ignore next 2 */
            default:
                throw new LitsError("".concat(getNodeTypeName(node[0]), "-node cannot be evaluated"), node[2]);
        }
    }
    function evaluateNumber(node) {
        return node[1];
    }
    function evaluateString(node) {
        return node[1];
    }
    function evaluateReservedSymbol(node) {
        var reservedName = node[1];
        if (!['true', 'false', 'null'].includes(reservedName)) {
            throw new LitsError("Reserved symbol ".concat(reservedName, " cannot be evaluated"), node[2]);
        }
        var value = reservedSymbolRecord[reservedName];
        return asNonUndefined(value, node[2]);
    }
    function evaluateNormalExpression(node, contextStack) {
        var _a, _b;
        var sourceCodeInfo = node[2];
        var paramNodes = node[1][1];
        var params = [];
        var placeholders = [];
        paramNodes.forEach(function (paramNode, index) {
            if (isSpreadNode(paramNode)) {
                var spreadValue = evaluateNode(paramNode[1], contextStack);
                if (Array.isArray(spreadValue)) {
                    params.push.apply(params, __spreadArray([], __read(spreadValue), false));
                }
                else {
                    throw new LitsError("Spread operator requires an array, got ".concat(valueToString(paramNode)), paramNode[2]);
                }
            }
            else if (paramNode[0] === NodeTypes.ReservedSymbol && paramNode[1] === '_') {
                placeholders.push(index);
            }
            else {
                params.push(evaluateNode(paramNode, contextStack));
            }
        });
        if (isNormalExpressionNodeWithName(node)) {
            var nameSymbol = node[1][0];
            if (placeholders.length > 0) {
                var fn = evaluateNode(nameSymbol, contextStack);
                var partialFunction = (_a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.function = asFunctionLike(fn, sourceCodeInfo),
                    _a.functionType = 'Partial',
                    _a.params = params,
                    _a.placeholders = placeholders,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a.arity = toFixedArity(placeholders.length),
                    _a);
                return partialFunction;
            }
            if (isNormalBuiltinSymbolNode(nameSymbol)) {
                var type = nameSymbol[1];
                var normalExpression = builtin.allNormalExpressions[type];
                return normalExpression.evaluate(params, node[2], contextStack, { executeFunction: executeFunction });
            }
            else {
                var fn = contextStack.getValue(nameSymbol[1]);
                if (fn !== undefined) {
                    return executeFunction(asFunctionLike(fn, sourceCodeInfo), params, contextStack, sourceCodeInfo);
                }
                throw new UndefinedSymbolError(nameSymbol[1], node[2]);
            }
        }
        else {
            var fnNode = node[1][0];
            var fn = asFunctionLike(evaluateNode(fnNode, contextStack), sourceCodeInfo);
            if (placeholders.length > 0) {
                var partialFunction = (_b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.function = fn,
                    _b.functionType = 'Partial',
                    _b.params = params,
                    _b.placeholders = placeholders,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b.arity = toFixedArity(placeholders.length),
                    _b);
                return partialFunction;
            }
            return executeFunction(fn, params, contextStack, sourceCodeInfo);
        }
    }
    function executeFunction(fn, params, contextStack, sourceCodeInfo) {
        if (isLitsFunction(fn))
            return functionExecutors[fn.functionType](fn, params, sourceCodeInfo, contextStack, { evaluateNode: evaluateNode, executeFunction: executeFunction });
        if (Array.isArray(fn))
            return evaluateArrayAsFunction(fn, params, sourceCodeInfo);
        if (isObj(fn))
            return evalueateObjectAsFunction(fn, params, sourceCodeInfo);
        if (typeof fn === 'string')
            return evaluateStringAsFunction(fn, params, sourceCodeInfo);
        if (isNumber(fn)) {
            return evaluateNumberAsFunction(fn, params, sourceCodeInfo);
            /* v8 ignore next 4 */
        }
        throw new LitsError('Unexpected function type', sourceCodeInfo);
    }
    function evaluateSpecialExpression(node, contextStack) {
        var specialExpressionType = node[1][0];
        var specialExpression = asNonUndefined(builtin.specialExpressions[specialExpressionType], node[2]);
        var castedEvaluate = specialExpression.evaluate;
        return castedEvaluate(node, contextStack, { evaluateNode: evaluateNode, builtin: builtin, getUndefinedSymbols: getUndefinedSymbols });
    }
    function evalueateObjectAsFunction(fn, params, sourceCodeInfo) {
        if (params.length !== 1)
            throw new LitsError('Object as function requires one string parameter.', sourceCodeInfo);
        var key = params[0];
        assertString(key, sourceCodeInfo);
        return toAny(fn[key]);
    }
    function evaluateArrayAsFunction(fn, params, sourceCodeInfo) {
        if (params.length !== 1)
            throw new LitsError('Array as function requires one non negative integer parameter.', sourceCodeInfo);
        var index = params[0];
        assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
        return toAny(fn[index]);
    }
    function evaluateStringAsFunction(fn, params, sourceCodeInfo) {
        if (params.length !== 1)
            throw new LitsError('String as function requires one Obj parameter.', sourceCodeInfo);
        var param = toAny(params[0]);
        if (isObj(param))
            return toAny((param)[fn]);
        if (isNumber(param, { integer: true }))
            return toAny(fn[param]);
        throw new LitsError("string as function expects Obj or integer parameter, got ".concat(valueToString(param)), sourceCodeInfo);
    }
    function evaluateNumberAsFunction(fn, params, sourceCodeInfo) {
        assertNumber(fn, sourceCodeInfo, { integer: true });
        if (params.length !== 1)
            throw new LitsError('Number as function requires one Arr parameter.', sourceCodeInfo);
        var param = params[0];
        assertSeq(param, sourceCodeInfo);
        return toAny(param[fn]);
    }

    function isContextEntry(value) {
        return isUnknownRecord(value) && value.value !== undefined;
    }

    var ContextStackImpl = /** @class */ (function () {
        function ContextStackImpl(_a) {
            var contexts = _a.contexts, hostValues = _a.values, nativeJsFunctions = _a.nativeJsFunctions, namespaces = _a.namespaces;
            this.globalContext = asNonUndefined(contexts[0]);
            this.contexts = contexts;
            this.values = hostValues;
            this.nativeJsFunctions = nativeJsFunctions;
            this.namespaces = namespaces !== null && namespaces !== void 0 ? namespaces : new Map();
        }
        ContextStackImpl.prototype.getNamespace = function (name) {
            return this.namespaces.get(name);
        };
        ContextStackImpl.prototype.create = function (context) {
            var globalContext = this.globalContext;
            var contextStack = new ContextStackImpl({
                contexts: __spreadArray([context], __read(this.contexts), false),
                values: this.values,
                nativeJsFunctions: this.nativeJsFunctions,
                namespaces: this.namespaces,
            });
            contextStack.globalContext = globalContext;
            return contextStack;
        };
        ContextStackImpl.prototype.new = function (context) {
            var contexts = [{}, context];
            return new ContextStackImpl({ contexts: contexts, namespaces: this.namespaces });
        };
        ContextStackImpl.prototype.exportValues = function (values, sourceCodeInfo) {
            var e_1, _a;
            try {
                for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), name_1 = _d[0], value = _d[1];
                    if (this.globalContext[name_1]) {
                        throw new LitsError("Cannot redefine exported value \"".concat(name_1, "\""), sourceCodeInfo);
                    }
                    if (specialExpressionKeys.includes(name_1)) {
                        throw new LitsError("Cannot shadow special expression \"".concat(name_1, "\""), sourceCodeInfo);
                    }
                    if (normalExpressionKeys.includes(name_1)) {
                        throw new LitsError("Cannot shadow builtin function \"".concat(name_1, "\""), sourceCodeInfo);
                    }
                    if (name_1 === 'self') {
                        throw new LitsError("Cannot shadow builtin value \"".concat(name_1, "\""), sourceCodeInfo);
                    }
                    this.globalContext[name_1] = { value: value };
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this.contexts[0] !== this.globalContext) {
                this.addValues(values, sourceCodeInfo);
            }
        };
        ContextStackImpl.prototype.addValues = function (values, sourceCodeInfo) {
            var e_2, _a;
            var currentContext = this.contexts[0];
            try {
                for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), name_2 = _d[0], value = _d[1];
                    if (currentContext[name_2]) {
                        throw new LitsError("Cannot redefine value \"".concat(name_2, "\""), sourceCodeInfo);
                    }
                    if (specialExpressionKeys.includes(name_2)) {
                        throw new LitsError("Cannot shadow special expression \"".concat(name_2, "\""), sourceCodeInfo);
                    }
                    if (normalExpressionKeys.includes(name_2)) {
                        throw new LitsError("Cannot shadow builtin function \"".concat(name_2, "\""), sourceCodeInfo);
                    }
                    if (name_2 === 'self') {
                        throw new LitsError("Cannot shadow builtin value \"".concat(name_2, "\""), sourceCodeInfo);
                    }
                    currentContext[name_2] = { value: toAny(value) };
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        ContextStackImpl.prototype.getValue = function (name) {
            var e_3, _a;
            var _b, _c;
            try {
                for (var _d = __values(this.contexts), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var context = _e.value;
                    var contextEntry = context[name];
                    if (contextEntry)
                        return contextEntry.value;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_3) throw e_3.error; }
            }
            var nativeJsFunction = (_b = this.nativeJsFunctions) === null || _b === void 0 ? void 0 : _b[name];
            if (nativeJsFunction)
                return nativeJsFunction;
            return (_c = this.values) === null || _c === void 0 ? void 0 : _c[name];
        };
        ContextStackImpl.prototype.lookUp = function (node) {
            var e_4, _a;
            var _b, _c;
            var value = node[1];
            try {
                for (var _d = __values(this.contexts), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var context = _e.value;
                    var contextEntry = context[value];
                    if (contextEntry)
                        return contextEntry;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_4) throw e_4.error; }
            }
            var hostValue = (_b = this.values) === null || _b === void 0 ? void 0 : _b[value];
            if (hostValue !== undefined) {
                return {
                    value: toAny(hostValue),
                };
            }
            var nativeJsFunction = (_c = this.nativeJsFunctions) === null || _c === void 0 ? void 0 : _c[value];
            if (nativeJsFunction) {
                return {
                    value: nativeJsFunction,
                };
            }
            return null;
        };
        ContextStackImpl.prototype.evaluateSymbol = function (node) {
            var _a, _b;
            if (isSpecialBuiltinSymbolNode(node)) {
                var functionType = node[1];
                switch (functionType) {
                    case specialExpressionTypes['&&']:
                    case specialExpressionTypes['||']:
                    case specialExpressionTypes.array:
                    case specialExpressionTypes.object:
                    case specialExpressionTypes['defined?']:
                    case specialExpressionTypes.recur:
                    case specialExpressionTypes.throw:
                    case specialExpressionTypes['??']: {
                        var specialExpression = asNonUndefined(builtin.specialExpressions[functionType], node[2]);
                        return _a = {},
                            _a[FUNCTION_SYMBOL] = true,
                            _a.functionType = 'SpecialBuiltin',
                            _a.specialBuiltinSymbolType = functionType,
                            _a.sourceCodeInfo = node[2],
                            _a.arity = specialExpression.arity,
                            _a;
                    }
                    default:
                        throw new LitsError("Unknown special builtin symbol type: ".concat(functionType), node[2]);
                }
            }
            if (isNormalBuiltinSymbolNode(node)) {
                var type = node[1];
                var normalExpression = allNormalExpressions[type];
                var name_3 = normalExpression.name;
                return _b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.functionType = 'Builtin',
                    _b.normalBuitinSymbolType = type,
                    _b.sourceCodeInfo = node[2],
                    _b.arity = normalExpression.arity,
                    _b.name = name_3,
                    _b;
            }
            var lookUpResult = this.lookUp(node);
            if (isContextEntry(lookUpResult))
                return lookUpResult.value;
            throw new UndefinedSymbolError(node[1], node[2]);
        };
        return ContextStackImpl;
    }());
    function checkNotDefined(name) {
        if (specialExpressionKeys.includes(name)) {
            console.warn("Cannot shadow special expression \"".concat(name, "\", ignoring."));
            return false;
        }
        if (normalExpressionKeys.includes(name)) {
            console.warn("Cannot shadow builtin function \"".concat(name, "\", ignoring."));
            return false;
        }
        if (name === 'self') {
            console.warn("Cannot shadow builtin value \"".concat(name, "\", ignoring."));
            return false;
        }
        return true;
    }
    function createContextStack(params, namespaces) {
        var _a;
        if (params === void 0) { params = {}; }
        var globalContext = (_a = params.globalContext) !== null && _a !== void 0 ? _a : {};
        // Contexts are checked from left to right
        var contexts = params.contexts ? __spreadArray([globalContext], __read(params.contexts), false) : [globalContext];
        var contextStack = new ContextStackImpl({
            contexts: contexts,
            values: params.values,
            namespaces: namespaces,
            nativeJsFunctions: params.jsFunctions
                && Object.entries(params.jsFunctions).reduce(function (acc, _a) {
                    var e_5, _b, _c;
                    var _d, _e;
                    var _f = __read(_a, 2), identifier = _f[0], entry = _f[1];
                    var identifierParts = identifier.split('.');
                    var name = identifierParts.pop();
                    if (/^[A-Z]/.test(name)) {
                        console.warn("Invalid identifier \"".concat(identifier, "\" in jsFunctions, function name must not start with an uppercase letter"), undefined);
                        return acc;
                    }
                    var scope = acc;
                    try {
                        for (var identifierParts_1 = __values(identifierParts), identifierParts_1_1 = identifierParts_1.next(); !identifierParts_1_1.done; identifierParts_1_1 = identifierParts_1.next()) {
                            var part = identifierParts_1_1.value;
                            if (part.length === 0) {
                                console.warn("Invalid empty identifier \"".concat(identifier, "\" in nativeJsFunctions"), undefined);
                                return acc;
                            }
                            if (!/^[A-Z]/.test(part)) {
                                console.warn("Invalid identifier \"".concat(identifier, "\" in jsFunctions, module name must start with an uppercase letter"), undefined);
                                return acc;
                            }
                            if (!scope[part]) {
                                scope[part] = {};
                            }
                            scope = scope[part];
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (identifierParts_1_1 && !identifierParts_1_1.done && (_b = identifierParts_1.return)) _b.call(identifierParts_1);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    assertJsFunction(entry);
                    var natifeFn = (_c = {
                            functionType: 'NativeJsFunction',
                            nativeFn: entry,
                            name: name
                        },
                        _c[FUNCTION_SYMBOL] = true,
                        _c.arity = (_d = entry.arity) !== null && _d !== void 0 ? _d : {},
                        _c.docString = (_e = entry.docString) !== null && _e !== void 0 ? _e : '',
                        _c);
                    if (scope === acc && !checkNotDefined(name)) {
                        return acc;
                    }
                    scope[name] = natifeFn;
                    return acc;
                }, {}),
        });
        return params.globalModuleScope ? contextStack : contextStack.create({});
    }

    var binaryOperators = [
        '^', // exponentiation
        '*', // multiplication
        '/', // division
        '%', // remainder
        '+', // addition
        '-', // subtraction
        '<<', // left shift
        '>>', // signed right shift
        '>>>', // unsigned right shift
        '++', // string concatenation
        '<', // less than
        '<=', // less than or equal
        '≤', // less than or equal
        '>', // greater than
        '>=', // greater than or equal
        '≥', // greater than or equal
        '==', // equal
        '!=', // not equal
        '≠', // not equal
        '&', // bitwise AND
        'xor', // bitwise XOR
        '|', // bitwise OR
        '&&', // logical AND
        '||', // logical OR
        '??', // nullish coalescing
        '|>', // pipe
    ];
    var otherOperators = [
        '?', // conditional operator
        ':', // conditional operator
        '->', // lambda
        '...', // rest
        '.', // property accessor
        ',', // item separator
        '=', // assignment
        ':', // property assignment
        ';', // statement terminator
    ];
    var symbolicOperators = __spreadArray(__spreadArray([], __read(binaryOperators), false), __read(otherOperators), false);
    var nonFunctionOperators = [
        'comment',
        'cond',
        'def',
        'defined?',
        'block',
        'doseq',
        'if',
        'let',
        'loop',
        'recur',
        'throw',
        'try',
        'unless',
        'while',
    ];
    var nonFunctionOperatorSet = new Set(nonFunctionOperators);
    function isFunctionOperator(operator) {
        return !nonFunctionOperatorSet.has(operator);
    }
    var binaryOperatorSet = new Set(binaryOperators);
    function isBinaryOperator(operator) {
        return binaryOperatorSet.has(operator);
    }
    var symbolicOperatorSet = new Set(symbolicOperators);
    function isSymbolicOperator(operator) {
        return symbolicOperatorSet.has(operator);
    }

    var illegalSymbolCharacters = [
        '(',
        ')',
        '[',
        ']',
        '{',
        '}',
        '\'',
        '"',
        '`',
        ',',
        '.',
        ';',
        ' ',
        '\n',
        '\r',
        '\t',
    ];
    var illegalFirstSymbolCharacters = __spreadArray([
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9'
    ], __read(illegalSymbolCharacters), false);
    var illegalSymbolCharacterSet = new Set(illegalSymbolCharacters);
    var illegalFirstSymbolCharacterSet = new Set(illegalFirstSymbolCharacters);
    var whitespaceRegExp = /\s/;
    var NO_MATCH = [0];
    var tokenizeLParen = function (input, position) {
        return tokenizeToken('LParen', '(', input, position);
    };
    var tokenizeRParen = function (input, position) {
        return tokenizeToken('RParen', ')', input, position);
    };
    var tokenizeLBracket = function (input, position) {
        return tokenizeToken('LBracket', '[', input, position);
    };
    var tokenizeRBracket = function (input, position) {
        return tokenizeToken('RBracket', ']', input, position);
    };
    var tokenizeLBrace = function (input, position) {
        return tokenizeToken('LBrace', '{', input, position);
    };
    var tokenizeRBrace = function (input, position) {
        return tokenizeToken('RBrace', '}', input, position);
    };
    var tokenizeDocString = function (input, position) {
        if (input[position] !== '"' || input[position + 1] !== '"' || input[position + 2] !== '"')
            return NO_MATCH;
        var value = '"""';
        var length = 3;
        var char = input[position + length];
        var nextThreeChars = input.slice(position + length, position + length + 3);
        var escaping = false;
        while (char && (nextThreeChars !== '"""' || escaping)) {
            length += 1;
            if (escaping) {
                escaping = false;
                value += char;
            }
            else {
                if (char === '\\') {
                    escaping = true;
                }
                value += char;
            }
            char = input[position + length];
            nextThreeChars = input.slice(position + length, position + length + 3);
        }
        if (!char) {
            return [length, ['Error', value, undefined, "Unclosed doc string at position ".concat(position)]];
        }
        value += '"""'; // closing quote
        return [length + 3, ['DocString', value]];
    };
    var tokenizeString = function (input, position) {
        if (input[position] !== '"')
            return NO_MATCH;
        var value = '"';
        var length = 1;
        var char = input[position + length];
        var escaping = false;
        while (char && (char !== '"' || escaping)) {
            length += 1;
            if (escaping) {
                escaping = false;
                value += char;
            }
            else {
                if (char === '\\') {
                    escaping = true;
                }
                value += char;
            }
            char = input[position + length];
        }
        if (!char) {
            return [length, ['Error', value, undefined, "Unclosed string at position ".concat(position)]];
        }
        value += '"'; // closing quote
        return [length + 1, ['String', value]];
    };
    var tokenizeRegexpShorthand = function (input, position) {
        if (input[position] !== '#')
            return NO_MATCH;
        var _a = __read(tokenizeString(input, position + 1), 2), stringLength = _a[0], token = _a[1];
        if (!token)
            return NO_MATCH;
        if (token[0] === 'Error') {
            var errorToken = ['Error', "#".concat(token[1]), undefined, "Unclosed regexp at position ".concat(position)];
            return [stringLength + 1, errorToken];
        }
        position += stringLength + 1;
        var length = stringLength + 1;
        var options = '';
        while (input[position] === 'g' || input[position] === 'i') {
            options += input[position];
            length += 1;
            position += 1;
            if (options.includes(input[position])) {
                return [length, ['Error', "#".concat(token[1]).concat(options), undefined, "Duplicated regexp option \"".concat(input[position], "\"")]];
            }
        }
        return [length, ['RegexpShorthand', "#".concat(token[1]).concat(options)]];
    };
    function tokenizeToken(type, value, input, position) {
        if (value === input.slice(position, position + value.length))
            return [value.length, [type, value]];
        else
            return NO_MATCH;
    }
    var tokenizeWhitespace = function (input, position) {
        var char = input[position];
        if (!char || !whitespaceRegExp.test(char)) {
            return NO_MATCH;
        }
        var value = char;
        position += 1;
        char = input[position];
        while (char && whitespaceRegExp.test(char)) {
            value += char;
            position += 1;
            char = input[position];
        }
        return [value.length, ['Whitespace', value]];
    };
    var decimalNumberRegExp = /\d/;
    var octalNumberRegExp = /[0-7]/;
    var hexNumberRegExp = /[0-9a-f]/i;
    var binaryNumberRegExp = /[01]/;
    var postNumberRegExp = /[\s)\]}(,;]/;
    var tokenizeNumber = function (input, position) {
        var i;
        var negate = input[position] === '-';
        var plusPrefix = input[position] === '+';
        var start = negate || plusPrefix ? position + 1 : position;
        var hasDecimalPoint = false;
        var hasExponent = false;
        for (i = start; i < input.length; i += 1) {
            var char = input[i];
            if (char === '_') {
                if (!decimalNumberRegExp.test(input[i - 1]) || !decimalNumberRegExp.test(input[i + 1])) {
                    if (i === start) {
                        return NO_MATCH;
                    }
                    return [i - position + 1, ['Error', input.substring(position, i + 1), undefined, "Invalid number format at position ".concat(i + 1)]];
                }
            }
            else if (char === '.') {
                if (i === start) {
                    return NO_MATCH;
                }
                if (hasDecimalPoint || hasExponent) {
                    return [i - position + 1, ['Error', input.substring(position, i + 1), undefined, "Invalid number format at position ".concat(i + 1)]];
                }
                hasDecimalPoint = true;
            }
            else if (char === 'e' || char === 'E') {
                if (i === start) {
                    return NO_MATCH;
                }
                if (hasExponent) {
                    return [i - position + 1, ['Error', input.substring(position, i + 1), undefined, "Invalid number format at position ".concat(i + 1)]];
                }
                if (input[i - 1] === '.' || input[i - 1] === '+' || input[i - 1] === '-') {
                    return [i - position + 1, ['Error', input.substring(position, i + 1), undefined, "Invalid number format at position ".concat(i + 1)]];
                }
                if (input[i + 1] === '+' || input[i + 1] === '-') {
                    i += 1;
                }
                hasExponent = true;
            }
            else if (!decimalNumberRegExp.test(char)) {
                break;
            }
        }
        if ((negate || plusPrefix) && i === start) {
            return NO_MATCH;
        }
        var length = i - position;
        if (length === 0) {
            return NO_MATCH;
        }
        var nextChar = input[i];
        if (nextChar && nextChar !== ':' && !postNumberRegExp.test(nextChar)) {
            return [i - position + 1, ['Error', input.substring(position, i + 1), undefined, "Invalid number format at position ".concat(i + 1)]];
        }
        return [length, ['Number', input.substring(position, i)]];
    };
    var tokenizeBasePrefixedNumber = function (input, position) {
        if (input[position] !== '0') {
            return NO_MATCH;
        }
        var baseChar = input[position + 1];
        var type = baseChar === 'b' || baseChar === 'B'
            ? 'binary'
            : baseChar === 'o' || baseChar === 'O'
                ? 'octal'
                : baseChar === 'x' || baseChar === 'X'
                    ? 'hex'
                    : null;
        if (type === null) {
            return NO_MATCH;
        }
        var i;
        for (i = position + 2; i < input.length; i += 1) {
            var char = input[i];
            if (type === 'binary' && !binaryNumberRegExp.test(char)) {
                break;
            }
            if (type === 'octal' && !octalNumberRegExp.test(char)) {
                break;
            }
            if (type === 'hex' && !hexNumberRegExp.test(char)) {
                break;
            }
        }
        var length = i - position;
        if (length <= 2) {
            return NO_MATCH;
        }
        var nextChar = input[i];
        if (nextChar && !postNumberRegExp.test(nextChar)) {
            return NO_MATCH;
        }
        return [length, ['BasePrefixedNumber', input.substring(position, i)]];
    };
    var tokenizeSymbol = function (input, position) {
        var value = input[position];
        if (value === '\'') {
            var length_1 = 1;
            var char = input[position + length_1];
            var escaping = false;
            while (char !== '\'' || escaping) {
                if (char === undefined)
                    return [length_1, ['Error', value, undefined, "Unclosed quoted symbol at position ".concat(position)]];
                length_1 += 1;
                if (escaping) {
                    escaping = false;
                    value += char;
                }
                else {
                    if (char === '\\') {
                        escaping = true;
                    }
                    value += char;
                }
                char = input[position + length_1];
            }
            value += '\''; // closing quote
            return [length_1 + 1, ['Symbol', value]];
        }
        if (!illegalFirstSymbolCharacterSet.has(value)) {
            var initialPosition = position;
            position += 1;
            var char = input[position];
            while (char && !illegalSymbolCharacterSet.has(char)) {
                value += char;
                position += 1;
                char = input[position];
            }
            // : can be used as symbol character, but it must not be the last character
            return value.endsWith(':')
                ? [position - initialPosition - 1, ['Symbol', value.slice(0, -1)]]
                : [position - initialPosition, ['Symbol', value]];
        }
        return NO_MATCH;
    };
    var tokenizeReservedSymbolToken = function (input, position) {
        var symbolMeta = tokenizeSymbol(input, position);
        if (symbolMeta[0] === 0 || !symbolMeta[1]) {
            return NO_MATCH;
        }
        var symbolName = symbolMeta[1][1];
        symbolName = symbolName.startsWith('\'') ? symbolName.slice(1, symbolName.length - 1) : symbolName;
        var info = reservedSymbolRecord[symbolName];
        if (info === undefined) {
            return NO_MATCH;
        }
        return [symbolMeta[0], ['ReservedSymbol', symbolName]];
    };
    var tokenizeOperator = function (input, position) {
        var _a;
        var threeChars = input.slice(position, position + 3);
        if (position + 2 < input.length && isSymbolicOperator(threeChars)) {
            return [3, ['Operator', threeChars]];
        }
        var twoChars = input.slice(position, position + 2);
        if (position + 1 < input.length && isSymbolicOperator(twoChars)) {
            return [2, ['Operator', twoChars]];
        }
        var oneChar = (_a = input[position]) !== null && _a !== void 0 ? _a : '';
        if (isSymbolicOperator(oneChar)) {
            return [1, ['Operator', oneChar]];
        }
        return NO_MATCH;
    };
    var tokenizeMultiLineComment = function (input, position) {
        if (input[position] === '/' && input[position + 1] === '*') {
            var length_2 = 2;
            var value = '/*';
            while ((input[position + length_2] !== '*' || input[position + length_2 + 1] !== '/') && position + length_2 + 1 < input.length) {
                value += input[position + length_2];
                length_2 += 1;
            }
            if (position + length_2 + 1 >= input.length) {
                return [length_2, ['Error', value, undefined, "Unclosed multi-line comment at position ".concat(position)]];
            }
            value += '*/';
            length_2 += 2;
            return [length_2, ['MultiLineComment', value]];
        }
        return NO_MATCH;
    };
    var tokenizeShebang = function (input, position) {
        if (input[position] === '#' && input[position + 1] === '!') {
            var length_3 = 2;
            var value = '#!';
            while (input[position + length_3] !== '\n' && position + length_3 < input.length) {
                value += input[position + length_3];
                length_3 += 1;
            }
            return [length_3, ['SingleLineComment', value]];
        }
        return NO_MATCH;
    };
    var tokenizeSingleLineComment = function (input, position) {
        if (input[position] === '/' && input[position + 1] === '/') {
            var length_4 = 2;
            var value = '//';
            while (input[position + length_4] !== '\n' && position + length_4 < input.length) {
                value += input[position + length_4];
                length_4 += 1;
            }
            return [length_4, ['SingleLineComment', value]];
        }
        return NO_MATCH;
    };
    // All tokenizers, order matters!
    var tokenizers = [
        tokenizeWhitespace,
        tokenizeMultiLineComment,
        tokenizeSingleLineComment,
        tokenizeReservedSymbolToken,
        tokenizeLParen,
        tokenizeRParen,
        tokenizeLBracket,
        tokenizeRBracket,
        tokenizeLBrace,
        tokenizeRBrace,
        tokenizeDocString,
        tokenizeString,
        tokenizeRegexpShorthand,
        tokenizeBasePrefixedNumber,
        tokenizeNumber,
        tokenizeOperator,
        tokenizeSymbol,
    ];

    function tokenize$1(input, debug, filePath) {
        var position = 0;
        var tokenStream = {
            tokens: [],
            filePath: filePath,
            hasDebugData: debug,
        };
        while (position < input.length) {
            var sourceCodeInfo = debug
                ? createSourceCodeInfo(input, position, filePath)
                : undefined;
            var tokenDescriptor = getCurrentToken(input, position);
            var _a = __read(tokenDescriptor, 2), count = _a[0], token = _a[1];
            position += count;
            if (token) {
                if (sourceCodeInfo) {
                    token[2] = sourceCodeInfo;
                }
                tokenStream.tokens.push(token);
            }
        }
        return tokenStream;
    }
    function getSourceCodeLine(input, lineNbr) {
        return input.split(/\r\n|\r|\n/)[lineNbr];
    }
    function createSourceCodeInfo(input, position, filePath) {
        var lines = input.substring(0, position + 1).split(/\r\n|\r|\n/);
        var lastLine = lines[lines.length - 1];
        var code = getSourceCodeLine(input, lines.length - 1);
        var line = lines.length;
        var column = lastLine.length;
        return {
            code: code,
            position: {
                line: line,
                column: column,
            },
            filePath: filePath,
        };
    }
    function getCurrentToken(input, position) {
        var e_1, _a;
        var initialPosition = position;
        if (position === 0) {
            var _b = __read(tokenizeShebang(input, position), 2), nbrOfCharacters = _b[0], token = _b[1];
            position += nbrOfCharacters;
            if (nbrOfCharacters > 0) {
                return [position - initialPosition, token];
            }
        }
        try {
            for (var tokenizers_1 = __values(tokenizers), tokenizers_1_1 = tokenizers_1.next(); !tokenizers_1_1.done; tokenizers_1_1 = tokenizers_1.next()) {
                var tokenizer = tokenizers_1_1.value;
                var _c = __read(tokenizer(input, position), 2), nbrOfCharacters = _c[0], token = _c[1];
                position += nbrOfCharacters;
                if (nbrOfCharacters === 0) {
                    continue;
                }
                return [position - initialPosition, token];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tokenizers_1_1 && !tokenizers_1_1.done && (_a = tokenizers_1.return)) _a.call(tokenizers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return [1, ['Error', input[initialPosition], undefined, 'Unrecognized character']];
    }

    function isSymbolToken(token, symbolName) {
        if ((token === null || token === void 0 ? void 0 : token[0]) !== 'Symbol') {
            return false;
        }
        if (symbolName && token[1] !== symbolName) {
            return false;
        }
        return true;
    }
    function assertSymbolToken(token, symbolName) {
        if (!isSymbolToken(token, symbolName)) {
            throwUnexpectedToken('Symbol', undefined, token);
        }
    }
    function asSymbolToken(token, symbolName) {
        assertSymbolToken(token, symbolName);
        return token;
    }
    function isReservedSymbolToken(token, symbolName) {
        if ((token === null || token === void 0 ? void 0 : token[0]) !== 'ReservedSymbol') {
            return false;
        }
        if (symbolName && token[1] !== symbolName) {
            return false;
        }
        return true;
    }
    function assertReservedSymbolToken(token, symbolName) {
        if (!isReservedSymbolToken(token, symbolName)) {
            throwUnexpectedToken('ReservedSymbol', symbolName, token);
        }
    }
    function asReservedSymbolToken(token, symbolName) {
        assertReservedSymbolToken(token, symbolName);
        return token;
    }
    function isShebangToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'Shebang';
    }
    function isSingleLineCommentToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'SingleLineComment';
    }
    function isMultiLineCommentToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'MultiLineComment';
    }
    function isOperatorToken(token, operatorName) {
        if ((token === null || token === void 0 ? void 0 : token[0]) !== 'Operator') {
            return false;
        }
        if (operatorName && token[1] !== operatorName) {
            return false;
        }
        return true;
    }
    function assertOperatorToken(token, operatorName) {
        if (!isOperatorToken(token, operatorName)) {
            throwUnexpectedToken('Operator', operatorName, token);
        }
    }
    function isWhitespaceToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'Whitespace';
    }
    function isLParenToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'LParen';
    }
    function assertLParenToken(token) {
        if (!isLParenToken(token)) {
            throwUnexpectedToken('LParen', undefined, token);
        }
    }
    function isRParenToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'RParen';
    }
    function assertRParenToken(token) {
        if (!isRParenToken(token)) {
            throwUnexpectedToken('RParen', undefined, token);
        }
    }
    function isLBracketToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'LBracket';
    }
    function assertLBracketToken(token) {
        if (!isLBracketToken(token)) {
            throwUnexpectedToken('LBracket', undefined, token);
        }
    }
    function asLBracketToken(token) {
        assertLBracketToken(token);
        return token;
    }
    function isRBracketToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'RBracket';
    }
    function assertRBracketToken(token) {
        if (!isRBracketToken(token)) {
            throwUnexpectedToken('RBracket', undefined, token);
        }
    }
    function isLBraceToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'LBrace';
    }
    function assertLBraceToken(token) {
        if (!isLBraceToken(token)) {
            throwUnexpectedToken('LBrace', undefined, token);
        }
    }
    function asLBraceToken(token) {
        assertLBraceToken(token);
        return token;
    }
    function isRBraceToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'RBrace';
    }
    function assertRBraceToken(token) {
        if (!isRBraceToken(token)) {
            throwUnexpectedToken('RBrace', undefined, token);
        }
    }
    function isStringToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'String';
    }
    function isDocStringToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'DocString';
    }
    function isA_BinaryOperatorToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'Operator' && isBinaryOperator(token[1]);
    }
    function throwUnexpectedToken(expected, expectedValue, actual) {
        var actualOutput = actual ? "".concat(actual[0], " '").concat(actual[1], "'") : 'end of input';
        throw new LitsError("Unexpected token: ".concat(actualOutput, ", expected ").concat(expected).concat(expectedValue ? " '".concat(expectedValue, "'") : ''), actual === null || actual === void 0 ? void 0 : actual[2]);
    }

    function minifyTokenStream(tokenStream, _a) {
        var removeWhiteSpace = _a.removeWhiteSpace;
        var tokens = tokenStream.tokens
            .filter(function (token) {
            if (isSingleLineCommentToken(token)
                || isMultiLineCommentToken(token)
                || isShebangToken(token)
                || (removeWhiteSpace && isWhitespaceToken(token))) {
                return false;
            }
            return true;
        });
        return __assign(__assign({}, tokenStream), { tokens: tokens });
    }

    function transformSymbolTokens(tokenStram, transformer) {
        return __assign(__assign({}, tokenStram), { tokens: tokenStram.tokens.map(function (token) { return isSymbolToken(token)
                ? [token[0], transformer(token[1])]
                : token; }) });
    }

    function untokenize(tokenStream) {
        return tokenStream.tokens.reduce(function (acc, token) {
            return "".concat(acc).concat(token[1]);
        }, '');
    }

    // Reverse lookup tables for getting symbol names from builtin types
    var normalExpressionNames = Object.entries(normalExpressionTypes).reduce(function (acc, _a) {
        var _b = __read(_a, 2), name = _b[0], index = _b[1];
        acc[index] = name;
        return acc;
    }, []);
    var specialExpressionNames = Object.entries(specialExpressionTypes).reduce(function (acc, _a) {
        var _b = __read(_a, 2), name = _b[0], index = _b[1];
        acc[index] = name;
        return acc;
    }, []);
    /**
     * Extract the symbol name from any symbol node type.
     * UserDefinedSymbolNode: node[1] is the string name
     * NormalBuiltinSymbolNode: node[1] is an index, need reverse lookup
     * SpecialBuiltinSymbolNode: node[1] is an index, need reverse lookup
     */
    function getSymbolName(symbol) {
        if (isUserDefinedSymbolNode(symbol)) {
            return symbol[1];
        }
        if (isNormalBuiltinSymbolNode(symbol)) {
            return normalExpressionNames[symbol[1]];
        }
        // SpecialBuiltinSymbolNode
        return specialExpressionNames[symbol[1]];
    }
    var exponentiationPrecedence = 12;
    var binaryFunctionalOperatorPrecedence = 3;
    var conditionalOperatorPrecedence = 1;
    var placeholderRegexp = /^\$([1-9]\d?)?$/;
    function withSourceCodeInfo(node, sourceCodeInfo) {
        if (sourceCodeInfo) {
            node[2] = sourceCodeInfo;
        }
        return node;
    }
    function getPrecedence(operatorSign, sourceCodeInfo) {
        switch (operatorSign) {
            case '^': // exponentiation
                return exponentiationPrecedence;
            case '*': // multiplication
            case '/': // division
            case '%': // remainder
                return 11;
            case '+': // addition
            case '-': // subtraction
                return 10;
            case '<<': // left shift
            case '>>': // signed right shift
            case '>>>': // unsigned right shift
                return 9;
            case '++': // string concatenation
                return 8;
            case '<': // less than
            case '<=': // less than or equal
            case '≤': // less than or equal
            case '>': // greater than
            case '>=': // greater than or equal
            case '≥': // greater than or equal
                return 7;
            case '==': // equal
            case '!=': // not equal
            case '≠': // not equal
                return 6;
            case '&': // bitwise AND
            case 'xor': // bitwise XOR
            case '|': // bitwise OR
                return 5;
            case '&&': // logical AND
            case '||': // logical OR
            case '??': // nullish coalescing
                return 4;
            // leave room for binaryFunctionalOperatorPrecedence = 3
            case '|>': // pipe
                return 2;
            // leave room for conditionalOperatorPrecedence = 1
            /* v8 ignore next 2 */
            default:
                throw new LitsError("Unknown binary operator: ".concat(operatorSign), sourceCodeInfo);
        }
    }
    function createNamedNormalExpressionNode(symbolNode, params, sourceCodeInfo) {
        var node = withSourceCodeInfo([NodeTypes.NormalExpression, [symbolNode, params]], sourceCodeInfo);
        if (isNormalBuiltinSymbolNode(symbolNode)) {
            assertNumberOfParams(allNormalExpressions[symbolNode[1]].arity, node[1][1].length, sourceCodeInfo);
        }
        return node;
    }
    function createAccessorNode(left, right, sourceCodeInfo) {
        return withSourceCodeInfo([NodeTypes.NormalExpression, [[NodeTypes.NormalBuiltinSymbol, normalExpressionTypes.get], [left, right]]], sourceCodeInfo);
    }
    function fromBinaryOperatorToNode(operator, symbolNode, left, right, sourceCodeInfo) {
        var operatorName = operator[1];
        switch (operatorName) {
            case '^': // exponentiation
            case '*':
            case '/':
            case '%':
            case '+':
            case '-':
            case '<<':
            case '>>':
            case '>>>':
            case '++':
            case '<':
            case '<=':
            case '≤':
            case '>':
            case '>=':
            case '≥':
            case '==':
            case '!=':
            case '≠':
            case '&':
            case 'xor':
            case '|':
            case '|>':
                return createNamedNormalExpressionNode(symbolNode, [left, right], sourceCodeInfo);
            case '&&':
            case '||':
            case '??':
                return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes[operatorName], [left, right]]], sourceCodeInfo);
            /* v8 ignore next 11 */
            case '.':
            case ';':
            case ':':
            case '=':
            case ',':
            case '->':
            case '...':
            case '?':
                throw new LitsError("Unknown binary operator: ".concat(operatorName), sourceCodeInfo);
            default:
                throw new LitsError("Unknown binary operator: ".concat(operatorName), sourceCodeInfo);
        }
    }
    var Parser = /** @class */ (function () {
        function Parser(tokenStream, parseState) {
            this.tokenStream = tokenStream;
            this.parseState = parseState;
        }
        Parser.prototype.peek = function () {
            return this.tokenStream.tokens[this.parseState.position];
        };
        Parser.prototype.peekSourceCodeInfo = function () {
            var _a;
            var currentToken = this.peek();
            return currentToken ? currentToken[2] : (_a = this.tokenStream.tokens.at(-1)) === null || _a === void 0 ? void 0 : _a[2];
        };
        Parser.prototype.peekAhead = function (count) {
            return this.tokenStream.tokens[this.parseState.position + count];
        };
        Parser.prototype.advance = function () {
            this.parseState.position += 1;
        };
        Parser.prototype.parse = function () {
            this.tokenStream.tokens.forEach(function (token) {
                if (token[0] === 'Error') {
                    throw new LitsError(token[3], token[2]);
                }
            });
            var nodes = [];
            while (!this.isAtEnd()) {
                nodes.push(this.parseExpression(0, true));
                if (isOperatorToken(this.peek(), ';')) {
                    this.advance();
                }
                else {
                    if (!this.isAtEnd()) {
                        throw new LitsError('Expected ;', this.peekSourceCodeInfo());
                    }
                }
            }
            return nodes;
        };
        Parser.prototype.parseExpression = function (precedence, moduleScope) {
            if (precedence === void 0) { precedence = 0; }
            if (moduleScope === void 0) { moduleScope = false; }
            var firstToken = this.peek();
            var left;
            if (isSymbolToken(firstToken)) {
                switch (firstToken[1]) {
                    case 'let':
                        return this.parseLet(firstToken);
                    case 'if':
                    case 'unless':
                        left = this.parseIfOrUnless(firstToken);
                        break;
                    case 'cond':
                        left = this.parseCond(firstToken);
                        break;
                    case 'switch':
                        left = this.parseSwitch(firstToken);
                        break;
                    case 'for':
                    case 'doseq':
                        left = this.parseForOrDoseq(firstToken);
                        break;
                    case 'loop':
                        left = this.parseLoop(firstToken);
                        break;
                    case 'try':
                        left = this.parseTry(firstToken);
                        break;
                }
            }
            else if (isReservedSymbolToken(firstToken, 'export')) {
                if (!moduleScope) {
                    throw new LitsError('export is only allowed in module scope', firstToken[2]);
                }
                return this.parseExport(firstToken);
            }
            left || (left = this.parseOperand());
            var operator = this.peek();
            while (!this.isAtExpressionEnd()) {
                if (isA_BinaryOperatorToken(operator)) {
                    var name_1 = operator[1];
                    var newPrecedece = getPrecedence(name_1, operator[2]);
                    if (newPrecedece <= precedence
                        // ^ (exponentiation) is right associative
                        && !(newPrecedece === exponentiationPrecedence && precedence === exponentiationPrecedence)) {
                        break;
                    }
                    var symbol = specialExpressionTypes[name_1]
                        ? withSourceCodeInfo([NodeTypes.SpecialBuiltinSymbol, specialExpressionTypes[name_1]], operator[2])
                        : withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol, normalExpressionTypes[name_1]], operator[2]);
                    this.advance();
                    var right = this.parseExpression(newPrecedece);
                    left = fromBinaryOperatorToNode(operator, symbol, left, right, operator[2]);
                }
                else if (isSymbolToken(operator)) {
                    if (!isFunctionOperator(operator[1])) {
                        break;
                    }
                    var newPrecedece = binaryFunctionalOperatorPrecedence;
                    if (newPrecedece <= precedence) {
                        break;
                    }
                    var operatorSymbol = this.parseSymbol();
                    var right = this.parseExpression(newPrecedece);
                    if (isSpecialBuiltinSymbolNode(operatorSymbol)) {
                        throw new LitsError('Special expressions are not allowed in binary functional operators', operatorSymbol[2]);
                    }
                    left = createNamedNormalExpressionNode(operatorSymbol, [left, right], operator[2]);
                }
                else if ((operator === null || operator === void 0 ? void 0 : operator[1]) === '?') {
                    if (conditionalOperatorPrecedence <= precedence) {
                        break;
                    }
                    this.advance();
                    var trueNode = this.parseExpression();
                    if (!isOperatorToken(this.peek(), ':')) {
                        throw new LitsError('Expected :', this.peekSourceCodeInfo());
                    }
                    this.advance();
                    var falseNode = this.parseExpression();
                    left = withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.if, [left, trueNode, falseNode]]], left[2]);
                }
                else {
                    break;
                }
                operator = this.peek();
            }
            return left;
        };
        Parser.prototype.asToken = function (token) {
            if (!token) {
                throw new LitsError('Unexpected end of input', this.peekSourceCodeInfo());
            }
            return token;
        };
        Parser.prototype.parseOperand = function () {
            var operand = this.parseOperandPart();
            var token = this.peek();
            while (isOperatorToken(token, '.') || isLBracketToken(token) || isLParenToken(token)) {
                if (token[1] === '.') {
                    this.advance();
                    var symbolToken = this.asToken(this.peek());
                    if (!isSymbolToken(symbolToken)) {
                        throw new LitsError('Expected symbol', this.peekSourceCodeInfo());
                    }
                    var stringNode = withSourceCodeInfo([NodeTypes.String, symbolToken[1]], symbolToken[2]);
                    operand = createAccessorNode(operand, stringNode, token[2]);
                    this.advance();
                    token = this.peek();
                }
                else if (isLBracketToken(token)) {
                    this.advance();
                    var expression = this.parseExpression();
                    if (!isRBracketToken(this.peek())) {
                        throw new LitsError('Expected closing bracket', this.peekSourceCodeInfo());
                    }
                    operand = createAccessorNode(operand, expression, token[2]);
                    this.advance();
                    token = this.peek();
                }
                else if (isLParenToken(token)) {
                    operand = this.parseFunctionCall(operand);
                    token = this.peek();
                }
            }
            return operand;
        };
        Parser.prototype.parseOperandPart = function () {
            var token = this.asToken(this.peek());
            // Parentheses
            if (isLParenToken(token)) {
                var positionBefore = this.parseState.position;
                var lamdaFunction = this.parseLambdaFunction();
                if (lamdaFunction) {
                    return lamdaFunction;
                }
                this.parseState.position = positionBefore;
                this.advance();
                var expression = this.parseExpression();
                if (!isRParenToken(this.peek())) {
                    throw new LitsError('Expected closing parenthesis', this.peekSourceCodeInfo());
                }
                this.advance();
                return expression;
            }
            else if (isOperatorToken(token)) {
                var operatorName = token[1];
                if (isBinaryOperator(operatorName)) {
                    this.advance();
                    if (specialExpressionTypes[operatorName] !== undefined) {
                        return withSourceCodeInfo([NodeTypes.SpecialBuiltinSymbol, specialExpressionTypes[operatorName]], token[2]);
                    }
                    return withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol, normalExpressionTypes[operatorName]], token[2]);
                }
                if (operatorName === '->') {
                    return this.parseShorthandLamdaFunction();
                }
                else {
                    throw new LitsError("Illegal operator: ".concat(operatorName), token[2]);
                }
            }
            // Object litteral, e.g. {a: 1, b: 2}
            // Or block.
            if (isLBraceToken(token)) {
                var positionBefore = this.parseState.position;
                try {
                    return this.parseObject();
                }
                catch (_a) {
                    this.parseState.position = positionBefore;
                    return this.parseBlock()[0];
                }
            }
            // Array litteral, e.g. [1, 2]
            if (isLBracketToken(token)) {
                return this.parseArray();
            }
            var tokenType = token[0];
            switch (tokenType) {
                case 'Number':
                case 'BasePrefixedNumber':
                    return this.parseNumber();
                case 'String':
                    return this.parseString(token);
                case 'Symbol': {
                    var positionBefore = this.parseState.position;
                    var lamdaFunction = this.parseLambdaFunction();
                    if (lamdaFunction) {
                        return lamdaFunction;
                    }
                    this.parseState.position = positionBefore;
                    return this.parseSymbol();
                }
                case 'ReservedSymbol':
                    return this.parseReservedSymbol();
                case 'RegexpShorthand':
                    return this.parseRegexpShorthand();
                default:
                    throw new LitsError("Unknown token type: ".concat(tokenType), token[2]);
            }
        };
        Parser.prototype.parseObject = function () {
            var firstToken = asLBraceToken(this.peek());
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isRBraceToken(this.peek())) {
                if (isOperatorToken(this.peek(), '...')) {
                    this.advance();
                    params.push(withSourceCodeInfo([NodeTypes.Spread, this.parseExpression()], this.peekSourceCodeInfo()));
                }
                else {
                    var token = this.peek();
                    if (isStringToken(token)) {
                        var stringNode = this.parseString(token);
                        params.push(withSourceCodeInfo([NodeTypes.String, stringNode[1]], token[2]));
                    }
                    else if (isSymbolToken(token)) {
                        var value = token[1].startsWith('\'')
                            ? this.stringFromQuotedSymbol(token[1])
                            : token[1];
                        params.push(withSourceCodeInfo([NodeTypes.String, value], token[2]));
                        this.advance();
                    }
                    else if (isLBracketToken(token)) {
                        this.advance();
                        params.push(this.parseExpression());
                        assertRBracketToken(this.peek());
                        this.advance();
                    }
                    else {
                        throw new LitsError('Expected key to be a symbol or a string', this.peekSourceCodeInfo());
                    }
                    assertOperatorToken(this.peek(), ':');
                    this.advance();
                    params.push(this.parseExpression());
                }
                var nextToken = this.peek();
                if (!isOperatorToken(nextToken, ',') && !isRBraceToken(nextToken)) {
                    throw new LitsError('Expected comma or closing brace', this.peekSourceCodeInfo());
                }
                if (isOperatorToken(nextToken, ',')) {
                    this.advance();
                }
            }
            assertRBraceToken(this.peek());
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.object, params]], firstToken[2]);
        };
        Parser.prototype.parseArray = function () {
            var firstToken = asLBracketToken(this.peek());
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isRBracketToken(this.peek())) {
                if (isOperatorToken(this.peek(), '...')) {
                    this.advance();
                    params.push(withSourceCodeInfo([NodeTypes.Spread, this.parseExpression()], this.peekSourceCodeInfo()));
                }
                else {
                    params.push(this.parseExpression());
                }
                var nextToken = this.peek();
                if (!isOperatorToken(nextToken, ',') && !isRBracketToken(nextToken)) {
                    throw new LitsError('Expected comma or closing parenthesis', this.peekSourceCodeInfo());
                }
                if (isOperatorToken(nextToken, ',')) {
                    this.advance();
                }
            }
            assertRBracketToken(this.peek());
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.array, params]], firstToken[2]);
        };
        Parser.prototype.parseFunctionCall = function (symbol) {
            var _a;
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isRParenToken(this.peek())) {
                if (isOperatorToken(this.peek(), '...')) {
                    this.advance();
                    params.push(withSourceCodeInfo([NodeTypes.Spread, this.parseExpression()], this.peekSourceCodeInfo()));
                }
                else {
                    params.push(this.parseExpression());
                }
                var nextToken = this.peek();
                if (!isOperatorToken(nextToken, ',') && !isRParenToken(nextToken)) {
                    throw new LitsError('Expected comma or closing parenthesis', (_a = this.peek()) === null || _a === void 0 ? void 0 : _a[2]);
                }
                if (isOperatorToken(nextToken, ',')) {
                    this.advance();
                }
            }
            if (!isRParenToken(this.peek())) {
                throw new LitsError('Expected closing parenthesis', this.peekSourceCodeInfo());
            }
            this.advance();
            if (isSpecialBuiltinSymbolNode(symbol)) { // Named function
                var specialExpressionType = symbol[1];
                var type = specialExpressionType;
                var specialExpression = builtin.specialExpressions[type];
                assertNumberOfParams(specialExpression.arity, params.length, symbol[2]);
                switch (type) {
                    case specialExpressionTypes['||']:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes['&&']:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes.recur:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes.array:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes.object:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes['??']: {
                        if (params.length === 1) {
                            return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, [params[0], undefined]]], symbol[2]);
                        }
                        else {
                            return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, [params[0], params[1]]]], symbol[2]);
                        }
                    }
                    case specialExpressionTypes['defined?']: {
                        var _b = __read(params, 1), param = _b[0];
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, param]], symbol[2]);
                    }
                    case specialExpressionTypes.throw: {
                        var _c = __read(params, 1), param = _c[0];
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, param]], symbol[2]);
                    }
                    case specialExpressionTypes['0_lambda']:
                    case specialExpressionTypes['0_def']:
                        throw new LitsError("".concat(type, " is not allowed"), symbol[2]);
                    /* v8 ignore next 2 */
                    default:
                        throw new LitsError("Unknown special expression: ".concat(type), symbol[2]);
                }
            }
            else if (isNormalBuiltinSymbolNode(symbol) || isNormalBuiltinSymbolNode(symbol)) {
                return createNamedNormalExpressionNode(symbol, params, symbol[2]);
            }
            else {
                return withSourceCodeInfo([NodeTypes.NormalExpression, [symbol, params]], symbol[2]);
            }
        };
        Parser.prototype.parseLambdaFunction = function () {
            var firstToken = this.asToken(this.peek());
            if (isLParenToken(firstToken)
                && isSymbolToken(this.peekAhead(1))
                && isOperatorToken(this.peekAhead(2), '->')) {
                return null;
            }
            try {
                var functionArguments = this.parseFunctionArguments();
                if (!isOperatorToken(this.peek(), '->')) {
                    return null;
                }
                this.advance();
                var nodes = void 0;
                var docString = '';
                if (isLBraceToken(this.peek())) {
                    var positionBefore = this.parseState.position;
                    try {
                        var objectNode = this.parseObject();
                        nodes = [objectNode];
                    }
                    catch (_a) {
                        this.parseState.position = positionBefore;
                        var parsedBlock = this.parseBlock(true);
                        docString = parsedBlock[1];
                        nodes = parsedBlock[0][1][1];
                    }
                }
                else {
                    nodes = [this.parseExpression()];
                }
                return withSourceCodeInfo([
                    NodeTypes.SpecialExpression,
                    [
                        specialExpressionTypes['0_lambda'],
                        [
                            functionArguments,
                            nodes,
                        ],
                        docString,
                    ],
                ], firstToken[2]);
            }
            catch (_b) {
                return null;
            }
        };
        Parser.prototype.parseFunctionArguments = function () {
            var firstToken = this.peek();
            if (isSymbolToken(firstToken)) {
                return [withSourceCodeInfo([bindingTargetTypes.symbol, [this.parseSymbol(), undefined]], firstToken[2])];
            }
            assertLParenToken(firstToken);
            this.advance();
            var rest = false;
            var defaults = false;
            var functionArguments = [];
            while (!this.isAtEnd() && !isRParenToken(this.peek()) && !isSymbolToken(this.peek(), 'let')) {
                if (rest) {
                    throw new LitsError('Rest argument must be last', this.peekSourceCodeInfo());
                }
                var bindingTarget = this.parseBindingTarget();
                if (bindingTarget[1][1] !== undefined) {
                    defaults = true;
                }
                if (bindingTarget[0] === bindingTargetTypes.rest) {
                    rest = true;
                }
                if (defaults && !bindingTarget[1][1]) {
                    throw new LitsError('Default arguments must be last', this.peekSourceCodeInfo());
                }
                functionArguments.push(bindingTarget);
                if (!isOperatorToken(this.peek(), ',') && !isRParenToken(this.peek()) && !isSymbolToken(this.peek(), 'let')) {
                    throw new LitsError('Expected comma or closing parenthesis', this.peekSourceCodeInfo());
                }
                if (isOperatorToken(this.peek(), ',')) {
                    this.advance();
                }
            }
            if (!isRParenToken(this.peek())) {
                throw new LitsError('Expected closing parenthesis', this.peekSourceCodeInfo());
            }
            this.advance();
            return functionArguments;
        };
        Parser.prototype.parseShorthandLamdaFunction = function () {
            var _a;
            var firstToken = this.asToken(this.peek());
            this.advance();
            var startPos = this.parseState.position;
            var nodes;
            var docString = '';
            if (isLBraceToken(this.peek())) {
                var positionBefore = this.parseState.position;
                try {
                    var objectNode = this.parseObject();
                    nodes = [objectNode];
                }
                catch (_b) {
                    this.parseState.position = positionBefore;
                    var parsedBlock = this.parseBlock(true);
                    docString = parsedBlock[1];
                    nodes = parsedBlock[0][1][1];
                }
            }
            else {
                nodes = [this.parseExpression()];
            }
            var endPos = this.parseState.position - 1;
            var arity = 0;
            var dollar1 = 'NOT_SET'; // referring to argument bindings. $ = NAKED, $1, $2, $3, etc = WITH_1
            for (var pos = startPos; pos <= endPos; pos += 1) {
                var token = this.tokenStream.tokens[pos];
                if (isSymbolToken(token)) {
                    var match = placeholderRegexp.exec(token[1]);
                    if (match) {
                        var number = (_a = match[1]) !== null && _a !== void 0 ? _a : '1';
                        if (number === '1') {
                            var mixedPercent1 = (!match[1] && dollar1 === 'WITH_1') || (match[1] && dollar1 === 'NAKED');
                            if (mixedPercent1)
                                throw new LitsError('Please make up your mind, either use $ or $1', firstToken[2]);
                            dollar1 = match[1] ? 'WITH_1' : 'NAKED';
                        }
                        arity = Math.max(arity, Number(number));
                        if (arity > 20)
                            throw new LitsError('Can\'t specify more than 20 arguments', firstToken[2]);
                    }
                }
            }
            var functionArguments = [];
            for (var i = 1; i <= arity; i += 1) {
                if (i === 1 && dollar1 === 'NAKED') {
                    functionArguments.push(withSourceCodeInfo([bindingTargetTypes.symbol, [[NodeTypes.UserDefinedSymbol, '$'], undefined]], firstToken[2]));
                }
                else {
                    functionArguments.push(withSourceCodeInfo([bindingTargetTypes.symbol, [[NodeTypes.UserDefinedSymbol, "$".concat(i)], undefined]], firstToken[2]));
                }
            }
            var node = withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes['0_lambda'], [
                        functionArguments,
                        nodes,
                    ], docString]], firstToken[2]);
            return node;
        };
        Parser.prototype.parseOptionalDefaulValue = function () {
            if (isOperatorToken(this.peek(), '=')) {
                this.advance();
                return this.parseExpression();
            }
            return undefined;
        };
        Parser.prototype.parseBindingTarget = function (_a) {
            var _b = _a === void 0 ? {} : _a, requireDefaultValue = _b.requireDefaultValue, noRest = _b.noRest;
            var firstToken = this.peek();
            // Symbol
            if (isSymbolToken(firstToken)) {
                var symbol = this.parseSymbol();
                if (!isUserDefinedSymbolNode(symbol)) {
                    throw new LitsError('Expected user defined symbol', firstToken[2]);
                }
                var defaultValue = this.parseOptionalDefaulValue();
                if (requireDefaultValue && !defaultValue) {
                    throw new LitsError('Expected assignment', this.peekSourceCodeInfo());
                }
                return withSourceCodeInfo([bindingTargetTypes.symbol, [symbol, defaultValue]], firstToken[2]);
            }
            // Rest
            if (isOperatorToken(firstToken, '...')) {
                if (noRest) {
                    throw new LitsError('Rest element not allowed', firstToken[2]);
                }
                this.advance();
                var symbol = asUserDefinedSymbolNode(this.parseSymbol());
                if (isOperatorToken(this.peek(), '=')) {
                    throw new LitsError('Rest argument can not have default value', this.peekSourceCodeInfo());
                }
                return withSourceCodeInfo([bindingTargetTypes.rest, [symbol[1], undefined]], firstToken[2]);
            }
            // Array
            if (isLBracketToken(firstToken)) {
                this.advance();
                var elements = [];
                var token = this.asToken(this.peek());
                var rest = false;
                while (!isRBracketToken(token)) {
                    if (rest) {
                        throw new LitsError('Rest argument must be last', token[2]);
                    }
                    if (isOperatorToken(token, ',')) {
                        elements.push(null);
                        this.advance();
                        token = this.asToken(this.peek());
                        continue;
                    }
                    var target = this.parseBindingTarget();
                    if (target[0] === bindingTargetTypes.rest) {
                        rest = true;
                    }
                    elements.push(target);
                    token = this.asToken(this.peek());
                    if (!isRBracketToken(token)) {
                        assertOperatorToken(token, ',');
                        this.advance();
                    }
                    token = this.asToken(this.peek());
                }
                this.advance();
                var defaultValue = this.parseOptionalDefaulValue();
                if (requireDefaultValue && !defaultValue) {
                    throw new LitsError('Expected assignment', this.peekSourceCodeInfo());
                }
                return withSourceCodeInfo([bindingTargetTypes.array, [elements, defaultValue]], firstToken[2]);
            }
            // Object
            if (isLBraceToken(firstToken)) {
                this.advance();
                var elements = {};
                var token = this.asToken(this.peek());
                var rest = false;
                while (!isRBraceToken(token)) {
                    if (rest) {
                        throw new LitsError('Rest argument must be last', token[2]);
                    }
                    if (isOperatorToken(token, '...')) {
                        rest = true;
                        this.advance();
                    }
                    // Parse the key symbol - can be any symbol type (including builtins) when using 'as' alias
                    var keySymbol = this.parseSymbol();
                    var keyName = getSymbolName(keySymbol);
                    token = this.asToken(this.peek());
                    if (isReservedSymbolToken(token, 'as')) {
                        if (rest) {
                            throw new LitsError('Rest argument can not have alias', token[2]);
                        }
                        this.advance();
                        var name_2 = asUserDefinedSymbolNode(this.parseSymbol());
                        if (elements[name_2[1]]) {
                            throw new LitsError("Duplicate binding name: ".concat(name_2), token[2]);
                        }
                        elements[keyName] = withSourceCodeInfo([bindingTargetTypes.symbol, [name_2, this.parseOptionalDefaulValue()]], firstToken[2]);
                    }
                    else if (isRBraceToken(token) || isOperatorToken(token, ',') || isOperatorToken(token, '=')) {
                        // Without 'as' alias, the key becomes the binding name - must be user-defined symbol
                        var key = asUserDefinedSymbolNode(keySymbol, keySymbol[2]);
                        if (elements[key[1]]) {
                            throw new LitsError("Duplicate binding name: ".concat(key), token[2]);
                        }
                        if (rest && isOperatorToken(this.peek(), '=')) {
                            throw new LitsError('Rest argument can not have default value', this.peekSourceCodeInfo());
                        }
                        elements[key[1]] = rest
                            ? withSourceCodeInfo([bindingTargetTypes.rest, [key[1], this.parseOptionalDefaulValue()]], firstToken[2])
                            : withSourceCodeInfo([bindingTargetTypes.symbol, [key, this.parseOptionalDefaulValue()]], firstToken[2]);
                    }
                    else if (isOperatorToken(token, ':')) {
                        this.advance();
                        token = this.asToken(this.peek());
                        if (!isLBraceToken(token) && !isLBracketToken(token)) {
                            throw new LitsError('Expected object or array', token[2]);
                        }
                        elements[keyName] = this.parseBindingTarget();
                    }
                    if (!isRBraceToken(this.peek())) {
                        assertOperatorToken(this.peek(), ',');
                        this.advance();
                    }
                    token = this.asToken(this.peek());
                }
                this.advance();
                token = this.asToken(this.peek());
                var defaultValue = this.parseOptionalDefaulValue();
                if (requireDefaultValue && !defaultValue) {
                    throw new LitsError('Expected assignment', token[2]);
                }
                return withSourceCodeInfo([bindingTargetTypes.object, [elements, defaultValue]], firstToken[2]);
            }
            throw new LitsError('Expected symbol', this.peekSourceCodeInfo());
        };
        Parser.prototype.parseLet = function (token) {
            this.advance();
            var target = this.parseBindingTarget({ requireDefaultValue: true, noRest: true });
            var value = target[1][1];
            target[1][1] = undefined;
            var bindingTarget = withSourceCodeInfo([NodeTypes.Binding, [target, value]], token[2]);
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.let, bindingTarget]], token[2]);
        };
        Parser.prototype.parseBlock = function (allowDocString) {
            if (allowDocString === void 0) { allowDocString = false; }
            var token = asLBraceToken(this.peek());
            this.advance();
            var docString = '';
            if (allowDocString && isDocStringToken(this.peek())) {
                docString = this.parseDocString();
            }
            var expressions = [];
            while (!this.isAtEnd() && !isRBraceToken(this.peek())) {
                expressions.push(this.parseExpression());
                if (isOperatorToken(this.peek(), ';')) {
                    this.advance();
                }
                else if (!isRBraceToken(this.peek())) {
                    throw new LitsError('Expected }', this.peekSourceCodeInfo());
                }
            }
            assertRBraceToken(this.peek());
            this.advance();
            return [
                withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.block, expressions]], token[2]),
                docString,
            ];
        };
        Parser.prototype.parseImplicitBlock = function (ends) {
            var nodes = [];
            while (!this.isAtEnd() && !this.isImplicitBlockEnd(ends)) {
                if (isOperatorToken(this.peek(), ';')) {
                    this.advance();
                }
                else {
                    nodes.push(this.parseExpression());
                }
            }
            this.assertImplicitBlockEnd(ends);
            if (nodes.length === 0) {
                throw new LitsError('Expected expression', this.peekSourceCodeInfo());
            }
            return nodes.length === 1
                ? nodes[0]
                : withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.block, nodes]], this.peekSourceCodeInfo());
        };
        Parser.prototype.assertImplicitBlockEnd = function (ends) {
            if (!this.isImplicitBlockEnd(ends)) {
                throw new LitsError("Expected ".concat(ends.map(function (e) { return e[1]; }).join(' or ')), this.peekSourceCodeInfo());
            }
        };
        Parser.prototype.isImplicitBlockEnd = function (ends) {
            var e_1, _a;
            try {
                for (var ends_1 = __values(ends), ends_1_1 = ends_1.next(); !ends_1_1.done; ends_1_1 = ends_1.next()) {
                    var end = ends_1_1.value;
                    if (isReservedSymbolToken(this.peek(), end)) {
                        return true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (ends_1_1 && !ends_1_1.done && (_a = ends_1.return)) _a.call(ends_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        };
        Parser.prototype.parseLoop = function (firstToken) {
            this.advance();
            assertLParenToken(this.peek());
            this.advance();
            var bindingNodes = [];
            var token = this.peek();
            while (!this.isAtEnd() && !isRParenToken(token)) {
                var target = this.parseBindingTarget({ requireDefaultValue: true, noRest: true });
                var value = target[1][1];
                target[1][1] = undefined;
                bindingNodes.push(withSourceCodeInfo([NodeTypes.Binding, [target, value]], target[2]));
                if (isOperatorToken(this.peek(), ',')) {
                    this.advance();
                }
                token = this.peek();
            }
            if (bindingNodes.length === 0) {
                throw new LitsError('Expected binding', this.peekSourceCodeInfo());
            }
            assertRParenToken(token);
            this.advance();
            assertOperatorToken(this.peek(), '->');
            this.advance();
            var expression = this.parseExpression();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.loop, bindingNodes, expression]], firstToken[2]);
        };
        Parser.prototype.parseTry = function (token) {
            this.advance();
            var tryExpression = this.parseImplicitBlock(['catch']);
            this.advance();
            var errorSymbol;
            if (isLParenToken(this.peek())) {
                this.advance();
                errorSymbol = this.parseSymbol();
                assertRParenToken(this.peek());
                this.advance();
            }
            var catchExpression = this.parseImplicitBlock(['end']);
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.try, tryExpression, errorSymbol, catchExpression]], token[2]);
        };
        Parser.prototype.parseForOrDoseq = function (firstToken) {
            var isDoseq = firstToken[1] === 'doseq';
            this.advance();
            assertLParenToken(this.peek());
            this.advance();
            var forLoopBindings = [];
            var _loop_1 = function () {
                var loopBinding = this_1.parseForLoopBinding();
                var existingBoundNames = forLoopBindings.flatMap(function (b) { return Object.keys(getAllBindingTargetNames(b[0][1][0])); });
                var newBoundNames = getAllBindingTargetNames(loopBinding[0][1][0]);
                if (Object.keys(newBoundNames).some(function (n) { return existingBoundNames.includes(n); })) {
                    throw new LitsError('Duplicate binding', loopBinding[0][2]);
                }
                forLoopBindings.push(loopBinding);
                if (isOperatorToken(this_1.peek(), ',')) {
                    this_1.advance();
                }
            };
            var this_1 = this;
            while (!this.isAtEnd() && !isRParenToken(this.peek())) {
                _loop_1();
            }
            assertRParenToken(this.peek());
            this.advance();
            assertOperatorToken(this.peek(), '->');
            this.advance();
            var expression = this.parseExpression();
            return isDoseq
                ? withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.doseq, forLoopBindings, expression]], firstToken[2])
                : withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.for, forLoopBindings, expression]], firstToken[2]);
        };
        Parser.prototype.parseForLoopBinding = function () {
            var bindingNode = this.parseBinding();
            var modifiers = [];
            var token = this.asToken(this.peek());
            this.assertInternalLoopBindingDelimiter(token, ['let', 'when', 'while']);
            var letBindings = [];
            if (token[1] === 'let') {
                modifiers.push('&let');
                var _loop_2 = function () {
                    var letNode = this_2.parseLet(token);
                    var existingBoundNames = letBindings.flatMap(function (b) { return Object.keys(getAllBindingTargetNames(b[1][0])); });
                    var newBoundNames = Object.keys(getAllBindingTargetNames(letNode[1][1][1][0]));
                    if (newBoundNames.some(function (n) { return existingBoundNames.includes(n); })) {
                        throw new LitsError('Duplicate binding', letNode[1][1][2]);
                    }
                    letBindings.push(letNode[1][1]);
                    token = this_2.asToken(this_2.peek());
                    this_2.assertInternalLoopBindingDelimiter(token, ['let', 'when', 'while']);
                    token = this_2.asToken(this_2.peek());
                };
                var this_2 = this;
                while (isSymbolToken(token, 'let')) {
                    _loop_2();
                }
            }
            var whenNode;
            var whileNode;
            while (isReservedSymbolToken(token, 'when')
                || isReservedSymbolToken(token, 'while')) {
                this.advance();
                if (token[1] === 'when') {
                    modifiers.push('&when');
                    whenNode = this.parseExpression();
                }
                else {
                    modifiers.push('&while');
                    whileNode = this.parseExpression();
                }
                token = this.asToken(this.peek());
                var symbols = modifiers.includes('&when') && modifiers.includes('&while')
                    ? []
                    : modifiers.includes('&when')
                        ? ['while']
                        : ['when'];
                this.assertInternalLoopBindingDelimiter(token, symbols);
                token = this.asToken(this.peek());
            }
            this.assertInternalLoopBindingDelimiter(token, []);
            return [bindingNode, letBindings, whenNode, whileNode];
        };
        Parser.prototype.assertInternalLoopBindingDelimiter = function (token, symbols) {
            if (!this.isInternalLoopBindingDelimiter(token, symbols)) {
                var symbolsString = "".concat(__spreadArray(__spreadArray([], __read(symbols), false), [','], false).map(function (symbol) { return "\"".concat(symbol, "\""); }).join(', '), " or \")\"");
                throw new LitsError("Expected symbol ".concat(symbolsString), token[2]);
            }
        };
        Parser.prototype.isInternalLoopBindingDelimiter = function (token, symbols) {
            var e_2, _a;
            // end of loop binding
            if (isOperatorToken(token, ',') || isRParenToken(token)) {
                return true;
            }
            try {
                for (var symbols_1 = __values(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {
                    var symbol = symbols_1_1.value;
                    if (symbol === 'let' && isSymbolToken(token, 'let')) {
                        return true;
                    }
                    if (['when', 'while'].includes(symbol) && isReservedSymbolToken(token, symbol)) {
                        return true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return false;
        };
        Parser.prototype.parseBinding = function () {
            var firstToken = asSymbolToken(this.peek());
            var name = asUserDefinedSymbolNode(this.parseSymbol());
            assertReservedSymbolToken(this.peek(), 'in');
            this.advance();
            var value = this.parseExpression();
            var node = withSourceCodeInfo([
                NodeTypes.Binding,
                [
                    withSourceCodeInfo([bindingTargetTypes.symbol, [name, undefined]], firstToken[2]),
                    value,
                ],
            ], firstToken[2]);
            return node;
        };
        Parser.prototype.parseIfOrUnless = function (token) {
            var isUnless = token[1] === 'unless';
            this.advance();
            var condition = this.parseExpression();
            assertReservedSymbolToken(this.peek(), 'then');
            this.advance();
            var thenExpression = this.parseImplicitBlock(['else', 'end']);
            var elseExpression;
            if (isReservedSymbolToken(this.peek(), 'else')) {
                this.advance();
                elseExpression = this.parseImplicitBlock(['end']);
            }
            this.advance();
            return isUnless
                ? withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.unless, [condition, thenExpression, elseExpression]]], token[2])
                : withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.if, [condition, thenExpression, elseExpression]]], token[2]);
        };
        Parser.prototype.parseCond = function (token) {
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isReservedSymbolToken(this.peek(), 'end')) {
                assertReservedSymbolToken(this.peek(), 'case');
                this.advance();
                var caseExpression = this.parseExpression();
                assertReservedSymbolToken(this.peek(), 'then');
                this.advance();
                var thenExpression = this.parseImplicitBlock(['case', 'end']);
                params.push([caseExpression, thenExpression]);
                if (isReservedSymbolToken(this.peek(), 'end')) {
                    break;
                }
            }
            assertReservedSymbolToken(this.peek());
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.cond, params]], token[2]);
        };
        Parser.prototype.parseSwitch = function (token) {
            this.advance();
            var valueExpression = this.parseExpression();
            var params = [];
            while (!this.isAtEnd() && !isReservedSymbolToken(this.peek(), 'end')) {
                assertReservedSymbolToken(this.peek(), 'case');
                this.advance();
                var caseExpression = this.parseExpression();
                assertReservedSymbolToken(this.peek(), 'then');
                this.advance();
                var thenExpression = this.parseImplicitBlock(['case', 'end']);
                params.push([caseExpression, thenExpression]);
                if (isReservedSymbolToken(this.peek(), 'end')) {
                    break;
                }
            }
            assertReservedSymbolToken(this.peek(), 'end');
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.switch, valueExpression, params]], token[2]);
        };
        Parser.prototype.isAtEnd = function () {
            return this.parseState.position >= this.tokenStream.tokens.length;
        };
        Parser.prototype.isAtExpressionEnd = function () {
            if (this.isAtEnd()) {
                return true;
            }
            var token = this.peek();
            if (isOperatorToken(token)) {
                return [';', ',', ':'].includes(token[1]);
            }
            if (isReservedSymbolToken(token)) {
                return ['else', 'when', 'while', 'case', 'catch', 'let', 'then'].includes(token[1]);
            }
            return false;
        };
        Parser.prototype.parseExport = function (exportToken) {
            this.advance();
            var token = this.peek();
            if (isSymbolToken(token, 'let')) {
                var letNode = this.parseLet(asSymbolToken(token));
                return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes['0_def'], letNode[1][1]]], exportToken[2]);
            }
            else {
                throw new LitsError('Expected let', this.peekSourceCodeInfo());
            }
        };
        Parser.prototype.stringToSymbolNode = function (value, sourceCodeInfo) {
            if (specialExpressionTypes[value] !== undefined && value !== 'fn' && value !== 'def' && value !== 'defn') {
                return withSourceCodeInfo([NodeTypes.SpecialBuiltinSymbol, specialExpressionTypes[value]], sourceCodeInfo);
            }
            if (normalExpressionTypes[value] !== undefined) {
                return withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol, normalExpressionTypes[value]], sourceCodeInfo);
            }
            return withSourceCodeInfo([NodeTypes.UserDefinedSymbol, value], sourceCodeInfo);
        };
        Parser.prototype.stringFromQuotedSymbol = function (value) {
            return value.substring(1, value.length - 1)
                .replace(/(\\{2})|(\\')|\\(.)/g, function (_, backslash, singleQuote, normalChar) {
                if (backslash) {
                    return '\\';
                }
                if (singleQuote) {
                    return '\'';
                }
                return "\\".concat(normalChar);
            });
        };
        Parser.prototype.parseSymbol = function () {
            var token = this.asToken(this.peek());
            this.advance();
            if (!isSymbolToken(token)) {
                throw new LitsError("Expected symbol token, got ".concat(token[0]), token[2]);
            }
            if (token[1][0] === '\'') {
                return this.stringToSymbolNode(this.stringFromQuotedSymbol(token[1]), token[2]);
            }
            else {
                return this.stringToSymbolNode(token[1], token[2]);
            }
        };
        Parser.prototype.parseReservedSymbol = function () {
            var token = asReservedSymbolToken(this.peek());
            this.advance();
            var symbol = token[1];
            if (isNumberReservedSymbol(symbol)) {
                return withSourceCodeInfo([NodeTypes.Number, numberReservedSymbolRecord[symbol]], token[2]);
            }
            return withSourceCodeInfo([NodeTypes.ReservedSymbol, token[1]], token[2]);
        };
        Parser.prototype.parseNumber = function () {
            var token = this.asToken(this.peek());
            this.advance();
            var value = token[1];
            var negative = value[0] === '-';
            var numberString = (negative ? value.substring(1) : value).replace(/_/g, '');
            return withSourceCodeInfo([NodeTypes.Number, negative ? -Number(numberString) : Number(numberString)], token[2]);
        };
        Parser.prototype.parseDocString = function () {
            var token = this.asToken(this.peek());
            var stringToken = token[2] ? ['String', token[1].slice(2, -2), token[2]] : ['String', token[1].slice(2, -2)];
            var stringNode = this.parseString(stringToken);
            return smartTrim(stringNode[1]); // Extract the string value from the StringNode
        };
        Parser.prototype.parseString = function (token) {
            this.advance();
            var value = token[1].substring(1, token[1].length - 1)
                .replace(/(\\{2})|(\\")|(\\n)|(\\t)|(\\r)|(\\b)|(\\f)|\\(.)/g, function (_, backslash, doubleQuote, newline, tab, carriageReturn, backspace, formFeed, normalChar) {
                // If it's a double escape (\\x), return \x
                if (backslash) {
                    return '\\';
                }
                // If it's a special character (\n, \t, \r, \b, \f), return the special character
                else if (newline) {
                    return '\n';
                }
                else if (tab) {
                    return '\t';
                }
                else if (carriageReturn) {
                    return '\r';
                }
                else if (backspace) {
                    return '\b';
                }
                else if (formFeed) {
                    return '\f';
                }
                else if (doubleQuote) {
                    return '"';
                }
                return normalChar;
            });
            return withSourceCodeInfo([NodeTypes.String, value], token[2]);
        };
        Parser.prototype.parseRegexpShorthand = function () {
            var token = this.asToken(this.peek());
            this.advance();
            var endStringPosition = token[1].lastIndexOf('"');
            var regexpString = token[1].substring(2, endStringPosition);
            var optionsString = token[1].substring(endStringPosition + 1);
            var stringNode = withSourceCodeInfo([NodeTypes.String, regexpString], token[2]);
            var optionsNode = withSourceCodeInfo([NodeTypes.String, optionsString], token[2]);
            var node = withSourceCodeInfo([
                NodeTypes.NormalExpression,
                [
                    withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol, normalExpressionTypes.regexp], token[2]),
                    [stringNode, optionsNode],
                ],
            ], token[2]);
            return node;
        };
        return Parser;
    }());

    var litsCommands = new Set(__spreadArray(__spreadArray(__spreadArray([], __read(normalExpressionKeys), false), __read(specialExpressionKeys), false), __read(Object.keys(reservedSymbolRecord)), false));
    // TODO: replace with get suggestions function
    var AutoCompleter = /** @class */ (function () {
        function AutoCompleter(originalProgram, originalPosition, lits, params) {
            this.originalProgram = originalProgram;
            this.originalPosition = originalPosition;
            this.prefixProgram = '';
            this.suffixProgram = '';
            this.searchString = '';
            this.suggestions = [];
            this.suggestionIndex = null;
            var partialProgram = this.originalProgram.slice(0, this.originalPosition);
            var tokenStream = lits.tokenize(partialProgram);
            var lastToken = tokenStream.tokens.at(-1);
            if (!lastToken) {
                return;
            }
            if (lastToken[0] === 'Error') {
                return;
            }
            this.searchString = lastToken[1];
            this.prefixProgram = this.originalProgram.slice(0, this.originalPosition - this.searchString.length);
            this.suffixProgram = this.originalProgram.slice(this.prefixProgram.length + this.searchString.length);
            this.originalProgram.slice(this.prefixProgram.length + this.searchString.length);
            this.suggestions = this.generateSuggestions(params);
        }
        AutoCompleter.prototype.getNextSuggestion = function () {
            return this.getAutoCompleteSuggestionResult(this.getNextSuggestionSymbol());
        };
        AutoCompleter.prototype.getPreviousSuggestion = function () {
            return this.getAutoCompleteSuggestionResult(this.getPreviousSuggestionSymbol());
        };
        AutoCompleter.prototype.getAutoCompleteSuggestionResult = function (suggestion) {
            if (suggestion === null) {
                return null;
            }
            return {
                program: this.prefixProgram + suggestion + this.suffixProgram,
                position: this.prefixProgram.length + suggestion.length,
            };
        };
        AutoCompleter.prototype.getNextSuggestionSymbol = function () {
            if (this.suggestions.length === 0) {
                return null;
            }
            if (this.suggestionIndex === null) {
                this.suggestionIndex = 0;
            }
            else {
                this.suggestionIndex += 1;
                if (this.suggestionIndex >= this.suggestions.length) {
                    this.suggestionIndex = 0;
                }
            }
            return this.suggestions[this.suggestionIndex];
        };
        AutoCompleter.prototype.getPreviousSuggestionSymbol = function () {
            if (this.suggestions.length === 0) {
                return null;
            }
            if (this.suggestionIndex === null) {
                this.suggestionIndex = this.suggestions.length - 1;
            }
            else {
                this.suggestionIndex -= 1;
                if (this.suggestionIndex < 0) {
                    this.suggestionIndex = this.suggestions.length - 1;
                }
            }
            return this.suggestions[this.suggestionIndex];
        };
        AutoCompleter.prototype.getSuggestions = function () {
            return __spreadArray([], __read(this.suggestions), false);
        };
        AutoCompleter.prototype.getSearchString = function () {
            return this.searchString;
        };
        AutoCompleter.prototype.generateSuggestions = function (params) {
            var _this = this;
            var blacklist = new Set(['0_def', '0_defn', '0_lambda']);
            var startsWithCaseSensitive = this.generateWithPredicate(params, function (suggestion) {
                return !blacklist.has(suggestion) && suggestion.startsWith(_this.searchString);
            });
            startsWithCaseSensitive.forEach(function (suggestion) { return blacklist.add(suggestion); });
            var startsWithCaseInsensitive = this.generateWithPredicate(params, function (suggestion) {
                return !blacklist.has(suggestion) && suggestion.toLowerCase().startsWith(_this.searchString.toLowerCase());
            });
            startsWithCaseInsensitive.forEach(function (suggestion) { return blacklist.add(suggestion); });
            var includesCaseSensitive = this.generateWithPredicate(params, function (suggestion) {
                return !blacklist.has(suggestion) && suggestion.includes(_this.searchString);
            });
            includesCaseSensitive.forEach(function (suggestion) { return blacklist.add(suggestion); });
            var includesCaseInsensitive = this.generateWithPredicate(params, function (suggestion) {
                return !blacklist.has(suggestion) && suggestion.includes(_this.searchString.toLowerCase());
            });
            includesCaseInsensitive.forEach(function (suggestion) { return blacklist.add(suggestion); });
            return __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(startsWithCaseSensitive), false), __read(startsWithCaseInsensitive), false), __read(includesCaseSensitive), false), __read(includesCaseInsensitive), false);
        };
        AutoCompleter.prototype.generateWithPredicate = function (params, shouldInclude) {
            var _a, _b, _c, _d;
            var suggestions = new Set();
            litsCommands.forEach(function (suggestion) {
                if (shouldInclude(suggestion)) {
                    suggestions.add(suggestion);
                }
            });
            Object.keys((_a = params.globalContext) !== null && _a !== void 0 ? _a : {})
                .filter(shouldInclude)
                .forEach(function (suggestion) { return suggestions.add(suggestion); });
            (_b = params.contexts) === null || _b === void 0 ? void 0 : _b.forEach(function (context) {
                Object.keys(context)
                    .filter(shouldInclude)
                    .forEach(function (suggestion) { return suggestions.add(suggestion); });
            });
            Object.keys((_c = params.jsFunctions) !== null && _c !== void 0 ? _c : {})
                .filter(shouldInclude)
                .forEach(function (suggestion) { return suggestions.add(suggestion); });
            Object.keys((_d = params.values) !== null && _d !== void 0 ? _d : {})
                .filter(shouldInclude)
                .forEach(function (suggestion) { return suggestions.add(suggestion); });
            return __spreadArray([], __read(suggestions), false).sort(function (a, b) { return a.localeCompare(b); });
        };
        return AutoCompleter;
    }());

    var Cache = /** @class */ (function () {
        function Cache(maxSize) {
            this.cache = {};
            this.firstEntry = undefined;
            this.lastEntry = undefined;
            this._size = 0;
            this.maxSize = maxSize === null ? null : toNonNegativeInteger(maxSize);
            if (typeof this.maxSize === 'number' && this.maxSize < 1)
                throw new Error("1 is the minimum maxSize, got ".concat(valueToString(maxSize)));
        }
        Cache.prototype.getContent = function () {
            return Object.entries(this.cache).reduce(function (result, _a) {
                var _b = __read(_a, 2), key = _b[0], entry = _b[1];
                result[key] = entry.value;
                return result;
            }, {});
        };
        Object.defineProperty(Cache.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        Cache.prototype.get = function (key) {
            var _a;
            return (_a = this.cache[key]) === null || _a === void 0 ? void 0 : _a.value;
        };
        Cache.prototype.clear = function () {
            this.cache = {};
            this.firstEntry = undefined;
            this.lastEntry = undefined;
            this._size = 0;
        };
        Cache.prototype.has = function (key) {
            return !!this.cache[key];
        };
        Cache.prototype.set = function (key, value) {
            if (this.has(key))
                throw new Error("AstCache - key already present: ".concat(key));
            var newEntry = { value: value, nextEntry: undefined, key: key };
            this.cache[key] = newEntry;
            this._size += 1;
            if (this.lastEntry)
                this.lastEntry.nextEntry = newEntry;
            this.lastEntry = newEntry;
            if (!this.firstEntry)
                this.firstEntry = this.lastEntry;
            while (this.maxSize !== null && this.size > this.maxSize)
                this.dropFirstEntry();
        };
        Cache.prototype.dropFirstEntry = function () {
            var firstEntry = this.firstEntry;
            delete this.cache[firstEntry.key];
            this._size -= 1;
            this.firstEntry = firstEntry.nextEntry;
        };
        return Cache;
    }());

    var Lits = /** @class */ (function () {
        function Lits(config) {
            var e_1, _a;
            if (config === void 0) { config = {}; }
            var _b, _c, _d, _e;
            this.debug = (_b = config.debug) !== null && _b !== void 0 ? _b : false;
            this.astCacheSize = (_c = config.astCacheSize) !== null && _c !== void 0 ? _c : null;
            if (this.astCacheSize) {
                this.astCache = new Cache(this.astCacheSize);
                var initialCache = (_d = config.initialCache) !== null && _d !== void 0 ? _d : {};
                try {
                    for (var _f = __values(Object.keys(initialCache)), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var cacheEntry = _g.value;
                        this.astCache.set(cacheEntry, initialCache[cacheEntry]);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                this.astCache = null;
            }
            var nsList = (_e = config.namespaces) !== null && _e !== void 0 ? _e : [];
            this.namespaces = new Map(nsList.map(function (ns) { return [ns.name, ns]; }));
        }
        Lits.prototype.getRuntimeInfo = function () {
            return {
                astCacheSize: this.astCacheSize,
                astCache: this.astCache,
                debug: this.debug,
            };
        };
        Lits.prototype.run = function (program, params) {
            if (params === void 0) { params = {}; }
            var ast = this.generateAst(program, params);
            var result = this.evaluate(ast, params);
            return result;
        };
        Lits.prototype.context = function (programOrAst, params) {
            if (params === void 0) { params = {}; }
            var ast = typeof programOrAst === 'string' ? this.generateAst(programOrAst, params) : programOrAst;
            var contextStack = createContextStack(params, this.namespaces);
            evaluate(ast, contextStack);
            return contextStack.globalContext;
        };
        Lits.prototype.getUndefinedSymbols = function (programOrAst, params) {
            if (params === void 0) { params = {}; }
            var ast = typeof programOrAst === 'string' ? this.generateAst(programOrAst, params) : programOrAst;
            var contextStack = createContextStack(params, this.namespaces);
            return getUndefinedSymbols(ast, contextStack, builtin, evaluateNode);
        };
        Lits.prototype.tokenize = function (program, tokenizeParams) {
            if (tokenizeParams === void 0) { tokenizeParams = {}; }
            var tokenStream = tokenize$1(program, this.debug, tokenizeParams.filePath);
            return tokenizeParams.minify ? minifyTokenStream(tokenStream, { removeWhiteSpace: false }) : tokenStream;
        };
        Lits.prototype.parse = function (tokenStream) {
            tokenStream = minifyTokenStream(tokenStream, { removeWhiteSpace: true });
            var ast = {
                body: [],
                hasDebugData: tokenStream.hasDebugData,
            };
            var parseState = {
                position: 0,
            };
            ast.body = new Parser(tokenStream, parseState).parse();
            return ast;
        };
        Lits.prototype.evaluate = function (ast, params) {
            var contextStack = createContextStack(params, this.namespaces);
            return evaluate(ast, contextStack);
        };
        Lits.prototype.transformSymbols = function (tokenStream, transformer) {
            return transformSymbolTokens(tokenStream, transformer);
        };
        Lits.prototype.untokenize = function (tokenStream) {
            return untokenize(tokenStream);
        };
        Lits.prototype.apply = function (fn, fnParams, params) {
            var _a;
            if (params === void 0) { params = {}; }
            var fnName = 'FN_2eb7b316_471c_5bfa_90cb_d3dfd9164a59';
            var program = this.generateApplyFunctionCall(fnName, fnParams);
            var ast = this.generateAst(program, params);
            var hostValues = fnParams.reduce(function (result, param, index) {
                result["".concat(fnName, "_").concat(index)] = param;
                return result;
            }, (_a = {}, _a[fnName] = fn, _a));
            params.values = __assign(__assign({}, params.values), hostValues);
            return this.evaluate(ast, params);
        };
        Lits.prototype.generateApplyFunctionCall = function (fnName, fnParams) {
            var paramsString = fnParams
                .map(function (_, index) {
                return "".concat(fnName, "_").concat(index);
            })
                .join(', ');
            return "".concat(fnName, "(").concat(paramsString, ")");
        };
        Lits.prototype.generateAst = function (program, params) {
            var _a;
            if (this.astCache) {
                var cachedAst = this.astCache.get(program);
                if (cachedAst)
                    return cachedAst;
            }
            var tokenStream = this.tokenize(program, {
                filePath: params.filePath,
            });
            var ast = this.parse(tokenStream);
            (_a = this.astCache) === null || _a === void 0 ? void 0 : _a.set(program, ast);
            return ast;
        };
        Lits.prototype.getAutoCompleter = function (program, position, params) {
            if (params === void 0) { params = {}; }
            return new AutoCompleter(program, position, this, params);
        };
        return Lits;
    }());

    var namespaceDocs$6 = {
        'assert': {
            category: 'Assert',
            description: 'If $value is falsy it throws `AssertionError` with $message. If no $message is provided, message is set to $value.',
            returns: {
                type: 'any',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'value',
                    ],
                },
                {
                    argumentNames: [
                        'value',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert } = import("Assert");\ntry assert(0, "Expected a positive value") catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert!=': {
            category: 'Assert',
            description: 'If $a is the same as $b it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                a: {
                    type: 'any',
                },
                b: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
                {
                    argumentNames: [
                        'a',
                        'b',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert!= } = import("Assert");\ntry assert!=(0, 0, "Expected different values") catch (e) e.message end',
                'let { assert!= } = import("Assert");\ntry assert!=(0, 0) catch (e) e.message end',
                'let { assert!= } = import("Assert");\ntry 0 assert!= 0 catch (e) e.message end',
                'let { assert!= } = import("Assert");\ntry assert!=(0, 1) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert=': {
            category: 'Assert',
            description: 'If $a is not structural equal to $b it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                a: {
                    type: 'any',
                },
                b: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
                {
                    argumentNames: [
                        'a',
                        'b',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert= } = import("Assert");\ntry assert=({ "a": 1 }, { "a": 2 }, "Expected equal values") catch (e) e.message end',
                'let { assert= } = import("Assert");\ntry assert=({ "a": 1 }, { "a": 2 }) catch (e) e.message end',
                'let { assert= } = import("Assert");\ntry assert=({ "a": 1 }, { "a": 1 }) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-gt': {
            category: 'Assert',
            description: 'If $a is not greater than $b it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                a: {
                    type: 'any',
                },
                b: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
                {
                    argumentNames: [
                        'a',
                        'b',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-gt } = import("Assert");\ntry assert-gt(0, 1, "Expected greater value") catch (e) e.message end',
                'let { assert-gt } = import("Assert");\ntry assert-gt(0, 0) catch (e) e.message end',
                'let { assert-gt } = import("Assert");\ntry assert-gt(1, 0) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-lt': {
            category: 'Assert',
            description: 'If $a is not less than $b it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                a: {
                    type: 'any',
                },
                b: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
                {
                    argumentNames: [
                        'a',
                        'b',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-lt } = import("Assert");\ntry assert-lt(1, 0, "Expected smaller value value") catch (e) e.message end',
                'let { assert-lt } = import("Assert");\ntry assert-lt(1, 1) catch (e) e.message end',
                'let { assert-lt } = import("Assert");\ntry assert-lt(0, 1) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-gte': {
            category: 'Assert',
            description: 'If $a is less than $b it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                a: {
                    type: 'any',
                },
                b: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
                {
                    argumentNames: [
                        'a',
                        'b',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-gte } = import("Assert");\ntry assert-gte(0, 1, "Expected greater value") catch (e) e.message end',
                'let { assert-gte } = import("Assert");\ntry assert-gte(0, 1) catch (e) e.message end',
                'let { assert-gte } = import("Assert");\ntry assert-gte(1, 1) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-lte': {
            category: 'Assert',
            description: 'If $a is grater than $b it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                a: {
                    type: 'any',
                },
                b: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
                {
                    argumentNames: [
                        'a',
                        'b',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-lte } = import("Assert");\ntry assert-lte(1, 0, "Expected smaller value value") catch (e) e.message end',
                'let { assert-lte } = import("Assert");\ntry assert-lte(1, 0) catch (e) e.message end',
                'let { assert-lte } = import("Assert");\ntry assert-lte(1, 1) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-true': {
            category: 'Assert',
            description: 'If $value is not `true` it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'value',
                    ],
                },
                {
                    argumentNames: [
                        'value',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-true } = import("Assert");\ntry assert-true(false, "Expected true") catch (e) e.message end',
                'let { assert-true } = import("Assert");\ntry assert-true(false) catch (e) e.message end',
                'let { assert-true } = import("Assert");\ntry assert-true(true) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-false': {
            category: 'Assert',
            description: 'If $value is not `false` it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'value',
                    ],
                },
                {
                    argumentNames: [
                        'value',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-false } = import("Assert");\ntry assert-false(true, "Expected false") catch (e) e.message end',
                'let { assert-false } = import("Assert");\ntry assert-false(true) catch (e) e.message end',
                'let { assert-false } = import("Assert");\ntry assert-false(false) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-truthy': {
            category: 'Assert',
            description: 'If $value is not `truthy` it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'value',
                    ],
                },
                {
                    argumentNames: [
                        'value',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-truthy } = import("Assert");\ntry assert-truthy(false, "Expected truthy") catch (e) e.message end',
                'let { assert-truthy } = import("Assert");\ntry assert-truthy(false) catch (e) e.message end',
                'let { assert-truthy } = import("Assert");\ntry assert-truthy(0) catch (e) e.message end',
                'let { assert-truthy } = import("Assert");\ntry assert-truthy(null) catch (e) e.message end',
                'let { assert-truthy } = import("Assert");\ntry assert-truthy("") catch (e) e.message end',
                'let { assert-truthy } = import("Assert");\ntry assert-truthy(true) catch (e) e.message end',
                'let { assert-truthy } = import("Assert");\ntry assert-truthy(1) catch (e) e.message end',
                'let { assert-truthy } = import("Assert");\ntry assert-truthy("x") catch (e) e.message end',
                'let { assert-truthy } = import("Assert");\ntry assert-truthy([]) catch (e) e.message end',
                'let { assert-truthy } = import("Assert");\ntry assert-truthy(nd) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-falsy': {
            category: 'Assert',
            description: 'If $value is not `falsy` it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'value',
                    ],
                },
                {
                    argumentNames: [
                        'value',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-falsy } = import("Assert");\ntry assert-falsy(true, "Expected falsy") catch (e) e.message end',
                'let { assert-falsy } = import("Assert");\ntry assert-falsy("x") catch (e) e.message end',
                'let { assert-falsy } = import("Assert");\ntry assert-falsy([]) catch (e) e.message end',
                'let { assert-falsy } = import("Assert");\ntry assert-falsy(nd) catch (e) e.message end',
                'let { assert-falsy } = import("Assert");\ntry assert-falsy(1) catch (e) e.message end',
                'let { assert-falsy } = import("Assert");\ntry assert-falsy(false) catch (e) e.message end',
                'let { assert-falsy } = import("Assert");\ntry assert-falsy(0) catch (e) e.message end',
                'let { assert-falsy } = import("Assert");\ntry assert-falsy(null) catch (e) e.message end',
                'let { assert-falsy } = import("Assert");\ntry assert-falsy("") catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-null': {
            category: 'Assert',
            description: 'If $value is not `null` it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'value',
                    ],
                },
                {
                    argumentNames: [
                        'value',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-null } = import("Assert");\ntry assert-null(null) catch (e) e.message end',
                'let { assert-null } = import("Assert");\ntry assert-null(true, "Expected null") catch (e) e.message end',
                'let { assert-null } = import("Assert");\ntry assert-null("x") catch (e) e.message end',
                'let { assert-null } = import("Assert");\ntry assert-null([]) catch (e) e.message end',
                'let { assert-null } = import("Assert");\ntry assert-null(nd) catch (e) e.message end',
                'let { assert-null } = import("Assert");\ntry assert-null(1) catch (e) e.message end',
                'let { assert-null } = import("Assert");\ntry assert-null(false) catch (e) e.message end',
                'let { assert-null } = import("Assert");\ntry assert-null(0) catch (e) e.message end',
                'let { assert-null } = import("Assert");\ntry assert-null("") catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-throws': {
            category: 'Assert',
            description: 'If $fun does not throw, it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                fun: {
                    type: 'function',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'fun',
                    ],
                },
                {
                    argumentNames: [
                        'fun',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-throws } = import("Assert");\nassert-throws(-> throw("Error"))',
                'let { assert-throws } = import("Assert");\ntry assert-throws(-> identity("Error")) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-throws-error': {
            category: 'Assert',
            description: 'If $fun does not throw $error-message, it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                'fun': {
                    type: 'function',
                },
                'error-message': {
                    type: 'string',
                },
                'message': {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'value',
                        'error-message',
                    ],
                },
                {
                    argumentNames: [
                        'value',
                        'error-message',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-throws-error } = import("Assert");\ntry assert-throws-error(-> throw("Error"), "Error") catch (e) e.message end',
                'let { assert-throws-error } = import("Assert");\ntry assert-throws-error(-> identity("Error"), "Error") catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
        'assert-not-throws': {
            category: 'Assert',
            description: 'If $fun throws, it throws `AssertionError`.',
            returns: {
                type: 'null',
            },
            args: {
                fun: {
                    type: 'function',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'fun',
                    ],
                },
                {
                    argumentNames: [
                        'fun',
                        'message',
                    ],
                },
            ],
            examples: [
                'let { assert-not-throws } = import("Assert");\ntry assert-not-throws(-> identity("Error")) catch (e) e.message end',
                'let { assert-not-throws } = import("Assert");\ntry assert-not-throws(-> throw("Error")) catch (e) e.message end',
            ],
            hideOperatorForm: true,
        },
    };

    var e_1$6, _a$6;
    // TODO, remove some, add some. E.g. type guards, assert-number, assert-string, etc.
    var assertNormalExpression = {
        'assert': {
            evaluate: function (params, sourceCodeInfo) {
                var value = params[0];
                var message = params.length === 2 ? params[1] : "".concat(value);
                assertString(message, sourceCodeInfo);
                if (!value)
                    throw new AssertionError(message, sourceCodeInfo);
                return asAny(value, sourceCodeInfo);
            },
            arity: { min: 1, max: 2 },
        },
        'assert=': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (!deepEqual(asAny(first, sourceCodeInfo), asAny(second, sourceCodeInfo), sourceCodeInfo)) {
                    throw new AssertionError("Expected ".concat(JSON.stringify(first, null, 2), " to deep equal ").concat(JSON.stringify(second, null, 2), ".").concat(message), sourceCodeInfo);
                }
                return null;
            },
            arity: { min: 2, max: 3 },
        },
        'assert!=': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (deepEqual(asAny(first, sourceCodeInfo), asAny(second, sourceCodeInfo), sourceCodeInfo)) {
                    throw new AssertionError("Expected ".concat(JSON.stringify(first), " not to deep equal ").concat(JSON.stringify(second), ".").concat(message), sourceCodeInfo);
                }
                return null;
            },
            arity: { min: 2, max: 3 },
        },
        'assert-gt': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                assertStringOrNumber(first, sourceCodeInfo);
                assertStringOrNumber(second, sourceCodeInfo);
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (compare(first, second, sourceCodeInfo) <= 0)
                    throw new AssertionError("Expected ".concat(first, " to be grater than ").concat(second, ".").concat(message), sourceCodeInfo);
                return null;
            },
            arity: { min: 2, max: 3 },
        },
        'assert-gte': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                assertStringOrNumber(first, sourceCodeInfo);
                assertStringOrNumber(second, sourceCodeInfo);
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (compare(first, second, sourceCodeInfo) < 0)
                    throw new AssertionError("Expected ".concat(first, " to be grater than or equal to ").concat(second, ".").concat(message), sourceCodeInfo);
                return null;
            },
            arity: { min: 2, max: 3 },
        },
        'assert-lt': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                assertStringOrNumber(first, sourceCodeInfo);
                assertStringOrNumber(second, sourceCodeInfo);
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (compare(first, second, sourceCodeInfo) >= 0)
                    throw new AssertionError("Expected ".concat(first, " to be less than ").concat(second, ".").concat(message), sourceCodeInfo);
                return null;
            },
            arity: { min: 2, max: 3 },
        },
        'assert-lte': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                assertStringOrNumber(first, sourceCodeInfo);
                assertStringOrNumber(second, sourceCodeInfo);
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (compare(first, second, sourceCodeInfo) > 0)
                    throw new AssertionError("Expected ".concat(first, " to be less than or equal to ").concat(second, ".").concat(message), sourceCodeInfo);
                return null;
            },
            arity: { min: 2, max: 3 },
        },
        'assert-true': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (first !== true)
                    throw new AssertionError("Expected ".concat(first, " to be true.").concat(message), sourceCodeInfo);
                return null;
            },
            arity: { min: 1, max: 2 },
        },
        'assert-false': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (first !== false)
                    throw new AssertionError("Expected ".concat(first, " to be false.").concat(message), sourceCodeInfo);
                return null;
            },
            arity: { min: 1, max: 2 },
        },
        'assert-truthy': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (!first)
                    throw new AssertionError("Expected ".concat(first, " to be truthy.").concat(message), sourceCodeInfo);
                return null;
            },
            arity: { min: 1, max: 2 },
        },
        'assert-falsy': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (first)
                    throw new AssertionError("Expected ".concat(first, " to be falsy.").concat(message), sourceCodeInfo);
                return null;
            },
            arity: { min: 1, max: 2 },
        },
        'assert-null': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (first !== null)
                    throw new AssertionError("Expected ".concat(first, " to be null.").concat(message), sourceCodeInfo);
                return null;
            },
            arity: { min: 1, max: 2 },
        },
        'assert-throws': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), func = _c[0], message = _c[1];
                var executeFunction = _b.executeFunction;
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                assertFunctionLike(func, sourceCodeInfo);
                try {
                    executeFunction(func, [], contextStack, sourceCodeInfo);
                }
                catch (_d) {
                    return null;
                }
                throw new AssertionError("Expected function to throw.".concat(message), sourceCodeInfo);
            },
            arity: { min: 1, max: 2 },
        },
        'assert-throws-error': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), func = _c[0], throwMessage = _c[1], message = _c[2];
                var executeFunction = _b.executeFunction;
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                assertString(throwMessage, sourceCodeInfo);
                assertFunctionLike(func, sourceCodeInfo);
                try {
                    executeFunction(func, [], contextStack, sourceCodeInfo);
                }
                catch (error) {
                    var errorMessage = error.shortMessage;
                    if (errorMessage !== throwMessage) {
                        throw new AssertionError("Expected function to throw \"".concat(throwMessage, "\", but thrown \"").concat(errorMessage, "\".").concat(message), sourceCodeInfo);
                    }
                    return null;
                }
                throw new AssertionError("Expected function to throw \"".concat(throwMessage, "\".").concat(message), sourceCodeInfo);
            },
            arity: { min: 2, max: 3 },
        },
        'assert-not-throws': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), func = _c[0], message = _c[1];
                var executeFunction = _b.executeFunction;
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                    message = " ".concat(message);
                }
                message !== null && message !== void 0 ? message : (message = '');
                assertFunctionLike(func, sourceCodeInfo);
                try {
                    executeFunction(func, [], contextStack, sourceCodeInfo);
                }
                catch (_d) {
                    throw new AssertionError("Expected function not to throw.".concat(message), sourceCodeInfo);
                }
                return null;
            },
            arity: { min: 1, max: 2 },
        },
    };
    try {
        for (var _b$6 = __values(Object.entries(namespaceDocs$6)), _c$6 = _b$6.next(); !_c$6.done; _c$6 = _b$6.next()) {
            var _d$6 = __read(_c$6.value, 2), key$6 = _d$6[0], docs$6 = _d$6[1];
            if (assertNormalExpression[key$6])
                assertNormalExpression[key$6].docs = docs$6;
        }
    }
    catch (e_1_1) { e_1$6 = { error: e_1_1 }; }
    finally {
        try {
            if (_c$6 && !_c$6.done && (_a$6 = _b$6.return)) _a$6.call(_b$6);
        }
        finally { if (e_1$6) throw e_1$6.error; }
    }
    var assertNamespace = {
        name: 'Assert',
        functions: assertNormalExpression,
    };

    var namespaceDocs$5 = {
        'every?': {
            category: 'Grid',
            description: 'Checks if all elements in a grid satisfy a predicate. Returns true only if the predicate returns true for every element in the grid.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                '// Using "as" alias because "every?" shadows a builtin function\nlet { every? as grid-every? } = import("Grid");\ngrid-every?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], string?)',
                '// Using "as" alias because "every?" shadows a builtin function\nlet { every? as grid-every? } = import("Grid");\ngrid-every?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], string?)',
                '// Using "as" alias because "every?" shadows a builtin function\nlet { every? as grid-every? } = import("Grid");\ngrid-every?([\n  [1, 2],\n  [3, 4],\n], string?)',
            ],
        },
        'some?': {
            category: 'Grid',
            description: 'Checks if any element in a grid satisfies a predicate. Returns true if the predicate returns true for at least one element in the grid.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { some? } = import("Grid");\nsome?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], string?)',
                'let { some? } = import("Grid");\nsome?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], string?)',
                'let { some? } = import("Grid");\nsome?([\n  [1, 2],\n  [3, 4],\n], string?)',
            ],
        },
        'every-row?': {
            category: 'Grid',
            description: 'Checks if all rows in a grid satisfy a predicate. Returns true only if the predicate returns true for every row in the grid.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { every-row? } = import("Grid");\nevery-row?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> string?($[0]))',
                'let { every-row? } = import("Grid");\nevery-row?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], -> string?($[0]))',
                'let { every-row? } = import("Grid");\nevery-row?([\n  [1, 2],\n  [3, 4],\n], -> string?($[0]))',
            ],
        },
        'some-row?': {
            category: 'Grid',
            description: 'Checks if any row in a grid satisfies a predicate. Returns true if the predicate returns true for at least one row in the grid.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { some-row? } = import("Grid");\nsome-row?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> $ contains? "Albert")',
                'let { some-row? } = import("Grid");\nsome-row?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], -> $ contains? "Albert")',
                'let { some-row? } = import("Grid");\nsome-row?([\n  [1, 2],\n  [3, 4],\n], -> $ contains? "Albert")',
            ],
        },
        'every-col?': {
            category: 'Grid',
            description: 'Checks if all columns in a grid satisfy a predicate. Returns true only if the predicate returns true for every column in the grid.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { every-col? } = import("Grid");\nevery-col?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> string?($[0]))',
                'let { every-col? } = import("Grid");\nevery-col?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], -> string?($[0]))',
                'let { every-col? } = import("Grid");\nevery-col?([\n  [1, 2],\n  [3, 4],\n], -> string?($[0]))',
            ],
        },
        'some-col?': {
            category: 'Grid',
            description: 'Checks if any column in a grid satisfies a predicate. Returns true if the predicate returns true for at least one column in the grid.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { some-col? } = import("Grid");\nsome-col?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> $ contains? "Albert")',
                'let { some-col? } = import("Grid");\nsome-col?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], -> $ contains? "Albert")',
                'let { some-col? } = import("Grid");\nsome-col?([\n  [1, 2],\n  [3, 4],\n], -> $ contains? "Albert")',
            ],
        },
        'row': {
            category: 'Grid',
            description: 'Returns the row at index $a in the grid $b.',
            returns: {
                type: 'any',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'number',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { row } = import("Grid");\nrow([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 0)',
                'let { row } = import("Grid");\nrow([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1)',
                'let { row } = import("Grid");\nrow([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 2)',
            ],
        },
        'col': {
            category: 'Grid',
            description: 'Returns the column at index $a in the grid $b.',
            returns: {
                type: 'any',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'number',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { col } = import("Grid");\ncol([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 0)',
                'let { col } = import("Grid");\ncol([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1)',
                'let { col } = import("Grid");\ncol([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 2)',
            ],
        },
        'shape': {
            category: 'Grid',
            description: 'Returns the shape of the grid `g` as a `vector` of two numbers, where the first number is the number of rows and the second number is the number of columns.',
            returns: {
                type: 'vector',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to get the shape of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { shape } = import("Grid");\nshape([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
                'let { shape } = import("Grid");\nshape([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])',
                'let { shape } = import("Grid");\nshape([\n  [1, 2],\n  [3, 4],\n])',
            ],
        },
        'fill': {
            category: 'Grid',
            description: 'Creates a grid of the specified size, filled with the specified value.',
            returns: {
                type: 'grid',
            },
            args: {
                rows: {
                    type: 'integer',
                    description: 'The number of rows in the grid.',
                },
                cols: {
                    type: 'integer',
                    description: 'The number of columns in the grid.',
                },
                value: {
                    type: 'any',
                    description: 'The value to fill the grid with.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'rows',
                        'cols',
                        'value',
                    ],
                },
            ],
            examples: [
                'let { fill } = import("Grid");\nfill(2, 3, 0)',
                'let { fill } = import("Grid");\nfill(2, 3, "x")',
            ],
        },
        'generate': {
            category: 'Grid',
            description: 'Generates a grid of the specified size, where each element is generated by the provided function.',
            returns: {
                type: 'grid',
            },
            args: {
                rows: {
                    type: 'number',
                    description: 'The number of rows in the grid.',
                },
                cols: {
                    type: 'number',
                    description: 'The number of columns in the grid.',
                },
                fn: {
                    type: 'function',
                    description: 'The function to generate the grid. It takes two arguments: the row index and the column index.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'rows',
                        'cols',
                        'fn',
                    ],
                },
            ],
            examples: [
                'let { generate } = import("Grid");\ngenerate(3, 3, (i, j) -> i + j)',
            ],
        },
        'reshape': {
            category: 'Grid',
            description: 'Reshapes the grid `a` into a new grid with the specified number of rows `b`. The number of columns is automatically calculated based on the total number of elements in the grid.',
            returns: {
                type: 'grid',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'number',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { reshape } = import("Grid");\nreshape([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], 2)',
            ],
        },
        'transpose': {
            category: 'Grid',
            description: 'Transposes the grid `g`, swapping its rows and columns.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to transpose.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { transpose } = import("Grid");\ntranspose([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
                'let { transpose } = import("Grid");\ntranspose([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])',
                'let { transpose } = import("Grid");\ntranspose([\n  [1, 2],\n  [3, 4],\n])',
            ],
        },
        'flip-h': {
            category: 'Grid',
            description: 'Flips the grid `g` horizontally.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to flip horizontally.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { flip-h } = import("Grid");\nflip-h([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
                'let { flip-h } = import("Grid");\nflip-h([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])',
                'let { flip-h } = import("Grid");\nflip-h([\n  [1, 2],\n  [3, 4],\n])',
            ],
        },
        'flip-v': {
            category: 'Grid',
            description: 'Flips the grid `g` vertically.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to flip vertically.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { flip-v } = import("Grid");\nflip-v([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
                'let { flip-v } = import("Grid");\nflip-v([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])',
                'let { flip-v } = import("Grid");\nflip-v([\n  [1, 2],\n  [3, 4],\n])',
            ],
        },
        'rotate': {
            category: 'Grid',
            description: 'Rotates the grid `g` by the specified angle. The angle is given in terms of 90-degree rotations. Positive values rotate the grid clockwise, while negative values rotate it counterclockwise.',
            returns: {
                type: 'grid',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { rotate } = import("Grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], 1)',
                'let { rotate } = import("Grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], 2)',
                'let { rotate } = import("Grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], 3)',
                'let { rotate } = import("Grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], 4)',
                'let { rotate } = import("Grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], -1)',
                'let { rotate } = import("Grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], -2)',
                'let { rotate } = import("Grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], -3)',
            ],
        },
        'reverse-rows': {
            category: 'Grid',
            description: 'Reverses the order of rows in the grid `g`.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to reverse rows.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { reverse-rows } = import("Grid");\nreverse-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
                'let { reverse-rows } = import("Grid");\nreverse-rows([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])',
                'let { reverse-rows } = import("Grid");\nreverse-rows([\n  [1, 2],\n  [3, 4],\n])',
            ],
        },
        'reverse-cols': {
            category: 'Grid',
            description: 'Reverses the order of columns in the grid `g`.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to reverse columns.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { reverse-cols } = import("Grid");\nreverse-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
                'let { reverse-cols } = import("Grid");\nreverse-cols([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])',
                'let { reverse-cols } = import("Grid");\nreverse-cols([\n  [1, 2],\n  [3, 4],\n])',
            ],
        },
        'slice': {
            category: 'Grid',
            description: 'Slices the grid `g` from the starting index `begin` to the optional ending index `stop`. The slice is inclusive of the starting index and exclusive of the ending index.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to slice.',
                },
                begin: {
                    type: 'vector',
                    description: 'The starting index of the slice as a vector of two numbers: `[row, col]`.',
                },
                stop: {
                    type: 'vector',
                    description: 'Optional ending index of the slice as a vector of two numbers: `[row, col]`.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'begin',
                    ],
                },
                {
                    argumentNames: [
                        'g',
                        'begin',
                        'stop',
                    ],
                },
            ],
            examples: [
                '// Using "as" alias because "slice" shadows a builtin function\nlet { slice as grid-slice } = import("Grid");\ngrid-slice([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], [1, 1], [2, 2])',
                '// Using "as" alias because "slice" shadows a builtin function\nlet { slice as grid-slice } = import("Grid");\ngrid-slice([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], [1, 1])',
            ],
            hideOperatorForm: true,
        },
        'slice-rows': {
            category: 'Grid',
            description: 'Slices rows of the grid `g` from the starting index `begin` to the optional ending index `stop`. The slice is inclusive of the starting index and exclusive of the ending index.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to slice.',
                },
                begin: {
                    type: 'number',
                    description: 'The starting index of the slice.',
                },
                stop: {
                    type: 'number',
                    description: 'Optional ending index of the slice.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'begin',
                    ],
                },
                {
                    argumentNames: [
                        'g',
                        'begin',
                        'stop',
                    ],
                },
            ],
            examples: [
                'let { slice-rows } = import("Grid");\nslice-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 2)',
                'let { slice-rows } = import("Grid");\nslice-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1)',
            ],
            hideOperatorForm: true,
        },
        'slice-cols': {
            category: 'Grid',
            description: 'Slices columns of the grid `g` from the starting index `begin` to the optional ending index `stop`. The slice is inclusive of the starting index and exclusive of the ending index.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to slice.',
                },
                begin: {
                    type: 'number',
                    description: 'The starting index of the slice.',
                },
                stop: {
                    type: 'number',
                    description: 'Optional ending index of the slice.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'begin',
                    ],
                },
                {
                    argumentNames: [
                        'g',
                        'begin',
                        'stop',
                    ],
                },
            ],
            examples: [
                'let { slice-cols } = import("Grid");\nslice-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 2)',
                'let { slice-cols } = import("Grid");\nslice-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1)',
            ],
            hideOperatorForm: true,
        },
        'splice-rows': {
            category: 'Grid',
            description: 'Splices rows of the grid `g` starting from the index `begin`. Deletes `deleteCount` rows and inserts the specified `items` at that position.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to splice.',
                },
                begin: {
                    type: 'number',
                    description: 'The starting index of the splice.',
                },
                deleteCount: {
                    type: 'number',
                    description: 'The number of rows to delete.',
                },
                items: {
                    type: 'array',
                    rest: true,
                    description: 'The rows to insert.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'begin',
                        'deleteCount',
                    ],
                },
                {
                    argumentNames: [
                        'g',
                        'begin',
                        'deleteCount',
                        'items',
                    ],
                },
            ],
            examples: [
                'let { splice-rows } = import("Grid");\nsplice-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 2)',
                'let { splice-rows } = import("Grid");\nsplice-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 1, ["Nazanin", "mother", 40])',
            ],
            hideOperatorForm: true,
        },
        'splice-cols': {
            category: 'Grid',
            description: 'Splices columns of the grid `g` starting from the index `begin`. Deletes `deleteCount` columns and inserts the specified `items` at that position.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to splice.',
                },
                begin: {
                    type: 'number',
                    description: 'The starting index of the splice.',
                },
                deleteCount: {
                    type: 'number',
                    description: 'The number of columns to delete.',
                },
                items: {
                    type: 'array',
                    rest: true,
                    description: 'The columns to insert.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'begin',
                        'deleteCount',
                    ],
                },
                {
                    argumentNames: [
                        'g',
                        'begin',
                        'deleteCount',
                        'items',
                    ],
                },
            ],
            examples: [
                'let { splice-cols } = import("Grid");\nsplice-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 2)',
                'let { splice-cols } = import("Grid");\nsplice-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 1, ["f", "m", "s"])',
            ],
            hideOperatorForm: true,
        },
        'concat-rows': {
            category: 'Grid',
            description: 'Concatenates two grids `a` and `b` by rows. The number of columns in both grids must be the same.',
            returns: {
                type: 'grid',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'grid',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { concat-rows } = import("Grid");\nconcat-rows([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], [\n  [1, 2],\n  [3, 4],\n])',
            ],
        },
        'concat-cols': {
            category: 'Grid',
            description: 'Concatenates two grids `a` and `b` by columns. The number of rows in both grids must be the same.',
            returns: {
                type: 'grid',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'grid',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { concat-cols } = import("Grid");\nconcat-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], [\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])',
            ],
        },
        'map': {
            category: 'Grid',
            description: 'Maps a function `a` over each element of the grid `b`, returning a new grid with the results.',
            returns: {
                type: 'grid',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                '// Using "as" alias because "map" shadows a builtin function\nlet { map as grid-map } = import("Grid");\ngrid-map([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], str)',
            ],
        },
        'mapi': {
            category: 'Grid',
            description: 'Maps a function `a` over each element of the grid `b`, passing the row and column index as additional arguments to the function.',
            returns: {
                type: 'grid',
            },
            args: {
                a: {
                    type: 'grid',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                '// Using "as" alias because "mapi" shadows a builtin function\nlet { mapi as grid-mapi } = import("Grid");\ngrid-mapi([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> $1 ++ "(" ++ $2 ++ ", " ++ $3 ++ ")")',
            ],
        },
        'reduce': {
            category: 'Grid',
            description: 'Reduces the grid `a` using the function `b`, returning a single value.',
            returns: {
                type: 'any',
            },
            args: {
                'g': {
                    type: 'grid',
                    description: 'The grid to reduce.',
                },
                'fn': {
                    type: 'function',
                    description: 'The function to reduce the grid. It takes two arguments: the accumulator and the current element.',
                },
                'initial-value': {
                    type: 'any',
                    description: 'The initial value for the accumulator.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'fn',
                        'initial-value',
                    ],
                },
            ],
            examples: [
                '// Using "as" alias because "reduce" shadows a builtin function\nlet { reduce as grid-reduce } = import("Grid");\ngrid-reduce([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ++, "")',
            ],
        },
        'reducei': {
            category: 'Grid',
            description: 'Reduces the grid `a` using the function `b`, passing the row and column indices as additional arguments to the function.',
            returns: {
                type: 'any',
            },
            args: {
                'g': {
                    type: 'grid',
                    description: 'The grid to reduce.',
                },
                'fn': {
                    type: 'function',
                    description: 'The function to reduce the grid. It takes four arguments: the accumulator, the current element, the row index, and the column index.',
                },
                'initial-value': {
                    type: 'any',
                    description: 'The initial value for the accumulator.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'fn',
                        'initial-value',
                    ],
                },
            ],
            examples: [
                '// Using "as" alias because "reducei" shadows a builtin function\nlet { reducei as grid-reducei } = import("Grid");\ngrid-reducei([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ++, "")',
            ],
        },
        'push-rows': {
            category: 'Grid',
            description: 'Pushes the specified rows into the grid `g` and returns the new grid.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to push rows into.',
                },
                rows: {
                    type: 'array',
                    rest: true,
                    description: 'The rows to push into the grid.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'rows',
                    ],
                },
            ],
            examples: [
                'let { push-rows } = import("Grid");\npush-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ["Nazanin", "mother", 40])',
            ],
            hideOperatorForm: true,
        },
        'unshift-rows': {
            category: 'Grid',
            description: 'Unshifts the specified rows into the grid `g` and returns the new grid.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to unshift rows into.',
                },
                rows: {
                    type: 'array',
                    rest: true,
                    description: 'The rows to unshift into the grid.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'rows',
                    ],
                },
            ],
            examples: [
                'let { unshift-rows } = import("Grid");\nunshift-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ["Nazanin", "mother", 40])',
            ],
            hideOperatorForm: true,
        },
        'pop-row': {
            category: 'Grid',
            description: 'Pops the last row from the grid `g` and returns the new grid.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to pop a row from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { pop-row } = import("Grid");\npop-row([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
            ],
        },
        'shift-row': {
            category: 'Grid',
            description: 'Shifts the first row from the grid `g` and returns the new grid.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to shift a row from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { shift-row } = import("Grid");\nshift-row([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
            ],
        },
        'push-cols': {
            category: 'Grid',
            description: 'Pushes the specified columns into the grid `g` and returns the new grid.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to push columns into.',
                },
                cols: {
                    type: 'array',
                    rest: true,
                    description: 'The columns to push into the grid.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'cols',
                    ],
                },
            ],
            examples: [
                'let { push-cols } = import("Grid");\npush-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ["f", "m", "s"])',
            ],
            hideOperatorForm: true,
        },
        'unshift-cols': {
            category: 'Grid',
            description: 'Unshifts the specified columns into the grid `g` and returns the new grid.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to unshift columns into.',
                },
                cols: {
                    type: 'array',
                    rest: true,
                    description: 'The columns to unshift into the grid.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                        'cols',
                    ],
                },
            ],
            examples: [
                'let { unshift-cols } = import("Grid");\nunshift-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ["f", "m", "s"])',
            ],
            hideOperatorForm: true,
        },
        'pop-col': {
            category: 'Grid',
            description: 'Pops the last column from the grid `g` and returns the new grid.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to pop a column from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { pop-col } = import("Grid");\npop-col([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
            ],
        },
        'shift-col': {
            category: 'Grid',
            description: 'Shifts the first column from the grid `g` and returns the new grid.',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to shift a column from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'g',
                    ],
                },
            ],
            examples: [
                'let { shift-col } = import("Grid");\nshift-col([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])',
            ],
        },
        'from-array': {
            category: 'Grid',
            description: 'Creates a grid from a flat array with specified dimensions. The array is reshaped into the specified number of rows, and the number of columns is automatically calculated based on the total number of elements in the array.',
            returns: {
                type: 'grid',
            },
            args: {
                a: {
                    type: 'array',
                },
                b: {
                    type: 'number',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { from-array } = import("Grid");\nfrom-array([1, 2, 3, 4], 2)',
                'let { from-array } = import("Grid");\nfrom-array([1, 2, 3, 4], 4)',
            ],
        },
    };

    /**
     * Creates a grid from a flat array with specified dimensions
     *
     * @param flatArray The flat array of values
     * @param rows Number of rows in the resulting grid
     * @returns A 2D array representing the grid
     */
    function fromArray(flatArray, rows) {
        // Create the grid
        var grid = [];
        var cols = flatArray.length / rows;
        // Reshape the flat array into rows and columns
        for (var i = 0; i < rows; i++) {
            var start = i * cols;
            var end = start + cols;
            grid.push(flatArray.slice(start, end));
        }
        return grid;
    }

    function transpose(grid) {
        var result = [];
        for (var i = 0; i < grid[0].length; i += 1) {
            var row = [];
            for (var j = 0; j < grid.length; j += 1) {
                row.push(grid[j][i]);
            }
            result.push(row);
        }
        return result;
    }

    var e_1$5, _a$5;
    var gridFunctions = {
        'every?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_2, _c, e_3, _d;
                var _e = __read(_a, 2), grid = _e[0], predicate = _e[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                try {
                    for (var grid_1 = __values(grid), grid_1_1 = grid_1.next(); !grid_1_1.done; grid_1_1 = grid_1.next()) {
                        var row = grid_1_1.value;
                        try {
                            for (var row_1 = (e_3 = void 0, __values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                                var cell = row_1_1.value;
                                if (!executeFunction(predicate, [cell], contextStack, sourceCodeInfo)) {
                                    return false;
                                }
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (row_1_1 && !row_1_1.done && (_d = row_1.return)) _d.call(row_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (grid_1_1 && !grid_1_1.done && (_c = grid_1.return)) _c.call(grid_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return true;
            },
            arity: toFixedArity(2),
        },
        'some?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_4, _c, e_5, _d;
                var _e = __read(_a, 2), grid = _e[0], predicate = _e[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                try {
                    for (var grid_2 = __values(grid), grid_2_1 = grid_2.next(); !grid_2_1.done; grid_2_1 = grid_2.next()) {
                        var row = grid_2_1.value;
                        try {
                            for (var row_2 = (e_5 = void 0, __values(row)), row_2_1 = row_2.next(); !row_2_1.done; row_2_1 = row_2.next()) {
                                var cell = row_2_1.value;
                                if (executeFunction(predicate, [cell], contextStack, sourceCodeInfo)) {
                                    return true;
                                }
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (row_2_1 && !row_2_1.done && (_d = row_2.return)) _d.call(row_2);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (grid_2_1 && !grid_2_1.done && (_c = grid_2.return)) _c.call(grid_2);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                return false;
            },
            arity: toFixedArity(2),
        },
        'every-row?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_6, _c;
                var _d = __read(_a, 2), grid = _d[0], predicate = _d[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                try {
                    for (var grid_3 = __values(grid), grid_3_1 = grid_3.next(); !grid_3_1.done; grid_3_1 = grid_3.next()) {
                        var row = grid_3_1.value;
                        if (!executeFunction(predicate, [row], contextStack, sourceCodeInfo)) {
                            return false;
                        }
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (grid_3_1 && !grid_3_1.done && (_c = grid_3.return)) _c.call(grid_3);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                return true;
            },
            arity: toFixedArity(2),
        },
        'some-row?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_7, _c;
                var _d = __read(_a, 2), grid = _d[0], predicate = _d[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                try {
                    for (var grid_4 = __values(grid), grid_4_1 = grid_4.next(); !grid_4_1.done; grid_4_1 = grid_4.next()) {
                        var row = grid_4_1.value;
                        if (executeFunction(predicate, [row], contextStack, sourceCodeInfo)) {
                            return true;
                        }
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (grid_4_1 && !grid_4_1.done && (_c = grid_4.return)) _c.call(grid_4);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                return false;
            },
            arity: toFixedArity(2),
        },
        'every-col?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_8, _c;
                var _d = __read(_a, 2), grid = _d[0], predicate = _d[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                var transposed = transpose(grid);
                try {
                    for (var transposed_1 = __values(transposed), transposed_1_1 = transposed_1.next(); !transposed_1_1.done; transposed_1_1 = transposed_1.next()) {
                        var row = transposed_1_1.value;
                        if (!executeFunction(predicate, [row], contextStack, sourceCodeInfo)) {
                            return false;
                        }
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (transposed_1_1 && !transposed_1_1.done && (_c = transposed_1.return)) _c.call(transposed_1);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
                return true;
            },
            arity: toFixedArity(2),
        },
        'some-col?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_9, _c;
                var _d = __read(_a, 2), grid = _d[0], predicate = _d[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                var transposed = transpose(grid);
                try {
                    for (var transposed_2 = __values(transposed), transposed_2_1 = transposed_2.next(); !transposed_2_1.done; transposed_2_1 = transposed_2.next()) {
                        var row = transposed_2_1.value;
                        if (executeFunction(predicate, [row], contextStack, sourceCodeInfo)) {
                            return true;
                        }
                    }
                }
                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                finally {
                    try {
                        if (transposed_2_1 && !transposed_2_1.done && (_c = transposed_2.return)) _c.call(transposed_2);
                    }
                    finally { if (e_9) throw e_9.error; }
                }
                return false;
            },
            arity: toFixedArity(2),
        },
        'row': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), grid = _b[0], row = _b[1];
                assertGrid(grid, sourceCodeInfo);
                assertNumber(row, sourceCodeInfo, { integer: true, nonNegative: true, lt: grid.length });
                return grid[row];
            },
            arity: toFixedArity(2),
        },
        'col': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), grid = _b[0], col = _b[1];
                assertGrid(grid, sourceCodeInfo);
                assertNumber(col, sourceCodeInfo, { integer: true, nonNegative: true, lt: grid[0].length });
                return grid.map(function (row) { return row[col]; });
            },
            arity: toFixedArity(2),
        },
        'shape': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return [grid.length, grid[0].length];
            },
            arity: toFixedArity(1),
        },
        'fill': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), rows = _b[0], cols = _b[1], value = _b[2];
                assertNumber(rows, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(cols, sourceCodeInfo, { integer: true, positive: true });
                assertAny(value, sourceCodeInfo);
                var result = [];
                for (var i = 0; i < rows; i += 1) {
                    var row = [];
                    for (var j = 0; j < cols; j += 1) {
                        row.push(value);
                    }
                    result.push(row);
                }
                return result;
            },
            arity: toFixedArity(3),
        },
        'generate': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), rows = _c[0], cols = _c[1], generator = _c[2];
                var executeFunction = _b.executeFunction;
                assertNumber(rows, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(cols, sourceCodeInfo, { integer: true, positive: true });
                assertFunctionLike(generator, sourceCodeInfo);
                var result = [];
                for (var i = 0; i < rows; i += 1) {
                    var row = [];
                    for (var j = 0; j < cols; j += 1) {
                        var value = executeFunction(generator, [i, j], contextStack, sourceCodeInfo);
                        assertAny(value, sourceCodeInfo);
                        row.push(value);
                    }
                    result.push(row);
                }
                return result;
            },
            arity: toFixedArity(3),
        },
        'reshape': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), grid = _b[0], rows = _b[1];
                assertGrid(grid, sourceCodeInfo);
                assertNumber(rows, sourceCodeInfo, { integer: true, positive: true });
                var flatTable = grid.flat();
                if (flatTable.length % rows !== 0) {
                    throw new LitsError("The number of elements in the grid must be divisible by rows, but got ".concat(flatTable.length, " and ").concat(rows), sourceCodeInfo);
                }
                var cols = flatTable.length / rows;
                var result = [];
                for (var i = 0; i < rows; i += 1) {
                    var row = [];
                    for (var j = 0; j < cols; j += 1) {
                        row.push(flatTable[i * cols + j]);
                    }
                    result.push(row);
                }
                return result;
            },
            arity: toFixedArity(2),
        },
        'transpose': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return transpose(grid);
            },
            arity: toFixedArity(1),
        },
        'flip-h': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return grid.map(function (row) { return row.reverse(); });
            },
            arity: toFixedArity(1),
        },
        'flip-v': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return grid.reverse();
            },
            arity: toFixedArity(1),
        },
        'rotate': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), grid = _b[0], times = _b[1];
                assertGrid(grid, sourceCodeInfo);
                assertNumber(times, sourceCodeInfo, { integer: true });
                // Normalize times to be between 0 and 3
                times = ((times % 4) + 4) % 4;
                // If times is 0, return the original grid
                if (times === 0 || grid.length === 0) {
                    return grid.map(function (row) { return __spreadArray([], __read(row), false); });
                }
                var height = grid.length;
                var width = grid[0].length;
                var result;
                switch (times) {
                    case 1: // 90 degrees clockwise
                        result = Array(width).fill(null).map(function () { return Array(height).fill(null); });
                        for (var y = 0; y < height; y++) {
                            for (var x = 0; x < width; x++) {
                                result[x][height - 1 - y] = grid[y][x];
                            }
                        }
                        break;
                    case 2: // 180 degrees
                        result = Array(height).fill(null).map(function () { return Array(width).fill(null); });
                        for (var y = 0; y < height; y++) {
                            for (var x = 0; x < width; x++) {
                                result[height - 1 - y][width - 1 - x] = grid[y][x];
                            }
                        }
                        break;
                    case 3: // 270 degrees clockwise (or 90 degrees counter-clockwise)
                        result = Array(width).fill(null).map(function () { return Array(height).fill(null); });
                        for (var y = 0; y < height; y++) {
                            for (var x = 0; x < width; x++) {
                                result[width - 1 - x][y] = grid[y][x];
                            }
                        }
                        break;
                }
                return result;
            },
            arity: toFixedArity(2),
        },
        'reverse-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return grid.reverse();
            },
            arity: toFixedArity(1),
        },
        'reverse-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return grid.map(function (row) { return row.reverse(); });
            },
            arity: toFixedArity(1),
        },
        'slice': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), grid = _b[0], start = _b[1], end = _b[2];
                assertGrid(grid, sourceCodeInfo);
                assertVector(start, sourceCodeInfo);
                if (start.length !== 2) {
                    throw new LitsError("The start vector must have 2 elements, but got ".concat(start.length), sourceCodeInfo);
                }
                var _c = __read(start, 2), rowStart = _c[0], colStart = _c[1];
                assertNumber(rowStart, sourceCodeInfo, { integer: true, nonNegative: true, lt: grid.length });
                assertNumber(colStart, sourceCodeInfo, { integer: true, nonNegative: true, lt: grid[0].length });
                end !== null && end !== void 0 ? end : (end = [grid.length, grid[0].length]);
                assertVector(end, sourceCodeInfo);
                if (end.length !== 2) {
                    throw new LitsError("The end vector must have 2 elements, but got ".concat(end.length), sourceCodeInfo);
                }
                var _d = __read(end, 2), rowEnd = _d[0], colEnd = _d[1];
                assertNumber(rowEnd, sourceCodeInfo, { gt: rowStart, lte: grid.length });
                assertNumber(colEnd, sourceCodeInfo, { gt: colStart, lte: grid[0].length });
                var result = [];
                for (var i = rowStart; i < rowEnd; i += 1) {
                    var row = [];
                    for (var j = colStart; j < colEnd; j += 1) {
                        row.push(grid[i][j]);
                    }
                    result.push(row);
                }
                return result;
            },
            arity: { min: 2, max: 3 },
        },
        'slice-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), grid = _b[0], rowStart = _b[1], rowEnd = _b[2];
                assertGrid(grid, sourceCodeInfo);
                if (typeof rowEnd === 'undefined') {
                    assertNumber(rowStart, sourceCodeInfo, { integer: true, lte: grid.length, gte: -grid.length });
                    if (rowStart < 0) {
                        return grid.slice(grid.length + rowStart);
                    }
                    return grid.slice(rowStart);
                }
                assertNumber(rowStart, sourceCodeInfo, { integer: true, nonNegative: true, lte: grid.length });
                assertNumber(rowEnd, sourceCodeInfo, { integer: true });
                rowEnd = rowEnd < 0 ? grid.length + rowEnd : rowEnd;
                assertNumber(rowEnd, sourceCodeInfo, { gt: rowStart, lte: grid.length });
                return grid.slice(rowStart, rowEnd);
            },
            arity: { min: 2, max: 3 },
        },
        'slice-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), grid = _b[0], colStart = _b[1], colEnd = _b[2];
                assertGrid(grid, sourceCodeInfo);
                var trMatrix = transpose(grid);
                if (typeof colEnd === 'undefined') {
                    assertNumber(colStart, sourceCodeInfo, { integer: true, lte: trMatrix.length, gte: -trMatrix.length });
                    if (colStart < 0) {
                        return transpose(trMatrix.slice(trMatrix.length + colStart));
                    }
                    return transpose(trMatrix.slice(colStart));
                }
                assertNumber(colStart, sourceCodeInfo, { integer: true, nonNegative: true, lte: trMatrix.length });
                assertNumber(colEnd, sourceCodeInfo, { integer: true });
                colEnd = colEnd < 0 ? trMatrix.length + colEnd : colEnd;
                assertNumber(colEnd, sourceCodeInfo, { gt: colStart, lte: trMatrix.length });
                return transpose(trMatrix.slice(colStart, colEnd));
            },
            arity: { min: 2, max: 3 },
        },
        'splice-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], rowStart = _b[1], rowDeleteCount = _b[2], rows = _b.slice(3);
                assertGrid(grid, sourceCodeInfo);
                assertNumber(rowStart, sourceCodeInfo, { integer: true, nonNegative: true, lte: grid.length });
                assertNumber(rowDeleteCount, sourceCodeInfo, { integer: true, nonNegative: true });
                if (rows.length !== 0) {
                    assertGrid(rows, sourceCodeInfo);
                    rows.every(function (row) {
                        assertArray(row, sourceCodeInfo);
                        if (grid[0].length !== row.length) {
                            throw new LitsError("All rows must have the same length as the number of columns in grid, but got ".concat(row.length), sourceCodeInfo);
                        }
                        return true;
                    });
                }
                var result = [];
                for (var i = 0; i < rowStart; i += 1) {
                    result.push(grid[i]);
                }
                if (rows.length > 0) {
                    result.push.apply(result, __spreadArray([], __read(rows), false));
                }
                for (var i = rowStart + rowDeleteCount; i < grid.length; i += 1) {
                    result.push(grid[i]);
                }
                return result;
            },
            arity: { min: 3 },
        },
        'splice-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], colStart = _b[1], colDeleteCount = _b[2], cols = _b.slice(3);
                assertGrid(grid, sourceCodeInfo);
                var trMatrix = transpose(grid);
                assertNumber(colStart, sourceCodeInfo, { integer: true, nonNegative: true, lte: trMatrix.length });
                assertNumber(colDeleteCount, sourceCodeInfo, { integer: true, nonNegative: true });
                if (cols.length !== 0) {
                    assertGrid(cols, sourceCodeInfo);
                    cols.every(function (row) {
                        assertArray(row, sourceCodeInfo);
                        if (trMatrix[0].length !== row.length) {
                            throw new LitsError("All rows must have the same length as the number of rows in grid, but got ".concat(row.length), sourceCodeInfo);
                        }
                        return true;
                    });
                }
                var result = [];
                for (var i = 0; i < colStart; i += 1) {
                    result.push(trMatrix[i]);
                }
                result.push.apply(result, __spreadArray([], __read(cols), false));
                for (var i = colStart + colDeleteCount; i < trMatrix.length; i += 1) {
                    result.push(trMatrix[i]);
                }
                return transpose(result);
            },
            arity: { min: 3 },
        },
        'concat-rows': {
            evaluate: function (params, sourceCodeInfo) {
                assertArray(params, sourceCodeInfo);
                params.every(function (grid) { return assertGrid(grid, sourceCodeInfo); });
                var cols = params[0][0].length;
                params.slice(1).every(function (grid) {
                    if (grid[0].length !== cols) {
                        throw new LitsError("All matrices must have the same number of columns, but got ".concat(cols, " and ").concat(grid[0].length), sourceCodeInfo);
                    }
                    return true;
                });
                var result = [];
                params.forEach(function (grid) {
                    grid.forEach(function (row) {
                        result.push(row);
                    });
                });
                return result;
            },
            arity: { min: 1 },
        },
        'concat-cols': {
            evaluate: function (params, sourceCodeInfo) {
                assertArray(params, sourceCodeInfo);
                params.every(function (grid) { return assertGrid(grid, sourceCodeInfo); });
                var rows = params[0].length;
                params.slice(1).every(function (grid) {
                    if (grid.length !== rows) {
                        throw new LitsError("All matrices must have the same number of rows, but got ".concat(rows, " and ").concat(grid.length), sourceCodeInfo);
                    }
                    return true;
                });
                var result = [];
                var _loop_1 = function (i) {
                    var row = [];
                    params.forEach(function (grid) {
                        row.push.apply(row, __spreadArray([], __read(grid[i]), false));
                    });
                    result.push(row);
                };
                for (var i = 0; i < rows; i += 1) {
                    _loop_1(i);
                }
                return result;
            },
            arity: { min: 1 },
        },
        'map': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var fn = asFunctionLike(params.at(-1), sourceCodeInfo);
                var grids = params.slice(0, -1);
                assertGrid(grids[0], sourceCodeInfo);
                var rows = grids[0].length;
                var cols = grids[0][0].length;
                grids.slice(1).forEach(function (grid) {
                    assertGrid(grid, sourceCodeInfo);
                    if (grid.length !== rows) {
                        throw new LitsError("All matrices must have the same number of rows, but got ".concat(rows, " and ").concat(grid.length), sourceCodeInfo);
                    }
                    if (grid[0].length !== cols) {
                        throw new LitsError("All matrices must have the same number of columns, but got ".concat(cols, " and ").concat(grid[0].length), sourceCodeInfo);
                    }
                });
                var result = [];
                var _loop_2 = function (i) {
                    var row = [];
                    var _loop_3 = function (j) {
                        var args = grids.map(function (grid) { return grid[i][j]; });
                        row.push(asAny(executeFunction(fn, args, contextStack, sourceCodeInfo)));
                    };
                    for (var j = 0; j < cols; j += 1) {
                        _loop_3(j);
                    }
                    result.push(row);
                };
                for (var i = 0; i < rows; i += 1) {
                    _loop_2(i);
                }
                return result;
            },
            arity: { min: 2 },
        },
        'mapi': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), grid = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var rows = grid.length;
                var cols = grid[0].length;
                var result = [];
                for (var i = 0; i < rows; i += 1) {
                    var row = [];
                    for (var j = 0; j < cols; j += 1) {
                        row.push(asAny(executeFunction(fn, [grid[i][j], i, j], contextStack, sourceCodeInfo)));
                    }
                    result.push(row);
                }
                return result;
            },
            arity: toFixedArity(2),
        },
        'reduce': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_10, _c, e_11, _d;
                var _e = __read(_a, 3), grid = _e[0], fn = _e[1], initialValue = _e[2];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var accumulator = asAny(initialValue);
                try {
                    for (var grid_5 = __values(grid), grid_5_1 = grid_5.next(); !grid_5_1.done; grid_5_1 = grid_5.next()) {
                        var row = grid_5_1.value;
                        try {
                            for (var row_3 = (e_11 = void 0, __values(row)), row_3_1 = row_3.next(); !row_3_1.done; row_3_1 = row_3.next()) {
                                var cell = row_3_1.value;
                                accumulator = executeFunction(fn, [accumulator, cell], contextStack, sourceCodeInfo);
                            }
                        }
                        catch (e_11_1) { e_11 = { error: e_11_1 }; }
                        finally {
                            try {
                                if (row_3_1 && !row_3_1.done && (_d = row_3.return)) _d.call(row_3);
                            }
                            finally { if (e_11) throw e_11.error; }
                        }
                    }
                }
                catch (e_10_1) { e_10 = { error: e_10_1 }; }
                finally {
                    try {
                        if (grid_5_1 && !grid_5_1.done && (_c = grid_5.return)) _c.call(grid_5);
                    }
                    finally { if (e_10) throw e_10.error; }
                }
                return accumulator;
            },
            arity: toFixedArity(3),
        },
        'reducei': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), grid = _c[0], fn = _c[1], initialValue = _c[2];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var accumulator = asAny(initialValue);
                for (var i = 0; i < grid.length; i += 1) {
                    for (var j = 0; j < grid[i].length; j += 1) {
                        accumulator = executeFunction(fn, [accumulator, grid[i][j], i, j], contextStack, sourceCodeInfo);
                    }
                }
                return accumulator;
            },
            arity: toFixedArity(3),
        },
        'push-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], rows = _b.slice(1);
                assertGrid(grid, sourceCodeInfo);
                assertGrid(rows, sourceCodeInfo);
                if (grid[0].length !== rows[0].length) {
                    throw new LitsError("All rows must have the same length as the number of columns in grid, but got ".concat(grid[0].length, " and ").concat(rows[0].length), sourceCodeInfo);
                }
                return __spreadArray(__spreadArray([], __read(grid), false), __read(rows), false);
            },
            arity: { min: 2 },
        },
        'unshift-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], rows = _b.slice(1);
                assertGrid(grid, sourceCodeInfo);
                assertGrid(rows, sourceCodeInfo);
                if (grid[0].length !== rows[0].length) {
                    throw new LitsError("All rows must have the same length as the number of columns in grid, but got ".concat(grid[0].length, " and ").concat(rows[0].length), sourceCodeInfo);
                }
                return __spreadArray(__spreadArray([], __read(rows), false), __read(grid), false);
            },
            arity: { min: 2 },
        },
        'pop-row': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                if (grid.length === 1) {
                    return null;
                }
                return grid.slice(0, -1);
            },
            arity: toFixedArity(1),
        },
        'shift-row': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                if (grid.length === 1) {
                    return null;
                }
                return grid.slice(1);
            },
            arity: toFixedArity(1),
        },
        'push-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], cols = _b.slice(1);
                assertGrid(grid, sourceCodeInfo);
                assertGrid(cols, sourceCodeInfo);
                if (grid.length !== cols[0].length) {
                    throw new LitsError("All columns must have the same length as the number of rows in grid, but got ".concat(cols.length), sourceCodeInfo);
                }
                var result = [];
                var _loop_4 = function (i) {
                    var row = [];
                    row.push.apply(row, __spreadArray([], __read(grid[i]), false));
                    cols.forEach(function (col) {
                        row.push(col[i]);
                    });
                    result.push(row);
                };
                for (var i = 0; i < grid.length; i += 1) {
                    _loop_4(i);
                }
                return result;
            },
            arity: { min: 2 },
        },
        'unshift-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], cols = _b.slice(1);
                assertGrid(grid, sourceCodeInfo);
                assertGrid(cols, sourceCodeInfo);
                if (grid.length !== cols[0].length) {
                    throw new LitsError("All columns must have the same length as the number of rows in grid, but got ".concat(cols.length), sourceCodeInfo);
                }
                var result = [];
                var _loop_5 = function (i) {
                    var row = [];
                    cols.forEach(function (col) {
                        row.push(col[i]);
                    });
                    row.push.apply(row, __spreadArray([], __read(grid[i]), false));
                    result.push(row);
                };
                for (var i = 0; i < grid.length; i += 1) {
                    _loop_5(i);
                }
                return result;
            },
            arity: { min: 2 },
        },
        'pop-col': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                if (grid[0].length === 1) {
                    return null;
                }
                return grid.map(function (row) { return row.slice(0, -1); });
            },
            arity: toFixedArity(1),
        },
        'shift-col': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                if (grid[0].length === 1) {
                    return null;
                }
                return grid.map(function (row) { return row.slice(1); });
            },
            arity: toFixedArity(1),
        },
        'from-array': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], rows = _b[1];
                assertArray(array, sourceCodeInfo);
                assertNumber(rows, sourceCodeInfo, { integer: true, positive: true });
                if (array.length % rows !== 0) {
                    throw new LitsError("The number of elements in the array must be divisible by rows, but got ".concat(array.length, " and ").concat(rows), sourceCodeInfo);
                }
                return fromArray(array, rows);
            },
            arity: toFixedArity(2),
        },
    };
    try {
        /**
         * The grid namespace containing 2D array manipulation functions.
         */
        for (var _b$5 = __values(Object.entries(namespaceDocs$5)), _c$5 = _b$5.next(); !_c$5.done; _c$5 = _b$5.next()) {
            var _d$5 = __read(_c$5.value, 2), key$5 = _d$5[0], docs$5 = _d$5[1];
            if (gridFunctions[key$5])
                gridFunctions[key$5].docs = docs$5;
        }
    }
    catch (e_1_1) { e_1$5 = { error: e_1_1 }; }
    finally {
        try {
            if (_c$5 && !_c$5.done && (_a$5 = _b$5.return)) _a$5.call(_b$5);
        }
        finally { if (e_1$5) throw e_1$5.error; }
    }
    var gridNamespace = {
        name: 'Grid',
        functions: gridFunctions,
    };

    var namespaceDocs$4 = {
        'random!': {
            category: 'Random',
            description: 'Returns a random number between 0 and 1.',
            returns: {
                type: 'number',
            },
            args: {},
            variants: [
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { random! } = import("Random"); random!()',
            ],
        },
        'random-int!': {
            category: 'Random',
            description: 'Returns a random integer between min and max (exclusive).',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                    description: 'The minimum value.',
                },
                b: {
                    type: 'integer',
                    description: 'The maximum value (exclusive).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { random-int! } = import("Random"); random-int!(0, 10)',
                'let { random-int! } = import("Random"); random-int!(1, 100)',
            ],
        },
        'random-int-inclusive!': {
            category: 'Random',
            description: 'Returns a random integer between min and max (inclusive).',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                    description: 'The minimum value.',
                },
                b: {
                    type: 'integer',
                    description: 'The maximum value (inclusive).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { random-int-inclusive! } = import("Random"); random-int-inclusive!(0, 10)',
            ],
        },
        'random-float!': {
            category: 'Random',
            description: 'Returns a random float between min and max.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'number',
                    description: 'The minimum value.',
                },
                b: {
                    type: 'number',
                    description: 'The maximum value.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { random-float! } = import("Random"); random-float!(0, 10)',
                'let { random-float! } = import("Random"); random-float!(1, 100)',
            ],
        },
        'random-boolean!': {
            category: 'Random',
            description: 'Returns a random boolean.',
            returns: {
                type: 'boolean',
            },
            args: {
                prob: {
                    type: 'number',
                    description: 'The probability of returning true (between 0 and 1).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'prob',
                    ],
                },
            ],
            examples: [
                'let { random-boolean! } = import("Random"); random-boolean!()',
                'let { random-boolean! } = import("Random"); random-boolean!(0.99)',
            ],
        },
        'random-item!': {
            category: 'Random',
            description: 'Returns a random item from the array.',
            returns: {
                type: 'any',
            },
            args: {
                a: {
                    type: 'array',
                    description: 'The array to sample from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                    ],
                },
            ],
            examples: [
                'let { random-item! } = import("Random"); random-item!([1, 2, 3, 4, 5])',
                'let { random-item! } = import("Random"); random-item!(["apple", "banana", "cherry"])',
            ],
        },
        'random-sample-unique!': {
            category: 'Random',
            description: 'Returns a random sample of n unique items from the array.',
            returns: {
                type: 'array',
            },
            args: {
                a: {
                    type: 'array',
                    description: 'The array to sample from.',
                },
                b: {
                    type: 'integer',
                    description: 'The number of items to sample.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { random-sample-unique! } = import("Random"); random-sample-unique!([1, 2, 3, 4, 5], 3)',
                'let { random-sample-unique! } = import("Random"); random-sample-unique!(["apple", "banana", "cherry"], 2)',
            ],
        },
        'random-sample!': {
            category: 'Random',
            description: 'Returns a random sample of n items from the array.',
            returns: {
                type: 'array',
            },
            args: {
                a: {
                    type: 'array',
                    description: 'The array to sample from.',
                },
                b: {
                    type: 'integer',
                    description: 'The number of items to sample.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { random-sample! } = import("Random"); random-sample!([1, 2, 3, 4, 5], 3)',
                'let { random-sample! } = import("Random"); random-sample!(["apple", "banana", "cherry"], 10)',
            ],
        },
        'shuffle!': {
            category: 'Random',
            description: 'Returns a shuffled version of the array.',
            returns: {
                type: 'array',
            },
            args: {
                a: {
                    type: 'array',
                    description: 'The array to shuffle.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                    ],
                },
            ],
            examples: [
                'let { shuffle! } = import("Random"); shuffle!([1, 2, 3, 4, 5])',
                'let { shuffle! } = import("Random"); shuffle!(["apple", "banana", "cherry"])',
            ],
        },
        'random-normal!': {
            category: 'Random',
            description: 'Returns a random number from a normal distribution with the given mean and standard deviation.',
            returns: {
                type: 'number',
            },
            args: {
                mean: {
                    type: 'number',
                    description: 'The mean of the normal distribution.',
                },
                stdDev: {
                    type: 'number',
                    description: 'The standard deviation of the normal distribution.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'mean',
                        'stdDev',
                    ],
                },
            ],
            examples: [
                'let { random-normal! } = import("Random"); random-normal!(0, 1)',
                'let { random-normal! } = import("Random"); random-normal!(5, 2)',
            ],
            hideOperatorForm: true,
        },
        'random-exponential!': {
            category: 'Random',
            description: 'Returns a random number from an exponential distribution with the given rate parameter.',
            returns: {
                type: 'number',
            },
            args: {
                lambda: {
                    type: 'number',
                    description: 'The rate parameter of the exponential distribution.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'lambda',
                    ],
                },
            ],
            examples: [
                'let { random-exponential! } = import("Random"); random-exponential!(1)',
                'let { random-exponential! } = import("Random"); random-exponential!(0.5)',
            ],
        },
        'random-binomial!': {
            category: 'Random',
            description: 'Returns a random number from a binomial distribution with the given number of trials and probability of success.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number of trials.',
                },
                p: {
                    type: 'number',
                    description: 'The probability of success on each trial.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                        'p',
                    ],
                },
            ],
            examples: [
                'let { random-binomial! } = import("Random"); random-binomial!(10, 0.5)',
                'let { random-binomial! } = import("Random"); random-binomial!(20, 0.3)',
            ],
            hideOperatorForm: true,
        },
        'random-poisson!': {
            category: 'Random',
            description: 'Returns a random number from a Poisson distribution with the given rate parameter.',
            returns: {
                type: 'integer',
            },
            args: {
                lambda: {
                    type: 'number',
                    description: 'The rate parameter of the Poisson distribution.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'lambda',
                    ],
                },
            ],
            examples: [
                'let { random-poisson! } = import("Random"); random-poisson!(1)',
                'let { random-poisson! } = import("Random"); random-poisson!(5)',
            ],
        },
        'random-gamma!': {
            category: 'Random',
            description: 'Returns a random number from a gamma distribution with the given shape and scale parameters.',
            returns: {
                type: 'number',
            },
            args: {
                shape: {
                    type: 'number',
                    description: 'The shape parameter of the gamma distribution.',
                },
                scale: {
                    type: 'number',
                    description: 'The scale parameter of the gamma distribution.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'shape',
                        'scale',
                    ],
                },
            ],
            examples: [
                'let { random-gamma! } = import("Random"); random-gamma!(2, 2)',
                'let { random-gamma! } = import("Random"); random-gamma!(5, 1)',
            ],
            hideOperatorForm: true,
        },
        'random-pareto!': {
            category: 'Random',
            description: 'Returns a random number from a Pareto distribution with the given shape parameter.',
            returns: {
                type: 'number',
            },
            args: {
                alpha: {
                    type: 'number',
                    description: 'The shape parameter of the Pareto distribution.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'alpha',
                    ],
                },
            ],
            examples: [
                'let { random-pareto! } = import("Random"); random-pareto!(1)',
                'let { random-pareto! } = import("Random"); random-pareto!(2)',
            ],
        },
        'uuid!': {
            category: 'Random',
            description: 'Returns a random UUID v4 (Universally Unique Identifier).',
            returns: {
                type: 'string',
            },
            args: {},
            variants: [
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { uuid! } = import("Random"); uuid!()',
            ],
        },
        'random-char!': {
            category: 'Random',
            description: 'Returns a random character from the given string.',
            returns: {
                type: 'string',
            },
            args: {
                charSet: {
                    type: 'string',
                    description: 'The string to sample from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'charSet',
                    ],
                },
            ],
            examples: [
                'let { random-char! } = import("Random"); random-char!("abcde")',
                'let { random-char! } = import("Random"); random-char!("ABCDEFGHIJKLMNOPQRSTUVWXYZ")',
            ],
        },
        'random-string!': {
            category: 'Random',
            description: 'Returns a random string of the given length from the given string.',
            returns: {
                type: 'string',
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the random string.',
                },
                charSet: {
                    type: 'string',
                    description: 'The string to sample from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                        'charSet',
                    ],
                },
            ],
            examples: [
                'let { random-string! } = import("Random"); random-string!(10, "abcde")',
                'let { random-string! } = import("Random"); random-string!(5, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")',
            ],
            hideOperatorForm: true,
        },
        'random-id!': {
            category: 'Random',
            description: 'Returns a random ID of the given length.',
            returns: {
                type: 'string',
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the random ID.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { random-id! } = import("Random"); random-id!(10)',
                'let { random-id! } = import("Random"); random-id!(5)',
            ],
        },
        'random-color!': {
            category: 'Random',
            description: 'Returns a random color in hex format.',
            returns: {
                type: 'string',
            },
            args: {},
            variants: [
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { random-color! } = import("Random"); random-color!()',
            ],
        },
    };

    var e_1$4, _a$4;
    var randomFunctions = {
        'random!': {
            evaluate: function () {
                return Math.random();
            },
            arity: toFixedArity(0),
        },
        'random-int!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), min = _b[0], max = _b[1];
                assertNumber(min, sourceCodeInfo, { integer: true });
                assertNumber(max, sourceCodeInfo, { integer: true, gt: min });
                return Math.floor(Math.random() * (max - min)) + min;
            },
            arity: toFixedArity(2),
        },
        'random-int-inclusive!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), min = _b[0], max = _b[1];
                assertNumber(min, sourceCodeInfo, { integer: true });
                assertNumber(max, sourceCodeInfo, { integer: true, gte: min });
                return Math.floor(Math.random() * (max - min + 1)) + min;
            },
            arity: toFixedArity(2),
        },
        'random-float!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), min = _b[0], max = _b[1];
                assertNumber(min, sourceCodeInfo);
                assertNumber(max, sourceCodeInfo, { gt: min });
                return Math.random() * (max - min) + min;
            },
            arity: toFixedArity(2),
        },
        'random-boolean!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), prob = _b[0];
                var probability = prob !== null && prob !== void 0 ? prob : 0.5;
                assertNumber(probability, sourceCodeInfo, { gte: 0, lte: 1 });
                return Math.random() < probability;
            },
            arity: { min: 0, max: 1 },
        },
        'random-item!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), array = _b[0];
                assertArray(array, sourceCodeInfo);
                var index = Math.floor(Math.random() * array.length);
                return asAny(array[index]);
            },
            arity: toFixedArity(1),
        },
        'random-sample!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], n = _b[1];
                assertArray(array, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                if (array.length === 0) {
                    throw new LitsError('Cannot sample from an empty array.', sourceCodeInfo);
                }
                var result = [];
                for (var i = 0; i < n; i++) {
                    // Pick a random index from the array
                    var randomIndex = Math.floor(Math.random() * array.length);
                    // Add the randomly selected item to the result
                    result.push(array[randomIndex]);
                }
                return result;
            },
            arity: toFixedArity(2),
        },
        'random-sample-unique!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], n = _b[1];
                assertArray(array, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true, lte: array.length });
                if (array.length === 0) {
                    throw new LitsError('Cannot sample from an empty array.', sourceCodeInfo);
                }
                var result = [];
                var copyArray = __spreadArray([], __read(array), false);
                for (var i = 0; i < n; i++) {
                    // Pick a random index from the array
                    var randomIndex = Math.floor(Math.random() * copyArray.length);
                    // Add the randomly selected item to the result
                    result.push(copyArray[randomIndex]);
                    // Remove the used item from the copy array
                    copyArray.splice(randomIndex, 1);
                }
                return result;
            },
            arity: toFixedArity(2),
        },
        'shuffle!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a, 1), array = _c[0];
                assertArray(array, sourceCodeInfo);
                var shuffledArray = __spreadArray([], __read(array), false);
                for (var i = shuffledArray.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    _b = __read([shuffledArray[j], shuffledArray[i]], 2), shuffledArray[i] = _b[0], shuffledArray[j] = _b[1];
                }
                return shuffledArray;
            },
            arity: toFixedArity(1),
        },
        'random-normal!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), mean = _b[0], stdDev = _b[1];
                assertNumber(mean, sourceCodeInfo);
                assertNumber(stdDev, sourceCodeInfo, { gt: 0 });
                var u1 = Math.random();
                var u2 = Math.random();
                var z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
                return z0 * stdDev + mean;
            },
            arity: toFixedArity(2),
        },
        'random-exponential!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), lambda = _b[0];
                assertNumber(lambda, sourceCodeInfo, { gt: 0 });
                var u = Math.random();
                return -Math.log(u) / lambda;
            },
            arity: toFixedArity(1),
        },
        'random-binomial!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], p = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                assertNumber(p, sourceCodeInfo, { gte: 0, lte: 1 });
                var k = 0;
                for (var i = 0; i < n; i++) {
                    if (Math.random() < p) {
                        k++;
                    }
                }
                return k;
            },
            arity: toFixedArity(2),
        },
        'random-poisson!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), lambda = _b[0];
                assertNumber(lambda, sourceCodeInfo, { gt: 0 });
                var L = Math.exp(-lambda);
                var k = 0;
                var p = 1;
                do {
                    k++;
                    p *= Math.random();
                } while (p > L);
                return k - 1;
            },
            arity: toFixedArity(1),
        },
        'random-gamma!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), shape = _b[0], scale = _b[1];
                assertNumber(shape, sourceCodeInfo, { gt: 0 });
                assertNumber(scale, sourceCodeInfo, { gt: 0 });
                return randomGamma(shape, scale);
            },
            arity: toFixedArity(2),
        },
        'random-pareto!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), alpha = _b[0];
                assertNumber(alpha, sourceCodeInfo, { gt: 0 });
                var u = Math.random();
                return Math.pow((1 / u), (1 / alpha));
            },
            arity: toFixedArity(1),
        },
        'uuid!': {
            evaluate: function () {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (char) {
                    var random = Math.random() * 16 | 0;
                    var value = char === 'x' ? random : (random & 0x3 | 0x8);
                    return value.toString(16);
                });
            },
            arity: toFixedArity(0),
        },
        'random-char!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), charSet = _b[0];
                assertString(charSet, sourceCodeInfo);
                if (charSet.length === 0) {
                    throw new LitsError('Character set cannot be empty.', sourceCodeInfo);
                }
                var randomIndex = Math.floor(Math.random() * charSet.length);
                return charSet[randomIndex];
            },
            arity: toFixedArity(1),
        },
        'random-string!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), length = _b[0], charSet = _b[1];
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                assertString(charSet, sourceCodeInfo);
                if (charSet.length === 0) {
                    throw new LitsError('Character set cannot be empty.', sourceCodeInfo);
                }
                var result = '';
                for (var i = 0; i < length; i++) {
                    var randomIndex = Math.floor(Math.random() * charSet.length);
                    result += charSet[randomIndex];
                }
                return result;
            },
            arity: toFixedArity(2),
        },
        'random-id!': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), length = _b[0];
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                var result = '';
                for (var i = 0; i < length; i++) {
                    var randomIndex = Math.floor(Math.random() * chars.length);
                    result += chars[randomIndex];
                }
                return result;
            },
            arity: toFixedArity(1),
        },
        'random-color!': {
            evaluate: function () {
                var randomColor = Math.floor(Math.random() * 0x1000000).toString(16);
                return "#".concat(randomColor.padStart(6, '0'));
            },
            arity: toFixedArity(0),
        },
    };
    /**
     * Generates a random number from a gamma distribution
     * @param shape The shape parameter (alpha) - must be positive
     * @param scale The scale parameter (beta) - must be positive
     * @returns A random number following the gamma distribution
     */
    function randomGamma(shape, scale) {
        if (scale === void 0) { scale = 1; }
        // Special case for shape < 1
        if (shape < 1) {
            var d_1 = shape + 1.0 - 1.0 / 3.0;
            return randomGamma(d_1, scale) * Math.pow(Math.random(), (1.0 / shape));
        }
        // Marsaglia and Tsang method for shape >= 1
        var d = shape - 1.0 / 3.0;
        var c = 1.0 / Math.sqrt(9.0 * d);
        var x, v, u;
        while (true) {
            do {
                x = randn(); // Standard normal random variable
                v = 1.0 + c * x;
            } while (v <= 0);
            v = v * v * v;
            u = Math.random();
            if (u < 1.0 - 0.0331 * x * x * x * x) {
                return scale * d * v;
            }
            if (Math.log(u) < 0.5 * x * x + d * (1.0 - v + Math.log(v))) {
                return scale * d * v;
            }
        }
    }
    /**
     * Helper function to generate standard normal random variables
     * using Box-Muller transform
     */
    function randn() {
        var u = 0;
        var v = 0;
        while (u === 0)
            u = Math.random();
        while (v === 0)
            v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    try {
        for (var _b$4 = __values(Object.entries(namespaceDocs$4)), _c$4 = _b$4.next(); !_c$4.done; _c$4 = _b$4.next()) {
            var _d$4 = __read(_c$4.value, 2), key$4 = _d$4[0], docs$4 = _d$4[1];
            if (randomFunctions[key$4])
                randomFunctions[key$4].docs = docs$4;
        }
    }
    catch (e_1_1) { e_1$4 = { error: e_1_1 }; }
    finally {
        try {
            if (_c$4 && !_c$4.done && (_a$4 = _b$4.return)) _a$4.call(_b$4);
        }
        finally { if (e_1$4) throw e_1$4.error; }
    }
    var randomNamespace = {
        name: 'Random',
        functions: randomFunctions,
    };

    var namespaceDocs$3 = {
        'mean': {
            category: 'Vector',
            description: 'Returns the `mean` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `mean` of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { mean } = import("Vector");\nmean([1, 2, 3])',
                'let { mean } = import("Vector");\nmean([1, 2, -3])',
            ],
        },
        'moving-mean': {
            category: 'Vector',
            description: 'Returns the **moving mean** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving mean** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-mean } = import("Vector");\nmoving-mean([1, 2, 3, 4, 5], 3)',
                'let { moving-mean } = import("Vector");\nmoving-mean([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-mean': {
            category: 'Vector',
            description: 'Returns the **centered moving mean** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving mean** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-mean } = import("Vector");\ncentered-moving-mean([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-mean } = import("Vector");\ncentered-moving-mean([1, 2, 3, 4, 5], 3, 0, 10)',
                'let { centered-moving-mean } = import("Vector");\ncentered-moving-mean([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'running-mean': {
            category: 'Vector',
            description: 'Returns the **running mean** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running mean** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-mean } = import("Vector");\nrunning-mean([1, 2, 3, 4, 5])',
            ],
        },
        'geometric-mean': {
            category: 'Vector',
            description: 'Returns the `geometric mean` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `geometric mean` of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { geometric-mean } = import("Vector");\ngeometric-mean([1, 2, 3])',
                'let { geometric-mean } = import("Vector");\ngeometric-mean([1, 2, 9])',
            ],
        },
        'moving-geometric-mean': {
            category: 'Vector',
            description: 'Returns the **moving geometric mean** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving geometric mean** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-geometric-mean } = import("Vector");\nmoving-geometric-mean([1, 2, 3, 4, 5], 3)',
                'let { moving-geometric-mean } = import("Vector");\nmoving-geometric-mean([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-geometric-mean': {
            category: 'Vector',
            description: 'Returns the **centered moving geometric mean** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving geometric mean** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-geometric-mean } = import("Vector");\ncentered-moving-geometric-mean([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-geometric-mean } = import("Vector");\ncentered-moving-geometric-mean([1, 2, 3, 4, 5], 3, 0, 10)',
                'let { centered-moving-geometric-mean } = import("Vector");\ncentered-moving-geometric-mean([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'running-geometric-mean': {
            category: 'Vector',
            description: 'Returns the **running geometric mean** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running geometric mean** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-geometric-mean } = import("Vector");\nrunning-geometric-mean([1, 2, 3, 4, 5])',
            ],
        },
        'harmonic-mean': {
            category: 'Vector',
            description: 'Returns the `harmonic mean` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `harmonic mean` of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { harmonic-mean } = import("Vector");\nharmonic-mean([1, 2, 3])',
                'let { harmonic-mean } = import("Vector");\nharmonic-mean([1, 2, 9])',
            ],
        },
        'moving-harmonic-mean': {
            category: 'Vector',
            description: 'Returns the **moving harmonic mean** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving harmonic mean** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-harmonic-mean } = import("Vector");\nmoving-harmonic-mean([1, 2, 3, 4, 5], 3)',
                'let { moving-harmonic-mean } = import("Vector");\nmoving-harmonic-mean([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-harmonic-mean': {
            category: 'Vector',
            description: 'Returns the **centered moving harmonic mean** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving harmonic mean** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-harmonic-mean } = import("Vector");\ncentered-moving-harmonic-mean([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-harmonic-mean } = import("Vector");\ncentered-moving-harmonic-mean([1, 2, 3, 4, 5], 3, 0, 10)',
                'let { centered-moving-harmonic-mean } = import("Vector");\ncentered-moving-harmonic-mean([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'running-harmonic-mean': {
            category: 'Vector',
            description: 'Returns the **running harmonic mean** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running harmonic mean** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-harmonic-mean } = import("Vector");\nrunning-harmonic-mean([1, 2, 3, 4, 5])',
            ],
        },
        'median': {
            category: 'Vector',
            description: 'Returns the median of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the median of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { median } = import("Vector");\nmedian([1, 2, 3])',
                'let { median } = import("Vector");\nmedian([1, 2, -3])',
                'let { median } = import("Vector");\nmedian([1, 2, 3, 4])',
                'let { median } = import("Vector");\nmedian([1, 2, -3, 4])',
            ],
        },
        'moving-median': {
            category: 'Vector',
            description: 'Returns the **moving median** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving median** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-median } = import("Vector");\nmoving-median([1, 2, 3, 4, 5], 3)',
                'let { moving-median } = import("Vector");\nmoving-median([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-median': {
            category: 'Vector',
            description: 'Returns the **centered moving median** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving median** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-median } = import("Vector");\ncentered-moving-median([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-median } = import("Vector");\ncentered-moving-median([1, 2, 3, 4, 5], 3, 0, 10)',
                'let { centered-moving-median } = import("Vector");\ncentered-moving-median([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'running-median': {
            category: 'Vector',
            description: 'Returns the **running median** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running median** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-median } = import("Vector");\nrunning-median([1, 2, 3, 4, 5])',
            ],
        },
        'variance': {
            category: 'Vector',
            description: 'Returns the `variance` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `variance` of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { variance } = import("Vector");\nvariance([1, 2, 3])',
                'let { variance } = import("Vector");\nvariance([1, 2, -3])',
            ],
        },
        'moving-variance': {
            category: 'Vector',
            description: 'Returns the **moving variance** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving variance** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-variance } = import("Vector");\nmoving-variance([1, 2, 3, 4, 5], 3)',
                'let { moving-variance } = import("Vector");\nmoving-variance([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-variance': {
            category: 'Vector',
            description: 'Returns the **centered moving variance** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving variance** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-variance } = import("Vector");\ncentered-moving-variance([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-variance } = import("Vector");\ncentered-moving-variance([1, 2, 3, 4, 5], 3, 1)',
                'let { centered-moving-variance } = import("Vector");\ncentered-moving-variance([1, 2, 3, 4, 5], 3, 1, 5)',
                'let { centered-moving-variance } = import("Vector");\ncentered-moving-variance([1, 2, 3, 4, 5], 3, 0, 6)',
            ],
        },
        'running-variance': {
            category: 'Vector',
            description: 'Returns the **running variance** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running variance** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-variance } = import("Vector");\nrunning-variance([1, 2, 3, 4, 5])',
            ],
        },
        'sample-variance': {
            category: 'Vector',
            description: 'Returns the sample variance of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the sample variance of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { sample-variance } = import("Vector");\nsample-variance([1, 2, 3])',
                'let { sample-variance } = import("Vector");\nsample-variance([1, 2, -3])',
                'let { sample-variance } = import("Vector");\nsample-variance([1, 2, 3, 4])',
                'let { sample-variance } = import("Vector");\nsample-variance([1, 2, -3, 4])',
                'let { sample-variance } = import("Vector");\nsample-variance([1, 2, 3, 40, 50])',
            ],
        },
        'moving-sample-variance': {
            category: 'Vector',
            description: 'Returns the **moving sample variance** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample variance** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-sample-variance } = import("Vector");\nmoving-sample-variance([1, 2, 3, 4, 5], 3)',
                'let { moving-sample-variance } = import("Vector");\nmoving-sample-variance([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-sample-variance': {
            category: 'Vector',
            description: 'Returns the **centered moving sample variance** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample variance** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-sample-variance } = import("Vector");\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-sample-variance } = import("Vector");\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3, 1)',
                'let { centered-moving-sample-variance } = import("Vector");\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3, 1, 5)',
                'let { centered-moving-sample-variance } = import("Vector");\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3, 0, 6)',
            ],
        },
        'running-sample-variance': {
            category: 'Vector',
            description: 'Returns the **running sample variance** of the `vector`.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample variance** of. First element in result is `null` since **sample variance** is not defined for a single element.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-sample-variance } = import("Vector");\nrunning-sample-variance([1, 2, 3, 4, 5])',
            ],
        },
        'stdev': {
            category: 'Vector',
            description: 'Returns the standard deviation of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the standard deviation of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { stdev } = import("Vector");\nstdev([1, 2, 3])',
                'let { stdev } = import("Vector");\nstdev([1, 2, -3])',
                'let { stdev } = import("Vector");\nstdev([1, 2, 3, 4])',
                'let { stdev } = import("Vector");\nstdev([1, 2, -3, 4])',
                'let { stdev } = import("Vector");\nstdev([1, 2, 3, 40, 50])',
            ],
        },
        'moving-stdev': {
            category: 'Vector',
            description: 'Returns the **moving standard deviation** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving standard deviation** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-stdev } = import("Vector");\nmoving-stdev([1, 2, 3, 4, 5], 3)',
                'let { moving-stdev } = import("Vector");\nmoving-stdev([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-stdev': {
            category: 'Vector',
            description: 'Returns the **centered moving standard deviation** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving standard deviation** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-stdev } = import("Vector");\ncentered-moving-stdev([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-stdev } = import("Vector");\ncentered-moving-stdev([1, 2, 3, 4, 5], 3, 1)',
                'let { centered-moving-stdev } = import("Vector");\ncentered-moving-stdev([1, 2, 3, 4, 5], 3, 1, 5)',
                'let { centered-moving-stdev } = import("Vector");\ncentered-moving-stdev([1, 2, 3, 4, 5], 3, 0, 6)',
            ],
        },
        'running-stdev': {
            category: 'Vector',
            description: 'Returns the **running standard deviation** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running standard deviation** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-stdev } = import("Vector");\nrunning-stdev([1, 2, 3, 4, 5])',
            ],
        },
        'sample-stdev': {
            category: 'Vector',
            description: 'Returns the sample standard deviation of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the sample standard deviation of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { sample-stdev } = import("Vector");\nsample-stdev([1, 2, 3])',
                'let { sample-stdev } = import("Vector");\nsample-stdev([1, 2, -3])',
                'let { sample-stdev } = import("Vector");\nsample-stdev([1, 2, 3, 4])',
                'let { sample-stdev } = import("Vector");\nsample-stdev([1, 2, -3, 4])',
                'let { sample-stdev } = import("Vector");\nsample-stdev([1, 2, 3, 40, 50])',
            ],
        },
        'moving-sample-stdev': {
            category: 'Vector',
            description: 'Returns the **moving sample standard deviation** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample standard deviation** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-sample-stdev } = import("Vector");\nmoving-sample-stdev([1, 2, 3, 4, 5], 3)',
                'let { moving-sample-stdev } = import("Vector");\nmoving-sample-stdev([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-sample-stdev': {
            category: 'Vector',
            description: 'Returns the **centered moving sample standard deviation** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample standard deviation** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-sample-stdev } = import("Vector");\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-sample-stdev } = import("Vector");\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 1)',
                'let { centered-moving-sample-stdev } = import("Vector");\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 1, 5)',
                'let { centered-moving-sample-stdev } = import("Vector");\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 0, 6)',
            ],
        },
        'running-sample-stdev': {
            category: 'Vector',
            description: 'Returns the **running sample standard deviation** of the `vector`.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample standard deviation** of. First element in result is `null` since **sample standard deviation** is not defined for a single element.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-sample-stdev } = import("Vector");\nrunning-sample-stdev([1, 2, 3, 4, 5])',
            ],
        },
        'iqr': {
            category: 'Vector',
            description: 'Calculates the **interquartile range** of a `vector`. Returns the difference between the third and first quartiles.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **interquartile range** of. Minimum length is 4.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { iqr } = import("Vector");\niqr([1, 2, 3, 4])',
                'let { iqr } = import("Vector");\niqr([5, 4, 3, 2, 1, 2, 3, 4, 5])',
                'let { iqr } = import("Vector");\niqr(range(1, 1000))',
                'let { iqr, generate } = import("Vector");\niqr(generate(1000, -> 1e6 / ($ + 1) ^ 2))',
                'let { iqr, generate } = import("Vector");\niqr(generate(1000, -> ln($ + 1)))',
            ],
        },
        'moving-iqr': {
            category: 'Vector',
            description: 'Calculates the **moving interquartile range** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving interquartile range** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-iqr } = import("Vector");\nmoving-iqr([1, 2, 4, 7, 11, 16], 4)',
                'let { moving-iqr } = import("Vector");\nmoving-iqr([1, 2, 4, 7, 11, 16], 5)',
                'let { moving-iqr } = import("Vector");\nmoving-iqr([1, 2, 4, 7, 11, 16], 6)',
            ],
        },
        'centered-moving-iqr': {
            category: 'Vector',
            description: 'Calculates the **centered moving interquartile range** of a `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving interquartile range** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-iqr } = import("Vector");\ncentered-moving-iqr([1, 2, 4, 7, 11, 16], 4)',
                'let { centered-moving-iqr } = import("Vector");\ncentered-moving-iqr([1, 2, 4, 7, 11, 16], 4, 0, 0)',
            ],
        },
        'running-iqr': {
            category: 'Vector',
            description: 'Calculates the **running interquartile range** of a `vector`. First three element in result is `null` since **running interquartile range** is not defined for less than four elements.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running interquartile range** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-iqr } = import("Vector");\nrunning-iqr([1, 2, 3, 4, 5, 6])',
                'let { running-iqr } = import("Vector");\nrunning-iqr([-1, -2, -3, 1, 2, 3])',
            ],
        },
        'sum': {
            category: 'Vector',
            description: 'Returns the sum of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to sum.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { sum } = import("Vector");\nsum([1, 2, 3])',
                'let { sum } = import("Vector");\nsum([1, 2, -3])',
            ],
        },
        'moving-sum': {
            category: 'Vector',
            description: 'Returns the **moving sum** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sum** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-sum } = import("Vector");\nmoving-sum([1, 2, 3, 4, 5], 3)',
                'let { moving-sum } = import("Vector");\nmoving-sum([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-sum': {
            category: 'Vector',
            description: 'Returns the **centered moving sum** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sum** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-sum } = import("Vector");\ncentered-moving-sum([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-sum } = import("Vector");\ncentered-moving-sum([1, 2, 3, 4, 5], 3, 0, 0)',
                'let { centered-moving-sum } = import("Vector");\ncentered-moving-sum([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'running-sum': {
            category: 'Vector',
            description: 'Returns the **running sum** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sum** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-sum } = import("Vector");\nrunning-sum([1, 2, 3])',
                'let { running-sum } = import("Vector");\nrunning-sum([1, -2, -3])',
            ],
        },
        'prod': {
            category: 'Vector',
            description: 'Returns the `product` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `product` of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { prod } = import("Vector");\nprod([1, 2, 3])',
                'let { prod } = import("Vector");\nprod([1, 2, -3])',
            ],
        },
        'moving-prod': {
            category: 'Vector',
            description: 'Returns the **moving product** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving product** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-prod } = import("Vector");\nmoving-prod([1, 2, 3, 4, 5], 3)',
                'let { moving-prod } = import("Vector");\nmoving-prod([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-prod': {
            category: 'Vector',
            description: 'Returns the **centered moving product** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving product** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-prod } = import("Vector");\ncentered-moving-prod([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-prod } = import("Vector");\ncentered-moving-prod([1, 2, 3, 4, 5], 3, 0, 0)',
            ],
        },
        'running-prod': {
            category: 'Vector',
            description: 'Returns the **running product** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running product** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-prod } = import("Vector");\nrunning-prod([1, 2, 3, 4, 5])',
                'let { running-prod } = import("Vector");\nrunning-prod([1, -2, -3])',
            ],
        },
        'min': {
            category: 'Vector',
            description: 'Returns the minimum value of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the minimum of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                '// Using "as" alias because "min" shadows a builtin function\nlet { min as vec-min } = import("Vector");\nvec-min([1, 2, 3])',
                '// Using "as" alias because "min" shadows a builtin function\nlet { min as vec-min } = import("Vector");\nvec-min([1, 1, 2, 3, 3])',
                '// Using "as" alias because "min" shadows a builtin function\nlet { min as vec-min } = import("Vector");\nvec-min([1, 2, -3])',
                '// Using "as" alias because "min" shadows a builtin function\nlet { min as vec-min } = import("Vector");\nvec-min([1, 2, 3, 4])',
                '// Using "as" alias because "min" shadows a builtin function\nlet { min as vec-min } = import("Vector");\nvec-min([1, 2, -3, 4])',
            ],
        },
        'moving-min': {
            category: 'Vector',
            description: 'Returns the **moving minimum** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving minimum** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-min } = import("Vector");\nmoving-min([1, 2, 3, 4, 5], 3)',
                'let { moving-min } = import("Vector");\nmoving-min([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-min': {
            category: 'Vector',
            description: 'Returns the **centered moving minimum** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving minimum** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-min } = import("Vector");\ncentered-moving-min([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-min } = import("Vector");\ncentered-moving-min([1, 2, 3, 4, 5], 3, 0, 100)',
                'let { centered-moving-min } = import("Vector");\ncentered-moving-min([1, 2, 3, 4, 5], 3, 0)',
            ],
        },
        'running-min': {
            category: 'Vector',
            description: 'Returns the **running minimum** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running minimum** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-min } = import("Vector");\nrunning-min([1, 2, 3])',
                'let { running-min } = import("Vector");\nrunning-min([1, -2, -3])',
            ],
        },
        'max': {
            category: 'Vector',
            description: 'Returns the maximum value of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the maximum of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                '// Using "as" alias because "max" shadows a builtin function\nlet { max as vec-max } = import("Vector");\nvec-max([1, 2, 3])',
                '// Using "as" alias because "max" shadows a builtin function\nlet { max as vec-max } = import("Vector");\nvec-max([1, 1, 2, 3, 3])',
                '// Using "as" alias because "max" shadows a builtin function\nlet { max as vec-max } = import("Vector");\nvec-max([1, 2, -3])',
                '// Using "as" alias because "max" shadows a builtin function\nlet { max as vec-max } = import("Vector");\nvec-max([1, 2, 3, 4])',
                '// Using "as" alias because "max" shadows a builtin function\nlet { max as vec-max } = import("Vector");\nvec-max([1, 2, -3, 4])',
            ],
        },
        'moving-max': {
            category: 'Vector',
            description: 'Returns the **moving maximum** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving maximum** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-max } = import("Vector");\nmoving-max([1, 2, 3, 4, 5], 3)',
                'let { moving-max } = import("Vector");\nmoving-max([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-max': {
            category: 'Vector',
            description: 'Returns the **centered moving maximum** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving maximum** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-max } = import("Vector");\ncentered-moving-max([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-max } = import("Vector");\ncentered-moving-max([1, 2, 3, 4, 5], 3, 0, 100)',
                'let { centered-moving-max } = import("Vector");\ncentered-moving-max([1, 2, 3, 4, 5], 3, 0)',
            ],
        },
        'running-max': {
            category: 'Vector',
            description: 'Returns the **running maximum** of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running maximum** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-max } = import("Vector");\nrunning-max([1, 2, 3])',
                'let { running-max } = import("Vector");\nrunning-max([1, -2, -3])',
            ],
        },
        'span': {
            category: 'Vector',
            description: 'Returns the difference between the maximum and minimum values in a vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the span of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { span } = import("Vector");\nspan([1, 2, 3])',
                'let { span } = import("Vector");\nspan([1, 1, 2, 3, 3])',
                'let { span } = import("Vector");\nspan([1, 2, -3])',
            ],
        },
        'moving-span': {
            category: 'Vector',
            description: 'Calculates the **moving span** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving span** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-span } = import("Vector");\nmoving-span([1, 2, 4, 7, 11, 16], 4)',
                'let { moving-span } = import("Vector");\nmoving-span([1, 2, 4, 7, 11, 16], 5)',
                'let { moving-span } = import("Vector");\nmoving-span([1, 2, 4, 7, 11, 16], 6)',
            ],
        },
        'centered-moving-span': {
            category: 'Vector',
            description: 'Calculates the **centered moving span** of a `vector` with a given window size. The result is padded with `leftPadding` on the left and right.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving span** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'The value to pad the result with on the left.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'The value to pad the result with on the right.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-span } = import("Vector");\ncentered-moving-span([1, 2, 4, 7, 11, 16], 4)',
                'let { centered-moving-span } = import("Vector");\ncentered-moving-span([1, 2, 4, 7, 11, 16], 3, 0, 100)',
            ],
        },
        'running-span': {
            category: 'Vector',
            description: 'Calculates the **running span** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running span** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-span } = import("Vector");\nrunning-span([1, 2, 4])',
            ],
        },
        'skewness': {
            category: 'Vector',
            description: 'Calculates the **skewness** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **skewness** of. Minimum length is 3.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { skewness } = import("Vector");\nskewness([1, 2, 3, 6, 20])',
                'let { skewness } = import("Vector");\nskewness([1, 2, 2, 3])',
            ],
        },
        'moving-skewness': {
            category: 'Vector',
            description: 'Calculates the **moving skewness** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving skewness** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-skewness } = import("Vector");\nmoving-skewness([1, 2, 4, 7, 11, 16], 4)',
                'let { moving-skewness } = import("Vector");\nmoving-skewness([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'centered-moving-skewness': {
            category: 'Vector',
            description: 'Calculates the **centered moving skewness** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving skewness** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-skewness } = import("Vector");\ncentered-moving-skewness([1, 2, 4, 7, 11, 16], 4)',
                'let { centered-moving-skewness } = import("Vector");\ncentered-moving-skewness([1, 2, 4, 7, 11, 16], 4, 0, 0)',
            ],
        },
        'running-skewness': {
            category: 'Vector',
            description: 'Calculates the **running skewness** of a `vector` with a given window size. First two element in result is `null` since **running skewness** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running skewness** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-skewness } = import("Vector");\nrunning-skewness([1, 2, 4, 7, 11])',
            ],
        },
        'sample-skewness': {
            category: 'Vector',
            description: 'Calculates the **sample skewness** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **sample skewness** of. Minimum length is 3.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { sample-skewness } = import("Vector");\nsample-skewness([1, 2, 3, 6, 20])',
                'let { sample-skewness } = import("Vector");\nsample-skewness([1, 2, 2, 3])',
            ],
        },
        'moving-sample-skewness': {
            category: 'Vector',
            description: 'Calculates the **moving sample skewness** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample skewness** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-sample-skewness } = import("Vector");\nmoving-sample-skewness([1, 2, 4, 7, 11, 16], 4)',
                'let { moving-sample-skewness } = import("Vector");\nmoving-sample-skewness([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'centered-moving-sample-skewness': {
            category: 'Vector',
            description: 'Calculates the **centered moving sample skewness** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample skewness** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-sample-skewness } = import("Vector");\ncentered-moving-sample-skewness([1, 2, 4, 7, 11, 16], 4)',
                'let { centered-moving-sample-skewness } = import("Vector");\ncentered-moving-sample-skewness([1, 2, 4, 7, 11, 16], 3, 0, 100)',
            ],
        },
        'running-sample-skewness': {
            category: 'Vector',
            description: 'Calculates the **running sample skewness** of a `vector` with a given window size. First two element in result is `null` since **running sample skewness** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample skewness** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-sample-skewness } = import("Vector");\nrunning-sample-skewness([1, 2, 4, 7, 11])',
            ],
        },
        'excess-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **excess kurtosis** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **excess kurtosis** of. Minimum length is 3.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { excess-kurtosis } = import("Vector");\nexcess-kurtosis([1, 2, 3, 6, 20])',
                'let { excess-kurtosis } = import("Vector");\nexcess-kurtosis([1, 2, 2, 3])',
            ],
        },
        'moving-excess-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **moving excess kurtosis** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving excess kurtosis** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-excess-kurtosis } = import("Vector");\nmoving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'let { moving-excess-kurtosis } = import("Vector");\nmoving-excess-kurtosis([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'centered-moving-excess-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **centered moving excess kurtosis** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving excess kurtosis** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-excess-kurtosis } = import("Vector");\ncentered-moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'let { centered-moving-excess-kurtosis } = import("Vector");\ncentered-moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 0)',
            ],
        },
        'running-excess-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **running excess kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running excess kurtosis** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running excess kurtosis** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-excess-kurtosis } = import("Vector");\nrunning-excess-kurtosis([1, 2, 4, 7, 11])',
            ],
        },
        'kurtosis': {
            category: 'Vector',
            description: 'Calculates the **kurtosis** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **kurtosis** of. Minimum length is 3.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { kurtosis } = import("Vector");\nkurtosis([1, 2, 3, 6, 20])',
                'let { kurtosis } = import("Vector");\nkurtosis([1, 2, 2, 3])',
            ],
        },
        'moving-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **moving kurtosis** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving kurtosis** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-kurtosis } = import("Vector");\nmoving-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'let { moving-kurtosis } = import("Vector");\nmoving-kurtosis([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'centered-moving-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **centered moving kurtosis** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving kurtosis** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-kurtosis } = import("Vector");\ncentered-moving-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'let { centered-moving-kurtosis } = import("Vector");\ncentered-moving-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 0)',
            ],
        },
        'running-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **running kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running kurtosis** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running kurtosis** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-kurtosis } = import("Vector");\nrunning-kurtosis([1, 2, 4, 7, 11])',
            ],
        },
        'sample-excess-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **sample excess kurtosis** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **sample excess kurtosis** of. Minimum length is 3.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { sample-excess-kurtosis } = import("Vector");\nsample-excess-kurtosis([1, 2, 3, 6, 20])',
                'let { sample-excess-kurtosis } = import("Vector");\nsample-excess-kurtosis([1, 2, 2, 3])',
            ],
        },
        'moving-sample-excess-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **moving sample excess kurtosis** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample excess kurtosis** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-sample-excess-kurtosis } = import("Vector");\nmoving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'let { moving-sample-excess-kurtosis } = import("Vector");\nmoving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'centered-moving-sample-excess-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **centered moving sample excess kurtosis** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample excess kurtosis** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-sample-excess-kurtosis } = import("Vector");\ncentered-moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'let { centered-moving-sample-excess-kurtosis } = import("Vector");\ncentered-moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 100)',
            ],
        },
        'running-sample-excess-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **running sample excess kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running sample excess kurtosis** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample excess kurtosis** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-sample-excess-kurtosis } = import("Vector");\nrunning-sample-excess-kurtosis([1, 2, 4, 7, 11])',
            ],
        },
        'sample-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **sample kurtosis** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **sample kurtosis** of. Minimum length is 3.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { sample-kurtosis } = import("Vector");\nsample-kurtosis([1, 2, 3, 6, 20])',
                'let { sample-kurtosis } = import("Vector");\nsample-kurtosis([1, 2, 2, 3])',
            ],
        },
        'moving-sample-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **moving sample kurtosis** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample kurtosis** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-sample-kurtosis } = import("Vector");\nmoving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'let { moving-sample-kurtosis } = import("Vector");\nmoving-sample-kurtosis([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'centered-moving-sample-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **centered moving sample kurtosis** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample kurtosis** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-sample-kurtosis } = import("Vector");\ncentered-moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'let { centered-moving-sample-kurtosis } = import("Vector");\ncentered-moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 100)',
            ],
        },
        'running-sample-kurtosis': {
            category: 'Vector',
            description: 'Calculates the **running sample kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running sample kurtosis** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample kurtosis** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-sample-kurtosis } = import("Vector");\nrunning-sample-kurtosis([1, 2, 4, 7, 11])',
            ],
        },
        'rms': {
            category: 'Vector',
            description: 'Calculates the **root mean square** of a `vector`. Returns the square root of the average of the squares of the elements.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **root mean square** of. Minimum length is 1.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { rms } = import("Vector");\nrms([1, 2, 3, 4])',
                'let { rms } = import("Vector");\nrms([5, 4, 3, 2, 1])',
                'let { rms } = import("Vector");\nrms(range(1, 1000))',
                'let { rms, generate } = import("Vector");\nrms(generate(1000, -> 1e6 / ($ + 1) ^ 2))',
                'let { rms, generate } = import("Vector");\nrms(generate(1000, -> ln($ + 1)))',
            ],
        },
        'moving-rms': {
            category: 'Vector',
            description: 'Calculates the **moving root mean square** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving root mean square** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-rms } = import("Vector");\nmoving-rms([1, 2, 4, 7, 11, 16], 4)',
                'let { moving-rms } = import("Vector");\nmoving-rms([1, 2, 4, 7, 11, 16], 5)',
                'let { moving-rms } = import("Vector");\nmoving-rms([1, 2, 4, 7, 11, 16], 6)',
            ],
        },
        'centered-moving-rms': {
            category: 'Vector',
            description: 'Calculates the **centered moving root mean square** of a `vector` with a given window size and padding value.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving root mean square** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-rms } = import("Vector");\ncentered-moving-rms([1, 2, 4, 7, 11, 16], 4)',
                'let { centered-moving-rms } = import("Vector");\ncentered-moving-rms([1, 2, 4, 7, 11, 16], 5, 0)',
                'let { centered-moving-rms } = import("Vector");\ncentered-moving-rms([1, 2, 4, 7, 11, 16], 6, 0, 0)',
            ],
        },
        'running-rms': {
            category: 'Vector',
            description: 'Calculates the **running root mean square** of a `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running root mean square** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-rms } = import("Vector");\nrunning-rms([1, 2, 3, 4, 5, 6])',
                'let { running-rms } = import("Vector");\nrunning-rms([1, -3, 2])',
                'let { running-rms } = import("Vector");\nrunning-rms([-1, -2, -3])',
                'let { running-rms } = import("Vector");\nrunning-rms([0])',
            ],
        },
        'mad': {
            category: 'Vector',
            description: 'Returns the `mean absolute deviation` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `mean absolute deviation` of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { mad } = import("Vector");\nmad([1, 2, 3])',
                'let { mad } = import("Vector");\nmad([1, 2, -3])',
            ],
        },
        'moving-mad': {
            category: 'Vector',
            description: 'Returns the `moving mean absolute deviation` of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `moving mean absolute deviation` of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-mad } = import("Vector");\nmoving-mad([1, 2, 3, 4, 5], 3)',
                'let { moving-mad } = import("Vector");\nmoving-mad([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-mad': {
            category: 'Vector',
            description: 'Returns the `centered moving mean absolute deviation` of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `centered moving mean absolute deviation` of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-mad } = import("Vector");\ncentered-moving-mad([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-mad } = import("Vector");\ncentered-moving-mad([1, 2, 3, 4, 5], 5)',
            ],
        },
        'running-mad': {
            category: 'Vector',
            description: 'Returns the `running mean absolute deviation` of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `running mean absolute deviation` of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-mad } = import("Vector");\nrunning-mad([1, 2, 3])',
                'let { running-mad } = import("Vector");\nrunning-mad([1, 2, -3])',
            ],
        },
        'medad': {
            category: 'Vector',
            description: 'Returns the `median absolute deviation` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `median absolute deviation` of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { medad } = import("Vector");\nmedad([1, 2, 3])',
                'let { medad } = import("Vector");\nmedad([1, 2, -3])',
            ],
        },
        'moving-medad': {
            category: 'Vector',
            description: 'Returns the `moving median absolute deviation` of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `moving median absolute deviation` of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-medad } = import("Vector");\nmoving-medad([1, 2, 3, 4, 5], 3)',
                'let { moving-medad } = import("Vector");\nmoving-medad([1, 2, 3, 4, 5], 5)',
            ],
        },
        'centered-moving-medad': {
            category: 'Vector',
            description: 'Returns the `centered moving median absolute deviation` of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `centered moving median absolute deviation` of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-medad } = import("Vector");\ncentered-moving-medad([1, 2, 3, 4, 5], 3)',
                'let { centered-moving-medad } = import("Vector");\ncentered-moving-medad([1, 2, 3, 4, 5], 5)',
            ],
        },
        'running-medad': {
            category: 'Vector',
            description: 'Returns the `running median absolute deviation` of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `running median absolute deviation` of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-medad } = import("Vector");\nrunning-medad([1, 2, 3])',
                'let { running-medad } = import("Vector");\nrunning-medad([1, 2, -3])',
            ],
        },
        'gini-coefficient': {
            category: 'Vector',
            description: 'Returns the **gini coefficient** of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **gini coefficient** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { gini-coefficient } = import("Vector");\ngini-coefficient([1, 2, 3])',
                'let { gini-coefficient } = import("Vector");\ngini-coefficient([1, 1, 3])',
            ],
        },
        'moving-gini-coefficient': {
            category: 'Vector',
            description: 'Returns the **moving gini coefficient** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving gini coefficient** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-gini-coefficient } = import("Vector");\nmoving-gini-coefficient([1, 2, 3], 2)',
                'let { moving-gini-coefficient } = import("Vector");\nmoving-gini-coefficient([1, 1, 3], 2)',
            ],
        },
        'centered-moving-gini-coefficient': {
            category: 'Vector',
            description: 'Returns the **centered moving gini coefficient** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving gini coefficient** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-gini-coefficient } = import("Vector");\ncentered-moving-gini-coefficient([1, 2, 3], 2)',
                'let { centered-moving-gini-coefficient } = import("Vector");\ncentered-moving-gini-coefficient([1, 1, 3], 2)',
            ],
        },
        'running-gini-coefficient': {
            category: 'Vector',
            description: 'Returns the **running gini coefficient** of the `vector`.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running gini coefficient** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-gini-coefficient } = import("Vector");\nrunning-gini-coefficient([1, 2, 3])',
                'let { running-gini-coefficient } = import("Vector");\nrunning-gini-coefficient([1, 1, 3])',
            ],
        },
        'entropy': {
            category: 'Vector',
            description: 'Calculates the **entropy** of a `vector`. The entropy is a measure of the uncertainty associated with a random variable.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **entropy** of. Minimum length is 1.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { entropy } = import("Vector");\nentropy([1, 1, 2, 3, 3, 3])',
                'let { entropy } = import("Vector");\nentropy([1, 2, 3])',
                'let { entropy } = import("Vector");\nentropy([1, 2, 2, 3])',
                'let { entropy } = import("Vector");\nentropy([0])',
                'let { entropy } = import("Vector");\nentropy([1])',
                'let { entropy } = import("Vector");\nentropy([1, 2])',
            ],
        },
        'moving-entropy': {
            category: 'Vector',
            description: 'Calculates the **moving entropy** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving entropy** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
            ],
            examples: [
                'let { moving-entropy } = import("Vector");\nmoving-entropy([1, 1, 2, 3, 3, 3], 4)',
                'let { moving-entropy } = import("Vector");\nmoving-entropy([1, 1, 2, 3, 3, 3], 3)',
                'let { moving-entropy } = import("Vector");\nmoving-entropy([1, 2], 2)',
            ],
        },
        'centered-moving-entropy': {
            category: 'Vector',
            description: 'Calculates the **centered moving entropy** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving entropy** of.',
                },
                windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                },
                leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                },
                rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                },
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'windowSize',
                        'leftPadding',
                        'rightPadding',
                    ],
                },
            ],
            examples: [
                'let { centered-moving-entropy } = import("Vector");\ncentered-moving-entropy([1, 1, 2, 3, 3, 3], 4)',
                'let { centered-moving-entropy } = import("Vector");\ncentered-moving-entropy([1, 1, 2, 3, 3, 3], 3)',
                'let { centered-moving-entropy } = import("Vector");\ncentered-moving-entropy([1, 2], 2)',
            ],
        },
        'running-entropy': {
            category: 'Vector',
            description: 'Calculates the **running entropy** of a `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running entropy** of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { running-entropy } = import("Vector");\nrunning-entropy([1, 1, 2, 3, 3, 3])',
                'let { running-entropy } = import("Vector");\nrunning-entropy([1, 2])',
            ],
        },
        'monotonic?': {
            category: 'Vector',
            description: 'Checks if a vector is monotonic.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { monotonic? } = import("Vector");\nmonotonic?([1, 2, 3])',
                'let { monotonic? } = import("Vector");\nmonotonic?([1, 2, 2, 3])',
                'let { monotonic? } = import("Vector");\nmonotonic?([3, 2, 1])',
                'let { monotonic? } = import("Vector");\nmonotonic?([3, 2, 1, 1])',
                'let { monotonic? } = import("Vector");\nmonotonic?([3, 2, 1, 2])',
                'let { monotonic? } = import("Vector");\nmonotonic?([1])',
                'let { monotonic? } = import("Vector");\nmonotonic?([])',
            ],
        },
        'strictly-monotonic?': {
            category: 'Vector',
            description: 'Checks if a vector is strictly monotonic.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { strictly-monotonic? } = import("Vector");\nstrictly-monotonic?([1, 2, 3])',
                'let { strictly-monotonic? } = import("Vector");\nstrictly-monotonic?([1, 2, 2, 3])',
                'let { strictly-monotonic? } = import("Vector");\nstrictly-monotonic?([3, 2, 1])',
                'let { strictly-monotonic? } = import("Vector");\nstrictly-monotonic?([3, 2, 1, 1])',
                'let { strictly-monotonic? } = import("Vector");\nstrictly-monotonic?([3, 2, 1, 2])',
                'let { strictly-monotonic? } = import("Vector");\nstrictly-monotonic?([1])',
                'let { strictly-monotonic? } = import("Vector");\nstrictly-monotonic?([])',
            ],
        },
        'increasing?': {
            category: 'Vector',
            description: 'Checks if a vector is increasing.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { increasing? } = import("Vector");\nincreasing?([1, 2, 3])',
                'let { increasing? } = import("Vector");\nincreasing?([1, 2, 2, 3])',
                'let { increasing? } = import("Vector");\nincreasing?([3, 2, 1])',
                'let { increasing? } = import("Vector");\nincreasing?([3, 2, 1, 1])',
                'let { increasing? } = import("Vector");\nincreasing?([3, 2, 1, 2])',
                'let { increasing? } = import("Vector");\nincreasing?([1])',
                'let { increasing? } = import("Vector");\nincreasing?([])',
            ],
        },
        'decreasing?': {
            category: 'Vector',
            description: 'Checks if a vector is decreasing.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { decreasing? } = import("Vector");\ndecreasing?([1, 2, 3])',
                'let { decreasing? } = import("Vector");\ndecreasing?([1, 2, 2, 3])',
                'let { decreasing? } = import("Vector");\ndecreasing?([3, 2, 1])',
                'let { decreasing? } = import("Vector");\ndecreasing?([3, 2, 1, 1])',
                'let { decreasing? } = import("Vector");\ndecreasing?([3, 2, 1, 2])',
                'let { decreasing? } = import("Vector");\ndecreasing?([1])',
                'let { decreasing? } = import("Vector");\ndecreasing?([])',
            ],
        },
        'strictly-increasing?': {
            category: 'Vector',
            description: 'Checks if a vector is strictly increasing.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { strictly-increasing? } = import("Vector");\nstrictly-increasing?([1, 2, 3])',
                'let { strictly-increasing? } = import("Vector");\nstrictly-increasing?([1, 2, 2, 3])',
                'let { strictly-increasing? } = import("Vector");\nstrictly-increasing?([3, 2, 1])',
                'let { strictly-increasing? } = import("Vector");\nstrictly-increasing?([3, 2, 1, 1])',
                'let { strictly-increasing? } = import("Vector");\nstrictly-increasing?([3, 2, 1, 2])',
                'let { strictly-increasing? } = import("Vector");\nstrictly-increasing?([1])',
                'let { strictly-increasing? } = import("Vector");\nstrictly-increasing?([])',
            ],
        },
        'strictly-decreasing?': {
            category: 'Vector',
            description: 'Checks if a vector is strictly decreasing.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { strictly-decreasing? } = import("Vector");\nstrictly-decreasing?([1, 2, 3])',
                'let { strictly-decreasing? } = import("Vector");\nstrictly-decreasing?([1, 2, 2, 3])',
                'let { strictly-decreasing? } = import("Vector");\nstrictly-decreasing?([3, 2, 1])',
                'let { strictly-decreasing? } = import("Vector");\nstrictly-decreasing?([3, 2, 1, 1])',
                'let { strictly-decreasing? } = import("Vector");\nstrictly-decreasing?([3, 2, 1, 2])',
                'let { strictly-decreasing? } = import("Vector");\nstrictly-decreasing?([1])',
                'let { strictly-decreasing? } = import("Vector");\nstrictly-decreasing?([])',
            ],
        },
        'mode': {
            category: 'Vector',
            description: 'Returns the mode of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the mode of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { mode } = import("Vector");\nmode([1, 2, 3])',
                'let { mode } = import("Vector");\nmode([1, 2, -3, 1])',
                'let { mode } = import("Vector");\nmode([2, 2, 3, 3, 4])',
                'let { mode } = import("Vector");\nmode([2, 2, 3, 3])',
                'let { mode } = import("Vector");\nmode([1, 2, 3, 2, 1, 2])',
            ],
        },
        'min-index': {
            category: 'Vector',
            description: 'Returns the index of the minimum value of all elements in the vector.',
            returns: {
                type: 'integer',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the minimum index of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { min-index } = import("Vector");\nmin-index([1, 2, 3])',
                'let { min-index } = import("Vector");\nmin-index([1, 1, 2, 3, 3])',
                'let { min-index } = import("Vector");\nmin-index([1, 2, -3])',
                'let { min-index } = import("Vector");\nmin-index([1, 2, 3, 4])',
                'let { min-index } = import("Vector");\nmin-index([1, 2, -3, 4])',
            ],
        },
        'max-index': {
            category: 'Vector',
            description: 'Returns the index of the maximum value of all elements in the vector.',
            returns: {
                type: 'integer',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the maximum index of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { max-index } = import("Vector");\nmax-index([1, 2, 3])',
                'let { max-index } = import("Vector");\nmax-index([1, 1, 2, 3, 3])',
                'let { max-index } = import("Vector");\nmax-index([1, 2, -3])',
                'let { max-index } = import("Vector");\nmax-index([1, 2, 3, 4])',
                'let { max-index } = import("Vector");\nmax-index([1, 2, -3, 4])',
            ],
        },
        'sort-indices': {
            category: 'Vector',
            description: 'Returns the indices of the elements in the vector sorted in ascending order.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the sorted indices of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { sort-indices } = import("Vector");\nsort-indices([1, 2, 3])',
                'let { sort-indices } = import("Vector");\nsort-indices([1, 1, 2, 3, 3])',
                'let { sort-indices } = import("Vector");\nsort-indices([1, 2, -3])',
                'let { sort-indices } = import("Vector");\nsort-indices([1, 2, 3, 4])',
                'let { sort-indices } = import("Vector");\nsort-indices([1, 2, -3, 4])',
            ],
        },
        'count-values': {
            category: 'Vector',
            description: 'Counts the number of occurrences of each value in the vector.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Vector to count the values of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { count-values } = import("Vector");\ncount-values([1, 2, 3])',
                'let { count-values } = import("Vector");\ncount-values([1, 1, 2, 3, 3])',
                'let { count-values } = import("Vector");\ncount-values([1, 2, -3])',
                'let { count-values } = import("Vector");\ncount-values([1, 2, 2, 1, 3, 2, 4, 2, 1, 2, 2, 1, 3, 2, 4])',
            ],
        },
        'linspace': {
            category: 'Vector',
            description: 'Generates a vector of evenly spaced numbers between two values.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting value.',
                },
                stop: {
                    type: 'number',
                    description: 'The ending value.',
                },
                n: {
                    type: 'integer',
                    description: 'The number of values to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                        'stop',
                        'n',
                    ],
                },
            ],
            examples: [
                'let { linspace } = import("Vector");\nlinspace(0, 10, 6)',
                'let { linspace } = import("Vector");\nlinspace(10, 20, 25)',
            ],
        },
        'ones': {
            category: 'Vector',
            description: 'Generates a vector of ones.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the vector.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { ones } = import("Vector");\nones(5)',
                'let { ones } = import("Vector");\nones(10)',
                'let { ones } = import("Vector");\nones(0)',
            ],
        },
        'zeros': {
            category: 'Vector',
            description: 'Generates a vector of zeros.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the vector.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { zeros } = import("Vector");\nzeros(5)',
                'let { zeros } = import("Vector");\nzeros(10)',
                'let { zeros } = import("Vector");\nzeros(0)',
            ],
        },
        'fill': {
            category: 'Vector',
            description: 'Generates a vector filled with a number.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the vector.',
                },
                value: {
                    type: 'number',
                    description: 'The value to fill the vector with.',
                },
                a: {
                    type: 'number',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                        'value',
                    ],
                },
            ],
            examples: [
                'let { fill } = import("Vector");\nfill(5, PI)',
                'let { fill } = import("Vector");\nfill(10, -1)',
            ],
        },
        'generate': {
            category: 'Vector',
            description: 'Generates a vector of numbers based on a function.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the vector.',
                },
                func: {
                    type: 'function',
                    description: 'A function that takes an index and returns a number.',
                },
                a: {
                    type: 'number',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                        'func',
                    ],
                },
            ],
            examples: [
                'let { generate } = import("Vector");\ngenerate(5, -> $ * 2)',
                'let { generate } = import("Vector");\ngenerate(10, -> $ + 1)',
                'let { generate } = import("Vector");\ngenerate(0, -> $ + 1)',
            ],
        },
        'cumsum': {
            category: 'Vector',
            description: 'Calculates the cumulative sum of a vector.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the cumulative sum of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { cumsum } = import("Vector");\ncumsum([1, 2, 3])',
                'let { cumsum } = import("Vector");\ncumsum([1, 2, -3])',
                'let { cumsum } = import("Vector");\ncumsum([])',
            ],
        },
        'cumprod': {
            category: 'Vector',
            description: 'Calculates the cumulative product of a vector.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the cumulative product of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { cumprod } = import("Vector");\ncumprod([1, 2, 3])',
                'let { cumprod } = import("Vector");\ncumprod([1, 2, -3, 0, 10])',
                'let { cumprod } = import("Vector");\ncumprod([])',
            ],
        },
        'quartiles': {
            category: 'Vector',
            description: 'Calculates the quartiles of a vector. Returns an array containing the first, second (median), and third quartiles.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the quartiles of. Minimum length is 4.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { quartiles } = import("Vector");\nquartiles([1, 2, 3, 4])',
                'let { quartiles } = import("Vector");\nquartiles([5, 4, 3, 2, 1, 2, 3, 4, 5])',
                'let { quartiles } = import("Vector");\nquartiles(range(1, 1000))',
                'let { quartiles, generate } = import("Vector");\nquartiles(generate(1000, -> 1e6 / ($ + 1) ^ 2))',
                'let { quartiles, generate } = import("Vector");\nquartiles(generate(1000, -> ln($ + 1)))',
            ],
        },
        'percentile': {
            category: 'Vector',
            description: 'Calculates the percentile of a vector. Returns the value at the specified percentile.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The non empty vector to calculate the percentile of.',
                },
                percentile: {
                    type: 'number',
                    description: 'The percentile to calculate. Must be between 0 and 1.',
                },
                a: {
                    type: 'number',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'percentile',
                    ],
                },
            ],
            examples: [
                'let { percentile } = import("Vector");\npercentile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 35)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 0)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 10)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 20)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 30)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 40)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 50)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 60)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 70)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 80)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 90)',
                'let { percentile } = import("Vector");\npercentile(range(100) ^ 0.5, 100)',
            ],
        },
        'quantile': {
            category: 'Vector',
            description: 'Calculates the quantile of a vector. Returns the value at the specified quantile.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The non empty vector to calculate the quantile of.',
                },
                quantile: {
                    type: 'number',
                    description: 'The quantile to calculate. Must be between 0 and 1.',
                },
                a: {
                    type: 'number',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'quantile',
                    ],
                },
            ],
            examples: [
                'let { quantile } = import("Vector");\nquantile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0.35)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0.1)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0.2)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0.3)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0.4)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0.5)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0.6)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0.7)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0.8)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 0.9)',
                'let { quantile } = import("Vector");\nquantile(range(100) ^ 0.5, 1)',
            ],
        },
        'histogram': {
            category: 'Vector',
            description: 'Creates a histogram from a numeric `array` by dividing the data range into the specified number of bins. Returns an `array` of `[binStart, binEnd, count]` tuples representing each bin\'s range and the number of values within it. Handles empty arrays, identical values, and properly places maximum values in the last bin.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The numeric array to create a histogram from.',
                },
                bins: {
                    type: 'integer',
                    description: 'The number of bins to divide the data range into.',
                },
                a: {
                    type: 'number',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'bins',
                    ],
                },
            ],
            examples: [
                'let { histogram } = import("Vector");\nhistogram([1, 2, 2, 3, 2, 6, 4, 3, 2, 4, 1, 3, 2, 9], 3)',
                'let { histogram } = import("Vector");\nhistogram([1, 2, 3, 4, 5], 5)',
                'let { histogram } = import("Vector");\nhistogram([1, 2, 3, 4, 5], 10)',
                'let { histogram } = import("Vector");\nhistogram([1, 2, 3, 4, 5], 1)',
            ],
        },
        'ecdf': {
            category: 'Vector',
            description: 'Calculates the empirical cumulative distribution function value for a given threshold in a non empty dataset. Returns the proportion of values in the `array` that are less than or equal to the specified threshold.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The numeric array to calculate the ECDF from.',
                },
                threshold: {
                    type: 'number',
                    description: 'The threshold value to calculate the ECDF for.',
                },
                a: {
                    type: 'number',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'threshold',
                    ],
                },
            ],
            examples: [
                'let { ecdf } = import("Vector");\necdf([1, 2, 2, 3, 2, 6, 4, 3, 2, 4, 1, 3, 2, 9, 10, 12], 5)',
                'let { ecdf } = import("Vector");\necdf([1, 2, 3, 4, 5], 3)',
                'let { ecdf } = import("Vector");\necdf([1, 2, 3, 4, 5], 0)',
                'let { ecdf } = import("Vector");\necdf([1, 2, 3, 4, 5], 10)',
                'let { ecdf } = import("Vector");\necdf([1, 2, 3, 4, 5], 2)',
            ],
        },
        'outliers?': {
            category: 'Vector',
            description: 'Checks if the `vector` contains outliers based on the interquartile range (IQR) method. Returns `true` if outliers are present, `false` otherwise.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to check for outliers.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { outliers? } = import("Vector");\noutliers?([1, 2, 3])',
                'let { outliers? } = import("Vector");\noutliers?([1, 2, -3])',
                'let { outliers? } = import("Vector");\noutliers?([1, 2, 3, 2, 4, 120])',
            ],
        },
        'outliers': {
            category: 'Vector',
            description: 'Identifies outliers in the `vector` based on the interquartile range (IQR) method. Returns an array of outlier values.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to check for outliers.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { outliers } = import("Vector");\noutliers([1, 2, 3])',
                'let { outliers } = import("Vector");\noutliers([1, 2, -3])',
                'let { outliers } = import("Vector");\noutliers([1, 2, 3, 2, 4, 120])',
            ],
        },
        'bincount': {
            category: 'Vector',
            description: 'counts occurrences of each `integer` in a vector, returning an array where index `i` contains the count of value `i`, with optional **minimum size** and **weights parameters**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to count occurrences in.',
                },
                minSize: {
                    type: 'integer',
                    description: 'Optional minimum size of the output array.',
                },
                weights: {
                    type: 'number',
                    array: true,
                    description: 'Optional weights for each element in the vector.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'minSize',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'minSize',
                        'weights',
                    ],
                },
            ],
            examples: [
                'let { bincount } = import("Vector");\nbincount([1, 2, 3])',
                'let { bincount } = import("Vector");\nbincount([1, 2, 2, 3, 3])',
            ],
            hideOperatorForm: true,
        },
        'winsorize': {
            category: 'Vector',
            description: 'Limits extreme values in a `vector` by replacing values below the **lower quantile** and above the **upper quantile** with the values at those quantiles. The function takes a `vector` of values and **quantile thresholds** (between 0 and 1), with the upper quantile. Winsorization reduces the influence of outliers while preserving the overall distribution shape, making statistical analyses more robust.',
            returns: {
                type: 'vector',
            },
            args: {
                'vector': {
                    type: 'vector',
                    description: 'The vector to winsorize.',
                },
                'lower-quantile': {
                    type: 'number',
                    description: 'The lower quantile threshold (between 0 and 1).',
                },
                'upper-quantile': {
                    type: 'number',
                    description: 'Optional Upper quantile threshold (between 0 and 1). Defaults to `(1 - lower-quantile)` if `lower-quantile <= 0.5` otherwise `1`.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'lower-quantile',
                    ],
                },
                {
                    argumentNames: [
                        'vector',
                        'lower-quantile',
                        'upper-quantile',
                    ],
                },
            ],
            examples: [
                'let { winsorize } = import("Vector");\nwinsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25)',
                'let { winsorize } = import("Vector");\nwinsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25, 0.75)',
                'let { winsorize } = import("Vector");\nwinsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25, 0.5)',
            ],
            hideOperatorForm: true,
        },
        'mse': {
            category: 'Vector',
            description: 'Calculates the **Mean Squared Error (MSE)** between two vectors. Returns the average of the squared differences between corresponding elements.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'The first vector.',
                },
                b: {
                    type: 'vector',
                    description: 'The second vector.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { mse } = import("Vector");\nmse([1, 2, 3], [1, 2, 3])',
                'let { mse } = import("Vector");\nmse([1, 2, 3], [4, 5, 6])',
                'let { mse } = import("Vector");\nmse([1, 2, 3], [2, 2, 2])',
                'let { mse } = import("Vector");\nmse([1, 2], [3, 3])',
                'let { mse } = import("Vector");\nmse([1], [3])',
            ],
        },
        'rmse': {
            category: 'Vector',
            description: 'Calculates the **Root Mean Squared Error (RMSE)** between two vectors. Returns the square root of the average of the squared differences between corresponding elements.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'The first vector.',
                },
                b: {
                    type: 'vector',
                    description: 'The second vector.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { rmse } = import("Vector");\nrmse([1, 2, 3], [1, 2, 3])',
                'let { rmse } = import("Vector");\nrmse([1, 2, 3], [4, 5, 6])',
                'let { rmse } = import("Vector");\nrmse([1, 2, 3], [2, 2, 2])',
                'let { rmse } = import("Vector");\nrmse([1, 2], [3, 3])',
                'let { rmse } = import("Vector");\nrmse([1], [3])',
            ],
        },
        'mae': {
            category: 'Vector',
            description: 'Calculates the **Mean Absolute Error (MAE)** between two vectors. Returns the average of the absolute differences between corresponding elements.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'The first vector.',
                },
                b: {
                    type: 'vector',
                    description: 'The second vector.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { mae } = import("Vector");\nmae([1, 2, 3], [1, 2, 3])',
                'let { mae } = import("Vector");\nmae([1, 2, 3], [4, 5, 6])',
                'let { mae } = import("Vector");\nmae([1, 2, 3], [2, 2, 2])',
                'let { mae } = import("Vector");\nmae([1, 2], [3, 3])',
                'let { mae } = import("Vector");\nmae([1], [3])',
            ],
        },
        'smape': {
            category: 'Vector',
            description: 'Calculates the **Symmetric Mean Absolute Percentage Error (SMAPE)** between two vectors. Returns the average of the absolute percentage differences between corresponding elements.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'The first vector.',
                },
                b: {
                    type: 'vector',
                    description: 'The second vector.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { smape } = import("Vector");\nsmape([1, 2, 3], [1, 2, 3])',
                'let { smape } = import("Vector");\nsmape([1, 2, 3], [4, 5, 6])',
                'let { smape } = import("Vector");\nsmape([1, 2, 3], [2, 2, 2])',
                'let { smape } = import("Vector");\nsmape([1, 2], [3, 3])',
                'let { smape } = import("Vector");\nsmape([1], [3])',
            ],
        },
    };

    /**
     * Counts occurrences of each integer value in an array of non-negative integers.
     *
     * @param array - Array of non-negative integers to count
     * @param minLength - Minimum length of the output array (default: 0)
     * @param weights - Optional array of weights (same length as input array)
     * @returns An array where index i contains the count of occurrences of i in the input array
     */
    function bincount(array, minLength, weights) {
        if (minLength === void 0) { minLength = 0; }
        if (array.length === 0) {
            return Array.from({ length: minLength }, function () { return 0; });
        }
        // Find the maximum value to determine output array size
        var maxValue = Math.max.apply(Math, __spreadArray([], __read(array), false));
        var outputLength = Math.max(maxValue + 1, minLength);
        var counts = Array.from({ length: outputLength }, function () { return 0; });
        // Count occurrences (or sum weights if provided)
        for (var i = 0; i < array.length; i++) {
            var value = Math.floor(array[i]);
            if (value < outputLength) {
                // If weights provided, add weight; otherwise add 1
                counts[value] += weights ? weights[i] : 1;
            }
        }
        return counts;
    }

    /**
     * Creates a histogram from an array of numbers, returning bin ranges and counts.
     * Each bin is represented as a tuple of [minValue, maxValue, count].
     *
     * @param vector - Array of numeric values
     * @param bins - Number of bins to divide the data into
     * @returns Array of tuples, each containing [binStart, binEnd, count]
     */
    function calcHistogram(vector, bins) {
        var e_1, _a;
        if (vector.length === 0) {
            // Return empty bins with zero counts if input is empty
            var result = [];
            for (var i = 0; i < bins; i++) {
                result.push([0, 0, 0]);
            }
            return result;
        }
        // Find min and max values
        var min = Math.min.apply(Math, __spreadArray([], __read(vector), false));
        var max = Math.max.apply(Math, __spreadArray([], __read(vector), false));
        // Handle the case where all values are the same
        if (min === max) {
            var result = [];
            // Create bins with the same min/max and zero counts
            for (var i = 0; i < bins; i++) {
                result.push([min, min, 0]);
            }
            // Put all values in the first bin
            result[0][2] = vector.length;
            return result;
        }
        // Calculate bin size
        var binSize = (max - min) / bins;
        // Initialize histogram array with bin boundaries and zero counts
        var histogram = [];
        for (var i = 0; i < bins; i++) {
            var binStart = min + i * binSize;
            var binEnd = i === bins - 1 ? max : min + (i + 1) * binSize;
            histogram.push([binStart, binEnd, 0]);
        }
        try {
            // Count values in each bin
            for (var vector_1 = __values(vector), vector_1_1 = vector_1.next(); !vector_1_1.done; vector_1_1 = vector_1.next()) {
                var value = vector_1_1.value;
                if (value === max) {
                    // Place maximum value in the last bin
                    histogram[bins - 1][2] += 1;
                }
                else {
                    var binIndex = Math.min(Math.floor((value - min) / binSize), bins - 1);
                    histogram[binIndex][2] += 1;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vector_1_1 && !vector_1_1.done && (_a = vector_1.return)) _a.call(vector_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return histogram;
    }

    /**
     * Calculates the mode (most frequent value(s)) of a dataset
     * @param values An array of values of any type
     * @returns An array containing the mode(s) of the dataset
     */
    function mode(values) {
        var e_1, _a, e_2, _b, e_3, _c;
        // Create a frequency map
        var frequencyMap = new Map();
        try {
            // Count occurrences of each value
            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                var value = values_1_1.value;
                frequencyMap.set(value, (frequencyMap.get(value) || 0) + 1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Find the maximum frequency
        var maxFrequency = 0;
        try {
            for (var _d = __values(frequencyMap.values()), _e = _d.next(); !_e.done; _e = _d.next()) {
                var frequency = _e.value;
                if (frequency > maxFrequency) {
                    maxFrequency = frequency;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // If all values appear only once, there is no mode
        if (maxFrequency === 1) {
            return values;
        }
        // Collect all values that appear with the maximum frequency
        var modes = [];
        try {
            for (var _f = __values(frequencyMap.entries()), _g = _f.next(); !_g.done; _g = _f.next()) {
                var _h = __read(_g.value, 2), value = _h[0], frequency = _h[1];
                if (frequency === maxFrequency) {
                    modes.push(value);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return modes;
    }

    /**
     * Checks if a vector has no extreme outliers using the IQR method
     * @param vector An array of numbers to check for extreme outliers
     * @returns true if there are no extreme outliers, false otherwise
     */
    function hasOutliers(vector) {
        return outliers(vector).length > 0;
    }
    function outliers(vector) {
        // Handle edge cases
        if (vector.length <= 1)
            return [];
        // Sort the vector to calculate quartiles
        var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
        // Calculate Q1 (25th percentile)
        var q1Index = Math.floor(sorted.length * 0.25);
        var q1 = sorted.length % 4 === 0
            ? (sorted[q1Index - 1] + sorted[q1Index]) / 2
            : sorted[q1Index];
        // Calculate Q3 (75th percentile)
        var q3Index = Math.floor(sorted.length * 0.75);
        var q3 = sorted.length % 4 === 0
            ? (sorted[q3Index - 1] + sorted[q3Index]) / 2
            : sorted[q3Index];
        // Calculate IQR (Interquartile Range)
        var iqr = q3 - q1;
        // Define bounds for outliers (using 1.5*IQR for mild outliers and 3*IQR for extreme outliers)
        var lowerBound = q1 - iqr * 1.5;
        var upperBound = q3 + iqr * 1.5;
        // Filter the vector to find outliers
        return vector.filter(function (val) { return val < lowerBound || val > upperBound; });
    }

    /**
     * Calculate the percentile value from an array of numbers
     * @param data Array of numbers to calculate percentile from
     * @param percentile The percentile to calculate (0-100)
     * @returns The value at the specified percentile
     */
    function calcPercentile(data, percentile) {
        // Sort the data in ascending order
        var sortedData = __spreadArray([], __read(data), false).sort(function (a, b) { return a - b; });
        // If percentile is 0, return the minimum value
        if (percentile === 0) {
            return sortedData[0];
        }
        // If percentile is 100, return the maximum value
        if (percentile === 100) {
            return sortedData[sortedData.length - 1];
        }
        // Calculate the index
        var index = (percentile / 100) * (sortedData.length - 1);
        // If index is an integer, return the value at that index
        if (Number.isInteger(index)) {
            return sortedData[index];
        }
        // Otherwise, interpolate between the two adjacent values
        var lowerIndex = Math.floor(index);
        var upperIndex = Math.ceil(index);
        var weight = index - lowerIndex;
        return sortedData[lowerIndex] * (1 - weight) + sortedData[upperIndex] * weight;
    }

    function quartiles(vector) {
        var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
        // Median calculation (Q2)
        var midIndex = sorted.length / 2;
        var q2;
        if (sorted.length % 2 === 0) {
            // Even length - average the two middle values
            q2 = (sorted[midIndex - 1] + sorted[midIndex]) / 2;
        }
        else {
            // Odd length - take the middle value
            q2 = sorted[Math.floor(midIndex)];
        }
        // Lower half for Q1
        var lowerHalf = sorted.slice(0, Math.floor(sorted.length / 2));
        // Upper half for Q3
        var upperHalf = sorted.slice(Math.ceil(sorted.length / 2));
        // Calculate Q1 and Q3 using the same median logic on the halves
        var q1, q3;
        if (lowerHalf.length % 2 === 0) {
            var midLower = lowerHalf.length / 2;
            q1 = (lowerHalf[midLower - 1] + lowerHalf[midLower]) / 2;
        }
        else {
            q1 = lowerHalf[Math.floor(lowerHalf.length / 2)];
        }
        if (upperHalf.length % 2 === 0) {
            var midUpper = upperHalf.length / 2;
            q3 = (upperHalf[midUpper - 1] + upperHalf[midUpper]) / 2;
        }
        else {
            q3 = upperHalf[Math.floor(upperHalf.length / 2)];
        }
        return [q1, q2, q3];
    }

    var maxReductionFunction = {
        max: function (vector) { return Math.max.apply(Math, __spreadArray([], __read(vector), false)); },
        padding: -Number.MAX_VALUE,
    };

    function calcMean(vector) {
        if (vector.length === 0) {
            return 0;
        }
        var sum = vector.reduce(function (acc, val) { return acc + val; }, 0);
        return sum / vector.length;
    }

    var meanReductionFunction = {
        mean: function (vector) { return calcMean(vector); },
    };
    var geometricMeanReductionFunction = {
        'geometric-mean': function (vector) {
            if (vector.some(function (val) { return val < 0; })) {
                throw new Error('Geometric mean is not defined for non-positive numbers');
            }
            return Math.exp(vector.reduce(function (acc, val) { return acc + Math.log(val); }, 0) / vector.length);
        },
    };
    var harmonicMeanReductionFunction = {
        'harmonic-mean': function (vector) { return vector.length / vector.reduce(function (acc, val) { return acc + 1 / val; }, 0); },
    };

    function calcMedian(vector) {
        var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
        var mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0
            ? (sorted[mid - 1] + sorted[mid]) / 2
            : sorted[mid];
    }

    var medianReductionFunction = {
        median: function (vector) { return calcMedian(vector); },
    };

    var minReductionFunction = {
        min: function (vector) { return Math.min.apply(Math, __spreadArray([], __read(vector), false)); },
        padding: Number.MAX_VALUE,
    };

    var prodReductionFunction = {
        prod: function (vector) { return vector.reduce(function (acc, val) { return acc * val; }, 1); },
        padding: 1,
        minLength: 0,
    };

    var sumReductionFunction = {
        sum: function (vector) { return vector.reduce(function (acc, val) { return acc + val; }, 0); },
        minLength: 0,
    };

    function calcVariance(vector, optionalMean) {
        var mean = optionalMean !== null && optionalMean !== void 0 ? optionalMean : calcMean(vector);
        return vector.reduce(function (acc, val) { return acc + Math.pow((val - mean), 2); }, 0) / vector.length;
    }
    function calcSampleVariance(vector, optionalMean) {
        var mean = calcMean(vector);
        return vector.reduce(function (acc, val) { return acc + Math.pow((val - mean), 2); }, 0) / (vector.length - 1);
    }

    var varianceReductionFunction = {
        variance: function (vector) { return calcVariance(vector); },
    };
    var sampleVarianceReductionFunction = {
        'sample-variance': function (vector) { return calcSampleVariance(vector); },
        'minLength': 2,
    };

    function calcStdDev(vector, optionalMean) {
        var variance = calcVariance(vector, optionalMean);
        return Math.sqrt(variance);
    }
    function calcSampleStdDev(vector, optionalMean) {
        var variance = calcVariance(vector, optionalMean);
        return Math.sqrt(variance * (vector.length / (vector.length - 1)));
    }

    var stdevReductionFunction = {
        stdev: function (vector) { return calcStdDev(vector); },
    };
    var sampleStdevReductionFunction = {
        'sample-stdev': function (vector) { return calcSampleStdDev(vector); },
        'minLength': 2,
    };

    var iqrReductionFunction = {
        iqr: function (vector) {
            var _a = __read(quartiles(vector), 3), q1 = _a[0], q3 = _a[2];
            return q3 - q1;
        },
        minLength: 4,
    };

    var spanReductionFunction = {
        span: function (vector) { return vector.length === 0 ? 0 : Math.max.apply(Math, __spreadArray([], __read(vector), false)) - Math.min.apply(Math, __spreadArray([], __read(vector), false)); },
        minLength: 0,
    };

    function skewness(vector) {
        var mean = calcMean(vector);
        var stdDev = calcStdDev(vector);
        if (stdDev === 0) {
            throw new Error('Standard deviation is zero, skewness is undefined');
        }
        return vector.reduce(function (acc, val) { return acc + (Math.pow((val - mean), 3)); }, 0) / (vector.length * Math.pow(stdDev, 3));
    }
    function sampleSkewness(vector) {
        var e_1, _a;
        var n = vector.length;
        // Calculate the mean
        var mean = vector.reduce(function (acc, val) { return acc + val; }, 0) / n;
        // Calculate sum of squared differences and sum of cubed differences
        var sumSquaredDiffs = 0;
        var sumCubedDiffs = 0;
        try {
            for (var vector_1 = __values(vector), vector_1_1 = vector_1.next(); !vector_1_1.done; vector_1_1 = vector_1.next()) {
                var val = vector_1_1.value;
                var diff = val - mean;
                sumSquaredDiffs += diff * diff;
                sumCubedDiffs += diff * diff * diff;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vector_1_1 && !vector_1_1.done && (_a = vector_1.return)) _a.call(vector_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Calculate sample standard deviation (using n-1)
        var sampleVariance = sumSquaredDiffs / (n - 1);
        var sampleStdDev = Math.sqrt(sampleVariance);
        // If standard deviation is 0, skewness is undefined
        if (sampleStdDev === 0) {
            throw new Error('Cannot calculate sample skewness when standard deviation is 0');
        }
        // Calculate sample skewness with Fisher's adjustment
        return (n / ((n - 1) * (n - 2))) * sumCubedDiffs / Math.pow(sampleStdDev, 3);
    }
    var skewnessReductionFunction = {
        skewness: function (vector) { return skewness(vector); },
        minLength: 3,
    };
    var sampleSkewnessReductionFunction = {
        'sample-skewness': function (vector) { return sampleSkewness(vector); },
        'minLength': 3,
    };

    function kurtosis(vector) {
        var mean = calcMean(vector);
        var stdDev = calcStdDev(vector);
        if (stdDev === 0) {
            throw new Error('Standard deviation is zero, kurtosis is undefined');
        }
        return vector.reduce(function (acc, val) { return acc + (Math.pow((val - mean), 4)); }, 0) / (vector.length * Math.pow(stdDev, 4));
    }
    function excessKurtosis(vector) {
        return kurtosis(vector) - 3;
    }
    /**
     * Calculates the sample kurtosis (bias-corrected)
     * @param vector Array of numeric values
     * @returns The sample kurtosis
     * @throws Error if sample size is less than 4 or if variance is zero
     */
    function sampleKurtosis(vector) {
        var n = vector.length;
        var mean = vector.reduce(function (sum, val) { return sum + val; }, 0) / n;
        var sumSquaredDeviations = vector.reduce(function (sum, val) { return sum + Math.pow((val - mean), 2); }, 0);
        var variance = sumSquaredDeviations / (n - 1);
        if (variance === 0) {
            throw new Error('Variance is zero, kurtosis is undefined');
        }
        var fourthMomentSum = vector.reduce(function (sum, val) { return sum + Math.pow((val - mean), 4); }, 0);
        // Correct formula for sample kurtosis
        return (n * (n + 1) * fourthMomentSum) / ((n - 1) * (n - 2) * (n - 3) * Math.pow(variance, 2));
    }
    /**
     * Calculates the sample excess kurtosis (bias-corrected)
     * @param vector Array of numeric values
     * @returns The sample excess kurtosis
     * @throws Error if sample size is less than 4 or if variance is zero
     */
    function sampleExcessKurtosis(vector) {
        var n = vector.length;
        var mean = vector.reduce(function (sum, val) { return sum + val; }, 0) / n;
        var sumSquaredDeviations = vector.reduce(function (sum, val) { return sum + Math.pow((val - mean), 2); }, 0);
        var variance = sumSquaredDeviations / (n - 1);
        if (variance === 0) {
            throw new Error('Variance is zero, kurtosis is undefined');
        }
        var fourthMomentSum = vector.reduce(function (sum, val) { return sum + Math.pow((val - mean), 4); }, 0);
        var rawKurtosis = (n * (n + 1) * fourthMomentSum) / ((n - 1) * (n - 2) * (n - 3) * Math.pow(variance, 2));
        // Compute excess kurtosis by subtracting 3 times the bias correction factor
        return rawKurtosis - (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3));
    }
    var kurtosisReductionFunction = {
        kurtosis: function (vector) { return kurtosis(vector); },
        minLength: 4,
    };
    var eccessKurtosisReductionFunction = {
        'excess-kurtosis': function (vector) { return excessKurtosis(vector); },
        'minLength': 4,
    };
    var sampleKurtosisReductionFunction = {
        'sample-kurtosis': function (vector) { return sampleKurtosis(vector); },
        'minLength': 4,
    };
    var sampleExcessKurtosisReductionFunction = {
        'sample-excess-kurtosis': function (vector) { return sampleExcessKurtosis(vector); },
        'minLength': 4,
    };

    var rmsReductionFunction = {
        rms: function (vector) { return Math.sqrt(vector.reduce(function (acc, val) { return acc + Math.pow(val, 2); }, 0) / vector.length); },
    };

    function calcMad(vector) {
        var median = calcMedian(vector);
        // Calculate mean absolute deviation
        return vector.reduce(function (acc, val) { return acc + Math.abs(val - median); }, 0) / vector.length;
    }

    var madReductionFunction = {
        mad: function (vector) { return calcMad(vector); },
    };

    function calcMedad(vector) {
        var median = calcMedian(vector);
        // Calculate absolute deviations from the median
        var absoluteDeviations = vector.map(function (val) { return Math.abs(val - median); });
        // Calculate the median of the absolute deviations
        var medianOfDeviations = calcMedian(absoluteDeviations);
        var scaleFactor = 1.4826; // Scale factor for robust scaling
        return medianOfDeviations * scaleFactor;
    }

    var medadReductionFunction = {
        medad: function (vector) { return calcMedad(vector); },
    };

    var giniCoefficientReductionFunction = {
        'gini-coefficient': function (vector) {
            if (vector.some(function (x) { return x < 0; })) {
                throw new Error('Gini coefficient is not defined for negative values');
            }
            var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
            var n = sorted.length;
            var sum = sorted.reduce(function (acc, val) { return acc + val; }, 0);
            if (sum === 0) {
                return 0;
            }
            var gini = (2 * sorted.reduce(function (acc, val, i) { return acc + (i + 1) * val; }, 0)) / (n * sum) - (n + 1) / n;
            return gini;
        },
        'minLength': 1,
    };

    /**
     * Calculates the Shannon entropy of a vector.
     * Entropy measures the amount of uncertainty or randomness in the data.
     *
     * @param vector - An array of values to calculate entropy for
     * @returns The entropy value (in bits) or 0 for empty arrays
     */
    function calculateEntropy(vector) {
        var e_1, _a, e_2, _b;
        // Count occurrences of each value
        var frequencies = new Map();
        try {
            for (var vector_1 = __values(vector), vector_1_1 = vector_1.next(); !vector_1_1.done; vector_1_1 = vector_1.next()) {
                var value = vector_1_1.value;
                frequencies.set(value, (frequencies.get(value) || 0) + 1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vector_1_1 && !vector_1_1.done && (_a = vector_1.return)) _a.call(vector_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Get the total number of elements
        var total = vector.length;
        // Calculate entropy using Shannon's formula
        var entropy = 0;
        try {
            for (var _c = __values(frequencies.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var frequency = _d.value;
                var probability = frequency / total;
                // Skip cases where probability is 0 (log(0) is undefined)
                if (probability > 0) {
                    entropy -= probability * Math.log2(probability);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return entropy;
    }

    var entropyReductionFunction = {
        entropy: function (vector) { return calculateEntropy(vector); },
        minLength: 1,
    };

    var reductionFunctionNormalExpressions = {};
    addReductionFunctions$1(meanReductionFunction);
    addReductionFunctions$1(geometricMeanReductionFunction);
    addReductionFunctions$1(harmonicMeanReductionFunction);
    addReductionFunctions$1(medianReductionFunction);
    addReductionFunctions$1(sumReductionFunction);
    addReductionFunctions$1(prodReductionFunction);
    addReductionFunctions$1(minReductionFunction);
    addReductionFunctions$1(maxReductionFunction);
    addReductionFunctions$1(varianceReductionFunction);
    addReductionFunctions$1(sampleVarianceReductionFunction);
    addReductionFunctions$1(stdevReductionFunction);
    addReductionFunctions$1(sampleStdevReductionFunction);
    addReductionFunctions$1(iqrReductionFunction);
    addReductionFunctions$1(spanReductionFunction);
    addReductionFunctions$1(skewnessReductionFunction);
    addReductionFunctions$1(sampleSkewnessReductionFunction);
    addReductionFunctions$1(eccessKurtosisReductionFunction);
    addReductionFunctions$1(kurtosisReductionFunction);
    addReductionFunctions$1(sampleExcessKurtosisReductionFunction);
    addReductionFunctions$1(sampleKurtosisReductionFunction);
    addReductionFunctions$1(rmsReductionFunction);
    addReductionFunctions$1(madReductionFunction);
    addReductionFunctions$1(medadReductionFunction);
    addReductionFunctions$1(giniCoefficientReductionFunction);
    addReductionFunctions$1(entropyReductionFunction);
    function addReductionFunctions$1(fns) {
        var e_1, _a;
        var _b, _c;
        try {
            for (var _d = __values(Object.entries(fns)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var _f = __read(_e.value, 2), key = _f[0], value = _f[1];
                /* v8 ignore next 3 */
                if (reductionFunctionNormalExpressions[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                if (key !== 'minLength' && key !== 'padding' && typeof value === 'function') {
                    var reductionFn = value;
                    var baseKey = key.replace(/^/, '');
                    var movingKey = "moving-".concat(baseKey);
                    var centeredMovingKey = "centered-moving-".concat(baseKey);
                    var runningKey = "running-".concat(baseKey);
                    var minLength = (_b = fns.minLength) !== null && _b !== void 0 ? _b : 1;
                    assertNumber(minLength, undefined, { integer: true, finite: true, gte: 0 });
                    reductionFunctionNormalExpressions[key] = createReductionNormalExpression(reductionFn, minLength);
                    reductionFunctionNormalExpressions[movingKey] = createMovingNormalExpression(reductionFn, minLength);
                    reductionFunctionNormalExpressions[centeredMovingKey] = createCenteredMovingNormalExpression(reductionFn, minLength, (_c = fns.padding) !== null && _c !== void 0 ? _c : null);
                    reductionFunctionNormalExpressions[runningKey] = createRunningNormalExpression(reductionFn, minLength);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    function createReductionNormalExpression(reductionFunction, minLength) {
        return {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < minLength) {
                    throw new LitsError("Vector length must be at least ".concat(minLength), sourceCodeInfo);
                }
                try {
                    return reductionFunction(vector);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(1),
        };
    }
    function createMovingNormalExpression(reductionFunction, minLength) {
        return {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], windowSize = _b[1];
                assertVector(vector, sourceCodeInfo);
                assertNumber(windowSize, sourceCodeInfo, { integer: true, finite: true, gte: minLength, lte: vector.length });
                if (vector.length === 0) {
                    return [];
                }
                try {
                    if (windowSize >= vector.length) {
                        return [reductionFunction(vector)];
                    }
                    var result = [];
                    for (var i = 0; i < vector.length - windowSize + 1; i += 1) {
                        result.push(reductionFunction(vector.slice(i, i + windowSize)));
                    }
                    return result;
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(2),
        };
    }
    function createCenteredMovingNormalExpression(reductionFunction, minLength, padding) {
        return {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 4), vector = _b[0], windowSize = _b[1], leftPadding = _b[2], rightPadding = _b[3];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < minLength) {
                    throw new LitsError("Vector length must be at least ".concat(minLength), sourceCodeInfo);
                }
                assertNumber(windowSize, sourceCodeInfo, { integer: true, finite: true, gte: minLength, lte: vector.length });
                leftPadding = leftPadding !== null && leftPadding !== void 0 ? leftPadding : padding;
                if (leftPadding !== null) {
                    assertNumber(leftPadding, sourceCodeInfo, { finite: true });
                }
                rightPadding = rightPadding !== null && rightPadding !== void 0 ? rightPadding : padding;
                if (rightPadding !== null) {
                    assertNumber(rightPadding, sourceCodeInfo, { finite: true });
                }
                if (vector.length === 0) {
                    return [];
                }
                var halfWindowSize = Math.floor(windowSize / 2);
                var paddedVector = __spreadArray(__spreadArray(__spreadArray([], __read(Array(halfWindowSize).fill(leftPadding)), false), __read(vector), false), __read(Array(halfWindowSize).fill(rightPadding)), false);
                var start = typeof leftPadding === 'number' ? 0 : halfWindowSize;
                var end = vector.length - (typeof rightPadding === 'number' ? 0 : (windowSize - halfWindowSize - 1));
                var result = __spreadArray([], __read(Array(start).fill(null)), false);
                try {
                    for (var i = start; i < end; i += 1) {
                        result.push(reductionFunction(paddedVector.slice(i, i + windowSize)));
                    }
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
                result.push.apply(result, __spreadArray([], __read(Array(vector.length - end).fill(null)), false));
                return result;
            },
            arity: { min: 2, max: 4 },
        };
    }
    function createRunningNormalExpression(reductionFunction, minLength) {
        return {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < minLength) {
                    throw new LitsError("Vector length must be at least ".concat(minLength), sourceCodeInfo);
                }
                if (vector.length === 0) {
                    return [];
                }
                try {
                    var nullsCount = Math.max(minLength - 1, 0);
                    var result = Array(nullsCount).fill(null);
                    for (var i = nullsCount; i < vector.length; i += 1) {
                        result.push(reductionFunction(vector.slice(0, i + 1)));
                    }
                    return result;
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(1),
        };
    }

    var e_1$3, _a$3;
    var vectorFunctions = {
        'monotonic?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val >= vector[i - 1]; })
                    || vector.every(function (val, i) { return i === 0 || val <= vector[i - 1]; });
            },
            arity: toFixedArity(1),
        },
        'strictly-monotonic?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val > vector[i - 1]; })
                    || vector.every(function (val, i) { return i === 0 || val < vector[i - 1]; });
            },
            arity: toFixedArity(1),
        },
        'increasing?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val >= vector[i - 1]; });
            },
            arity: toFixedArity(1),
        },
        'decreasing?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val <= vector[i - 1]; });
            },
            arity: toFixedArity(1),
        },
        'strictly-increasing?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val > vector[i - 1]; });
            },
            arity: toFixedArity(1),
        },
        'strictly-decreasing?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val < vector[i - 1]; });
            },
            arity: toFixedArity(1),
        },
        'mode': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return mode(vector);
            },
            arity: toFixedArity(1),
        },
        'min-index': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val, i) { return (val < vector[acc] ? i : acc); }, 0);
            },
            arity: toFixedArity(1),
        },
        'max-index': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val, i) { return (val > vector[acc] ? i : acc); }, 0);
            },
            arity: toFixedArity(1),
        },
        'sort-indices': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return __spreadArray([], __read(vector.keys()), false).sort(function (a, b) { return vector[a] - vector[b]; });
            },
            arity: toFixedArity(1),
        },
        'count-values': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_2, _b;
                var _c = __read(_a, 1), vector = _c[0];
                assertVector(vector, sourceCodeInfo);
                var frequencyMap = new Map();
                try {
                    for (var vector_1 = __values(vector), vector_1_1 = vector_1.next(); !vector_1_1.done; vector_1_1 = vector_1.next()) {
                        var value = vector_1_1.value;
                        frequencyMap.set(value, (frequencyMap.get(value) || 0) + 1);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (vector_1_1 && !vector_1_1.done && (_b = vector_1.return)) _b.call(vector_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return __spreadArray([], __read(frequencyMap.entries()), false).sort(function (a, b) {
                    // First compare by count (descending)
                    var countDiff = b[1] - a[1];
                    if (countDiff !== 0)
                        return countDiff;
                    // If counts are equal, sort by value (ascending)
                    return a[0] - b[0];
                });
            },
            arity: toFixedArity(1),
        },
        'linspace': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], end = _b[1], numPoints = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(end, sourceCodeInfo, { finite: true });
                assertNumber(numPoints, sourceCodeInfo, { integer: true, nonNegative: true });
                if (numPoints === 0) {
                    return [];
                }
                if (numPoints === 1) {
                    return [start];
                }
                var step = (end - start) / (numPoints - 1);
                return Array.from({ length: numPoints }, function (_, i) { return start + i * step; });
            },
            arity: toFixedArity(3),
        },
        'ones': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), length = _b[0];
                assertNumber(length, sourceCodeInfo, { integer: true, nonNegative: true });
                return Array.from({ length: length }, function () { return 1; });
            },
            arity: toFixedArity(1),
        },
        'zeros': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), length = _b[0];
                assertNumber(length, sourceCodeInfo, { integer: true, nonNegative: true });
                return Array.from({ length: length }, function () { return 0; });
            },
            arity: toFixedArity(1),
        },
        'fill': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), length = _b[0], value = _b[1];
                assertNumber(length, sourceCodeInfo, { integer: true, nonNegative: true });
                return Array.from({ length: length }, function () { return value; });
            },
            arity: toFixedArity(2),
        },
        'generate': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), length = _c[0], generator = _c[1];
                var executeFunction = _b.executeFunction;
                assertNumber(length, sourceCodeInfo, { integer: true, nonNegative: true });
                assertFunctionLike(generator, sourceCodeInfo);
                return Array.from({ length: length }, function (_, i) {
                    var value = executeFunction(generator, [i], contextStack, sourceCodeInfo);
                    assertNumber(value, sourceCodeInfo, { finite: true });
                    return value;
                });
            },
            arity: toFixedArity(2),
        },
        'cumsum': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val) {
                    var _a;
                    var last = (_a = acc[acc.length - 1]) !== null && _a !== void 0 ? _a : 0;
                    acc.push(last + val);
                    return acc;
                }, []);
            },
            arity: toFixedArity(1),
        },
        'cumprod': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val) {
                    var _a;
                    var last = (_a = acc[acc.length - 1]) !== null && _a !== void 0 ? _a : 1;
                    acc.push(last * val);
                    return acc;
                }, []);
            },
            arity: toFixedArity(1),
        },
        'quartiles': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < 4) {
                    throw new LitsError('Quartiles require at least four values', sourceCodeInfo);
                }
                return quartiles(vector);
            },
            arity: toFixedArity(1),
        },
        'percentile': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], percentile = _b[1];
                assertNonEmptyVector(vector, sourceCodeInfo);
                assertNumber(percentile, sourceCodeInfo, { finite: true, nonNegative: true, lte: 100 });
                return calcPercentile(vector, percentile);
            },
            arity: toFixedArity(2),
        },
        'quantile': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], quantile = _b[1];
                assertVector(vector, sourceCodeInfo);
                assertNumber(quantile, sourceCodeInfo, { finite: true, nonNegative: true, lte: 1 });
                return calcPercentile(vector, quantile * 100);
            },
            arity: toFixedArity(2),
        },
        'histogram': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], bins = _b[1];
                assertVector(vector, sourceCodeInfo);
                assertNumber(bins, sourceCodeInfo, { integer: true, positive: true });
                return calcHistogram(vector, bins);
            },
            arity: toFixedArity(2),
        },
        'ecdf': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], value = _b[1];
                assertNonEmptyVector(vector, sourceCodeInfo);
                assertNumber(value, sourceCodeInfo, { finite: true });
                var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
                var index = sorted.findIndex(function (val) { return val > value; });
                return index === -1 ? 1 : index / sorted.length;
            },
            arity: toFixedArity(2),
        },
        'outliers?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return hasOutliers(vector);
            },
            arity: toFixedArity(1),
        },
        'outliers': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return outliers(vector);
            },
            arity: toFixedArity(1),
        },
        'bincount': {
            evaluate: function (params, sourceCodeInfo) {
                var _a, _b;
                var vector = params[0];
                assertVector(vector, sourceCodeInfo);
                vector.forEach(function (val) { return assertNumber(val, sourceCodeInfo, { finite: true, integer: true, nonNegative: true }); });
                var minSize = (_a = params[1]) !== null && _a !== void 0 ? _a : 0;
                assertNumber(minSize, sourceCodeInfo, { integer: true, nonNegative: true });
                var weights = (_b = params[2]) !== null && _b !== void 0 ? _b : undefined;
                if (weights !== undefined) {
                    assertVector(weights, sourceCodeInfo);
                    if (weights.length !== vector.length) {
                        throw new LitsError('Weights vector must be the same length as the input vector', sourceCodeInfo);
                    }
                    weights.forEach(function (val) { return assertNumber(val, sourceCodeInfo, { finite: true }); });
                }
                return bincount(vector, minSize, weights);
            },
            arity: { min: 1, max: 3 },
        },
        'winsorize': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vector = _b[0], lowerQuantile = _b[1], upperQuantile = _b[2];
                assertVector(vector, sourceCodeInfo);
                assertNumber(lowerQuantile, sourceCodeInfo, { finite: true, gte: 0, lte: 1 });
                upperQuantile !== null && upperQuantile !== void 0 ? upperQuantile : (upperQuantile = lowerQuantile > 0.5 ? 1 : (1 - lowerQuantile));
                assertNumber(upperQuantile, sourceCodeInfo, { finite: true, gte: lowerQuantile, lte: 1 });
                if (vector.length === 0)
                    return [];
                var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
                var lowerIndex = Math.max(0, Math.floor(lowerQuantile * vector.length));
                var upperIndex = Math.min(vector.length - 1, Math.max(0, Math.floor(upperQuantile * vector.length) - 1));
                var lowerBound = sorted[lowerIndex];
                var upperBound = sorted[upperIndex];
                return vector.map(function (val) { return Math.max(lowerBound, Math.min(val, upperBound)); });
            },
            arity: { min: 2, max: 3 },
        },
        'mse': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) { return acc + Math.pow((val - vectorB[i]), 2); }, 0) / vectorA.length;
            },
            arity: toFixedArity(2),
        },
        'rmse': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return Math.sqrt(vectorA.reduce(function (acc, val, i) { return acc + Math.pow((val - vectorB[i]), 2); }, 0) / vectorA.length);
            },
            arity: toFixedArity(2),
        },
        'mae': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) { return acc + Math.abs(val - vectorB[i]); }, 0) / vectorA.length;
            },
            arity: toFixedArity(2),
        },
        'smape': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) {
                    var diff = Math.abs(val - vectorB[i]);
                    var denom = (Math.abs(val) + Math.abs(vectorB[i])) / 2;
                    return acc + (denom === 0 ? 0 : diff / denom);
                }, 0) / vectorA.length;
            },
            arity: toFixedArity(2),
        },
    };
    addReductionFunctions(reductionFunctionNormalExpressions);
    function addReductionFunctions(sequences) {
        var e_3, _a;
        try {
            for (var _b = __values(Object.entries(sequences)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (vectorFunctions[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                vectorFunctions[key] = value;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    try {
        for (var _b$3 = __values(Object.entries(namespaceDocs$3)), _c$3 = _b$3.next(); !_c$3.done; _c$3 = _b$3.next()) {
            var _d$3 = __read(_c$3.value, 2), key$3 = _d$3[0], docs$3 = _d$3[1];
            if (vectorFunctions[key$3])
                vectorFunctions[key$3].docs = docs$3;
        }
    }
    catch (e_1_1) { e_1$3 = { error: e_1_1 }; }
    finally {
        try {
            if (_c$3 && !_c$3.done && (_a$3 = _b$3.return)) _a$3.call(_b$3);
        }
        finally { if (e_1$3) throw e_1$3.error; }
    }
    var vectorNamespace = {
        name: 'Vector',
        functions: vectorFunctions,
    };

    var namespaceDocs$2 = {
        'reflect': {
            category: 'Linear Algebra',
            description: 'Reflects a vector across a given axis.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Vector to reflect.',
                },
                b: {
                    type: 'vector',
                    description: 'Axis of reflection.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { reflect } = import("Linear-Algebra");\nreflect([1, 2], [0, 1])',
                'let { reflect } = import("Linear-Algebra");\nreflect([1, 2, 3], [0, 0, 1])',
            ],
        },
        'refract': {
            category: 'Linear Algebra',
            description: 'Refracts a vector across a given axis.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Vector to refract.',
                },
                axis: {
                    type: 'vector',
                    description: 'Axis of refraction.',
                },
                eta: {
                    type: 'number',
                    description: 'Refraction index.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                        'axis',
                        'eta',
                    ],
                },
            ],
            examples: [
                'let { refract } = import("Linear-Algebra");\nrefract([1, 2], [0, 1], 1.5)',
                'let { refract } = import("Linear-Algebra");\nrefract([1, 2, 3], [0, 0, 1], 1.5)',
            ],
        },
        'lerp': {
            category: 'Linear Algebra',
            description: 'Performs linear interpolation between two vectors.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Start vector.',
                },
                b: {
                    type: 'vector',
                    description: 'End vector.',
                },
                t: {
                    type: 'number',
                    description: 'Interpolation factor (0 to 1).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                        't',
                    ],
                },
            ],
            examples: [
                'let { lerp } = import("Linear-Algebra");\nlerp([1, 2], [3, 4], 0.5)',
                'let { lerp } = import("Linear-Algebra");\nlerp([1, 2], [3, 4], 2)',
                'let { lerp } = import("Linear-Algebra");\nlerp([1, 2], [3, 4], -1)',
                'let { lerp } = import("Linear-Algebra");\nlerp([1, 2, 3], [4, 5, 6], 0.25)',
            ],
        },
        'rotate2d': {
            category: 'Linear Algebra',
            description: 'Rotates a 2D vector by a given angle in radians.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Vector to rotate.',
                },
                b: {
                    type: 'number',
                    description: 'Angle in b.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { rotate2d } = import("Linear-Algebra");\nrotate2d([1, 0], PI / 2)',
                'let { rotate2d } = import("Linear-Algebra");\nrotate2d([0, 1], PI)',
            ],
        },
        'rotate3d': {
            category: 'Linear Algebra',
            description: 'Rotates a 3D vector around a given axis by a given angle in radians.',
            returns: {
                type: 'vector',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to rotate.',
                },
                axis: {
                    type: 'vector',
                    description: 'Axis of rotation.',
                },
                radians: {
                    type: 'number',
                    description: 'Angle in radians.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                        'axis',
                        'radians',
                    ],
                },
            ],
            examples: [
                'let { rotate3d } = import("Linear-Algebra");\nrotate3d([1, 0, 0], [0, 1, 0], PI / 2)',
                'let { rotate3d } = import("Linear-Algebra");\nrotate3d([0, 1, 0], [1, 0, 0], PI)',
            ],
        },
        'dot': {
            category: 'Linear Algebra',
            description: 'Calculates the dot product of two vectors. The result is a scalar.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'First vector.',
                },
                b: {
                    type: 'vector',
                    description: 'Second vector.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { dot } = import("Linear-Algebra");\ndot([1, 2], [3, 4])',
                'let { dot } = import("Linear-Algebra");\ndot([1, 2, 3], [4, 5, 6])',
            ],
        },
        'cross': {
            category: 'Linear Algebra',
            description: 'Calculates the cross product of two 3D vectors. The result is a vector perpendicular to both input vectors.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'First vector (3D).',
                },
                b: {
                    type: 'vector',
                    description: 'Second vector (3D).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { cross } = import("Linear-Algebra");\ncross([1, 2, 3], [4, 5, 6])',
                'let { cross } = import("Linear-Algebra");\ncross([1, 0, 0], [0, 1, 0])',
                'let { cross } = import("Linear-Algebra");\ncross([0, 0, 1], [1, 0, 0])',
                'let { cross } = import("Linear-Algebra");\ncross([1, 2, 3], [0, 0, 0])',
                'let { cross } = import("Linear-Algebra");\ncross([0, 0, 0], [1, 2, 3])',
            ],
        },
        'normalize-minmax': {
            category: 'Linear Algebra',
            description: 'Normalizes the vector using min-max normalization. The result is a vector with values between 0 and 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { normalize-minmax } = import("Linear-Algebra");\nnormalize-minmax([1, 2, 3])',
                'let { normalize-minmax } = import("Linear-Algebra");\nnormalize-minmax([1, 2, -3])',
                'let { normalize-minmax } = import("Linear-Algebra");\nnormalize-minmax([1, 2, 3, 4])',
                'let { normalize-minmax } = import("Linear-Algebra");\nnormalize-minmax([1, 2, -3, 4])',
                'let { normalize-minmax } = import("Linear-Algebra");\nnormalize-minmax([1, 2, 3, 40, 50])',
            ],
        },
        'normalize-zscore': {
            category: 'Linear Algebra',
            description: 'Normalizes the vector using z-score normalization. The result is a vector with mean 0 and standard deviation 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { normalize-zscore } = import("Linear-Algebra");\nnormalize-zscore([1, 2, 3])',
                'let { normalize-zscore } = import("Linear-Algebra");\nnormalize-zscore([1, 2, -3])',
                'let { normalize-zscore } = import("Linear-Algebra");\nnormalize-zscore([1, 2, 3, 4])',
                'let { normalize-zscore } = import("Linear-Algebra");\nnormalize-zscore([1, 2, -3, 4])',
                'let { normalize-zscore } = import("Linear-Algebra");\nnormalize-zscore([1, 2, 3, 40, 50])',
            ],
        },
        'normalize-robust': {
            category: 'Linear Algebra',
            description: 'Normalizes the vector using robust normalization. The result is a vector with median 0 and median absolute deviation 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { normalize-robust } = import("Linear-Algebra");\nnormalize-robust([1, 2, 3])',
                'let { normalize-robust } = import("Linear-Algebra");\nnormalize-robust([1, 2, -3])',
                'let { normalize-robust } = import("Linear-Algebra");\nnormalize-robust([1, 2, 3, 4])',
                'let { normalize-robust } = import("Linear-Algebra");\nnormalize-robust([1, 2, -3, 4])',
                'let { normalize-robust } = import("Linear-Algebra");\nnormalize-robust([1, 2, 3, 40, 50])',
            ],
        },
        'normalize-l1': {
            category: 'Linear Algebra',
            description: 'Normalizes the vector using L1 normalization. The result is a vector with L1 norm equal to 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { normalize-l1 } = import("Linear-Algebra");\nnormalize-l1([1, 2, 3])',
                'let { normalize-l1 } = import("Linear-Algebra");\nnormalize-l1([1, 2, -3])',
                'let { normalize-l1 } = import("Linear-Algebra");\nnormalize-l1([1, 2, 3, 4])',
                'let { normalize-l1 } = import("Linear-Algebra");\nnormalize-l1([1, 2, -3, 4])',
                'let { normalize-l1 } = import("Linear-Algebra");\nnormalize-l1([1, 2, 3, 40, 50])',
            ],
        },
        'normalize-l2': {
            category: 'Linear Algebra',
            description: 'Normalizes the vector using L2 normalization. The result is a vector with L2 norm equal to 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { normalize-l2 } = import("Linear-Algebra");\nnormalize-l2([1, 2, 3])',
                'let { normalize-l2 } = import("Linear-Algebra");\nnormalize-l2([1, 2, 3])',
                'let { normalize-l2 } = import("Linear-Algebra");\nnormalize-l2([1, 2, -3])',
                'let { normalize-l2 } = import("Linear-Algebra");\nnormalize-l2([1, 2, 3, 4])',
                'let { normalize-l2 } = import("Linear-Algebra");\nnormalize-l2([1, 2, -3, 4])',
                'let { normalize-l2 } = import("Linear-Algebra");\nnormalize-l2([1, 2, 3, 40, 50])',
            ],
        },
        'normalize-log': {
            category: 'Linear Algebra',
            description: 'Normalizes the vector using natural log normalization. The result is a vector with log-transformed values.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { normalize-log } = import("Linear-Algebra");\nnormalize-log([1, 2, 3])',
                'let { normalize-log } = import("Linear-Algebra");\nnormalize-log([1, 2, 3, 4])',
                'let { normalize-log } = import("Linear-Algebra");\nnormalize-log([1, 2, 3, 40, 50])',
            ],
        },
        'angle': {
            category: 'Linear Algebra',
            description: 'Calculates the `angle` between two vectors in radians.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { angle } = import("Linear-Algebra");\nangle([1, 0], [0, 1])',
                'let { angle } = import("Linear-Algebra");\nangle([1, 0, 1], [0, 1, 0])',
            ],
        },
        'projection': {
            category: 'Linear Algebra',
            description: 'Calculates the **projection** of vector `a` onto vector `b`.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { projection } = import("Linear-Algebra");\nprojection([1, 2], [3, 4])',
                'let { projection } = import("Linear-Algebra");\nprojection([1, 2, 3], [4, 5, 6])',
            ],
        },
        'collinear?': {
            category: 'Linear Algebra',
            description: 'Checks if two vectors are **collinear**.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { collinear? } = import("Linear-Algebra");\ncollinear?([1, 2], [2, 4])',
                'let { collinear? } = import("Linear-Algebra");\ncollinear?([1, 2], [-2, -4])',
                'let { collinear? } = import("Linear-Algebra");\ncollinear?([1, 2, 3], [2, 4, 6])',
            ],
        },
        'parallel?': {
            category: 'Linear Algebra',
            description: 'Checks if two vectors are **parallel**.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { parallel? } = import("Linear-Algebra");\nparallel?([1, 2], [2, 4])',
                'let { parallel? } = import("Linear-Algebra");\nparallel?([1, 2], [-2, -4])',
                'let { parallel? } = import("Linear-Algebra");\nparallel?([1, 2, 3], [2, 4, 6])',
                'let { parallel? } = import("Linear-Algebra");\nparallel?([1, 2], [3, 4])',
            ],
        },
        'orthogonal?': {
            category: 'Linear Algebra',
            description: 'Checks if two vectors are **orthogonal**.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { orthogonal? } = import("Linear-Algebra");\northogonal?([1, 0], [0, 1])',
                'let { orthogonal? } = import("Linear-Algebra");\northogonal?([1, 0, 1], [0, 1, 0])',
                'let { orthogonal? } = import("Linear-Algebra");\northogonal?([1, 2], [2, -1])',
            ],
        },
        'cosine-similarity': {
            category: 'Linear Algebra',
            description: 'Calculates the **cosine similarity** between two vectors. The result is a value between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { cosine-similarity } = import("Linear-Algebra");\ncosine-similarity([1, 2], [3, 4])',
                'let { cosine-similarity } = import("Linear-Algebra");\ncosine-similarity([1, 2, 3], [4, 5, 6])',
                'let { cosine-similarity } = import("Linear-Algebra");\ncosine-similarity([1, 0], [0, 1])',
            ],
        },
        'euclidean-distance': {
            category: 'Linear Algebra',
            description: 'Calculates the **Euclidean distance** between two vectors. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { euclidean-distance } = import("Linear-Algebra");\neuclidean-distance([1, 2], [3, 4])',
                'let { euclidean-distance } = import("Linear-Algebra");\neuclidean-distance([1, 2, 3], [4, 5, 6])',
                'let { euclidean-distance } = import("Linear-Algebra");\neuclidean-distance([1, 0], [0, 1])',
            ],
        },
        'euclidean-norm': {
            category: 'Linear Algebra',
            description: 'Calculates the **Euclidean norm** (L2 norm) of a vector. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { euclidean-norm } = import("Linear-Algebra");\neuclidean-norm([1, 2])',
                'let { euclidean-norm } = import("Linear-Algebra");\neuclidean-norm([3, 4])',
                'let { euclidean-norm } = import("Linear-Algebra");\neuclidean-norm([1, 2, 3])',
            ],
        },
        'manhattan-distance': {
            category: 'Linear Algebra',
            description: 'Calculates the **Manhattan distance** between two vectors. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { manhattan-distance } = import("Linear-Algebra");\nmanhattan-distance([1, 2], [3, 4])',
                'let { manhattan-distance } = import("Linear-Algebra");\nmanhattan-distance([1, 2, 3], [4, 5, 6])',
                'let { manhattan-distance } = import("Linear-Algebra");\nmanhattan-distance([1, 0], [0, 1])',
            ],
        },
        'manhattan-norm': {
            category: 'Linear Algebra',
            description: 'Calculates the **Manhattan norm** (L1 norm) of a vector. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { manhattan-norm } = import("Linear-Algebra");\nmanhattan-norm([1, 2])',
                'let { manhattan-norm } = import("Linear-Algebra");\nmanhattan-norm([3, 4])',
                'let { manhattan-norm } = import("Linear-Algebra");\nmanhattan-norm([1, 2, 3])',
            ],
        },
        'hamming-distance': {
            category: 'Linear Algebra',
            description: 'Calculates the **Hamming distance** between two vectors. The result is a non-negative integer.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { hamming-distance } = import("Linear-Algebra");\nhamming-distance([1, 2], [3, 4])',
                'let { hamming-distance } = import("Linear-Algebra");\nhamming-distance([1, 2, 3], [4, 5, 6])',
                'let { hamming-distance } = import("Linear-Algebra");\nhamming-distance([1, 0], [0, 1])',
            ],
        },
        'hamming-norm': {
            category: 'Linear Algebra',
            description: 'Calculates the **Hamming norm** of a vector. The result is a non-negative integer.',
            returns: {
                type: 'integer',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { hamming-norm } = import("Linear-Algebra");\nhamming-norm([1, 2])',
                'let { hamming-norm } = import("Linear-Algebra");\nhamming-norm([3, 4])',
                'let { hamming-norm } = import("Linear-Algebra");\nhamming-norm([1, 2, 3])',
            ],
        },
        'chebyshev-distance': {
            category: 'Linear Algebra',
            description: 'Calculates the **Chebyshev distance** between two vectors. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { chebyshev-distance } = import("Linear-Algebra");\nchebyshev-distance([1, 2], [3, 4])',
                'let { chebyshev-distance } = import("Linear-Algebra");\nchebyshev-distance([1, 2, 3], [4, 5, 6])',
                'let { chebyshev-distance } = import("Linear-Algebra");\nchebyshev-distance([1, 0], [0, 1])',
            ],
        },
        'chebyshev-norm': {
            category: 'Linear Algebra',
            description: 'Calculates the **Chebyshev norm** of a vector. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { chebyshev-norm } = import("Linear-Algebra");\nchebyshev-norm([1, 2])',
                'let { chebyshev-norm } = import("Linear-Algebra");\nchebyshev-norm([3, 4])',
                'let { chebyshev-norm } = import("Linear-Algebra");\nchebyshev-norm([1, 2, 3])',
            ],
        },
        'minkowski-distance': {
            category: 'Linear Algebra',
            description: 'Calculates the **Minkowski distance** between two vectors. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
                p: {
                    type: 'number',
                    description: 'Order of the norm (p).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                        'p',
                    ],
                },
            ],
            examples: [
                'let { minkowski-distance } = import("Linear-Algebra");\nminkowski-distance([1, 2], [3, 4], 2)',
                'let { minkowski-distance } = import("Linear-Algebra");\nminkowski-distance([1, 2, 3], [4, 5, 6], 3)',
                'let { minkowski-distance } = import("Linear-Algebra");\nminkowski-distance([1, 0], [0, 1], 1)',
            ],
        },
        'minkowski-norm': {
            category: 'Linear Algebra',
            description: 'Calculates the **Minkowski norm** of a vector. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
                b: {
                    type: 'number',
                    description: 'Order of the norm (p).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { minkowski-norm } = import("Linear-Algebra");\nminkowski-norm([1, 2], 2)',
                'let { minkowski-norm } = import("Linear-Algebra");\nminkowski-norm([3, 4], 3)',
                'let { minkowski-norm } = import("Linear-Algebra");\nminkowski-norm([1, 2, 3], 4)',
            ],
        },
        'cov': {
            category: 'Linear Algebra',
            description: 'Calculates the **covariance** between two vectors. The result is a number.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { cov } = import("Linear-Algebra");\ncov([1, 2], [3, 4])',
                'let { cov } = import("Linear-Algebra");\ncov([1, 2, 3], [4, 5, 6])',
                'let { cov } = import("Linear-Algebra");\ncov([1, 0], [0, 1])',
            ],
        },
        'corr': {
            category: 'Linear Algebra',
            description: 'Calculates the **correlation** between two vectors. The result is a number between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { corr } = import("Linear-Algebra");\ncorr([1, 2], [3, 4])',
                'let { corr } = import("Linear-Algebra");\ncorr([1, 2, 3], [4, 5, 6])',
                'let { corr } = import("Linear-Algebra");\ncorr([1, 0], [0, 1])',
            ],
        },
        'spearman-corr': {
            category: 'Linear Algebra',
            description: 'Calculates the **Spearman rank correlation** between two vectors. The result is a number between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { spearman-corr } = import("Linear-Algebra");\nspearman-corr([1, 2], [3, 4])',
                'let { spearman-corr } = import("Linear-Algebra");\nspearman-corr([1, 2, 3], [4, 5, 6])',
                'let { spearman-corr } = import("Linear-Algebra");\nspearman-corr([1, 0], [0, 1])',
            ],
        },
        'pearson-corr': {
            category: 'Linear Algebra',
            description: 'Calculates the **Pearson correlation** between two vectors. The result is a number between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { pearson-corr } = import("Linear-Algebra");\npearson-corr([1, 2], [3, 4])',
                'let { pearson-corr } = import("Linear-Algebra");\npearson-corr([1, 2, 3], [4, 5, 6])',
                'let { pearson-corr } = import("Linear-Algebra");\npearson-corr([1, 0], [0, 1])',
            ],
        },
        'kendall-tau': {
            category: 'Linear Algebra',
            description: 'Calculates the **Kendall Tau** rank correlation coefficient between two vectors. The result is a number between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { kendall-tau } = import("Linear-Algebra");\nkendall-tau([1, 2], [3, 4])',
                'let { kendall-tau } = import("Linear-Algebra");\nkendall-tau([1, 2, 3], [4, 5, 6])',
                'let { kendall-tau } = import("Linear-Algebra");\nkendall-tau([1, 0], [0, 1])',
            ],
        },
        'autocorrelation': {
            category: 'Linear Algebra',
            description: 'Calculates the **autocorrelation** of a vector. The result is a vector of autocorrelation coefficients.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Vector to calculate the autocorrelation for.',
                },
                b: {
                    type: 'integer',
                    description: 'Lag value for the autocorrelation.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { autocorrelation } = import("Linear-Algebra");\nautocorrelation([1, 2, 3], -2)',
                'let { autocorrelation } = import("Linear-Algebra");\nautocorrelation([1, 2, 3], -1)',
                'let { autocorrelation } = import("Linear-Algebra");\nautocorrelation([1, 2, 3], 0)',
                'let { autocorrelation } = import("Linear-Algebra");\nautocorrelation([1, 2, 3], 1)',
                'let { autocorrelation } = import("Linear-Algebra");\nautocorrelation([1, 2, 3], 2)',
            ],
        },
        'cross-correlation': {
            category: 'Linear Algebra',
            description: 'Calculates the **cross-correlation** between two vectors. The result is a vector of cross-correlation coefficients.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                },
                b: {
                    type: 'vector',
                },
                lag: {
                    type: 'integer',
                    description: 'Lag value for the cross-correlation.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                        'lag',
                    ],
                },
            ],
            examples: [
                'let { cross-correlation } = import("Linear-Algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], -2)',
                'let { cross-correlation } = import("Linear-Algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], -1)',
                'let { cross-correlation } = import("Linear-Algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], 0)',
                'let { cross-correlation } = import("Linear-Algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], 1)',
                'let { cross-correlation } = import("Linear-Algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], 2)',
            ],
        },
        'rref': {
            category: 'Linear Algebra',
            description: 'Calculates the **Reduced Row Echelon Form** (RREF) of a matrix.',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'Matrix to calculate the RREF for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { rref } = import("Linear-Algebra");\nrref([[1, 2], [3, 4]])',
                'let { rref } = import("Linear-Algebra");\nrref([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'let { rref } = import("Linear-Algebra");\nrref([[1, 2, 3], [7, 8, 9], [4, 5, 7]])',
            ],
        },
        'solve': {
            category: 'Linear Algebra',
            description: 'Solves a system of linear equations represented by a matrix and a vector.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'matrix',
                },
                b: {
                    type: 'vector',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { solve } = import("Linear-Algebra");\nsolve([\n  [2, 1, -1, 1], \n  [4, 5, -3, 2], \n  [6, -2, 5, -3], \n  [8, 3, 2, 4]\n], [5, 10, 2, 17])',
                'let { solve } = import("Linear-Algebra"); solve([[2, 0, 0], [3, 1, 0], [4, 5, 6]], [4, 5, 38])',
                'let { solve } = import("Linear-Algebra"); solve([[2, 3], [1, -1]], [8, 2])',
            ],
        },
        'to-polar': {
            category: 'Linear Algebra',
            description: 'Converts a 2D vector to polar coordinates.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: '2D Vector to convert.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'vector',
                    ],
                },
            ],
            examples: [
                'let { to-polar } = import("Linear-Algebra");\nto-polar([1, 2])',
                'let { to-polar } = import("Linear-Algebra");\nto-polar([3, 4])',
            ],
        },
        'from-polar': {
            category: 'Linear Algebra',
            description: 'Converts polar coordinates to a 2D vector.',
            returns: {
                type: 'vector',
            },
            args: {
                polar: {
                    type: 'vector',
                    description: 'Polar coordinates to convert.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'polar',
                    ],
                },
            ],
            examples: [
                'let { from-polar } = import("Linear-Algebra");\nfrom-polar([1, PI / 4])',
                'let { from-polar } = import("Linear-Algebra");\nfrom-polar([1, 0])',
                'let { from-polar } = import("Linear-Algebra");\nfrom-polar([1, -PI / 2])',
            ],
        },
    };

    /**
     * Performs Gauss-Jordan elimination on a matrix, transforming it to reduced row echelon form
     *
     * @param matrix - The input matrix
     * @returns A tuple containing the reduced row echelon form matrix and the rank
     */
    function gaussJordanElimination(matrix) {
        var _a;
        // Create a copy of the matrix to avoid modifying the original
        var m = matrix.map(function (row) { return __spreadArray([], __read(row), false); });
        var rows = m.length;
        var cols = m[0].length;
        var rank = 0;
        var rowsProcessed = 0;
        // Row reduction to reduced row echelon form
        for (var col = 0; col < cols; col++) {
            // Find the pivot
            var pivotRow = -1;
            for (var row = rowsProcessed; row < rows; row++) {
                if (!approxZero(m[row][col])) {
                    pivotRow = row;
                    break;
                }
            }
            if (pivotRow === -1)
                continue; // No pivot in this column
            // Increase rank
            rank += 1;
            // Swap rows
            if (pivotRow !== rowsProcessed) {
                _a = __read([m[rowsProcessed], m[pivotRow]], 2), m[pivotRow] = _a[0], m[rowsProcessed] = _a[1];
            }
            // Get the pivot value
            var pivotValue = m[rowsProcessed][col];
            // Normalize the pivot row (always, for RREF)
            for (var j = col; j < cols; j++) {
                m[rowsProcessed][j] /= pivotValue;
            }
            // Eliminate above and below (full Gauss-Jordan)
            for (var row = 0; row < rows; row++) {
                if (row !== rowsProcessed && !approxZero(m[row][col])) {
                    var factor = m[row][col];
                    for (var j = col; j < cols; j++) {
                        m[row][j] -= factor * m[rowsProcessed][j];
                    }
                }
            }
            rowsProcessed++;
            if (rowsProcessed === rows)
                break;
        }
        return [m, rank];
    }

    /**
     * Solves a system of linear equations Ax = b
     *
     * @param A - The coefficient matrix
     * @param b - The constant vector
     * @returns The solution vector x, or null if no unique solution exists
     */
    function solve(A, b) {
        var n = A.length;
        // Create augmented matrix [A|b]
        var augmented = A.map(function (row, i) { return __spreadArray(__spreadArray([], __read(row), false), [b[i]], false); });
        // Convert to row echelon form using your existing function
        var _a = __read(gaussJordanElimination(augmented), 1), echelon = _a[0];
        // Check if the system has a unique solution
        for (var i = 0; i < n; i += 1) {
            if (approxZero(echelon[i][i])) {
                return null; // No unique solution
            }
        }
        // Back substitution
        var x = Array.from({ length: n }, function () { return 0; });
        for (var i = n - 1; i >= 0; i--) {
            var sum = 0;
            for (var j = i + 1; j < n; j++) {
                sum += echelon[i][j] * x[j];
            }
            x[i] = (echelon[i][n] - sum) / echelon[i][i];
        }
        return x;
    }

    function areVectorsCollinear(vectorA, vectorB) {
        // Check if either vector is zero
        var isZeroVector = function (vec) {
            return vec.every(function (component) { return approxZero(component); });
        };
        if (isZeroVector(vectorA) || isZeroVector(vectorB)) {
            return true; // Zero vector is technically collinear to all vectors
        }
        // Find the first non-zero component in vectorA
        var index = 0;
        while (index < vectorA.length && approxZero(vectorA[index])) {
            index++;
        }
        // Calculate the scale factor
        var ratio = vectorB[index] / vectorA[index];
        // Check if all other components maintain the same ratio
        for (var i = 0; i < vectorA.length; i++) {
            // Skip components where both vectors have (near) zero values
            if (approxZero(vectorA[i]) && approxZero(vectorB[i]))
                continue;
            // If vectorA component is near zero but vectorB is not, vectors are not collinear
            if (approxZero(vectorA[i]))
                return false;
            // Check if the ratio is consistent
            if (!approxEqual(vectorB[i] / vectorA[i], ratio)) {
                return false;
            }
        }
        return true;
    }
    function areVectorsParallel(vectorA, vectorB) {
        if (!areVectorsCollinear(vectorA, vectorB)) {
            return false;
        }
        // Then verify they point in the same direction
        // Find first non-zero component in both vectors
        for (var i = 0; i < vectorA.length; i++) {
            if (!approxZero(vectorA[i]) && !approxZero(vectorB[i])) {
                return Math.sign(vectorA[i]) === Math.sign(vectorB[i]);
            }
        }
        // If we get here, one of the vectors must be zero
        return true;
    }

    function isZeroVector(vector) {
        return vector.every(function (component) { return approxZero(component); });
    }

    function pearsonCorr(vectorA, vectorB) {
        var meanA = calcMean(vectorA);
        var meanB = calcMean(vectorB);
        var sumNumerator = 0;
        var sumSquareA = 0;
        var sumSquareB = 0;
        for (var i = 0; i < vectorA.length; i++) {
            var diffA = vectorA[i] - meanA;
            var diffB = vectorB[i] - meanB;
            sumNumerator += diffA * diffB;
            sumSquareA += diffA * diffA;
            sumSquareB += diffB * diffB;
        }
        // Check if either vector has zero variance
        if (sumSquareA === 0 || sumSquareB === 0) {
            throw new Error('Cannot calculate Pearson correlation coefficient: one of the vectors has zero variance.');
        }
        return sumNumerator / (Math.sqrt(sumSquareA) * Math.sqrt(sumSquareB));
    }

    function calcFractionalRanks(vector) {
        // Create array of indices and sort by values
        var indices = __spreadArray([], __read(vector.keys()), false).sort(function (a, b) { return vector[a] - vector[b]; });
        // Create ranks array (same size as input vector)
        var ranks = Array.from({ length: vector.length }).fill(0);
        // Assign ranks, handling ties properly
        var currentRank = 1;
        var i = 0;
        while (i < indices.length) {
            var value = vector[indices[i]];
            var j = i;
            // Find all indices with the same value
            while (j < indices.length && vector[indices[j]] === value) {
                j++;
            }
            // Calculate average rank for ties
            var averageRank = currentRank + (j - i - 1) / 2;
            // Assign average rank to all tied elements
            for (var k = i; k < j; k++) {
                ranks[indices[k]] = averageRank;
            }
            // Update current rank and index
            currentRank += j - i;
            i = j;
        }
        return ranks;
    }

    /**
     * Calculates Kendall's Tau-b rank correlation coefficient between two vectors
     * This implementation handles ties and uses an epsilon value for floating-point comparisons
     *
     * @param vectorA - First vector of numbers
     * @param vectorB - Second vector of numbers
     * @param epsilon - Threshold for considering two values as equal (default: 1e-10)
     * @returns The Kendall's Tau-b correlation coefficient
     */
    function kendallTau(vectorA, vectorB, epsilon) {
        if (epsilon === void 0) { epsilon = 1e-10; }
        var concordant = 0;
        var discordant = 0;
        var tiesInA = 0;
        var tiesInB = 0;
        // Compare all pairs
        for (var i = 0; i < vectorA.length; i++) {
            for (var j = i + 1; j < vectorA.length; j++) {
                // Calculate differences
                var diffA = vectorA[i] - vectorA[j];
                var diffB = vectorB[i] - vectorB[j];
                // Check for ties using epsilon
                var isTieA = Math.abs(diffA) < epsilon;
                var isTieB = Math.abs(diffB) < epsilon;
                if (isTieA && isTieB) {
                    // Tied in both vectors
                    continue;
                }
                else if (isTieA) {
                    // Tied in vector A only
                    tiesInA += 1;
                }
                else if (isTieB) {
                    // Tied in vector B only
                    tiesInB += 1;
                }
                else if (diffA * diffB > 0) {
                    // Concordant pair
                    concordant += 1;
                }
                else {
                    // Discordant pair
                    discordant += 1;
                }
            }
        }
        var n1 = concordant + discordant + tiesInA;
        var n2 = concordant + discordant + tiesInB;
        // Handle edge cases to avoid division by zero
        if (n1 === 0 || n2 === 0) {
            throw new Error('Not enough data to calculate Kendall\'s Tau');
        }
        // Kendall's Tau-b formula
        return (concordant - discordant) / Math.sqrt(n1 * n2);
    }

    /**
     * Calculate covariance between two segments
     */
    function calcCovariance(segmentA, segmentB) {
        var meanA = calcMean(segmentA);
        var meanB = calcMean(segmentB);
        var sum = 0;
        for (var i = 0; i < segmentA.length; i++) {
            sum += (segmentA[i] - meanA) * (segmentB[i] - meanB);
        }
        return sum / segmentA.length;
    }

    /**
     * Calculate Pearson correlation between two segments
     */
    function calcCorrelation(segmentA, segmentB) {
        var meanA = calcMean(segmentA);
        var meanB = calcMean(segmentB);
        var stdA = calcStdDev(segmentA, meanA);
        var stdB = calcStdDev(segmentB, meanB);
        // Handle zero variance
        if (stdA === 0 || stdB === 0) {
            // If both have zero variance and are the same constant, they're perfectly correlated
            if (stdA === 0 && stdB === 0 && meanA === meanB) {
                return 1;
            }
            // Otherwise, no meaningful correlation can be established
            return 0;
        }
        var covariance = calcCovariance(segmentA, segmentB);
        return covariance / (stdA * stdB);
    }
    /**
     * Extract overlapping segments from two vectors based on lag
     */
    function extractOverlappingSegments(vectorA, vectorB, lag) {
        var absLag = Math.abs(lag);
        var overlapLength = vectorA.length - absLag;
        var segmentA = [];
        var segmentB = [];
        if (lag >= 0) {
            segmentA = vectorA.slice(0, overlapLength);
            segmentB = vectorB.slice(lag, lag + overlapLength);
        }
        else {
            segmentA = vectorA.slice(absLag);
            segmentB = vectorB.slice(0, overlapLength);
        }
        return [segmentA, segmentB];
    }

    function getUnit(value, sourceCodeInfo) {
        if (value.length === 0) {
            return value;
        }
        var length = Math.sqrt(value.reduce(function (acc, item) { return acc + Math.pow(item, 2); }, 0));
        if (approxZero(length)) {
            throw new LitsError('The vector must not be zero', sourceCodeInfo);
        }
        return value.map(function (item) { return item / length; });
    }

    function dot(vector1, vector2) {
        return vector1.reduce(function (acc, item, index) { return acc + item * vector2[index]; }, 0);
    }

    function subtract(vector1, vector2) {
        return vector1.map(function (item, index) { return item - vector2[index]; });
    }

    function scale(vector, scalar) {
        return vector.map(function (item) { return item * scalar; });
    }

    function length(vector) {
        return Math.sqrt(vector.reduce(function (acc, item) { return acc + Math.pow(item, 2); }, 0));
    }

    var e_1$2, _a$2;
    var linearAlgebraNormalExpression = {
        'rotate2d': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], radians = _b[1];
                assert2dVector(vector, sourceCodeInfo);
                if (isZeroVector(vector)) {
                    return vector;
                }
                assertNumber(radians, sourceCodeInfo, { finite: true });
                var cosTheta = Math.cos(radians);
                var sinTheta = Math.sin(radians);
                return [
                    vector[0] * cosTheta - vector[1] * sinTheta,
                    vector[0] * sinTheta + vector[1] * cosTheta,
                ];
            },
            arity: toFixedArity(2),
        },
        'rotate3d': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vector = _b[0], axis = _b[1], radians = _b[2];
                assert3dVector(vector, sourceCodeInfo);
                if (isZeroVector(vector)) {
                    return vector;
                }
                assertNumber(radians, sourceCodeInfo, { finite: true });
                assert3dVector(axis, sourceCodeInfo);
                if (isZeroVector(axis)) {
                    throw new LitsError('Rotation axis must not be zero', sourceCodeInfo);
                }
                var cosTheta = Math.cos(radians);
                var sinTheta = Math.sin(radians);
                var _c = __read(getUnit(axis, sourceCodeInfo), 3), u = _c[0], v = _c[1], w = _c[2];
                var dotProduct = vector[0] * u + vector[1] * v + vector[2] * w;
                return [
                    dotProduct * u * (1 - cosTheta) + vector[0] * cosTheta + (-w * vector[1] + v * vector[2]) * sinTheta,
                    dotProduct * v * (1 - cosTheta) + vector[1] * cosTheta + (w * vector[0] - u * vector[2]) * sinTheta,
                    dotProduct * w * (1 - cosTheta) + vector[2] * cosTheta + (-v * vector[0] + u * vector[1]) * sinTheta,
                ];
            },
            arity: toFixedArity(3),
        },
        'reflect': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], normal = _b[1];
                assertVector(vector, sourceCodeInfo);
                assertVector(normal, sourceCodeInfo);
                if (vector.length !== normal.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                if (isZeroVector(normal)) {
                    throw new LitsError('Reflection normal must not be zero', sourceCodeInfo);
                }
                if (isZeroVector(vector)) {
                    return vector;
                }
                var unitNormal = getUnit(normal, sourceCodeInfo);
                var doubleDot = 2 * dot(vector, unitNormal);
                return subtract(vector, scale(unitNormal, doubleDot));
            },
            arity: toFixedArity(2),
        },
        'refract': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vector = _b[0], normal = _b[1], eta = _b[2];
                assertVector(vector, sourceCodeInfo);
                assertVector(normal, sourceCodeInfo);
                assertNumber(eta, sourceCodeInfo, { finite: true, positive: true });
                if (vector.length !== normal.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                if (isZeroVector(normal)) {
                    throw new LitsError('Refraction normal must not be zero', sourceCodeInfo);
                }
                if (isZeroVector(vector)) {
                    return vector;
                }
                // Make sure vectors are normalized
                var normalizedV = getUnit(vector, sourceCodeInfo);
                var normalizedNormal = getUnit(normal, sourceCodeInfo);
                // Calculate dot product between incident vector and normal
                var dotProduct = dot(normalizedV, normalizedNormal);
                // Calculate discriminant
                var discriminant = 1 - eta * eta * (1 - dotProduct * dotProduct);
                // Check for total internal reflection
                if (discriminant < 0) {
                    return vector; // Total internal reflection occurs
                }
                // Calculate the refracted vector
                var scaledIncident = scale(normalizedV, eta);
                var scaledNormal = scale(normalizedNormal, eta * dotProduct + Math.sqrt(discriminant));
                return subtract(scaledIncident, scaledNormal);
            },
            arity: toFixedArity(3),
        },
        'lerp': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vectorA = _b[0], vectorB = _b[1], t = _b[2];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                assertNumber(t, sourceCodeInfo, { finite: true });
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.map(function (val, i) { return val + (vectorB[i] - val) * t; });
            },
            arity: toFixedArity(3),
        },
        'dot': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return dot(vectorA, vectorB);
            },
            arity: toFixedArity(2),
        },
        'cross': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== 3 || vectorB.length !== 3) {
                    throw new LitsError('Cross product is only defined for 3D vectors', sourceCodeInfo);
                }
                return [
                    vectorA[1] * vectorB[2] - vectorA[2] * vectorB[1],
                    vectorA[2] * vectorB[0] - vectorA[0] * vectorB[2],
                    vectorA[0] * vectorB[1] - vectorA[1] * vectorB[0],
                ];
            },
            arity: toFixedArity(2),
        },
        'normalize-minmax': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length === 0) {
                    return [];
                }
                var min = vector.reduce(function (acc, val) { return (val < acc ? val : acc); }, vector[0]);
                var max = vector.reduce(function (acc, val) { return (val > acc ? val : acc); }, vector[0]);
                if (min === max) {
                    return vector.map(function () { return 0; });
                }
                return vector.map(function (val) { return (val - min) / (max - min); });
            },
            arity: toFixedArity(1),
        },
        'normalize-robust': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length === 0) {
                    return [];
                }
                var median = calcMedian(vector);
                var medad = calcMedad(vector);
                if (medad === 0) {
                    return vector.map(function (val) { return val - median; });
                }
                return vector.map(function (val) { return (val - median) / medad; });
            },
            arity: toFixedArity(1),
        },
        'normalize-zscore': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                var mean = calcMean(vector);
                var stdDev = calcStdDev(vector);
                if (stdDev === 0) {
                    return vector.map(function () { return 0; });
                }
                return vector.map(function (val) { return (val - mean) / stdDev; });
            },
            arity: toFixedArity(1),
        },
        'normalize-l1': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length === 0) {
                    return [];
                }
                var norm = vector.reduce(function (acc, val) { return acc + Math.abs(val); }, 0);
                if (norm === 0) {
                    return vector.map(function () { return 0; });
                }
                return vector.map(function (val) { return val / norm; });
            },
            arity: toFixedArity(1),
        },
        'normalize-l2': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return getUnit(vector, sourceCodeInfo);
            },
            arity: toFixedArity(1),
        },
        'normalize-log': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length === 0) {
                    return [];
                }
                var min = Math.min.apply(Math, __spreadArray([], __read(vector), false));
                if (min <= 0) {
                    throw new LitsError('Log normalization requires all values to be positive', sourceCodeInfo);
                }
                return vector.map(function (val) { return Math.log(val / min); });
            },
            arity: toFixedArity(1),
        },
        'angle': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (isZeroVector(vectorA) || isZeroVector(vectorB)) {
                    throw new LitsError('Cannot calculate angle with zero-length vector', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var dotProduct = vectorA.reduce(function (acc, val, i) { return acc + val * vectorB[i]; }, 0);
                var magnitudeA = Math.sqrt(vectorA.reduce(function (acc, val) { return acc + val * val; }, 0));
                var magnitudeB = Math.sqrt(vectorB.reduce(function (acc, val) { return acc + val * val; }, 0));
                return Math.acos(dotProduct / (magnitudeA * magnitudeB));
            },
            arity: toFixedArity(2),
        },
        'projection': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (isZeroVector(vectorB)) {
                    throw new LitsError('Cannot project onto zero-length vector', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var dotProduct = vectorA.reduce(function (acc, val, i) { return acc + val * vectorB[i]; }, 0);
                var magnitudeB = Math.sqrt(vectorB.reduce(function (acc, val) { return acc + val * val; }, 0));
                return vectorB.map(function (val) { return (dotProduct / (Math.pow(magnitudeB, 2))) * val; });
            },
            arity: toFixedArity(2),
        },
        'orthogonal?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var dotProduct = vectorA.reduce(function (acc, val, i) { return acc + val * vectorB[i]; }, 0);
                return dotProduct === 0;
            },
            arity: toFixedArity(2),
        },
        'parallel?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return areVectorsParallel(vectorA, vectorB);
            },
            arity: toFixedArity(2),
        },
        'collinear?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return areVectorsCollinear(vectorA, vectorB);
            },
            arity: toFixedArity(2),
        },
        'cosine-similarity': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (isZeroVector(vectorA) || isZeroVector(vectorB)) {
                    throw new LitsError('Cannot calculate cosine similarity with zero-length vector', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var dotProduct = vectorA.reduce(function (acc, val, i) { return acc + val * vectorB[i]; }, 0);
                var magnitudeA = Math.sqrt(vectorA.reduce(function (acc, val) { return acc + val * val; }, 0));
                var magnitudeB = Math.sqrt(vectorB.reduce(function (acc, val) { return acc + val * val; }, 0));
                return dotProduct / (magnitudeA * magnitudeB);
            },
            arity: toFixedArity(2),
        },
        'euclidean-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return Math.sqrt(vectorA.reduce(function (acc, val, i) { return acc + Math.pow((val - vectorB[i]), 2); }, 0));
            },
            arity: toFixedArity(2),
        },
        'euclidean-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return length(vector);
            },
            arity: toFixedArity(1),
        },
        'manhattan-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) { return acc + Math.abs(val - vectorB[i]); }, 0);
            },
            arity: toFixedArity(2),
        },
        'manhattan-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val) { return acc + Math.abs(val); }, 0);
            },
            arity: toFixedArity(1),
        },
        'hamming-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) { return acc + (val !== vectorB[i] ? 1 : 0); }, 0);
            },
            arity: toFixedArity(2),
        },
        'hamming-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val) { return acc + (val !== 0 ? 1 : 0); }, 0);
            },
            arity: toFixedArity(1),
        },
        'chebyshev-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return Math.max.apply(Math, __spreadArray([], __read(vectorA.map(function (val, i) { return Math.abs(val - vectorB[i]); })), false));
            },
            arity: toFixedArity(2),
        },
        'chebyshev-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return Math.max.apply(Math, __spreadArray([], __read(vector.map(function (val) { return Math.abs(val); })), false));
            },
            arity: toFixedArity(1),
        },
        'minkowski-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vectorA = _b[0], vectorB = _b[1], p = _b[2];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                assertNumber(p, sourceCodeInfo, { finite: true, positive: true });
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return Math.pow(vectorA.reduce(function (acc, val, i) { return acc + Math.pow(Math.abs(val - vectorB[i]), p); }, 0), (1 / p));
            },
            arity: toFixedArity(3),
        },
        'minkowski-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], p = _b[1];
                assertNonEmptyVector(vector, sourceCodeInfo);
                assertNumber(p, sourceCodeInfo, { finite: true, positive: true });
                return Math.pow(vector.reduce(function (acc, val) { return acc + Math.pow(Math.abs(val), p); }, 0), (1 / p));
            },
            arity: toFixedArity(2),
        },
        'cov': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                if (vectorA.length === 1) {
                    return 0;
                }
                return calcCovariance(vectorA, vectorB);
            },
            arity: toFixedArity(2),
        },
        'corr': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length <= 1) {
                    throw new LitsError('Vectors must have at least 2 elements for corr', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var meanA = calcMean(vectorA);
                var meanB = calcMean(vectorB);
                var numerator = vectorA.reduce(function (acc, val, i) { return acc + (val - meanA) * (vectorB[i] - meanB); }, 0);
                var denominator = Math.sqrt(vectorA.reduce(function (acc, val) { return acc + Math.pow((val - meanA), 2); }, 0) * vectorB.reduce(function (acc, val) { return acc + Math.pow((val - meanB), 2); }, 0));
                return numerator / denominator;
            },
            arity: toFixedArity(2),
        },
        'spearman-corr': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length <= 1) {
                    throw new LitsError('Vectors must have at least 2 elements for corr', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var ranksA = calcFractionalRanks(vectorA);
                var ranksB = calcFractionalRanks(vectorB);
                try {
                    return pearsonCorr(ranksA, ranksB);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(2),
        },
        'pearson-corr': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length <= 1) {
                    throw new LitsError('Vectors must have at least 2 elements for pearson-corr', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                try {
                    return pearsonCorr(vectorA, vectorB);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(2),
        },
        'kendall-tau': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length < 2) {
                    throw new LitsError('Vectors must have at least 2 elements for kendall-tau', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                try {
                    return kendallTau(vectorA, vectorB);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(2),
        },
        'autocorrelation': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], lag = _b[1];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < 2) {
                    throw new LitsError('Vector must have at least 2 elements for autocorrelation', sourceCodeInfo);
                }
                assertNumber(lag, sourceCodeInfo, {
                    integer: true,
                    lt: vector.length,
                    gt: -vector.length,
                });
                // For lag 0, return 1 (a series is perfectly correlated with itself)
                if (lag === 0) {
                    return 1;
                }
                var absLag = Math.abs(lag);
                var mean = calcMean(vector);
                // Calculate the numerator (sum of products of deviations)
                var numerator = 0;
                var n = vector.length;
                // If lag is positive, correlate current with past values
                // If lag is negative, correlate current with future values (same calculation, different interpretation)
                for (var i = 0; i < n - absLag; i++) {
                    var currentIndex = lag < 0 ? i + absLag : i;
                    var laggedIndex = lag < 0 ? i : i + absLag;
                    numerator += (vector[currentIndex] - mean) * (vector[laggedIndex] - mean);
                }
                // Calculate the denominator (sum of squared deviations)
                var denominator = 0;
                for (var i = 0; i < n; i++) {
                    denominator += Math.pow((vector[i] - mean), 2);
                }
                // Handle edge case of zero variance
                if (denominator === 0) {
                    return 0; // Conventional definition
                }
                // Return the autocorrelation coefficient
                return numerator / denominator;
            },
            arity: toFixedArity(2),
        },
        'cross-correlation': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vectorA = _b[0], vectorB = _b[1], lag = _b[2];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length < 2) {
                    throw new LitsError('Vectors must have at least 2 elements', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                assertNumber(lag, sourceCodeInfo, {
                    integer: true,
                    lt: vectorA.length,
                    gt: -vectorA.length,
                });
                // For lag 0 between identical vectors, return 1
                if (lag === 0
                    && vectorA.length === vectorB.length
                    && vectorA.every(function (v, i) { return v === vectorB[i]; })) {
                    return 1;
                }
                var _c = __read(extractOverlappingSegments(vectorA, vectorB, lag), 2), segmentA = _c[0], segmentB = _c[1];
                return calcCorrelation(segmentA, segmentB);
            },
            arity: toFixedArity(3),
        },
        'rref': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                // Reduced Row Echelon Form (RREF)
                var _c = __read(gaussJordanElimination(matrix), 1), rref = _c[0];
                return rref;
            },
            arity: toFixedArity(1),
        },
        'solve': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), matrix = _b[0], vector = _b[1];
                assertSquareMatrix(matrix, sourceCodeInfo);
                assertVector(vector, sourceCodeInfo);
                if (matrix.length !== vector.length) {
                    throw new LitsError("The number of rows in the matrix must be equal to the length of the vector, but got ".concat(matrix.length, " and ").concat(vector.length), sourceCodeInfo);
                }
                return solve(matrix, vector);
            },
            arity: toFixedArity(2),
        },
        'to-polar': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assert2dVector(vector, sourceCodeInfo);
                if (isZeroVector(vector)) {
                    return [0, 0];
                }
                var r = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
                var theta = Math.atan2(vector[1], vector[0]);
                return [r, theta];
            },
            arity: toFixedArity(1),
        },
        'from-polar': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), polar = _b[0];
                assert2dVector(polar, sourceCodeInfo);
                var _c = __read(polar, 2), r = _c[0], theta = _c[1];
                if (r === 0) {
                    return [0, 0];
                }
                return [r * Math.cos(theta), r * Math.sin(theta)];
            },
            arity: toFixedArity(1),
        },
    };
    try {
        for (var _b$2 = __values(Object.entries(namespaceDocs$2)), _c$2 = _b$2.next(); !_c$2.done; _c$2 = _b$2.next()) {
            var _d$2 = __read(_c$2.value, 2), key$2 = _d$2[0], docs$2 = _d$2[1];
            if (linearAlgebraNormalExpression[key$2])
                linearAlgebraNormalExpression[key$2].docs = docs$2;
        }
    }
    catch (e_1_1) { e_1$2 = { error: e_1_1 }; }
    finally {
        try {
            if (_c$2 && !_c$2.done && (_a$2 = _b$2.return)) _a$2.call(_b$2);
        }
        finally { if (e_1$2) throw e_1$2.error; }
    }
    var linearAlgebraNamespace = {
        name: 'Linear-Algebra',
        functions: linearAlgebraNormalExpression,
    };

    var namespaceDocs$1 = {
        'mul': {
            category: 'Matrix',
            description: 'Multiplies two `matrices` using standard `matrix` multiplication based on **dot products** of rows and columns.',
            returns: {
                type: 'matrix',
            },
            args: {
                a: {
                    type: 'matrix',
                },
                b: {
                    type: 'matrix',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { mul } = import("Matrix");\nmul([[1, 2], [3, 4]], [[5, 6], [7, 8]])',
                'let { mul } = import("Matrix");\nmul([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]])',
            ],
        },
        'det': {
            category: 'Matrix',
            description: 'Calculates the **determinant** of a square matrix.',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the determinant of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { det } = import("Matrix");\ndet([[1, 2], [3, 4]])',
                'let { det } = import("Matrix");\ndet([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
        'inv': {
            category: 'Matrix',
            description: 'Calculates the **inverse** of a square matrix.',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the inverse of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { inv } = import("Matrix");\ninv([[1, 2], [3, 4]])',
                'let { inv } = import("Matrix");\ninv([[1, 2, 3], [4, 5, 7], [7, 8, 10]])',
            ],
        },
        'adj': {
            category: 'Matrix',
            description: 'Calculates the **adjugate** of a square matrix.',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the adjugate of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { adj } = import("Matrix");\nadj([[1, 2], [3, 4]])',
                'let { adj } = import("Matrix");\nadj([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'let { adj } = import("Matrix");\nadj([[1, 2, 3], [7, 8, 9], [4, 5, 6]])',
            ],
        },
        'cofactor': {
            category: 'Matrix',
            description: 'Calculates the **cofactor** of a square matrix.',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the cofactor of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { cofactor } = import("Matrix");\ncofactor([[1, 2], [3, 4]])',
                'let { cofactor } = import("Matrix");\ncofactor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'let { cofactor } = import("Matrix");\ncofactor([[1, 2, 3], [7, 8, 9], [4, 5, 6]])',
            ],
        },
        'minor': {
            category: 'Matrix',
            description: 'Calculates the **minor** of a square matrix.',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the minor of.',
                },
                row: {
                    type: 'integer',
                    description: 'The row index of the element to calculate the minor for.',
                },
                col: {
                    type: 'integer',
                    description: 'The column index of the element to calculate the minor for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                        'row',
                        'col',
                    ],
                },
            ],
            examples: [
                'let { minor } = import("Matrix");\nminor([[1, 2], [3, 4]], 0, 1)',
                'let { minor } = import("Matrix");\nminor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1, 1)',
            ],
        },
        'trace': {
            category: 'Matrix',
            description: 'Calculates the **trace** of a square matrix.',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the trace of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { trace } = import("Matrix");\ntrace([[1, 2], [3, 4]])',
                'let { trace } = import("Matrix");\ntrace([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
        'symmetric?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is **symmetric**.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for symmetry.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { symmetric? } = import("Matrix");\nsymmetric?([[1, 2], [2, 1]])',
                'let { symmetric? } = import("Matrix");\nsymmetric?([[1, 2, 3], [2, 1, 4], [3, 4, 1]])',
            ],
        },
        'triangular?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is **triangular**.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for triangularity.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { triangular? } = import("Matrix");\ntriangular?([[2, 0], [0, 1]])',
                'let { triangular? } = import("Matrix");\ntriangular?([[1, 2, 3], [0, 4, 5], [0, 0, 6]])',
            ],
        },
        'upper-triangular?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is **upper triangular**.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for upper triangularity.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { upper-triangular? } = import("Matrix");\nupper-triangular?([[1, 2], [0, 3]])',
                'let { upper-triangular? } = import("Matrix");\nupper-triangular?([[1, 2, 3], [0, 4, 5], [0, 0, 6]])',
            ],
        },
        'lower-triangular?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is **lower triangular**.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for lower triangularity.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { lower-triangular? } = import("Matrix");\nlower-triangular?([[1, 0], [2, 3]])',
                'let { lower-triangular? } = import("Matrix");\nlower-triangular?([[1, 0, 0], [2, 3, 0], [4, 5, 6]])',
            ],
        },
        'diagonal?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is **diagonal**.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for diagonal property.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { diagonal? } = import("Matrix");\ndiagonal?([[1, 0], [0, 2]])',
                'let { diagonal? } = import("Matrix");\ndiagonal?([[1, 0, 0], [0, 2, 0], [0, 0, 3]])',
                'let { diagonal? } = import("Matrix");\ndiagonal?([[1, 0, 0], [2, 2, 2], [0, 0, 3]])',
            ],
        },
        'square?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is **square**.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for square property.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { square? } = import("Matrix");\nsquare?([[1, 2], [3, 4]])',
                'let { square? } = import("Matrix");\nsquare?([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'let { square? } = import("Matrix");\nsquare?([[1, 2, 3], [4, 5, 6]])',
            ],
        },
        'orthogonal?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is **orthogonal**.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for **orthogonality**.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { orthogonal? } = import("Matrix");\northogonal?([[1, 0], [0, 1]])',
                'let { orthogonal? } = import("Matrix");\northogonal?([[1, 0], [0, -1]])',
                'let { orthogonal? } = import("Matrix");\northogonal?([[1, 2], [3, 4]])',
            ],
        },
        'identity?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is an **identity matrix**.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for identity property.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { identity? } = import("Matrix");\nidentity?([[1, 0], [0, 1]])',
                'let { identity? } = import("Matrix");\nidentity?([[1, 0, 0], [0, 1, 0], [0, 0, 1]])',
                'let { identity? } = import("Matrix");\nidentity?([[1, 0, 0], [0, 1, 0], [0, 0, 0]])',
            ],
        },
        'invertible?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is **invertible**.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for invertibility.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { invertible? } = import("Matrix");\ninvertible?([[1, 2], [3, 4]])',
                'let { invertible? } = import("Matrix");\ninvertible?([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'let { invertible? } = import("Matrix");\ninvertible?([[1, 2], [2, 4]])',
            ],
        },
        'hilbert': {
            category: 'Matrix',
            description: 'Generates a **Hilbert matrix** of size `n`.',
            returns: {
                type: 'matrix',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The size of the Hilbert matrix.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { hilbert } = import("Matrix");\nhilbert(3)',
                'let { hilbert } = import("Matrix");\nhilbert(4)',
            ],
        },
        'vandermonde': {
            category: 'Matrix',
            description: 'Generates a **Vandermonde matrix** from a vector.',
            returns: {
                type: 'matrix',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'The vector to generate the Vandermonde matrix from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'v',
                    ],
                },
            ],
            examples: [
                'let { vandermonde } = import("Matrix");\nvandermonde([1, 2, 3])',
                'let { vandermonde } = import("Matrix");\nvandermonde([1, 0, 1])',
            ],
        },
        'band': {
            category: 'Matrix',
            description: 'Generates a **banded matrix** of size `n` with lower band index `lband` and upper band index `uband`.',
            returns: {
                type: 'matrix',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The size of the banded matrix.',
                },
                lband: {
                    type: 'integer',
                    description: 'The lower band index.',
                },
                uband: {
                    type: 'integer',
                    description: 'The upper band index.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                        'lband',
                        'uband',
                    ],
                },
            ],
            examples: [
                'let { band } = import("Matrix");\nband(3, 1, 1)',
                'let { band } = import("Matrix");\nband(4, 1, 2)',
            ],
        },
        'banded?': {
            category: 'Matrix',
            description: 'Checks if a `matrix` is **banded** with lower band index `lband` and upper band index `uband`.',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for **banded** property.',
                },
                lband: {
                    type: 'integer',
                    description: 'The lower band index.',
                },
                uband: {
                    type: 'integer',
                    description: 'The upper band index.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                        'lband',
                        'uband',
                    ],
                },
            ],
            examples: [
                'let { banded? } = import("Matrix");\nbanded?([\n  [1, 1, 1, 0],\n  [1, 1, 1, 1],\n  [1, 1, 1, 1],\n  [0, 1, 1, 1],\n], 2, 2)',
                'let { banded? } = import("Matrix");\nbanded?([\n  [1, 1, 1, 0],\n  [1, 1, 1, 1],\n  [1, 1, 1, 1],\n  [0, 1, 1, 1],\n], 1, 1)',
            ],
        },
        'rank': {
            category: 'Matrix',
            description: 'Calculates the **rank** of a matrix using **Gaussian elimination**.',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the rank of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { rank } = import("Matrix");\nrank([[1, 0, 0], [0, 1, 0], [0, 0, 1]])',
                'let { rank } = import("Matrix");\nrank([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'let { rank } = import("Matrix");\nrank([[2, 4, 6], [3, 6, 9], [4, 8, 12]])',
            ],
        },
        'frobenius-norm': {
            category: 'Matrix',
            description: 'Calculates the **Frobenius norm** of a matrix.',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the Frobenius norm of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { frobenius-norm } = import("Matrix");\nfrobenius-norm([[1, 2], [3, 4]])',
                'let { frobenius-norm } = import("Matrix");\nfrobenius-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
        'one-norm': {
            category: 'Matrix',
            description: 'Calculates the **one-norm** (column norm) of a matrix.',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the one-norm of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { one-norm } = import("Matrix");\none-norm([[1, 2], [3, 4]])',
                'let { one-norm } = import("Matrix");\none-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
        'inf-norm': {
            category: 'Matrix',
            description: 'Calculates the **infinity norm** of a matrix.',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the infinity norm of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { inf-norm } = import("Matrix");\ninf-norm([[1, 2], [3, 4]])',
                'let { inf-norm } = import("Matrix");\ninf-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
        'max-norm': {
            category: 'Matrix',
            description: 'Calculates the **max norm** of a matrix.',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the max norm of.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'm',
                    ],
                },
            ],
            examples: [
                'let { max-norm } = import("Matrix");\nmax-norm([[1, 2], [3, 4]])',
                'let { max-norm } = import("Matrix");\nmax-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
    };

    /**
     * Calculates the determinant of a matrix using Gaussian Elimination
     * @param matrix A square matrix represented as a 2D array
     * @returns The determinant of the matrix
     */
    function determinant(matrix) {
        var _a;
        // First, make a deep copy of the matrix to avoid modifying the original
        var n = matrix.length;
        var A = [];
        for (var i = 0; i < n; i++) {
            A[i] = __spreadArray([], __read(matrix[i]), false);
        }
        // Handle special cases for small matrices
        if (n === 1) {
            return A[0][0];
        }
        if (n === 2) {
            return A[0][0] * A[1][1] - A[0][1] * A[1][0];
        }
        // For larger matrices, use Gaussian elimination
        var sign = 1; // Track sign changes from row swaps
        // Perform Gaussian elimination to get an upper triangular matrix
        for (var i = 0; i < n - 1; i += 1) {
            // Find pivot (maximum element in current column)
            var maxRow = i;
            for (var j = i + 1; j < n; j += 1) {
                if (Math.abs(A[j][i]) > Math.abs(A[maxRow][i])) {
                    maxRow = j;
                }
            }
            // If the pivot is zero, the determinant is zero
            if (approxZero(A[maxRow][i])) {
                return 0;
            }
            // Swap rows if necessary
            if (maxRow !== i) {
                _a = __read([A[maxRow], A[i]], 2), A[i] = _a[0], A[maxRow] = _a[1]; // ES6 array destructuring for swap
                sign = -sign; // Each row swap changes the sign
            }
            // Eliminate entries below the pivot
            for (var j = i + 1; j < n; j += 1) {
                var factor = A[j][i] / A[i][i];
                // Subtract (factor * pivot row) from current row
                for (var k = i; k < n; k++) {
                    A[j][k] -= factor * A[i][k];
                }
            }
        }
        // Calculate determinant as the product of diagonal elements
        var det = sign;
        for (var i = 0; i < n; i++) {
            det *= A[i][i];
        }
        return det;
    }

    function minor(matrix, row, col) {
        var n = matrix.length;
        var result = [];
        for (var i = 0; i < n; i++) {
            if (i !== row) {
                var minorRow = [];
                for (var j = 0; j < n; j++) {
                    if (j !== col) {
                        minorRow.push(matrix[i][j]);
                    }
                }
                result.push(minorRow);
            }
        }
        return result;
    }

    function adjugate(matrix) {
        var n = matrix.length;
        var adj = [];
        for (var i = 0; i < n; i++) {
            adj[i] = [];
            for (var j = 0; j < n; j++) {
                var min = minor(matrix, j, i);
                var sign = Math.pow((-1), (i + j));
                var cofactor = sign * determinant(min);
                adj[i][j] = cofactor;
            }
        }
        return adj;
    }

    /**
     * Creates a band matrix with specified lower and upper bandwidths
     *
     * @param n Size of the square matrix
     * @param lband Lower bandwidth (number of non-zero diagonals below main diagonal)
     * @param uband Upper bandwidth (number of non-zero diagonals above main diagonal)
     * @returns A 2D array representing the band matrix with 1s in the band and 0s elsewhere
     */
    function band(n, lband, uband) {
        // Create an n×n matrix filled with zeros
        var matrix = Array.from({ length: n }, function () { return Array.from({ length: n }, function () { return 0; }); });
        // Fill the band with 1s
        for (var i = 0; i < n; i++) {
            for (var j = Math.max(0, i - lband); j <= Math.min(n - 1, i + uband); j++) {
                matrix[i][j] = 1;
            }
        }
        return matrix;
    }

    function cofactor(matrix) {
        var n = matrix.length;
        var cofactors = [];
        // Create a new matrix to store cofactors
        for (var i = 0; i < n; i++) {
            cofactors[i] = [];
            for (var j = 0; j < n; j++) {
                // Get the minor by removing row i and column j
                var min = minor(matrix, i, j);
                var sign = Math.pow((-1), (i + j));
                cofactors[i][j] = sign * determinant(min);
            }
        }
        return cofactors;
    }

    /**
     * Calculate the inverse of a matrix using the adjugate method
     * @param matrix The input matrix
     * @returns The inverse matrix or null if the matrix is not invertible
     */
    function inverse(matrix) {
        var n = matrix.length;
        // Special case for 1x1 matrix - handle it directly
        if (n === 1) {
            var element = matrix[0][0];
            if (approxZero(element)) {
                return null; // Not invertible
            }
            return [[1 / element]];
        }
        // Calculate determinant
        var det = determinant(matrix);
        // Check if matrix is invertible
        if (approxZero(det)) {
            return null; // Matrix is not invertible
        }
        // Get the adjugate matrix
        var adj = adjugate(matrix);
        // Calculate the inverse: inverse = adjugate / determinant
        var inverseMatrix = [];
        for (var i = 0; i < n; i++) {
            inverseMatrix[i] = [];
            for (var j = 0; j < n; j++) {
                inverseMatrix[i][j] = adj[i][j] / det;
            }
        }
        return inverseMatrix;
    }

    /**
     * Checks if a matrix is banded with the given lower and upper bandwidth.
     * A matrix is banded if all non-zero elements are within 'lower' diagonals
     * below the main diagonal and 'upper' diagonals above the main diagonal.
     *
     * @param matrix - The matrix to check, represented as a 2D array of numbers
     * @param lower - Number of non-zero diagonals below the main diagonal
     * @param upper - Number of non-zero diagonals above the main diagonal
     * @returns true if the matrix is banded with the given parameters, false otherwise
     */
    function isBanded(matrix, lower, upper) {
        var rows = matrix.length;
        var cols = matrix[0].length;
        // Check each element in the matrix
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
                // If we find a non-zero element outside the band, return false
                if (matrix[i][j] !== 0 && (i - j > lower || j - i > upper)) {
                    return false;
                }
            }
        }
        // All elements outside the band are zero
        return true;
    }

    function isSquare(matrix) {
        return matrix.length === matrix[0].length;
    }

    /**
     * Checks if a given matrix is diagonal.
     *
     * A matrix is considered diagonal if it is square (i.e., the number of rows equals the number of columns)
     * and all elements outside the main diagonal are zero.
     *
     * @param matrix - A two-dimensional array of numbers representing the matrix to check.
     * @returns `true` if the matrix is diagonal, otherwise `false`.
     */
    function isDiagonal(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var rows = matrix.length;
        for (var i = 0; i < rows; i += 1) {
            for (var j = 0; j < rows; j += 1) {
                if (i !== j && matrix[i][j] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }

    function isIdentity(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var n = matrix.length;
        for (var i = 0; i < n; i++) {
            for (var j = 0; j < n; j++) {
                if (i === j) {
                    if (!approxEqual(matrix[i][j], 1)) {
                        return false;
                    }
                }
                else {
                    if (!approxZero(matrix[i][j])) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    /**
     * Performs cache-optimized matrix multiplication.
     * @param A The first input matrix (m x n)
     * @param B The second input matrix (n x p)
     * @returns The result matrix C (m x p) where C = A × B
     */
    function matrixMultiply(A, B) {
        // Check if matrices can be multiplied
        if (A.length === 0 || B.length === 0 || A[0].length !== B.length) {
            throw new Error('Matrix dimensions do not match for multiplication');
        }
        var m = A.length; // Number of rows in A
        var n = A[0].length; // Number of columns in A / Number of rows in B
        var p = B[0].length; // Number of columns in B
        // Initialize result matrix C with zeros
        var C = Array(m).fill(0).map(function () { return Array(p).fill(0); });
        // Perform multiplication with cache-optimized loop order (i-k-j)
        for (var i = 0; i < m; i++) {
            for (var k = 0; k < n; k++) {
                var aik = A[i][k]; // Cache this value to avoid repeated lookups
                for (var j = 0; j < p; j++) {
                    C[i][j] += aik * B[k][j];
                }
            }
        }
        return C;
    }

    function isOrthogonal(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        // Calculate matrix transpose
        var transposed = transpose(matrix);
        // Check if matrix * transpose = Identity
        var product = matrixMultiply(matrix, transposed);
        // Check if the product is an identity matrix
        return isIdentity(product);
    }

    /**
     * Checks if a given matrix is symmetric.
     * A matrix is symmetric if it is square and its transpose is equal to itself.
     *
     * @param matrix - A 2D array representing the matrix.
     * @returns `true` if the matrix is symmetric, otherwise `false`.
     */
    function isSymetric(matrix) {
        var rows = matrix.length;
        // Check if the matrix is square
        if (!isSquare(matrix)) {
            return false;
        }
        // Check symmetry
        for (var i = 0; i < rows; i += 1) {
            for (var j = 0; j < i; j += 1) {
                if (matrix[i][j] !== matrix[j][i]) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Determines whether a given matrix is triangular.
     *
     * A triangular matrix is a square matrix where all elements
     * below or above the main diagonal are zero. This function
     * checks if the matrix is square and symmetric.
     *
     * @param matrix - A two-dimensional array of numbers representing the matrix.
     * @returns `true` if the matrix is triangular, otherwise `false`.
     */
    function isTriangular(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var rows = matrix.length;
        var isUpperTriangular = true;
        var isLowerTriangular = true;
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < rows; j++) {
                if (i > j && matrix[i][j] !== 0) {
                    isUpperTriangular = false;
                    if (!isLowerTriangular) {
                        return false;
                    }
                }
                if (i < j && matrix[i][j] !== 0) {
                    isLowerTriangular = false;
                }
            }
        }
        return isUpperTriangular || isLowerTriangular;
    }
    function isTriangularUpper(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var rows = matrix.length;
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < i; j++) {
                if (matrix[i][j] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }
    function isTriangularLower(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var rows = matrix.length;
        // Check if the matrix is square
        if (!matrix.every(function (row) { return row.length === rows; })) {
            return false;
        }
        for (var i = 0; i < rows; i++) {
            for (var j = i + 1; j < rows; j++) {
                if (matrix[i][j] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }

    // Assuming a matrix is represented as a 2D array
    function norm1(matrix) {
        var numRows = matrix.length;
        var numCols = matrix[0].length;
        var maxColSum = 0;
        // Iterate through each column
        for (var j = 0; j < numCols; j += 1) {
            var colSum = 0;
            // Sum the absolute values of all elements in this column
            for (var i = 0; i < numRows; i += 1) {
                colSum += Math.abs(matrix[i][j]);
            }
            // Update the maximum column sum if necessary
            maxColSum = Math.max(maxColSum, colSum);
        }
        return maxColSum;
    }

    /**
     * Calculates the trace of a square matrix.
     * The trace is defined as the sum of the elements on the main diagonal.
     *
     * @param matrix - A 2D array representing a square matrix.
     * @returns The trace of the matrix.
     */
    function trace(matrix) {
        return matrix.reduce(function (sum, row, i) { return sum + row[i]; }, 0);
    }

    var e_1$1, _a$1;
    var matrixNormalExpression = {
        'mul': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), matrix1 = _b[0], matrix2 = _b[1];
                assertMatrix(matrix1, sourceCodeInfo);
                assertMatrix(matrix2, sourceCodeInfo);
                try {
                    return matrixMultiply(matrix1, matrix2);
                }
                catch (error) {
                    throw new LitsError("The number of columns in the first matrix must be equal to the number of rows in the second matrix, but got ".concat(matrix1[0].length, " and ").concat(matrix2.length), sourceCodeInfo);
                }
            },
            arity: toFixedArity(2),
        },
        'det': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                return determinant(matrix);
            },
            arity: toFixedArity(1),
        },
        'inv': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                var result = inverse(matrix);
                if (result === null) {
                    throw new LitsError('The matrix must be invertible', sourceCodeInfo);
                }
                return result;
            },
            arity: toFixedArity(1),
        },
        'adj': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                return adjugate(matrix);
            },
            arity: toFixedArity(1),
        },
        'cofactor': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                return cofactor(matrix);
            },
            arity: toFixedArity(1),
        },
        'minor': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), matrix = _b[0], row = _b[1], col = _b[2];
                assertMatrix(matrix, sourceCodeInfo);
                assertNumber(row, sourceCodeInfo, { integer: true, nonNegative: true, lte: matrix.length });
                assertNumber(col, sourceCodeInfo, { integer: true, nonNegative: true, lte: matrix[0].length });
                return minor(matrix, row, col);
            },
            arity: toFixedArity(3),
        },
        'trace': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                return trace(matrix);
            },
            arity: toFixedArity(1),
        },
        'symmetric?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isSymetric(matrix);
            },
            arity: toFixedArity(1),
        },
        'triangular?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isTriangular(matrix);
            },
            arity: toFixedArity(1),
        },
        'upper-triangular?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isTriangularUpper(matrix);
            },
            arity: toFixedArity(1),
        },
        'lower-triangular?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isTriangularLower(matrix);
            },
            arity: toFixedArity(1),
        },
        'diagonal?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isDiagonal(matrix);
            },
            arity: toFixedArity(1),
        },
        'square?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isSquare(matrix);
            },
            arity: toFixedArity(1),
        },
        'orthogonal?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isOrthogonal(matrix);
            },
            arity: toFixedArity(1),
        },
        'identity?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isIdentity(matrix);
            },
            arity: toFixedArity(1),
        },
        'invertible?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                if (!isSquareMatrix(matrix)) {
                    return false;
                }
                return !approxZero(determinant(matrix));
            },
            arity: toFixedArity(1),
        },
        'hilbert': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), size = _b[0];
                assertNumber(size, sourceCodeInfo, { integer: true, positive: true });
                var result = [];
                for (var i = 0; i < size; i += 1) {
                    var row = [];
                    for (var j = 0; j < size; j += 1) {
                        row.push(1 / (i + j + 1));
                    }
                    result.push(row);
                }
                return result;
            },
            arity: toFixedArity(1),
        },
        'vandermonde': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                var result = [];
                for (var i = 0; i < vector.length; i += 1) {
                    var row = [];
                    for (var j = 0; j < vector.length; j += 1) {
                        row.push(Math.pow((vector[i]), j));
                    }
                    result.push(row);
                }
                return result;
            },
            arity: toFixedArity(1),
        },
        'band': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), n = _b[0], lband = _b[1], uband = _b[2];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(lband, sourceCodeInfo, { integer: true, nonNegative: true, lt: n });
                assertNumber(uband, sourceCodeInfo, { integer: true, nonNegative: true, lte: n });
                return band(n, lband, uband);
            },
            arity: toFixedArity(3),
        },
        'banded?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), matrix = _b[0], lband = _b[1], uband = _b[2];
                assertMatrix(matrix, sourceCodeInfo);
                var maxBand = Math.max(matrix.length, matrix[0].length);
                assertNumber(lband, sourceCodeInfo, { integer: true, nonNegative: true, lt: maxBand });
                assertNumber(uband, sourceCodeInfo, { integer: true, nonNegative: true, lt: maxBand });
                return isBanded(matrix, lband, uband);
            },
            arity: toFixedArity(3),
        },
        'rank': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                var _c = __read(gaussJordanElimination(matrix), 2), result = _c[1];
                return result;
            },
            arity: toFixedArity(1),
        },
        // Frobenius norm
        'frobenius-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return Math.sqrt(matrix.reduce(function (sum, row) { return sum + row.reduce(function (rowSum, cell) { return rowSum + cell * cell; }, 0); }, 0));
            },
            arity: toFixedArity(1),
        },
        // one-norm (column norm)
        'one-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return norm1(matrix);
            },
            arity: toFixedArity(1),
        },
        // Infinity norm
        'inf-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return matrix.reduce(function (max, row) { return Math.max(max, row.reduce(function (sum, cell) { return sum + Math.abs(cell); }, 0)); }, 0);
            },
            arity: toFixedArity(1),
        },
        // Max norm
        'max-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return matrix.reduce(function (maxVal, row) {
                    var rowMax = row.reduce(function (max, val) { return Math.max(max, Math.abs(val)); }, 0);
                    return Math.max(maxVal, rowMax);
                }, 0);
            },
            arity: toFixedArity(1),
        },
    };
    try {
        for (var _b$1 = __values(Object.entries(namespaceDocs$1)), _c$1 = _b$1.next(); !_c$1.done; _c$1 = _b$1.next()) {
            var _d$1 = __read(_c$1.value, 2), key$1 = _d$1[0], docs$1 = _d$1[1];
            if (matrixNormalExpression[key$1])
                matrixNormalExpression[key$1].docs = docs$1;
        }
    }
    catch (e_1_1) { e_1$1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c$1 && !_c$1.done && (_a$1 = _b$1.return)) _a$1.call(_b$1);
        }
        finally { if (e_1$1) throw e_1$1.error; }
    }
    var matrixNamespace = {
        name: 'Matrix',
        functions: matrixNormalExpression,
    };

    var namespaceDocs = {
        'abundant-seq': {
            category: 'Number Theory',
            description: 'Generates the abundant numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { abundant-seq } = import("Number-Theory");\nabundant-seq(1)',
                'let { abundant-seq } = import("Number-Theory");\nabundant-seq(5)',
            ],
        },
        'abundant-take-while': {
            category: 'Number Theory',
            description: 'Generates the abundant numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { abundant-take-while } = import("Number-Theory");\nabundant-take-while(-> $ < 100)',
            ],
        },
        'abundant-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the abundant numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the number in the sequence.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { abundant-nth } = import("Number-Theory");\nabundant-nth(1)',
                'let { abundant-nth } = import("Number-Theory");\nabundant-nth(5)',
            ],
        },
        'abundant?': {
            category: 'Number Theory',
            description: 'Checks if a number is abundant.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { abundant? } = import("Number-Theory");\nabundant?(12)',
                'let { abundant? } = import("Number-Theory");\nabundant?(15)',
            ],
        },
        'arithmetic-seq': {
            category: 'Number Theory',
            description: 'Generates the arithmetic sequence for a given $start, $step, and $length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                step: {
                    type: 'number',
                    description: 'The common difference of the sequence.',
                },
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                        'step',
                        'length',
                    ],
                },
            ],
            examples: [
                'let { arithmetic-seq } = import("Number-Theory");\narithmetic-seq(3, 2, 2)',
                'let { arithmetic-seq } = import("Number-Theory");\narithmetic-seq(2, 3, 2)',
                'let { arithmetic-seq } = import("Number-Theory");\narithmetic-seq(1, 2, 2)',
                'let { arithmetic-seq } = import("Number-Theory");\narithmetic-seq(1, 1.5, 12)',
            ],
        },
        'arithmetic-take-while': {
            category: 'Number Theory',
            description: 'Generates the arithmetic sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                step: {
                    type: 'number',
                    description: 'The common difference of the sequence.',
                },
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes a number and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                        'step',
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { arithmetic-take-while } = import("Number-Theory");\narithmetic-take-while(1, 0.25, -> $ < 3)',
            ],
        },
        'arithmetic-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the arithmetic sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                step: {
                    type: 'number',
                    description: 'The common difference of the sequence.',
                },
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                        'step',
                        'n',
                    ],
                },
            ],
            examples: [
                'let { arithmetic-nth } = import("Number-Theory");\narithmetic-nth(3, 2, 2)',
                'let { arithmetic-nth } = import("Number-Theory");\narithmetic-nth(2, 3, 2)',
                'let { arithmetic-nth } = import("Number-Theory");\narithmetic-nth(1, 2, 2)',
                'let { arithmetic-nth } = import("Number-Theory");\narithmetic-nth(1, 1.5, 12)',
            ],
        },
        'arithmetic?': {
            category: 'Number Theory',
            description: 'Checks if a number is part of the arithmetic sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                step: {
                    type: 'number',
                    description: 'The common difference of the sequence.',
                },
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                        'step',
                        'n',
                    ],
                },
            ],
            examples: [
                'let { arithmetic? } = import("Number-Theory");\narithmetic?(3, 2, 2)',
                'let { arithmetic? } = import("Number-Theory");\narithmetic?(2, 3, 2)',
                'let { arithmetic? } = import("Number-Theory");\narithmetic?(1, 2, 2)',
                'let { arithmetic? } = import("Number-Theory");\narithmetic?(1, 1.5, 12)',
            ],
        },
        'bell-seq': {
            category: 'Number Theory',
            description: 'Generates the Bell sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 22 (the maximum length of the pre-calculated bell numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { bell-seq } = import("Number-Theory");\nbell-seq(5)',
                'let { bell-seq } = import("Number-Theory");\nbell-seq(10)',
                'let { bell-seq } = import("Number-Theory");\nbell-seq()',
            ],
        },
        'bell-take-while': {
            category: 'Number Theory',
            description: 'Generates the Bell sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { bell-take-while } = import("Number-Theory");\nbell-take-while(-> $ < 1000)',
            ],
        },
        'bell-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Bell sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { bell-nth } = import("Number-Theory");\nbell-nth(5)',
                'let { bell-nth } = import("Number-Theory");\nbell-nth(10)',
            ],
        },
        'bell?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the Bell sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { bell? } = import("Number-Theory");\nbell?(1)',
                'let { bell? } = import("Number-Theory");\nbell?(27644437)',
                'let { bell? } = import("Number-Theory");\nbell?(27644436)',
            ],
        },
        'bernoulli-seq': {
            category: 'Number Theory',
            description: 'Generates the Bernoulli sequence up to a specified length.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { bernoulli-seq } = import("Number-Theory");\nbernoulli-seq(5)',
                'let { bernoulli-seq } = import("Number-Theory");\nbernoulli-seq(10)',
            ],
        },
        'bernoulli-take-while': {
            category: 'Number Theory',
            description: 'Generates the Bernoulli sequence while a condition is met.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { bernoulli-take-while } = import("Number-Theory");\nbernoulli-take-while(-> abs($) < 100)',
            ],
        },
        'bernoulli-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Bernoulli sequence.',
            returns: {
                type: 'number',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { bernoulli-nth } = import("Number-Theory");\nbernoulli-nth(5)',
                'let { bernoulli-nth } = import("Number-Theory");\nbernoulli-nth(10)',
                'let { bernoulli-nth } = import("Number-Theory");\nbernoulli-nth(23)',
            ],
        },
        'catalan-seq': {
            category: 'Number Theory',
            description: 'Generates the Catalan sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 30 (the maximum length of the pre-calculated catalan numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { catalan-seq } = import("Number-Theory");\ncatalan-seq(5)',
                'let { catalan-seq } = import("Number-Theory");\ncatalan-seq(10)',
                'let { catalan-seq } = import("Number-Theory");\ncatalan-seq()',
            ],
        },
        'catalan-take-while': {
            category: 'Number Theory',
            description: 'Generates the Catalan sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { catalan-take-while } = import("Number-Theory");\ncatalan-take-while(-> $ < 1000)',
            ],
        },
        'catalan-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Catalan sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { catalan-nth } = import("Number-Theory");\ncatalan-nth(5)',
                'let { catalan-nth } = import("Number-Theory");\ncatalan-nth(10)',
            ],
        },
        'catalan?': {
            category: 'Number Theory',
            description: 'Determines if a number is in the Catalan sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { catalan? } = import("Number-Theory");\ncatalan?(5)',
                'let { catalan? } = import("Number-Theory");\ncatalan?(10)',
            ],
        },
        'collatz-seq': {
            category: 'Number Theory',
            description: 'Generates the collatz sequence starting from a given integer.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'integer',
                    description: 'The starting integer for the collatz sequence.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                    ],
                },
            ],
            examples: [
                'let { collatz-seq } = import("Number-Theory");\ncollatz-seq(3)',
                'let { collatz-seq } = import("Number-Theory");\ncollatz-seq(11)',
            ],
        },
        'composite-seq': {
            category: 'Number Theory',
            description: 'Generates the composite sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { composite-seq } = import("Number-Theory");\ncomposite-seq(1)',
                'let { composite-seq } = import("Number-Theory");\ncomposite-seq(2)',
                'let { composite-seq } = import("Number-Theory");\ncomposite-seq(10)',
            ],
        },
        'composite-take-while': {
            category: 'Number Theory',
            description: 'Generates the composite sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { composite-take-while } = import("Number-Theory");\ncomposite-take-while(-> $ < 50)',
            ],
        },
        'composite-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the composite sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the composite number to retrieve.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { composite-nth } = import("Number-Theory");\ncomposite-nth(1)',
                'let { composite-nth } = import("Number-Theory");\ncomposite-nth(2)',
                'let { composite-nth } = import("Number-Theory");\ncomposite-nth(10)',
            ],
        },
        'composite?': {
            category: 'Number Theory',
            description: 'Determines if a number is composite.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { composite? } = import("Number-Theory");\ncomposite?(4)',
                'let { composite? } = import("Number-Theory");\ncomposite?(5)',
                'let { composite? } = import("Number-Theory");\ncomposite?(11)',
            ],
        },
        'deficient-seq': {
            category: 'Number Theory',
            description: 'Generates the deficient numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { deficient-seq } = import("Number-Theory");\ndeficient-seq(1)',
                'let { deficient-seq } = import("Number-Theory");\ndeficient-seq(5)',
            ],
        },
        'deficient-take-while': {
            category: 'Number Theory',
            description: 'Generates the deficient numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { deficient-take-while } = import("Number-Theory");\ndeficient-take-while(-> $ < 100)',
            ],
        },
        'deficient-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the deficient numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the number in the sequence.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { deficient-nth } = import("Number-Theory");\ndeficient-nth(5)',
                'let { deficient-nth } = import("Number-Theory");\ndeficient-nth(12)',
            ],
        },
        'deficient?': {
            category: 'Number Theory',
            description: 'Checks if a number is deficient.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { deficient? } = import("Number-Theory");\ndeficient?(12)',
                'let { deficient? } = import("Number-Theory");\ndeficient?(15)',
            ],
        },
        'factorial-seq': {
            category: 'Number Theory',
            description: 'Generates the factorial sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 19 (the maximum length of the pre-calculated factorial numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { factorial-seq } = import("Number-Theory");\nfactorial-seq(1)',
                'let { factorial-seq } = import("Number-Theory");\nfactorial-seq(2)',
                'let { factorial-seq } = import("Number-Theory");\nfactorial-seq(3)',
                'let { factorial-seq } = import("Number-Theory");\nfactorial-seq(4)',
                'let { factorial-seq } = import("Number-Theory");\nfactorial-seq(5)',
                'let { factorial-seq } = import("Number-Theory");\nfactorial-seq(10)',
            ],
        },
        'factorial-take-while': {
            category: 'Number Theory',
            description: 'Generates the factorial sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { factorial-take-while } = import("Number-Theory");\nfactorial-take-while(-> $ < 1000)',
            ],
        },
        'factorial-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the factorial sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { factorial-nth } = import("Number-Theory");\nfactorial-nth(1)',
                'let { factorial-nth } = import("Number-Theory");\nfactorial-nth(2)',
                'let { factorial-nth } = import("Number-Theory");\nfactorial-nth(3)',
                'let { factorial-nth } = import("Number-Theory");\nfactorial-nth(4)',
                'let { factorial-nth } = import("Number-Theory");\nfactorial-nth(5)',
                'let { factorial-nth } = import("Number-Theory");\nfactorial-nth(10)',
            ],
        },
        'factorial?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the factorial sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { factorial? } = import("Number-Theory");\nfactorial?(1)',
                'let { factorial? } = import("Number-Theory");\nfactorial?(2)',
                'let { factorial? } = import("Number-Theory");\nfactorial?(3)',
                'let { factorial? } = import("Number-Theory");\nfactorial?(4)',
                'let { factorial? } = import("Number-Theory");\nfactorial?(5)',
                'let { factorial? } = import("Number-Theory");\nfactorial?(6)',
                'let { factorial? } = import("Number-Theory");\nfactorial?(7)',
                'let { factorial? } = import("Number-Theory");\nfactorial?(8)',
                'let { factorial? } = import("Number-Theory");\nfactorial?(9)',
                'let { factorial? } = import("Number-Theory");\nfactorial?(3628800)',
            ],
        },
        'fibonacci-seq': {
            category: 'Number Theory',
            description: 'Generates the fibonacci sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 79 (the maximum length of the pre-calculated Fibonacci numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { fibonacci-seq } = import("Number-Theory");\nfibonacci-seq(1)',
                'let { fibonacci-seq } = import("Number-Theory");\nfibonacci-seq(2)',
                'let { fibonacci-seq } = import("Number-Theory");\nfibonacci-seq()',
            ],
        },
        'fibonacci-take-while': {
            category: 'Number Theory',
            description: 'Generates the fibonacci sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { fibonacci-take-while } = import("Number-Theory");\nfibonacci-take-while(-> $ < 100)',
            ],
        },
        'fibonacci-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the fibonacci sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { fibonacci-nth } = import("Number-Theory");\nfibonacci-nth(5)',
                'let { fibonacci-nth } = import("Number-Theory");\nfibonacci-nth(50)',
            ],
        },
        'fibonacci?': {
            category: 'Number Theory',
            description: 'Determines if a number is in the fibonacci sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(0)',
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(1)',
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(2)',
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(3)',
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(4)',
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(5)',
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(6)',
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(7)',
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(8)',
                'let { fibonacci? } = import("Number-Theory");\nfibonacci?(9)',
            ],
        },
        'geometric-seq': {
            category: 'Number Theory',
            description: 'Generates the geometric sequence for a given $start, $ratio, and $length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                ratio: {
                    type: 'number',
                    description: 'The common ratio of the sequence.',
                },
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                        'ratio',
                        'length',
                    ],
                },
            ],
            examples: [
                'let { geometric-seq } = import("Number-Theory");\ngeometric-seq(3, 2, 2)',
                'let { geometric-seq } = import("Number-Theory");\ngeometric-seq(2, 3, 2)',
                'let { geometric-seq } = import("Number-Theory");\ngeometric-seq(1, 2, 2)',
                'let { geometric-seq } = import("Number-Theory");\ngeometric-seq(1, 1.5, 12)',
            ],
        },
        'geometric-take-while': {
            category: 'Number Theory',
            description: 'Generates the geometric sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                ratio: {
                    type: 'number',
                    description: 'The common ratio of the sequence.',
                },
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes a number and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                        'ratio',
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { geometric-take-while } = import("Number-Theory");\ngeometric-take-while(1, 1.5, -> $ < 10)',
            ],
        },
        'geometric-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the geometric sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                ratio: {
                    type: 'number',
                    description: 'The common ratio of the sequence.',
                },
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                        'ratio',
                        'n',
                    ],
                },
            ],
            examples: [
                'let { geometric-nth } = import("Number-Theory");\ngeometric-nth(3, 2, 2)',
                'let { geometric-nth } = import("Number-Theory");\ngeometric-nth(2, 3, 2)',
                'let { geometric-nth } = import("Number-Theory");\ngeometric-nth(1, 2, 2)',
                'let { geometric-nth } = import("Number-Theory");\ngeometric-nth(1, 1.5, 4)',
            ],
        },
        'geometric?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the geometric sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                ratio: {
                    type: 'number',
                    description: 'The common ratio of the sequence.',
                },
                n: {
                    type: 'number',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                        'ratio',
                        'n',
                    ],
                },
            ],
            examples: [
                'let { geometric? } = import("Number-Theory");\ngeometric?(1, 2, 1)',
                'let { geometric? } = import("Number-Theory");\ngeometric?(2, 3, 2)',
                'let { geometric? } = import("Number-Theory");\ngeometric?(3, 2, 2)',
                'let { geometric? } = import("Number-Theory");\ngeometric?(1, 1.5, 2.25)',
                'let { geometric? } = import("Number-Theory");\ngeometric?(1, 1.5, -4)',
            ],
        },
        'golomb-seq': {
            category: 'Number Theory',
            description: 'Generates the Golomb sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { golomb-seq } = import("Number-Theory");\ngolomb-seq(5)',
                'let { golomb-seq } = import("Number-Theory");\ngolomb-seq(20)',
            ],
        },
        'golomb-take-while': {
            category: 'Number Theory',
            description: 'Generates the Golomb sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { golomb-take-while } = import("Number-Theory");\ngolomb-take-while(-> $ <= 10)',
            ],
        },
        'golomb-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Golomb sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { golomb-nth } = import("Number-Theory");\ngolomb-nth(5)',
                'let { golomb-nth } = import("Number-Theory");\ngolomb-nth(1000)',
            ],
        },
        'golomb?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the Golomb sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { golomb? } = import("Number-Theory");\ngolomb?(1)',
                'let { golomb? } = import("Number-Theory");\ngolomb?(2)',
                'let { golomb? } = import("Number-Theory");\ngolomb?(3345)',
                'let { golomb? } = import("Number-Theory");\ngolomb?(67867864)',
            ],
        },
        'happy-seq': {
            category: 'Number Theory',
            description: 'Generates the happy sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 20 (the maximum length of the pre-calculated happy numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { happy-seq } = import("Number-Theory");\nhappy-seq(1)',
                'let { happy-seq } = import("Number-Theory");\nhappy-seq(2)',
                'let { happy-seq } = import("Number-Theory");\nhappy-seq(20)',
            ],
        },
        'happy-take-while': {
            category: 'Number Theory',
            description: 'Generates the happy sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { happy-take-while } = import("Number-Theory");\nhappy-take-while(-> $ < 100)',
            ],
        },
        'happy-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the happy sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the happy number to return.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { happy-nth } = import("Number-Theory");\nhappy-nth(1)',
                'let { happy-nth } = import("Number-Theory");\nhappy-nth(2)',
                'let { happy-nth } = import("Number-Theory");\nhappy-nth(20)',
            ],
        },
        'happy?': {
            category: 'Number Theory',
            description: 'Determines if a number is a happy number.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { happy? } = import("Number-Theory");\nhappy?(1)',
                'let { happy? } = import("Number-Theory");\nhappy?(2)',
                'let { happy? } = import("Number-Theory");\nhappy?(100)',
            ],
        },
        'juggler-seq': {
            category: 'Number Theory',
            description: 'Generates the Juggler sequence starting from a given integer.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'integer',
                    description: 'The starting integer for the Juggler sequence.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'start',
                    ],
                },
            ],
            examples: [
                'let { juggler-seq } = import("Number-Theory");\njuggler-seq(3)',
                'let { juggler-seq } = import("Number-Theory");\njuggler-seq(5)',
            ],
        },
        'look-and-say-seq': {
            category: 'Number Theory',
            description: 'Generates the Look-and-Say sequence up to a specified length.',
            returns: {
                type: 'string',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { look-and-say-seq } = import("Number-Theory");\nlook-and-say-seq(5)',
            ],
        },
        'look-and-say-take-while': {
            category: 'Number Theory',
            description: 'Generates the Look-and-Say sequence while a condition is met.',
            returns: {
                type: 'string',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes a string and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { look-and-say-take-while } = import("Number-Theory");\nlook-and-say-take-while((term, index) -> count(term) < 10)',
                'let { look-and-say-take-while } = import("Number-Theory");\nlook-and-say-take-while(-> $2 <= 10)',
            ],
        },
        'look-and-say-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Look-and-Say sequence.',
            returns: {
                type: 'string',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term in the sequence.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { look-and-say-nth } = import("Number-Theory");\nlook-and-say-nth(5)',
            ],
        },
        'look-and-say?': {
            category: 'Number Theory',
            description: 'Checks if a string is a valid Look-and-Say term.',
            returns: {
                type: 'boolean',
            },
            args: {
                term: {
                    type: 'string',
                    description: 'The term to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'term',
                    ],
                },
            ],
            examples: [
                'let { look-and-say? } = import("Number-Theory");\nlook-and-say?("111221")',
                'let { look-and-say? } = import("Number-Theory");\nlook-and-say?("123")',
            ],
        },
        'lucas-seq': {
            category: 'Number Theory',
            description: 'Generates the lucas sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 77 (the maximum length of the pre-calculated Lucas numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { lucas-seq } = import("Number-Theory");\nlucas-seq(1)',
                'let { lucas-seq } = import("Number-Theory");\nlucas-seq(2)',
                'let { lucas-seq } = import("Number-Theory");\nlucas-seq()',
            ],
        },
        'lucas-take-while': {
            category: 'Number Theory',
            description: 'Generates the lucas sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { lucas-take-while } = import("Number-Theory");\nlucas-take-while(-> $ < 100)',
            ],
        },
        'lucas-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the lucas sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { lucas-nth } = import("Number-Theory");\nlucas-nth(1)',
                'let { lucas-nth } = import("Number-Theory");\nlucas-nth(2)',
                'let { lucas-nth } = import("Number-Theory");\nlucas-nth(10)',
            ],
        },
        'lucas?': {
            category: 'Number Theory',
            description: 'Determines if a number is in the lucas sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { lucas? } = import("Number-Theory");\nlucas?(1)',
                'let { lucas? } = import("Number-Theory");\nlucas?(2)',
                'let { lucas? } = import("Number-Theory");\nlucas?(10)',
            ],
        },
        'lucky-seq': {
            category: 'Number Theory',
            description: 'Generates the lucky sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { lucky-seq } = import("Number-Theory");\nlucky-seq(1)',
                'let { lucky-seq } = import("Number-Theory");\nlucky-seq(2)',
                'let { lucky-seq } = import("Number-Theory");\nlucky-seq(20)',
            ],
        },
        'lucky-take-while': {
            category: 'Number Theory',
            description: 'Generates the lucky sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { lucky-take-while } = import("Number-Theory");\nlucky-take-while(-> $ < 100)',
            ],
        },
        'lucky-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the lucky sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The position in the sequence.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { lucky-nth } = import("Number-Theory");\nlucky-nth(1)',
                'let { lucky-nth } = import("Number-Theory");\nlucky-nth(2)',
                'let { lucky-nth } = import("Number-Theory");\nlucky-nth(20)',
            ],
        },
        'lucky?': {
            category: 'Number Theory',
            description: 'Checks if a number is a lucky number.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { lucky? } = import("Number-Theory");\nlucky?(4)',
                'let { lucky? } = import("Number-Theory");\nlucky?(7)',
                'let { lucky? } = import("Number-Theory");\nlucky?(33)',
            ],
        },
        'mersenne-seq': {
            category: 'Number Theory',
            description: 'Generates the Mersenne sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 9 (the maximum length of the pre-calculated mersenne numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { mersenne-seq } = import("Number-Theory");\nmersenne-seq(1)',
                'let { mersenne-seq } = import("Number-Theory");\nmersenne-seq(5)',
                'let { mersenne-seq } = import("Number-Theory");\nmersenne-seq()',
            ],
        },
        'mersenne-take-while': {
            category: 'Number Theory',
            description: 'Generates the Mersenne sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { mersenne-take-while } = import("Number-Theory");\nmersenne-take-while(-> $ < 1000)',
            ],
        },
        'mersenne-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Mersenne sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { mersenne-nth } = import("Number-Theory");\nmersenne-nth(1)',
                'let { mersenne-nth } = import("Number-Theory");\nmersenne-nth(5)',
            ],
        },
        'mersenne?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the Mersenne sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { mersenne? } = import("Number-Theory");\nmersenne?(3)',
                'let { mersenne? } = import("Number-Theory");\nmersenne?(4)',
                'let { mersenne? } = import("Number-Theory");\nmersenne?(7)',
            ],
        },
        'padovan-seq': {
            category: 'Number Theory',
            description: 'Generates the Padovan sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { padovan-seq } = import("Number-Theory");\npadovan-seq(5)',
                'let { padovan-seq } = import("Number-Theory");\npadovan-seq(10)',
                'let { padovan-seq } = import("Number-Theory");\npadovan-seq(20)',
            ],
        },
        'padovan-take-while': {
            category: 'Number Theory',
            description: 'Generates the Padovan sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { padovan-take-while } = import("Number-Theory");\npadovan-take-while(-> $ < 1000)',
            ],
        },
        'padovan-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Padovan sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { padovan-nth } = import("Number-Theory");\npadovan-nth(5)',
                'let { padovan-nth } = import("Number-Theory");\npadovan-nth(10)',
                'let { padovan-nth } = import("Number-Theory");\npadovan-nth(20)',
            ],
        },
        'padovan?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the Padovan sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { padovan? } = import("Number-Theory");\npadovan?(1)',
                'let { padovan? } = import("Number-Theory");\npadovan?(265)',
                'let { padovan? } = import("Number-Theory");\npadovan?(6)',
            ],
        },
        'partition-seq': {
            category: 'Number Theory',
            description: 'Generates the partition numbers up to a specified length. If no length is provided, it defaults to 299 (the maximum length of the pre-calculated partition numbers).',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { partition-seq } = import("Number-Theory");\npartition-seq(1)',
                'let { partition-seq } = import("Number-Theory");\npartition-seq(10)',
                'let { partition-seq } = import("Number-Theory");\npartition-seq()',
            ],
        },
        'partition-take-while': {
            category: 'Number Theory',
            description: 'Generates the partition numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { partition-take-while } = import("Number-Theory");\npartition-take-while(-> $ < 1000)',
            ],
        },
        'partition-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the partition numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the partition number to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { partition-nth } = import("Number-Theory");\npartition-nth(1)',
                'let { partition-nth } = import("Number-Theory");\npartition-nth(5)',
            ],
        },
        'partition?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the partition numbers.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { partition? } = import("Number-Theory");\npartition?(0)',
                'let { partition? } = import("Number-Theory");\npartition?(1)',
                'let { partition? } = import("Number-Theory");\npartition?(2)',
                'let { partition? } = import("Number-Theory");\npartition?(3)',
                'let { partition? } = import("Number-Theory");\npartition?(4)',
                'let { partition? } = import("Number-Theory");\npartition?(5)',
            ],
        },
        'pell-seq': {
            category: 'Number Theory',
            description: 'Generates the Pell sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 42 (the maximum length of the pre-calculated Pell numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { pell-seq } = import("Number-Theory");\npell-seq(5)',
                'let { pell-seq } = import("Number-Theory");\npell-seq(10)',
                'let { pell-seq } = import("Number-Theory");\npell-seq()',
            ],
        },
        'pell-take-while': {
            category: 'Number Theory',
            description: 'Generates the Pell sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { pell-take-while } = import("Number-Theory");\npell-take-while(-> $ < 1000)',
            ],
        },
        'pell-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Pell sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { pell-nth } = import("Number-Theory");\npell-nth(5)',
                'let { pell-nth } = import("Number-Theory");\npell-nth(10)',
                'let { pell-nth } = import("Number-Theory");\npell-nth(20)',
            ],
        },
        'pell?': {
            category: 'Number Theory',
            description: 'Checks if a number is a Pell number.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { pell? } = import("Number-Theory");\npell?(1)',
                'let { pell? } = import("Number-Theory");\npell?(470832)',
                'let { pell? } = import("Number-Theory");\npell?(10)',
            ],
        },
        'perfect-seq': {
            category: 'Number Theory',
            description: 'Generates the perfect numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If no length is provided, it defaults to 7 (the maximum length of the pre-calculated perfect numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { perfect-seq } = import("Number-Theory");\nperfect-seq(1)',
                'let { perfect-seq } = import("Number-Theory");\nperfect-seq(5)',
                'let { perfect-seq } = import("Number-Theory");\nperfect-seq()',
            ],
        },
        'perfect-take-while': {
            category: 'Number Theory',
            description: 'Generates the perfect numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { perfect-take-while } = import("Number-Theory");\nperfect-take-while(-> $ < 1000)',
            ],
        },
        'perfect-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the perfect numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the perfect number to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { perfect-nth } = import("Number-Theory");\nperfect-nth(1)',
                'let { perfect-nth } = import("Number-Theory");\nperfect-nth(5)',
            ],
        },
        'perfect?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the perfect numbers.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { perfect? } = import("Number-Theory");\nperfect?(0)',
                'let { perfect? } = import("Number-Theory");\nperfect?(1)',
                'let { perfect? } = import("Number-Theory");\nperfect?(2)',
                'let { perfect? } = import("Number-Theory");\nperfect?(3)',
                'let { perfect? } = import("Number-Theory");\nperfect?(4)',
                'let { perfect? } = import("Number-Theory");\nperfect?(5)',
                'let { perfect? } = import("Number-Theory");\nperfect?(6)',
                'let { perfect? } = import("Number-Theory");\nperfect?(7)',
                'let { perfect? } = import("Number-Theory");\nperfect?(8)',
                'let { perfect? } = import("Number-Theory");\nperfect?(9)',
            ],
        },
        'perfect-square-seq': {
            category: 'Number Theory',
            description: 'Generates the perfect square numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { perfect-square-seq } = import("Number-Theory");\nperfect-square-seq(5)',
                'let { perfect-square-seq } = import("Number-Theory");\nperfect-square-seq(20)',
            ],
        },
        'perfect-square-take-while': {
            category: 'Number Theory',
            description: 'Generates the perfect square numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { perfect-square-take-while } = import("Number-Theory");\nperfect-square-take-while(-> $ <= 100)',
            ],
        },
        'perfect-square-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the perfect square numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { perfect-square-nth } = import("Number-Theory");\nperfect-square-nth(1)',
                'let { perfect-square-nth } = import("Number-Theory");\nperfect-square-nth(5)',
            ],
        },
        'perfect-square?': {
            category: 'Number Theory',
            description: 'Checks if a number is a perfect square.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { perfect-square? } = import("Number-Theory");\nperfect-square?(16)',
                'let { perfect-square? } = import("Number-Theory");\nperfect-square?(20)',
            ],
        },
        'perfect-cube-seq': {
            category: 'Number Theory',
            description: 'Generates the perfect cube numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { perfect-cube-seq } = import("Number-Theory");\nperfect-cube-seq(5)',
                'let { perfect-cube-seq } = import("Number-Theory");\nperfect-cube-seq(20)',
            ],
        },
        'perfect-cube-take-while': {
            category: 'Number Theory',
            description: 'Generates the perfect cube numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { perfect-cube-take-while } = import("Number-Theory");\nperfect-cube-take-while(-> $ <= 100)',
            ],
        },
        'perfect-cube-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the perfect cube numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { perfect-cube-nth } = import("Number-Theory");\nperfect-cube-nth(1)',
                'let { perfect-cube-nth } = import("Number-Theory");\nperfect-cube-nth(5)',
            ],
        },
        'perfect-cube?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the perfect cube numbers.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { perfect-cube? } = import("Number-Theory");\nperfect-cube?(7)',
                'let { perfect-cube? } = import("Number-Theory");\nperfect-cube?(8)',
                'let { perfect-cube? } = import("Number-Theory");\nperfect-cube?(9)',
            ],
        },
        'perfect-power-seq': {
            category: 'Number Theory',
            description: 'Generates the perfect power numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { perfect-power-seq } = import("Number-Theory");\nperfect-power-seq(5)',
                'let { perfect-power-seq } = import("Number-Theory");\nperfect-power-seq(20)',
            ],
        },
        'perfect-power-take-while': {
            category: 'Number Theory',
            description: 'Generates the perfect power numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { perfect-power-take-while } = import("Number-Theory");\nperfect-power-take-while(-> $ <= 100)',
            ],
        },
        'perfect-power-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the perfect power numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { perfect-power-nth } = import("Number-Theory");\nperfect-power-nth(3)',
                'let { perfect-power-nth } = import("Number-Theory");\nperfect-power-nth(15)',
            ],
        },
        'perfect-power?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the perfect power numbers.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { perfect-power? } = import("Number-Theory");\nperfect-power?(7)',
                'let { perfect-power? } = import("Number-Theory");\nperfect-power?(8)',
                'let { perfect-power? } = import("Number-Theory");\nperfect-power?(9)',
                'let { perfect-power? } = import("Number-Theory");\nperfect-power?(10)',
            ],
        },
        'polygonal-seq': {
            category: 'Number Theory',
            description: 'Generates the polygonal sequence for a given number of sides and length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                sides: {
                    type: 'integer',
                    description: 'The number of sides of the polygon.',
                },
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'sides',
                        'length',
                    ],
                },
            ],
            examples: [
                'let { polygonal-seq } = import("Number-Theory");\npolygonal-seq(3, 2)',
                'let { polygonal-seq } = import("Number-Theory");\npolygonal-seq(4, 2)',
                'let { polygonal-seq } = import("Number-Theory");\npolygonal-seq(5, 3)',
                'let { polygonal-seq } = import("Number-Theory");\npolygonal-seq(6, 5)',
                'let { polygonal-seq } = import("Number-Theory");\npolygonal-seq(100, 10)',
            ],
        },
        'polygonal-take-while': {
            category: 'Number Theory',
            description: 'Generates the polygonal sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                sides: {
                    type: 'integer',
                    description: 'The number of sides of the polygon.',
                },
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'sides',
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { polygonal-take-while } = import("Number-Theory");\npolygonal-take-while(15, -> $ < 1000)',
            ],
        },
        'polygonal-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the polygonal sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                sides: {
                    type: 'integer',
                    description: 'The number of sides of the polygon.',
                },
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'sides',
                        'n',
                    ],
                },
            ],
            examples: [
                'let { polygonal-nth } = import("Number-Theory");\npolygonal-nth(3, 9)',
                'let { polygonal-nth } = import("Number-Theory");\npolygonal-nth(4, 5)',
                'let { polygonal-nth } = import("Number-Theory");\npolygonal-nth(5, 5)',
            ],
        },
        'polygonal?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the polygonal sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                sides: {
                    type: 'integer',
                    description: 'The number of sides of the polygon.',
                },
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'sides',
                        'n',
                    ],
                },
            ],
            examples: [
                'let { polygonal? } = import("Number-Theory");\npolygonal?(3, 10)',
                'let { polygonal? } = import("Number-Theory");\npolygonal?(3, 9)',
                'let { polygonal? } = import("Number-Theory");\npolygonal?(4, 10000)',
                'let { polygonal? } = import("Number-Theory");\npolygonal?(4, 1000)',
                'let { polygonal? } = import("Number-Theory");\npolygonal?(6, 45)',
            ],
        },
        'prime-seq': {
            category: 'Number Theory',
            description: 'Generates the prime sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { prime-seq } = import("Number-Theory");\nprime-seq(1)',
                'let { prime-seq } = import("Number-Theory");\nprime-seq(2)',
                'let { prime-seq } = import("Number-Theory");\nprime-seq(10)',
            ],
        },
        'prime-take-while': {
            category: 'Number Theory',
            description: 'Generates the prime sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { prime-take-while } = import("Number-Theory");\nprime-take-while(-> $ < 50)',
            ],
        },
        'prime-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the prime sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { prime-nth } = import("Number-Theory");\nprime-nth(1)',
                'let { prime-nth } = import("Number-Theory");\nprime-nth(2)',
                'let { prime-nth } = import("Number-Theory");\nprime-nth(10)',
            ],
        },
        'prime?': {
            category: 'Number Theory',
            description: 'Determines if a number is prime.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { prime? } = import("Number-Theory");\nprime?(1)',
                'let { prime? } = import("Number-Theory");\nprime?(2)',
                'let { prime? } = import("Number-Theory");\nprime?(3)',
                'let { prime? } = import("Number-Theory");\nprime?(4)',
                'let { prime? } = import("Number-Theory");\nprime?(997)',
                'let { prime? } = import("Number-Theory");\nprime?(1001)',
            ],
        },
        'recaman-seq': {
            category: 'Number Theory',
            description: 'Generates the Recaman sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { recaman-seq } = import("Number-Theory");\nrecaman-seq(5)',
                'let { recaman-seq } = import("Number-Theory");\nrecaman-seq(10)',
                'let { recaman-seq } = import("Number-Theory");\nrecaman-seq(20)',
            ],
        },
        'recaman-take-while': {
            category: 'Number Theory',
            description: 'Generates the Recaman sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { recaman-take-while } = import("Number-Theory");\nrecaman-take-while(-> $ < 10)',
            ],
        },
        'recaman-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Recaman sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { recaman-nth } = import("Number-Theory");\nrecaman-nth(5)',
                'let { recaman-nth } = import("Number-Theory");\nrecaman-nth(10)',
                'let { recaman-nth } = import("Number-Theory");\nrecaman-nth(20)',
            ],
        },
        'recaman?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the Recaman sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { recaman? } = import("Number-Theory");\nrecaman?(5)',
                'let { recaman? } = import("Number-Theory");\nrecaman?(10)',
                'let { recaman? } = import("Number-Theory");\nrecaman?(20)',
            ],
        },
        'sylvester-seq': {
            category: 'Number Theory',
            description: 'Generates the Sylvester sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 6 (the maximum length of the pre-calculated Sylvester numbers).',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
                {
                    argumentNames: [],
                },
            ],
            examples: [
                'let { sylvester-seq } = import("Number-Theory");\nsylvester-seq(5)',
                'let { sylvester-seq } = import("Number-Theory");\nsylvester-seq()',
                'let { sylvester-seq } = import("Number-Theory");\nsylvester-seq()',
            ],
        },
        'sylvester-take-while': {
            category: 'Number Theory',
            description: 'Generates the Sylvester sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { sylvester-take-while } = import("Number-Theory");\nsylvester-take-while(-> $ < 100000)',
            ],
        },
        'sylvester-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Sylvester sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { sylvester-nth } = import("Number-Theory");\nsylvester-nth(1)',
                'let { sylvester-nth } = import("Number-Theory");\nsylvester-nth(5)',
            ],
        },
        'sylvester?': {
            category: 'Number Theory',
            description: 'Checks if a number is in the Sylvester sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { sylvester? } = import("Number-Theory");\nsylvester?(2)',
                'let { sylvester? } = import("Number-Theory");\nsylvester?(3)',
                'let { sylvester? } = import("Number-Theory");\nsylvester?(6)',
            ],
        },
        'thue-morse-seq': {
            category: 'Number Theory',
            description: 'Generates the Thue-Morse sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { thue-morse-seq } = import("Number-Theory");\nthue-morse-seq(5)',
                'let { thue-morse-seq } = import("Number-Theory");\nthue-morse-seq(10)',
                'let { thue-morse-seq } = import("Number-Theory");\nthue-morse-seq(20)',
            ],
        },
        'thue-morse-take-while': {
            category: 'Number Theory',
            description: 'Generates the Thue-Morse sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { thue-morse-take-while } = import("Number-Theory");\nthue-morse-take-while(-> $2 < 10)',
            ],
        },
        'thue-morse-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the Thue-Morse sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term in the sequence.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { thue-morse-nth } = import("Number-Theory");\nthue-morse-nth(5)',
                'let { thue-morse-nth } = import("Number-Theory");\nthue-morse-nth(10)',
                'let { thue-morse-nth } = import("Number-Theory");\nthue-morse-nth(20)',
            ],
        },
        'thue-morse?': {
            category: 'Number Theory',
            description: 'Checks if a number is part of the Thue-Morse sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { thue-morse? } = import("Number-Theory");\nthue-morse?(1)',
                'let { thue-morse? } = import("Number-Theory");\nthue-morse?(2)',
            ],
        },
        'tribonacci-seq': {
            category: 'Number Theory',
            description: 'Generates the tribonacci sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'length',
                    ],
                },
            ],
            examples: [
                'let { tribonacci-seq } = import("Number-Theory");\ntribonacci-seq(1)',
                'let { tribonacci-seq } = import("Number-Theory");\ntribonacci-seq(2)',
                'let { tribonacci-seq } = import("Number-Theory");\ntribonacci-seq(10)',
            ],
        },
        'tribonacci-take-while': {
            category: 'Number Theory',
            description: 'Generates the tribonacci sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'takeWhile',
                    ],
                },
            ],
            examples: [
                'let { tribonacci-take-while } = import("Number-Theory");\ntribonacci-take-while(-> $ < 100)',
            ],
        },
        'tribonacci-nth': {
            category: 'Number Theory',
            description: 'Generates the nth term of the tribonacci sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { tribonacci-nth } = import("Number-Theory");\ntribonacci-nth(1)',
                'let { tribonacci-nth } = import("Number-Theory");\ntribonacci-nth(2)',
                'let { tribonacci-nth } = import("Number-Theory");\ntribonacci-nth(10)',
            ],
        },
        'tribonacci?': {
            category: 'Number Theory',
            description: 'Determines if a number is in the tribonacci sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(0)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(1)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(2)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(3)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(4)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(5)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(6)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(7)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(8)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(9)',
                'let { tribonacci? } = import("Number-Theory");\ntribonacci?(10)',
            ],
        },
        'count-combinations': {
            category: 'Number Theory',
            description: 'Calculates the number of combinations of n items taken k at a time.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { count-combinations } = import("Number-Theory");\ncount-combinations(5, 3)',
                'let { count-combinations } = import("Number-Theory");\ncount-combinations(10, 2)',
            ],
        },
        'combinations': {
            category: 'Number Theory',
            description: 'Generates all possible combinations of a specified size from a collection.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                set: {
                    type: 'array',
                    array: true,
                    description: 'The input collection to generate combinations from.',
                },
                n: {
                    type: 'integer',
                    description: 'The size of each combination.',
                },
                a: {
                    type: 'array',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'set',
                        'n',
                    ],
                },
            ],
            examples: [
                'let { combinations } = import("Number-Theory");\ncombinations([1, 2, 3], 2)',
                'let { combinations } = import("Number-Theory");\ncombinations(["a", "b", "c"], 2)',
                'let { combinations } = import("Number-Theory");\ncombinations([1, 2, 3], 0)',
                'let { combinations } = import("Number-Theory");\ncombinations([1, 2, 3], 1)',
                'let { combinations } = import("Number-Theory");\ncombinations([1, 2, 3], 3)',
            ],
        },
        'count-derangements': {
            category: 'Number Theory',
            description: 'Calculates the number of derangements (permutations where no element appears in its original position) of n items.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The total number of items.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { count-derangements } = import("Number-Theory");\ncount-derangements(4)',
                'let { count-derangements } = import("Number-Theory");\ncount-derangements(5)',
            ],
        },
        'derangements': {
            category: 'Number Theory',
            description: 'Generates all derangements (permutations where no element appears in its original position) of a set.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                set: {
                    type: 'array',
                    array: true,
                    description: 'The input collection to generate derangements from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'set',
                    ],
                },
            ],
            examples: [
                'let { derangements } = import("Number-Theory");\nderangements([1, 2, 3, 4])',
                'let { derangements } = import("Number-Theory");\nderangements(["a", "b", "c"])',
            ],
        },
        'divisors': {
            category: 'Number Theory',
            description: 'Returns the divisors of a number.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to find divisors for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { divisors } = import("Number-Theory");\ndivisors(12)',
                'let { divisors } = import("Number-Theory");\ndivisors(100)',
                'let { divisors } = import("Number-Theory");\ndivisors(37)',
            ],
        },
        'count-divisors': {
            category: 'Number Theory',
            description: 'Returns the number of divisors of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count divisors for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { count-divisors } = import("Number-Theory");\ncount-divisors(12)',
                'let { count-divisors } = import("Number-Theory");\ncount-divisors(100)',
                'let { count-divisors } = import("Number-Theory");\ncount-divisors(37)',
            ],
        },
        'proper-divisors': {
            category: 'Number Theory',
            description: 'Returns the proper divisors of a number.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to find proper divisors for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { proper-divisors } = import("Number-Theory");\nproper-divisors(12)',
                'let { proper-divisors } = import("Number-Theory");\nproper-divisors(100)',
                'let { proper-divisors } = import("Number-Theory");\nproper-divisors(37)',
            ],
        },
        'count-proper-divisors': {
            category: 'Number Theory',
            description: 'Returns the number of proper divisors of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count proper divisors for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { count-proper-divisors } = import("Number-Theory");\ncount-proper-divisors(12)',
                'let { count-proper-divisors } = import("Number-Theory");\ncount-proper-divisors(100)',
                'let { count-proper-divisors } = import("Number-Theory");\ncount-proper-divisors(37)',
            ],
        },
        'factorial': {
            category: 'Number Theory',
            description: 'Calculates the factorial of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the factorial for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { factorial } = import("Number-Theory");\nfactorial(5)',
                'let { factorial } = import("Number-Theory");\nfactorial(0)',
                'let { factorial } = import("Number-Theory");\nfactorial(10)',
                'let { factorial } = import("Number-Theory");\nfactorial(20)',
            ],
        },
        'partitions': {
            category: 'Number Theory',
            description: 'Generates all partitions of a number.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to partition.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { partitions } = import("Number-Theory");\npartitions(4)',
                'let { partitions } = import("Number-Theory");\npartitions(8)',
            ],
        },
        'count-partitions': {
            category: 'Number Theory',
            description: 'Returns the number of partitions of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count partitions for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { count-partitions } = import("Number-Theory");\ncount-partitions(4)',
                'let { count-partitions } = import("Number-Theory");\ncount-partitions(8)',
                'let { count-partitions } = import("Number-Theory");\ncount-partitions(15)',
            ],
        },
        'permutations': {
            category: 'Number Theory',
            description: 'Generates all permutations of a collection.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                set: {
                    type: 'array',
                    array: true,
                    description: 'The input collection to generate permutations from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'set',
                    ],
                },
            ],
            examples: [
                'let { permutations } = import("Number-Theory");\npermutations([1, 2, 3])',
                'let { permutations } = import("Number-Theory");\npermutations(["a", "b", "c"])',
                'let { permutations } = import("Number-Theory");\npermutations([1, 2, 3, 4])',
                'let { permutations } = import("Number-Theory");\npermutations([1, 2])',
                'let { permutations } = import("Number-Theory");\npermutations([1])',
                'let { permutations } = import("Number-Theory");\npermutations([])',
            ],
        },
        'count-permutations': {
            category: 'Number Theory',
            description: 'Returns the number of permutations of n items taken k at a time.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { count-permutations } = import("Number-Theory");\ncount-permutations(5, 3)',
                'let { count-permutations } = import("Number-Theory");\ncount-permutations(10, 2)',
                'let { count-permutations } = import("Number-Theory");\ncount-permutations(10, 10)',
                'let { count-permutations } = import("Number-Theory");\ncount-permutations(10, 0)',
                'let { count-permutations } = import("Number-Theory");\ncount-permutations(10, 1)',
            ],
        },
        'power-set': {
            category: 'Number Theory',
            description: 'Generates the power set of a collection.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                set: {
                    type: 'any',
                    array: true,
                    description: 'The input collection to generate the power set from.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'set',
                    ],
                },
            ],
            examples: [
                'let { power-set } = import("Number-Theory");\npower-set(["a", "b", "c"])',
                'let { power-set } = import("Number-Theory");\npower-set([1, 2])',
                'let { power-set } = import("Number-Theory");\npower-set([1])',
                'let { power-set } = import("Number-Theory");\npower-set([])',
            ],
        },
        'count-power-set': {
            category: 'Number Theory',
            description: 'Returns the number of subsets of a set.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The size of the set.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { count-power-set } = import("Number-Theory");\ncount-power-set(3)',
                'let { count-power-set } = import("Number-Theory");\ncount-power-set(5)',
                'let { count-power-set } = import("Number-Theory");\ncount-power-set(10)',
            ],
        },
        'prime-factors': {
            category: 'Number Theory',
            description: 'Returns the prime factors of a number.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to factor.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { prime-factors } = import("Number-Theory");\nprime-factors(12)',
                'let { prime-factors } = import("Number-Theory");\nprime-factors(100)',
                'let { prime-factors } = import("Number-Theory");\nprime-factors(37)',
            ],
        },
        'count-prime-factors': {
            category: 'Number Theory',
            description: 'Returns the number of prime factors of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count prime factors for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { count-prime-factors } = import("Number-Theory");\ncount-prime-factors(12)',
                'let { count-prime-factors } = import("Number-Theory");\ncount-prime-factors(100)',
                'let { count-prime-factors } = import("Number-Theory");\ncount-prime-factors(37)',
            ],
        },
        'distinct-prime-factors': {
            category: 'Number Theory',
            description: 'Returns the distinct prime factors of a number.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to find distinct prime factors for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { distinct-prime-factors } = import("Number-Theory");\ndistinct-prime-factors(12)',
                'let { distinct-prime-factors } = import("Number-Theory");\ndistinct-prime-factors(100)',
                'let { distinct-prime-factors } = import("Number-Theory");\ndistinct-prime-factors(37)',
            ],
        },
        'count-distinct-prime-factors': {
            category: 'Number Theory',
            description: 'Returns the number of distinct prime factors of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count distinct prime factors for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { count-distinct-prime-factors } = import("Number-Theory");\ncount-distinct-prime-factors(12)',
                'let { count-distinct-prime-factors } = import("Number-Theory");\ncount-distinct-prime-factors(100)',
                'let { count-distinct-prime-factors } = import("Number-Theory");\ncount-distinct-prime-factors(37)',
            ],
        },
        'coprime?': {
            category: 'Number Theory',
            description: 'Checks if two numbers are coprime (i.e., their GCD is 1).',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { coprime? } = import("Number-Theory");\ncoprime?(12, 8)',
                'let { coprime? } = import("Number-Theory");\ncoprime?(12, 5)',
                'let { coprime? } = import("Number-Theory");\ncoprime?(37, 1)',
                'let { coprime? } = import("Number-Theory");\ncoprime?(0, 0)',
                'let { coprime? } = import("Number-Theory");\ncoprime?(0, 5)',
                'let { coprime? } = import("Number-Theory");\ncoprime?(5, 0)',
                'let { coprime? } = import("Number-Theory");\ncoprime?(1, 0)',
                'let { coprime? } = import("Number-Theory");\ncoprime?(0, 1)',
                'let { coprime? } = import("Number-Theory");\ncoprime?(1, 1)',
                'let { coprime? } = import("Number-Theory");\ncoprime?(2, 3)',
            ],
        },
        'divisible-by?': {
            category: 'Number Theory',
            description: 'Checks if a number is divisible by another number.',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { divisible-by? } = import("Number-Theory");\ndivisible-by?(12, 4)',
                'let { divisible-by? } = import("Number-Theory");\ndivisible-by?(12, 5)',
                'let { divisible-by? } = import("Number-Theory");\ndivisible-by?(37, 1)',
                'let { divisible-by? } = import("Number-Theory");\ndivisible-by?(0, 0)',
                'let { divisible-by? } = import("Number-Theory");\ndivisible-by?(0, 5)',
                'let { divisible-by? } = import("Number-Theory");\ndivisible-by?(5, 0)',
            ],
        },
        'gcd': {
            category: 'Number Theory',
            description: 'Calculates the greatest common divisor (GCD) of two numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { gcd } = import("Number-Theory");\ngcd(100, 25)',
                'let { gcd } = import("Number-Theory");\ngcd(37, 1)',
                'let { gcd } = import("Number-Theory");\ngcd(0, 0)',
                'let { gcd } = import("Number-Theory");\ngcd(0, 5)',
                'let { gcd } = import("Number-Theory");\ngcd(5, 0)',
            ],
        },
        'lcm': {
            category: 'Number Theory',
            description: 'Calculates the least common multiple (LCM) of two numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { lcm } = import("Number-Theory");\nlcm(100, 25)',
                'let { lcm } = import("Number-Theory");\nlcm(37, 1)',
                'let { lcm } = import("Number-Theory");\nlcm(0, 5)',
                'let { lcm } = import("Number-Theory");\nlcm(5, 0)',
            ],
        },
        'multinomial': {
            category: 'Number Theory',
            description: 'Calculates the multinomial coefficient from of a list of numbers representing the sizes of each group.',
            returns: {
                type: 'integer',
            },
            args: {
                args: {
                    type: 'integer',
                    rest: true,
                    description: 'The numbers representing the sizes of each group.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'args',
                    ],
                },
            ],
            examples: [
                'let { multinomial } = import("Number-Theory");\nmultinomial(5, 2, 3)',
                'let { multinomial } = import("Number-Theory");\nmultinomial(10, 2, 3, 5)',
            ],
            hideOperatorForm: true,
        },
        'amicable?': {
            category: 'Number Theory',
            description: 'Checks if two numbers are amicable (i.e., the sum of the proper divisors of each number equals the other number).',
            returns: {
                type: 'boolean',
            },
            args: {
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { amicable? } = import("Number-Theory");\namicable?(220, 284)',
                'let { amicable? } = import("Number-Theory");\namicable?(1184, 1210)',
                'let { amicable? } = import("Number-Theory");\namicable?(2620, 2924)',
                'let { amicable? } = import("Number-Theory");\namicable?(5020, 5564)',
                'let { amicable? } = import("Number-Theory");\namicable?(6232, 6368)',
            ],
        },
        'euler-totient': {
            category: 'Number Theory',
            description: 'Calculates the Euler\'s totient function (φ(n)) of a number, which counts the integers up to n that are coprime to n.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the totient for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { euler-totient } = import("Number-Theory");\neuler-totient(1)',
                'let { euler-totient } = import("Number-Theory");\neuler-totient(2)',
                'let { euler-totient } = import("Number-Theory");\neuler-totient(10)',
                'let { euler-totient } = import("Number-Theory");\neuler-totient(20)',
            ],
        },
        'mobius': {
            category: 'Number Theory',
            description: 'Calculates the Möbius function (μ(n)) of a number, which is used in number theory.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the Möbius function for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { mobius } = import("Number-Theory");\nmobius(1)',
                'let { mobius } = import("Number-Theory");\nmobius(2)',
                'let { mobius } = import("Number-Theory");\nmobius(3)',
                'let { mobius } = import("Number-Theory");\nmobius(4)',
                'let { mobius } = import("Number-Theory");\nmobius(6)',
                'let { mobius } = import("Number-Theory");\nmobius(12)',
                'let { mobius } = import("Number-Theory");\nmobius(30)',
            ],
        },
        'mertens': {
            category: 'Number Theory',
            description: 'Calculates the Mertens function (M(n)) of a number, which is the sum of the Möbius function up to n.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the Mertens function for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { mobius } = import("Number-Theory");\nmobius(1)',
                'let { mobius } = import("Number-Theory");\nmobius(2)',
                'let { mobius } = import("Number-Theory");\nmobius(3)',
                'let { mobius } = import("Number-Theory");\nmobius(4)',
                'let { mobius } = import("Number-Theory");\nmobius(6)',
                'let { mobius } = import("Number-Theory");\nmobius(12)',
                'let { mobius } = import("Number-Theory");\nmobius(30)',
            ],
        },
        'sigma': {
            category: 'Number Theory',
            description: 'Calculates the sum of divisors function (σ(n)) of a number, which is the sum of all positive divisors of n.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the sum of divisors for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { sigma } = import("Number-Theory");\nsigma(1)',
                'let { sigma } = import("Number-Theory");\nsigma(2)',
                'let { sigma } = import("Number-Theory");\nsigma(3)',
                'let { sigma } = import("Number-Theory");\nsigma(4)',
                'let { sigma } = import("Number-Theory");\nsigma(6)',
                'let { sigma } = import("Number-Theory");\nsigma(12)',
                'let { sigma } = import("Number-Theory");\nsigma(30)',
            ],
        },
        'carmichael-lambda': {
            category: 'Number Theory',
            description: 'Calculates the Carmichael function (λ(n)) of a number, which is the smallest positive integer m such that a^m ≡ 1 (mod n) for all integers a coprime to n.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the Carmichael function for.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { carmichael-lambda } = import("Number-Theory");\ncarmichael-lambda(1)',
                'let { carmichael-lambda } = import("Number-Theory");\ncarmichael-lambda(2)',
                'let { carmichael-lambda } = import("Number-Theory");\ncarmichael-lambda(3)',
                'let { carmichael-lambda } = import("Number-Theory");\ncarmichael-lambda(4)',
                'let { carmichael-lambda } = import("Number-Theory");\ncarmichael-lambda(6)',
                'let { carmichael-lambda } = import("Number-Theory");\ncarmichael-lambda(12)',
                'let { carmichael-lambda } = import("Number-Theory");\ncarmichael-lambda(30)',
            ],
        },
        'cartesian-product': {
            category: 'Number Theory',
            description: 'Calculates the Cartesian product of two or more sets.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                sets: {
                    type: 'array',
                    array: true,
                    description: 'The input collections to calculate the Cartesian product from.',
                },
                a: {
                    type: 'array',
                },
                b: {
                    type: 'array',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'sets',
                    ],
                },
            ],
            examples: [
                'let { cartesian-product } = import("Number-Theory");\ncartesian-product([1, 2], ["a", "b"])',
                'let { cartesian-product } = import("Number-Theory");\ncartesian-product([1, 2], ["a", "b"], [true, false])',
                'let { cartesian-product } = import("Number-Theory");\ncartesian-product([1, 2, 3], ["x", "y", "z"])',
            ],
        },
        'perfect-power': {
            category: 'Number Theory',
            description: 'Returns a tuple of the base and exponent if the number is a perfect power, otherwise returns null.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'n',
                    ],
                },
            ],
            examples: [
                'let { perfect-power } = import("Number-Theory");\nperfect-power(1)',
                'let { perfect-power } = import("Number-Theory");\nperfect-power(2)',
                'let { perfect-power } = import("Number-Theory");\nperfect-power(4)',
                'let { perfect-power } = import("Number-Theory");\nperfect-power(8)',
                'let { perfect-power } = import("Number-Theory");\nperfect-power(9)',
                'let { perfect-power } = import("Number-Theory");\nperfect-power(16)',
                'let { perfect-power } = import("Number-Theory");\nperfect-power(19)',
            ],
        },
        'mod-exp': {
            category: 'Number Theory',
            description: 'Calculates the modular exponentiation of a base raised to an exponent modulo a modulus.',
            returns: {
                type: 'integer',
            },
            args: {
                base: {
                    type: 'integer',
                },
                exponent: {
                    type: 'integer',
                },
                modulus: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'base',
                        'exponent',
                        'modulus',
                    ],
                },
            ],
            examples: [
                'let { mod-exp } = import("Number-Theory");\nmod-exp(2, 3, 5)',
                'let { mod-exp } = import("Number-Theory");\nmod-exp(3, 4, 7)',
                'let { mod-exp } = import("Number-Theory");\nmod-exp(5, 6, 11)',
                'let { mod-exp } = import("Number-Theory");\nmod-exp(7, 8, 13)',
            ],
        },
        'mod-inv': {
            category: 'Number Theory',
            description: 'Calculates the modular multiplicative inverse of a number modulo another number.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'm',
                    ],
                },
            ],
            examples: [
                'let { mod-inv } = import("Number-Theory");\nmod-inv(3, 11)',
                'let { mod-inv } = import("Number-Theory");\nmod-inv(10, 17)',
                'let { mod-inv } = import("Number-Theory");\nmod-inv(5, 13)',
                'let { mod-inv } = import("Number-Theory");\nmod-inv(7, 19)',
            ],
        },
        'extended-gcd': {
            category: 'Number Theory',
            description: 'Calculates the extended greatest common divisor (GCD) of two numbers, returning the GCD and the coefficients of Bézout\'s identity.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                a: {
                    type: 'integer',
                },
                b: {
                    type: 'integer',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { extended-gcd } = import("Number-Theory");\nextended-gcd(30, 12)',
                'let { extended-gcd } = import("Number-Theory");\nextended-gcd(56, 98)',
                'let { extended-gcd } = import("Number-Theory");\nextended-gcd(101, 10)',
                'let { extended-gcd } = import("Number-Theory");\nextended-gcd(17, 13)',
            ],
        },
        'chinese-remainder': {
            category: 'Number Theory',
            description: 'Solves a system of simultaneous congruences using the Chinese Remainder Theorem.',
            returns: {
                type: 'integer',
            },
            args: {
                remainders: {
                    type: 'integer',
                    array: true,
                    description: 'The remainders of the congruences.',
                },
                moduli: {
                    type: 'integer',
                    array: true,
                    description: 'The moduli of the congruences.',
                },
                a: {
                    type: 'array',
                },
                b: {
                    type: 'array',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'remainders',
                        'moduli',
                    ],
                },
            ],
            examples: [
                'let { chinese-remainder } = import("Number-Theory");\nchinese-remainder([2, 3], [3, 5])',
                'let { chinese-remainder } = import("Number-Theory");\nchinese-remainder([1, 2], [3, 4])',
                'let { chinese-remainder } = import("Number-Theory");\nchinese-remainder([0, 1], [2, 3])',
                'let { chinese-remainder } = import("Number-Theory");\nchinese-remainder([1, 2, 3], [4, 5, 7])',
            ],
        },
        'stirling-first': {
            category: 'Number Theory',
            description: 'Calculates the Stirling numbers of the first kind, which count the number of permutations of n elements with k cycles.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                    description: 'The number of elements.',
                },
                b: {
                    type: 'integer',
                    description: 'The number of cycles.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { stirling-first } = import("Number-Theory");\nstirling-first(5, 2)',
                'let { stirling-first } = import("Number-Theory");\nstirling-first(4, 3)',
                'let { stirling-first } = import("Number-Theory");\nstirling-first(6, 1)',
                'let { stirling-first } = import("Number-Theory");\nstirling-first(7, 4)',
                'let { stirling-first } = import("Number-Theory");\nstirling-first(8, 5)',
            ],
        },
        'stirling-second': {
            category: 'Number Theory',
            description: 'Calculates the Stirling numbers of the second kind, which count the number of ways to partition n elements into k non-empty subsets.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                    description: 'The number of elements.',
                },
                b: {
                    type: 'integer',
                    description: 'The number of subsets.',
                },
            },
            variants: [
                {
                    argumentNames: [
                        'a',
                        'b',
                    ],
                },
            ],
            examples: [
                'let { stirling-second } = import("Number-Theory");\nstirling-second(5, 2)',
                'let { stirling-second } = import("Number-Theory");\nstirling-second(4, 3)',
                'let { stirling-second } = import("Number-Theory");\nstirling-second(6, 1)',
                'let { stirling-second } = import("Number-Theory");\nstirling-second(7, 4)',
                'let { stirling-second } = import("Number-Theory");\nstirling-second(8, 5)',
            ],
        },
    };

    function binomialCoefficient(n, k) {
        if (k === 0 || k === n)
            return 1;
        var result = 1;
        for (var i = 0; i < k; i++)
            result *= (n - i) / (i + 1);
        return result;
    }

    /**
     * Generates all possible combinations of a specified size from a collection.
     * @param collection The input collection to generate combinations from
     * @param size The size of each combination
     * @returns An array of arrays, where each inner array is a combination of the specified size
     */
    function combinations(collection, size) {
        var e_1, _a;
        // Base case: if size is 1, return each element as its own combination
        if (size === 1) {
            return collection.map(function (item) { return [item]; });
        }
        var result = [];
        // Recursive approach to build combinations
        for (var i = 0; i <= collection.length - size; i++) {
            // Take the current element
            var current = collection[i];
            // Get all combinations of size-1 from the rest of the elements
            var subCombinations = combinations(collection.slice(i + 1), size - 1);
            try {
                // Add the current element to each sub-combination
                for (var subCombinations_1 = (e_1 = void 0, __values(subCombinations)), subCombinations_1_1 = subCombinations_1.next(); !subCombinations_1_1.done; subCombinations_1_1 = subCombinations_1.next()) {
                    var subComb = subCombinations_1_1.value;
                    result.push(__spreadArray([current], __read(subComb), false));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (subCombinations_1_1 && !subCombinations_1_1.done && (_a = subCombinations_1.return)) _a.call(subCombinations_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return result;
    }
    var combinationsNormalExpressions = {
        'combinations': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), set = _b[0], n = _b[1];
                assertArray(set, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true, lte: set.length });
                if (n === 0)
                    return [[]];
                return combinations(set, n);
            },
            arity: toFixedArity(2),
        },
        'count-combinations': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], k = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                assertNumber(k, sourceCodeInfo, { integer: true, nonNegative: true, lte: n });
                return binomialCoefficient(n, k);
            },
            arity: toFixedArity(2),
        },
    };

    function getAllDerangements(arr) {
        var n = arr.length;
        var result = [];
        var used = Array.from({ length: n }, function () { return false; });
        var temp = Array.from({ length: n });
        function generateDerangements(pos) {
            if (pos === n) {
                result.push(__spreadArray([], __read(temp), false));
                return;
            }
            for (var i = 0; i < n; i++) {
                // Skip if element is already used or would be in its original position
                if (used[i] || i === pos) {
                    continue;
                }
                used[i] = true;
                temp[pos] = arr[i];
                generateDerangements(pos + 1);
                used[i] = false;
            }
        }
        generateDerangements(0);
        return result;
    }
    function countDerangements(n) {
        if (n === 1)
            return 0;
        var a = 1; // !0
        var b = 0; // !1
        var result = 0;
        for (var i = 2; i <= n; i++) {
            result = (i - 1) * (a + b);
            a = b;
            b = result;
        }
        return result;
    }
    var derangementsNormalExpressions = {
        'derangements': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), set = _b[0];
                assertArray(set, sourceCodeInfo);
                return getAllDerangements(set);
            },
            arity: toFixedArity(1),
        },
        'count-derangements': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return countDerangements(n);
            },
            arity: toFixedArity(1),
        },
    };

    function calcUnsortedDivisors(number) {
        var divisors = [];
        for (var i = 1; i <= Math.sqrt(number); i++) {
            if (number % i === 0) {
                divisors.push(i);
                if (i !== number / i) {
                    divisors.push(number / i);
                }
            }
        }
        return divisors;
    }
    function getDivisors(n) {
        var unsortedDivisors = calcUnsortedDivisors(n);
        var sortedDivisors = unsortedDivisors.sort(function (a, b) { return a - b; });
        return sortedDivisors;
    }
    function getProperDivisors(n) {
        return getDivisors(n).slice(0, -1); // Exclude the number itself
    }
    var divisorsNormalExpressions = {
        'divisors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return getDivisors(number);
            },
            arity: toFixedArity(1),
        },
        'count-divisors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return calcUnsortedDivisors(number).length;
            },
            arity: toFixedArity(1),
        },
        'proper-divisors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return getProperDivisors(number);
            },
            arity: toFixedArity(1),
        },
        'count-proper-divisors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return calcUnsortedDivisors(number).length - 1; // Exclude the number itself
            },
            arity: toFixedArity(1),
        },
    };

    var factorialNumbers = [
        1,
        1,
        2,
        6,
        24,
        120,
        720,
        5040,
        40320,
        362880,
        3628800,
        39916800,
        479001600,
        6227020800,
        87178291200,
        1307674368000,
        20922789888000,
        355687428096000,
        6402373705728000,
    ];

    function factorialOf(n) {
        if (n < 0)
            throw new Error('Factorial is not defined for negative numbers');
        if (n === 0 || n === 1)
            return 1;
        if (n <= 18) {
            return factorialNumbers[n];
        }
        var result = factorialNumbers[18];
        for (var i = 19; i <= n; i++)
            result *= i;
        return result;
    }
    var factorialNormalExpressions = {
        factorial: {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true, lte: 170 });
                return factorialOf(n);
            },
            arity: toFixedArity(1),
        },
    };

    var partitionNumbers = [
        1,
        2,
        3,
        5,
        7,
        11,
        15,
        22,
        30,
        42,
        56,
        77,
        101,
        135,
        176,
        231,
        297,
        385,
        490,
        627,
        792,
        1002,
        1255,
        1575,
        1958,
        2436,
        3010,
        3718,
        4565,
        5604,
        6842,
        8349,
        10143,
        12310,
        14883,
        17977,
        21637,
        26015,
        31185,
        37338,
        44583,
        53174,
        63261,
        75175,
        89134,
        105558,
        124754,
        147273,
        173525,
        204226,
        239943,
        281589,
        329931,
        386155,
        451276,
        526823,
        614154,
        715220,
        831820,
        966467,
        1121505,
        1300156,
        1505499,
        1741630,
        2012558,
        2323520,
        2679689,
        3087735,
        3554345,
        4087968,
        4697205,
        5392783,
        6185689,
        7089500,
        8118264,
        9289091,
        10619863,
        12132164,
        13848650,
        15796476,
        18004327,
        20506255,
        23338469,
        26543660,
        30167357,
        34262962,
        38887673,
        44108109,
        49995925,
        56634173,
        64112359,
        72533807,
        82010177,
        92669720,
        104651419,
        118114304,
        133230930,
        150198136,
        169229875,
        190569292,
        214481126,
        241265379,
        271248950,
        304801365,
        342325709,
        384276336,
        431149389,
        483502844,
        541946240,
        607163746,
        679903203,
        761002156,
        851376628,
        952050665,
        1064144451,
        1188908248,
        1327710076,
        1482074143,
        1653668665,
        1844349560,
        2056148051,
        2291320912,
        2552338241,
        2841940500,
        3163127352,
        3519222692,
        3913864295,
        4351078600,
        4835271870,
        5371315400,
        5964539504,
        6620830889,
        7346629512,
        8149040695,
        9035836076,
        10015581680,
        11097645016,
        12292341831,
        13610949895,
        15065878135,
        16670689208,
        18440293320,
        20390982757,
        22540654445,
        24908858009,
        27517052599,
        30388671978,
        33549419497,
        37027355200,
        40853235313,
        45060624582,
        49686288421,
        54770336324,
        60356673280,
        66493182097,
        73232243759,
        80630964769,
        88751778802,
        97662728555,
        107438159466,
        118159068427,
        129913904637,
        142798995930,
        156919475295,
        172389800255,
        189334822579,
        207890420102,
        228204732751,
        250438925115,
        274768617130,
        301384802048,
        330495499613,
        362326859895,
        397125074750,
        435157697830,
        476715857290,
        522115831195,
        571701605655,
        625846753120,
        684957390936,
        749474411781,
        819876908323,
        896684817527,
        980462880430,
        1071823774337,
        1171432692373,
        1280011042268,
        1398341745571,
        1527273599625,
        1667727404093,
        1820701100652,
        1987276856363,
        2168627105469,
        2366022741845,
        2580840212973,
        2814570987591,
        3068829878530,
        3345365983698,
        3646072432125,
        3972999029388,
        4328363658647,
        4714566886083,
        5134205287973,
        5590088317495,
        6085253859260,
        6622987708040,
        7206841706490,
        7840656226137,
        8528581302375,
        9275102575355,
        10085065885767,
        10963707205259,
        11916681236278,
        12950095925895,
        14070545699287,
        15285151248481,
        16601598107914,
        18028182516671,
        19573856161145,
        21248279009367,
        23061871173849,
        25025873760111,
        27152408925615,
        29454549941750,
        31946390696157,
        34643126322519,
        37561133582570,
        40718063627362,
        44132934884255,
        47826239745920,
        51820051838712,
        56138148670947,
        60806135438329,
        65851585970275,
        71304185514919,
        77195892663512,
        83561103925871,
        90436839668817,
        97862933703585,
        105882246722733,
        114540884553038,
        123888443077259,
        133978259344888,
        144867692496445,
        156618412527946,
        169296722391554,
        182973889854026,
        197726516681672,
        213636919820625,
        230793554364681,
        249291451168559,
        269232701252579,
        290726957916112,
        313891991306665,
        338854264248680,
        365749566870782,
        394723676655357,
        425933084409356,
        459545750448675,
        495741934760846,
        534715062908609,
        576672674947168,
        621837416509615,
        670448123060170,
        722760953690372,
        779050629562167,
        839611730366814,
        904760108316360,
        974834369944625,
        1050197489931117,
        1131238503938606,
        1218374349844333,
        1312051800816215,
        1412749565173450,
        1520980492851175,
        1637293969337171,
        1762278433057269,
        1896564103591584,
        2040825852575075,
        2195786311682516,
        2362219145337711,
        2540952590045698,
        2732873183547535,
        2938929793929555,
        3160137867148997,
        3397584011986773,
        3652430836071053,
        3925922161489422,
        4219388528587095,
        4534253126900886,
        4872038056472084,
        5234371069753672,
        5622992691950605,
        6039763882095515,
        6486674127079088,
        6965850144195831,
        7479565078510584,
        8030248384943040,
        8620496275465025,
    ];

    function partitions(n) {
        // Base cases
        if (n <= 0)
            return [[]];
        if (n === 1)
            return [[1]];
        var result = [];
        // Helper function to generate partitions recursively
        function generatePartitions(remaining, max, current) {
            if (remaining === 0) {
                result.push(__spreadArray([], __read(current), false));
                return;
            }
            // Try all possible numbers from 1 up to max
            for (var i = Math.min(max, remaining); i >= 1; i--) {
                current.push(i);
                generatePartitions(remaining - i, i, current);
                current.pop();
            }
        }
        generatePartitions(n, n, []);
        return result;
    }
    var partitionsNormalExpressions = {
        'partitions': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                return partitions(n);
            },
            arity: toFixedArity(1),
        },
        'count-partitions': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                if (n === 0)
                    return 1;
                if (n > partitionNumbers.length) {
                    throw new LitsError("n is too large. The maximum value is ".concat(partitionNumbers.length - 1, "."), sourceCodeInfo);
                }
                return partitionNumbers[n - 1];
            },
            arity: toFixedArity(1),
        },
    };

    /**
     * Generates all possible permutations of a collection.
     * @param collection The input collection to generate permutations from
     * @returns An array of arrays, where each inner array is a permutation of the input collection
     */
    function permutations(collection) {
        var e_1, _a;
        // Base case: empty array has one permutation - itself
        if (collection.length === 0) {
            return [[]];
        }
        var result = [];
        // For each element in the array
        for (var i = 0; i < collection.length; i++) {
            // Extract the current element
            var current = collection[i];
            // Create a new array without the current element
            var remainingElements = __spreadArray(__spreadArray([], __read(collection.slice(0, i)), false), __read(collection.slice(i + 1)), false);
            // Generate all permutations of the remaining elements
            var subPermutations = permutations(remainingElements);
            try {
                // Add the current element to the beginning of each sub-permutation
                for (var subPermutations_1 = (e_1 = void 0, __values(subPermutations)), subPermutations_1_1 = subPermutations_1.next(); !subPermutations_1_1.done; subPermutations_1_1 = subPermutations_1.next()) {
                    var subPerm = subPermutations_1_1.value;
                    result.push(__spreadArray([current], __read(subPerm), false));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (subPermutations_1_1 && !subPermutations_1_1.done && (_a = subPermutations_1.return)) _a.call(subPermutations_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return result;
    }
    var permutationsNormalExpressions = {
        'permutations': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), set = _b[0];
                assertArray(set, sourceCodeInfo);
                return permutations(set);
            },
            arity: toFixedArity(1),
        },
        'count-permutations': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], k = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                assertNumber(k, sourceCodeInfo, { integer: true, nonNegative: true, lte: n });
                return factorialOf(n) / factorialOf(n - k);
            },
            arity: toFixedArity(2),
        },
    };

    function powerSet(set) {
        var e_1, _a;
        var result = [[]];
        var _loop_1 = function (value) {
            var newSubsets = result.map(function (subset) { return __spreadArray(__spreadArray([], __read(subset), false), [value], false); });
            result.push.apply(result, __spreadArray([], __read(newSubsets), false));
        };
        try {
            for (var set_1 = __values(set), set_1_1 = set_1.next(); !set_1_1.done; set_1_1 = set_1.next()) {
                var value = set_1_1.value;
                _loop_1(value);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (set_1_1 && !set_1_1.done && (_a = set_1.return)) _a.call(set_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    var powerSetNormalExpressions = {
        'power-set': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), set = _b[0];
                assertArray(set, sourceCodeInfo);
                return powerSet(set);
            },
            arity: toFixedArity(1),
        },
        'count-power-set': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                if (n >= 53) {
                    // Number.MAX_SAFE_INTEGER is 2^53 - 1
                    return Infinity;
                }
                return Math.pow(2, n);
            },
            arity: toFixedArity(1),
        },
    };

    /**
     * Returns the prime factorization of a number as an array of its prime factors.
     * For example, factors(12) returns [2, 2, 3].
     * Special case: factors(1) returns an empty array [].
     *
     * @param n - A positive integer to factorize
     * @returns An array of prime factors in ascending order
     */
    function primeFactors(n) {
        // Special case: 1 has no prime factors
        if (n === 1) {
            return [];
        }
        var factors = [];
        var divisor = 2;
        // Find factors by trial division
        while (n > 1) {
            // If divisor divides n evenly
            if (n % divisor === 0) {
                // Add divisor to the factors list
                factors.push(divisor);
                // Divide n by the found factor
                n /= divisor;
            }
            else {
                // Move to the next potential divisor
                divisor++;
            }
        }
        return factors;
    }
    var primeFactorsNormalExpressions = {
        'prime-factors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return primeFactors(number);
            },
            arity: toFixedArity(1),
        },
        'distinct-prime-factors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { finite: true, integer: true, positive: true });
                var factors = primeFactors(n);
                var distinctFactors = new Set(factors);
                return Array.from(distinctFactors);
            },
            arity: toFixedArity(1),
        },
        'count-prime-factors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return primeFactors(n).length;
            },
            arity: toFixedArity(1),
        },
        'count-distinct-prime-factors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { finite: true, integer: true, positive: true });
                var factors = primeFactors(n);
                var distinctFactors = new Set(factors);
                return distinctFactors.size;
            },
            arity: toFixedArity(1),
        },
    };

    function isAbundant(num) {
        var properDivisors = getProperDivisors(num);
        var sum = properDivisors.reduce(function (acc, curr) { return acc + curr; }, 0);
        return sum > num;
    }
    var abundantSequence = {
        'abundant-seq': function (length) {
            var abundants = [];
            var num = 2;
            while (abundants.length < length) {
                if (isAbundant(num)) {
                    abundants.push(num);
                }
                num += 1;
            }
            return abundants;
        },
        'abundant?': function (n) { return isAbundant(n); },
        'abundant-take-while': function (takeWhile) {
            var abundants = [];
            for (var i = 2;; i += 1) {
                if (!isAbundant(i)) {
                    continue;
                }
                if (!takeWhile(i, abundants.length)) {
                    break;
                }
                abundants.push(i);
            }
            return abundants;
        },
    };

    /**
     * Checks if a number is a member of an arithmetic sequence.
     * @param start The first term of the sequence
     * @param step The common difference between terms
     * @param n The number to check
     * @returns true if the number is in the sequence, false otherwise
     */
    function isInArithmeticSequence(start, step, n) {
        // Special case: If step is 0, n must equal start
        if (step === 0) {
            return approxEqual(n, start);
        }
        // Calculate position in sequence
        var position = (n - start) / step;
        // Position must be non-negative
        if (position < 0) {
            return false;
        }
        // Find nearest integer position
        var roundedPosition = Math.round(position);
        // Calculate the value at that position
        var calculatedValue = start + step * roundedPosition;
        // Check both if position is close to an integer and if the
        // calculated value is close to the input value
        return approxEqual(position, roundedPosition) && approxEqual(calculatedValue, n);
    }
    var arithmeticNormalExpressions = {
        'arithmetic-seq': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], step = _b[1], length = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(step, sourceCodeInfo, { finite: true });
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                return Array.from({ length: length }, function (_, i) { return start + i * step; });
            },
            arity: toFixedArity(3),
        },
        'arithmetic-take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), start = _c[0], step = _c[1], fn = _c[2];
                var executeFunction = _b.executeFunction;
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(step, sourceCodeInfo, { finite: true });
                assertFunctionLike(fn, sourceCodeInfo);
                var arithmetic = [];
                for (var i = 0;; i += 1) {
                    var value = start + i * step;
                    if (!(executeFunction)(fn, [value, i], contextStack, sourceCodeInfo)) {
                        break;
                    }
                    arithmetic[i] = value;
                }
                return arithmetic;
            },
            arity: toFixedArity(3),
        },
        'arithmetic-nth': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], step = _b[1], n = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(step, sourceCodeInfo, { finite: true });
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                return start + (n - 1) * step;
            },
            arity: toFixedArity(3),
        },
        'arithmetic?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], step = _b[1], n = _b[2];
                assertNumber(n, sourceCodeInfo);
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(step, sourceCodeInfo, { finite: true });
                return isInArithmeticSequence(start, step, n);
            },
            arity: toFixedArity(3),
        },
    };

    var bellNumbers = [
        1,
        2,
        5,
        15,
        52,
        203,
        877,
        4140,
        21147,
        115975,
        678570,
        4213597,
        27644437,
        190899322,
        1382958545,
        10480142147,
        82864869804,
        682076806159,
        5832742205057,
        51724158235372,
        474869816156751,
        4506715738447323,
    ];

    function getBernoulliSeq(length) {
        var bernoulli = [1];
        for (var n = 1; n < length; n += 1) {
            var sum = 0;
            for (var k = 0; k < n; k += 1) {
                sum += binomialCoefficient(n + 1, k) * bernoulli[k];
            }
            bernoulli[n] = n > 1 && n % 2 === 1 ? 0 : -sum / (n + 1);
        }
        return bernoulli;
    }
    /**
     * Generates Bernoulli numbers as long as the predicate function returns true
     * @param predicate - Function that takes a Bernoulli number and its index and returns true if generation should continue
     * @returns Array of Bernoulli numbers generated until predicate returns false
     */
    function generateBernoulli(predicate) {
        var batchSize = 100;
        // Start with computing the Bernoulli numbers
        var bernoulli = [1];
        var n = 1;
        // Continue generating as long as the predicate returns true
        while (true) {
            // Generate a batch of numbers at a time for efficiency
            var targetLength = bernoulli.length + batchSize;
            for (; n < targetLength; n++) {
                var sum = 0;
                for (var k = 0; k < n; k++) {
                    sum += binomialCoefficient(n + 1, k) * bernoulli[k];
                }
                var newValue = n > 1 && n % 2 === 1 ? 0 : -sum / (n + 1);
                // Check if we should continue
                if (!predicate(newValue, n)) {
                    // We're done, return the generated sequence (including the last value)
                    return bernoulli;
                }
                bernoulli.push(newValue);
            }
        }
    }
    var bernoulliNormalExpressions = {
        'bernoulli-seq': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), length = _b[0];
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                return getBernoulliSeq(length);
            },
            arity: toFixedArity(1),
        },
        'bernoulli-nth': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                var bernoulli = getBernoulliSeq(n);
                return bernoulli[n - 1];
            },
            arity: toFixedArity(1),
        },
        'bernoulli-take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 1), fn = _c[0];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                var bernoulli = generateBernoulli(function (value, index) { return !!(executeFunction)(fn, [value, index], contextStack); });
                return bernoulli;
            },
            arity: toFixedArity(1),
        },
    };

    var catalanNumbers = [
        1,
        2,
        5,
        14,
        42,
        132,
        429,
        1430,
        4862,
        16796,
        58786,
        208012,
        742900,
        2674440,
        9694845,
        35357670,
        129644790,
        477638700,
        1767263190,
        6564120420,
        24466267020,
        91482563640,
        343059613650,
        1289904147324,
        4861946401452,
        18367353072152,
        69533550916004,
        263747951750360,
        1002242216651368,
        3814986502092304,
    ];

    var collatzSequence = {
        'collatz-seq': function (start) {
            var x = start;
            var collatz = [x];
            while (x !== 1) {
                if (x % 2 === 0) {
                    x /= 2;
                }
                else {
                    x = 3 * x + 1;
                }
                collatz.push(x);
            }
            return collatz;
        },
        'noNth': true,
    };

    function isPrime(num) {
        if (num <= 1) {
            return false;
        }
        if (num <= 3) {
            return true;
        }
        if (num % 2 === 0 || num % 3 === 0) {
            return false;
        }
        for (var i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) {
                return false;
            }
        }
        return true;
    }
    var primeSequence = {
        'prime-seq': function (length) {
            var primes = [];
            var num = 2;
            while (primes.length < length) {
                if (isPrime(num)) {
                    primes.push(num);
                }
                num += 1;
            }
            return primes;
        },
        'prime?': function (n) { return isPrime(n); },
        'prime-take-while': function (takeWhile) {
            var primes = [];
            for (var i = 2;; i += 1) {
                if (!isPrime(i)) {
                    continue;
                }
                if (!takeWhile(i, primes.length)) {
                    break;
                }
                primes.push(i);
            }
            return primes;
        },
    };

    function isComposite(num) {
        if (num <= 1) {
            return false;
        }
        return !isPrime(num);
    }
    var compositeSequence = {
        'composite-seq': function (length) {
            var composites = [];
            var num = 2;
            while (composites.length < length) {
                if (isComposite(num)) {
                    composites.push(num);
                }
                num += 1;
            }
            return composites;
        },
        'composite?': function (n) { return isComposite(n); },
        'composite-take-while': function (takeWhile) {
            var composites = [];
            for (var i = 4;; i += 1) {
                if (!isComposite(i)) {
                    continue;
                }
                if (!takeWhile(i, composites.length)) {
                    break;
                }
                composites.push(i);
            }
            return composites;
        },
    };

    function isDeficient(num) {
        var properDivisors = getProperDivisors(num);
        var sum = properDivisors.reduce(function (acc, curr) { return acc + curr; }, 0);
        return sum < num;
    }
    var deficientSequence = {
        'deficient-seq': function (length) {
            var deficients = [];
            var num = 1;
            while (deficients.length < length) {
                if (isDeficient(num)) {
                    deficients.push(num);
                }
                num += 1;
            }
            return deficients;
        },
        'deficient?': function (n) { return isDeficient(n); },
        'deficient-take-while': function (takeWhile) {
            var deficients = [];
            for (var i = 1;; i += 1) {
                if (!isDeficient(i)) {
                    continue;
                }
                if (!takeWhile(i, deficients.length)) {
                    break;
                }
                deficients.push(i);
            }
            return deficients;
        },
    };

    var fibonacciNumbers = [
        0,
        1,
        1,
        2,
        3,
        5,
        8,
        13,
        21,
        34,
        55,
        89,
        144,
        233,
        377,
        610,
        987,
        1597,
        2584,
        4181,
        6765,
        10946,
        17711,
        28657,
        46368,
        75025,
        121393,
        196418,
        317811,
        514229,
        832040,
        1346269,
        2178309,
        3524578,
        5702887,
        9227465,
        14930352,
        24157817,
        39088169,
        63245986,
        102334155,
        165580141,
        267914296,
        433494437,
        701408733,
        1134903170,
        1836311903,
        2971215073,
        4807526976,
        7778742049,
        12586269025,
        20365011074,
        32951280099,
        53316291173,
        86267571272,
        139583862445,
        225851433717,
        365435296162,
        591286729879,
        956722026041,
        1548008755920,
        2504730781961,
        4052739537881,
        6557470319842,
        10610209857723,
        17167680177565,
        27777890035288,
        44945570212853,
        72723460248141,
        117669030460994,
        190392490709135,
        308061521170129,
        498454011879264,
        806515533049393,
        1304969544928657,
        2111485077978050,
        3416454622906707,
        5527939700884757,
        8944394323791464,
    ];

    /**
     * Checks if a number is a member of a geometric sequence.
     * @param initialTerm The first term of the sequence (a)
     * @param ratio The common ratio of the sequence (r)
     * @param number The number to check
     * @returns true if the number is in the sequence, false otherwise
     */
    function isInGeometricSequence(initialTerm, ratio, number) {
        // Handle special cases
        if (approxEqual(initialTerm, 0)) {
            return approxEqual(number, 0);
        }
        if (approxEqual(ratio, 1)) {
            return approxEqual(number, initialTerm);
        }
        if (approxEqual(ratio, 0)) {
            return approxEqual(number, 0) || approxEqual(number, initialTerm);
        }
        // Check if the number is exactly the initial term
        if (approxEqual(number, initialTerm)) {
            return true;
        }
        // Special case for ratio = -1 (alternating sequence)
        if (approxEqual(ratio, -1)) {
            // In an alternating sequence with ratio -1, the terms are just initialTerm and -initialTerm
            return approxEqual(number, initialTerm) || approxEqual(number, -initialTerm);
        }
        // For negative ratios, we need special handling
        if (ratio < 0) {
            // Calculate log using absolute values
            var logResult_1 = Math.log(Math.abs(number / initialTerm)) / Math.log(Math.abs(ratio));
            // Check if logResult is very close to an integer
            var roundedLogResult_1 = Math.round(logResult_1);
            if (!approxEqual(roundedLogResult_1, logResult_1) || roundedLogResult_1 < 0) {
                return false;
            }
            // For negative ratios, alternating terms have alternating signs
            // Check if sign matches what we expect based on the power
            var expectedSign = roundedLogResult_1 % 2 === 0
                ? Math.sign(initialTerm)
                : Math.sign(initialTerm) * Math.sign(ratio);
            return Math.sign(number) === expectedSign;
        }
        // For positive ratios
        // Quick check based on sequence direction
        if ((ratio > 1 && number < initialTerm) || (ratio < 1 && number > initialTerm)) {
            return false;
        }
        // Calculate n in: number = initialTerm * (ratio^n)
        var logResult = Math.log(number / initialTerm) / Math.log(ratio);
        // Check if logResult is very close to an integer and non-negative
        var roundedLogResult = Math.round(logResult);
        if (!approxEqual(roundedLogResult, logResult) || roundedLogResult < 0) {
            return false;
        }
        // Verify calculated value matches the number exactly
        var calculatedValue = initialTerm * Math.pow(ratio, roundedLogResult);
        return approxEqual(calculatedValue, number);
    }
    var geometricNormalExpressions = {
        'geometric-seq': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], ratio = _b[1], length = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(ratio, sourceCodeInfo, { finite: true });
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                return Array.from({ length: length }, function (_, i) { return start * Math.pow(ratio, i); });
            },
            arity: toFixedArity(3),
        },
        'geometric-take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), start = _c[0], ratio = _c[1], fn = _c[2];
                var executeFunction = _b.executeFunction;
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(ratio, sourceCodeInfo, { finite: true });
                assertFunctionLike(fn, sourceCodeInfo);
                var geometric = [];
                for (var i = 0;; i += 1) {
                    var value = start * Math.pow(ratio, i);
                    if (!(executeFunction)(fn, [value, i], contextStack, sourceCodeInfo)) {
                        break;
                    }
                    geometric[i] = value;
                }
                return geometric;
            },
            arity: toFixedArity(3),
        },
        'geometric-nth': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], ratio = _b[1], n = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(ratio, sourceCodeInfo, { finite: true });
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                return start * Math.pow(ratio, (n - 1));
            },
            arity: toFixedArity(3),
        },
        'geometric?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], ratio = _b[1], n = _b[2];
                assertNumber(n, sourceCodeInfo);
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(ratio, sourceCodeInfo, { finite: true });
                return isInGeometricSequence(start, ratio, n);
            },
            arity: toFixedArity(3),
        },
    };

    function getGolombSeq(n) {
        var golomb = [0, 1];
        for (var i = 2; i <= n; i += 1) {
            golomb.push(1 + golomb[i - golomb[golomb[i - 1]]]);
        }
        return golomb.slice(1);
    }
    function generateGolombSeq(pred) {
        if (!pred(1, 0)) {
            return [];
        }
        var golomb = [0, 1];
        for (var i = 2;; i++) {
            var golombNumber = 1 + golomb[i - golomb[golomb[i - 1]]];
            if (!pred(golombNumber, i - 1)) {
                break;
            }
            golomb.push(golombNumber);
        }
        return golomb.slice(1);
    }
    var golombSequence = {
        'golomb-seq': function (length) { return getGolombSeq(length); },
        'golomb?': function () { return true; },
        'golomb-take-while': function (takeWhile) { return generateGolombSeq(takeWhile); },
    };

    function isHappyNumber(n) {
        // A happy number is defined by the following process:
        // 1. Starting with any positive integer, replace the number by the sum of the squares of its digits
        // 2. Repeat until either:
        //    - The number equals 1 (in which case it's a happy number)
        //    - It enters a cycle that doesn't include 1 (in which case it's not a happy number)
        if (n <= 0)
            return false;
        // Use a set to detect cycles
        var seen = new Set();
        // Continue until we either reach 1 or detect a cycle
        while (n !== 1 && !seen.has(n)) {
            seen.add(n);
            n = getSumOfSquaredDigits(n);
        }
        // If we reached 1, it's a happy number
        return n === 1;
    }
    function getSumOfSquaredDigits(n) {
        var sum = 0;
        while (n > 0) {
            var digit = n % 10;
            sum += digit * digit;
            n = Math.floor(n / 10);
        }
        return sum;
    }
    var happySequence = {
        'happy-seq': function (length) {
            var happyNumbers = [];
            for (var i = 1; happyNumbers.length < length; i++) {
                var n = i;
                var seen = new Set();
                while (n !== 1 && !seen.has(n)) {
                    seen.add(n);
                    n = String(n)
                        .split('')
                        .reduce(function (sum, digit) { return sum + Math.pow(Number(digit), 2); }, 0);
                }
                if (n === 1)
                    happyNumbers.push(i);
            }
            return happyNumbers;
        },
        'happy?': function (n) { return isHappyNumber(n); },
        'happy-take-while': function (takeWhile) {
            var happyNumbers = [];
            for (var i = 1;; i++) {
                var n = i;
                var seen = new Set();
                while (n !== 1 && !seen.has(n)) {
                    seen.add(n);
                    n = String(n)
                        .split('')
                        .reduce(function (sum, digit) { return sum + Math.pow(Number(digit), 2); }, 0);
                }
                if (n === 1) {
                    if (!takeWhile(i, happyNumbers.length)) {
                        break;
                    }
                    happyNumbers.push(i);
                }
            }
            return happyNumbers;
        },
    };

    var jugglerSequence = {
        'juggler-seq': function (start) {
            var next = start;
            var juggler = [next];
            while (next > 1) {
                next = next % 2 === 0
                    ? Math.floor(Math.sqrt(next))
                    : Math.floor(Math.pow(next, (3 / 2)));
                juggler.push(next);
            }
            return juggler;
        },
        'noNth': true,
    };

    /**
     * Checks if a number is part of the Look-and-Say sequence.
     *
     * The Look-and-Say sequence starts with "1" and each subsequent term describes
     * the previous term by counting consecutive digits. For example:
     * 1, 11, 21, 1211, 111221, 312211, 13112221, ...
     *
     * @param {string|number} target - The number to check (can be a string or number)
     * @returns {boolean} - Whether the target is in the sequence
     */
    function isLookAndSay(target) {
        // The first term of the sequence
        var current = '1';
        // Check if the first term matches
        if (current === target) {
            return true;
        }
        // Generate terms and check against the target
        while (true) {
            current = getNextLookAndSayTerm(current);
            if (current === target) {
                return true;
            }
            // Optimization: if the current term is longer than the target, and
            // the sequence is strictly increasing in length, the target won't be found
            if (current.length > target.length) {
                return false;
            }
        }
    }
    /**
     * Generates the next term in the Look-and-Say sequence
     *
     * @param {string} term - The current term
     * @returns {string} - The next term in the sequence
     */
    function getNextLookAndSayTerm(term) {
        var result = '';
        var count = 1;
        for (var i = 0; i < term.length; i++) {
            // If the current digit is the same as the next one, increment count
            if (i + 1 < term.length && term[i] === term[i + 1]) {
                count++;
            }
            else {
                // Otherwise, append count and the digit to the result
                result += count.toString() + term[i];
                count = 1;
            }
        }
        return result;
    }
    var lookAndSaySequence = {
        'string': true,
        'look-and-say-seq': function (length) {
            var lookAndSay = ['1'];
            for (var i = 1; i < length; i += 1) {
                var prev = lookAndSay[i - 1];
                var next = prev.replace(/(\d)\1*/g, function (match) { return "".concat(match.length).concat(match[0]); });
                lookAndSay[i] = next;
            }
            return lookAndSay;
        },
        'look-and-say-take-while': function (takeWhile) {
            if (!takeWhile('1', 0)) {
                return [];
            }
            var lookAndSay = ['1'];
            for (var i = 1;; i += 1) {
                var prev = lookAndSay[i - 1];
                var next = prev.replace(/(\d)\1*/g, function (match) { return "".concat(match.length).concat(match[0]); });
                if (!takeWhile(next, i)) {
                    break;
                }
                lookAndSay[i] = next;
            }
            return lookAndSay;
        },
        'look-and-say?': function (n) { return isLookAndSay(n); },
    };

    var lucasNumbers = [
        2,
        1,
        3,
        4,
        7,
        11,
        18,
        29,
        47,
        76,
        123,
        199,
        322,
        521,
        843,
        1364,
        2207,
        3571,
        5778,
        9349,
        15127,
        24476,
        39603,
        64079,
        103682,
        167761,
        271443,
        439204,
        710647,
        1149851,
        1860498,
        3010349,
        4870847,
        7881196,
        12752043,
        20633239,
        33385282,
        54018521,
        87403803,
        141422324,
        228826127,
        370248451,
        599074578,
        969323029,
        1568397607,
        2537720636,
        4106118243,
        6643838879,
        10749957122,
        17393796001,
        28143753123,
        45537549124,
        73681302247,
        119218851371,
        192900153618,
        312119004989,
        505019158607,
        817138163596,
        1322157322203,
        2139295485799,
        3461452808002,
        5600748293801,
        9062201101803,
        14662949395604,
        23725150497407,
        38388099893011,
        62113250390418,
        100501350283429,
        162614600673847,
        263115950957276,
        425730551631123,
        688846502588399,
        1114577054219522,
        1803423556807921,
        2918000611027443,
        4721424167835364,
        7639424778862807,
    ];

    /**
     * Generates lucky numbers while the predicate function returns true.
     *
     * @param predicate - Function that tests if we should continue generating numbers.
     *                    Takes the current lucky number and index as parameters.
     * @returns An array of lucky numbers
     */
    function generateLuckyNumbers(predicate) {
        // Start with counting from 1
        var numbers = [];
        for (var i = 1; i <= 2000; i++) {
            numbers.push(i);
        }
        // First step: remove all even numbers (keep 1)
        var filteredNumbers = [1];
        for (var i = 1; i < numbers.length; i++) {
            if (numbers[i] % 2 !== 0) {
                filteredNumbers.push(numbers[i]);
            }
        }
        var luckyNumbers = [1]; // 1 is always the first lucky number
        var count = 1;
        // Check if we should continue after the first number
        if (!predicate(1, 0)) {
            return [];
        }
        // Continue the sieve process
        var index = 1; // Start with the second element (index 1, which is 3)
        while (index < filteredNumbers.length) {
            // Get the current lucky number
            var luckyNumber = filteredNumbers[index];
            // Check if we should continue
            if (!predicate(luckyNumber, count)) {
                break;
            }
            // Add to result
            luckyNumbers.push(luckyNumber);
            count++;
            // Apply the sieve
            var step = luckyNumber;
            var newFiltered = [];
            for (var i = 0; i < filteredNumbers.length; i++) {
                if ((i + 1) % step !== 0) { // Keep numbers not at positions divisible by step
                    newFiltered.push(filteredNumbers[i]);
                }
            }
            filteredNumbers = newFiltered;
            index++;
            // If we're running low on numbers, extend the sequence
            if (index >= filteredNumbers.length - 5) {
                var lastNum = filteredNumbers[filteredNumbers.length - 1];
                var next = lastNum + 2;
                while (filteredNumbers.length < index + 1000) {
                    filteredNumbers.push(next);
                    next += 2;
                }
            }
        }
        return luckyNumbers;
    }
    /**
     * Generates lucky numbers up to a specified length or count
     *
     * Lucky numbers are a subset of integers defined by a specific sieving process:
     * 1. Start with all positive integers: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
     * 2. Keep 1, delete every 2nd number: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, ...
     * 3. The second remaining number is 3, so keep it and delete every 3rd number: 1, 3, 7, 9, 13, 15, 19, ...
     * 4. The third remaining number is 7, so keep it and delete every 7th number
     * 5. Continue this process to get all lucky numbers
     *
     * @param count - The number of lucky numbers to generate
     * @returns An array containing the first 'count' lucky numbers
     */
    function getLuckyNumbers(count) {
        // Step 1: Start with all odd numbers (we skip the first elimination step since we know
        // the first sieve removes all even numbers)
        var numbers = [];
        var n = 1;
        // Generate enough odd numbers to ensure we'll have 'count' lucky numbers after sieving
        // The factor depends on how many numbers we expect to be eliminated
        // For larger counts, we need a higher factor to ensure we have enough numbers
        var factor = count < 100 ? 20 : 30;
        var initialSize = count * factor;
        while (numbers.length < initialSize) {
            numbers.push(n);
            n += 2;
        }
        // Step 2 and beyond: Apply the lucky number sieve
        var sieveIndex = 1; // Start at index 1 (the second element which is 3)
        while (sieveIndex < numbers.length && sieveIndex < count) {
            var sieveValue = numbers[sieveIndex];
            // Remove every sieveValue-th number
            // This is an optimization over creating a new array each time
            var j = 0;
            for (var i = 0; i < numbers.length; i++) {
                if ((i + 1) % sieveValue !== 0) {
                    numbers[j++] = numbers[i];
                }
            }
            numbers.length = j; // Truncate the array
            // Only increment sieveIndex if it's still within the new array bounds
            if (sieveIndex < numbers.length) {
                sieveIndex++;
            }
        }
        // Return the requested number of lucky numbers
        return numbers.slice(0, count);
    }
    var luckySequence = {
        'lucky-seq': function (length) { return getLuckyNumbers(length); },
        'lucky?': function (n) { return generateLuckyNumbers(function (l) { return l <= n; }).includes(n); },
        'lucky-take-while': function (takeWhile) { return generateLuckyNumbers(takeWhile); },
    };

    var mersenneNumbers = [3, 7, 31, 127, 2047, 8191, 131071, 524287, 2147483647];

    /**
     * Checks if a number is a Padovan number.
     * Padovan numbers follow the recurrence relation: P(n) = P(n-2) + P(n-3) for n >= 3,
     * with initial values P(0) = P(1) = P(2) = 1.
     *
     * The first few Padovan numbers are:
     * 1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 12, 16, 21, 28, 37, 49, 65, 86, 114, 151, 200, ...
     *
     * @param num - The number to check
     * @returns True if the number is a Padovan number, false otherwise
     */
    function isPadovan(num) {
        // Padovan numbers are always positive integers
        if (!Number.isInteger(num) || num <= 0) {
            return false;
        }
        // Special case: The first three Padovan numbers are all 1
        if (num === 1) {
            return true;
        }
        // Pre-calculated Padovan numbers (for efficient lookup, verified for correctness)
        var padovanNumbers = [
            1,
            1,
            1,
            2,
            2,
            3,
            4,
            5,
            7,
            9,
            12,
            16,
            21,
            28,
            37,
            49,
            65,
            86,
            114,
            151,
            200,
            265,
            351,
            465,
            616,
            816,
            1081,
            1432,
            1897,
            2513,
            3329,
            4410,
            5842,
            7739,
            10252,
            13581,
            17991,
            23833,
            31572,
            41824,
            55405,
            73396,
            97229,
        ];
        // Direct lookup for known values
        if (padovanNumbers.includes(num)) {
            return true;
        }
        // For numbers larger than our pre-calculated list but within JavaScript's safe range
        if (num > padovanNumbers[padovanNumbers.length - 1] && num <= Number.MAX_SAFE_INTEGER) {
            // Start with the last three values from our known sequence
            var a = padovanNumbers[padovanNumbers.length - 3];
            var b = padovanNumbers[padovanNumbers.length - 2];
            var c = padovanNumbers[padovanNumbers.length - 1];
            var next 
            // Generate Padovan numbers until we either find a match or exceed the input
            = void 0;
            // Generate Padovan numbers until we either find a match or exceed the input
            while (c < num) {
                next = a + b;
                a = b;
                b = c;
                c = next;
                if (c === num) {
                    return true;
                }
                // Check for numeric overflow/precision issues
                if (!Number.isSafeInteger(c)) {
                    return false;
                }
            }
        }
        return false;
    }
    var padovanSequence = {
        'padovan-seq': function (length) {
            var padovan = [1, 1, 1];
            for (var i = 3; i < length; i += 1) {
                padovan[i] = padovan[i - 2] + padovan[i - 3];
            }
            return padovan.slice(0, length);
        },
        'padovan?': function (n) { return isPadovan(n); },
        'padovan-take-while': function (takeWhile) {
            var padovan = [];
            if (!takeWhile(1, 0)) {
                return padovan;
            }
            padovan.push(1);
            if (!takeWhile(1, 1)) {
                return padovan;
            }
            padovan.push(1);
            if (!takeWhile(1, 2)) {
                return padovan;
            }
            padovan.push(1);
            var a = 1;
            var b = 1;
            var c = 1;
            for (var i = 4;; i += 1) {
                var temp = a + b;
                a = b;
                b = c;
                c = temp;
                if (!takeWhile(c, i)) {
                    break;
                }
                padovan.push(c);
            }
            return padovan;
        },
    };

    var pellNumbers = [
        1,
        2,
        5,
        12,
        29,
        70,
        169,
        408,
        985,
        2378,
        5741,
        13860,
        33461,
        80782,
        195025,
        470832,
        1136689,
        2744210,
        6625109,
        15994428,
        38613965,
        93222358,
        225058681,
        543339720,
        1311738121,
        3166815962,
        7645370045,
        18457556052,
        44560482149,
        107578520350,
        259717522849,
        627013566048,
        1513744654945,
        3654502875938,
        8822750406821,
        21300003689580,
        51422757785981,
        124145519261542,
        299713796309065,
        723573111879672,
        1746860020068409,
        4217293152016490,
    ];

    var perfectNumbers = [6, 28, 496, 8128, 33550336, 8589869056, 137438691328];

    var perfectCubeSequence = {
        'perfect-cube-seq': function (length) {
            var perfectcubes = [];
            for (var i = 1; i <= length; i++) {
                perfectcubes.push(Math.pow(i, 3));
            }
            return perfectcubes;
        },
        'perfect-cube?': function (n) { return n > 0 && Number.isInteger(Math.cbrt(n)); },
        'perfect-cube-take-while': function (takeWhile) {
            var perfectcubes = [];
            for (var i = 1;; i++) {
                var value = Math.pow(i, 3);
                if (!takeWhile(value, i)) {
                    break;
                }
                perfectcubes.push(value);
            }
            return perfectcubes;
        },
    };

    /**
     * Checks if a number is a perfect power and returns the base and exponent if it is.
     * A perfect power is a number that can be expressed as an integer power of another integer.
     *
     * @param n - The number to check
     * @returns [base, exponent] if n is a perfect power, null otherwise
     */
    function perfectPower(n) {
        // Handle edge cases
        if (n < 2) {
            if (n === 1) {
                // 1 is 1^k for any k, we return [1, 2] as the simplest representation
                return [1, 2];
            }
            return null; // Non positive numbers are not perfect powers
        }
        // For each possible exponent k, try to find base b such that b^k = n
        var maxK = Math.floor(Math.log2(n)) + 1;
        for (var k = 2; k <= maxK; k++) {
            // Calculate the potential base as n^(1/k)
            var b = Math.pow(n, (1 / k));
            var roundedB = Math.round(b);
            if (approxEqual(Math.pow(roundedB, k), n)) {
                return [roundedB, k];
            }
        }
        return null; // Not a perfect power
    }
    var perfectPowerSequence = {
        'perfect-power-seq': function (length) {
            var perfectPowers = [];
            for (var i = 1; perfectPowers.length < length; i++) {
                if (perfectPower(i)) {
                    perfectPowers.push(i);
                }
            }
            return perfectPowers;
        },
        'perfect-power?': function (n) { return perfectPower(n) !== null; },
        'perfect-power-take-while': function (takeWhile) {
            var perfectPowers = [];
            for (var i = 1;; i++) {
                if (perfectPower(i)) {
                    if (!takeWhile(i, perfectPowers.length)) {
                        break;
                    }
                    perfectPowers.push(i);
                }
            }
            return perfectPowers;
        },
    };

    var perfectSquareSequence = {
        'perfect-square-seq': function (length) {
            var perfectSquares = [];
            for (var i = 1; i <= length; i++) {
                perfectSquares.push(Math.pow(i, 2));
            }
            return perfectSquares;
        },
        'perfect-square?': function (n) { return n > 0 && Number.isInteger(Math.sqrt(n)); },
        'perfect-square-take-while': function (takeWhile) {
            var perfectSquares = [];
            for (var i = 1;; i++) {
                var value = Math.pow(i, 2);
                if (!takeWhile(value, i)) {
                    break;
                }
                perfectSquares.push(value);
            }
            return perfectSquares;
        },
    };

    var poligonalNormalExpressions = {
        'polygonal-seq': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), sides = _b[0], n = _b[1];
                assertNumber(sides, sourceCodeInfo, { integer: true, gte: 3 });
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                var polygonal = [];
                for (var i = 1; i <= n; i += 1) {
                    polygonal[i - 1] = (i * i * (sides - 2) - i * (sides - 4)) / 2;
                }
                return polygonal;
            },
            arity: toFixedArity(2),
        },
        'polygonal-take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), sides = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertNumber(sides, sourceCodeInfo, { integer: true, gte: 3 });
                assertFunctionLike(fn, sourceCodeInfo);
                var polygonal = [];
                for (var i = 1;; i += 1) {
                    var value = (i * i * (sides - 2) - i * (sides - 4)) / 2;
                    if (!(executeFunction)(fn, [value, i], contextStack, sourceCodeInfo)) {
                        break;
                    }
                    polygonal[i - 1] = (i * i * (sides - 2) - i * (sides - 4)) / 2;
                }
                return polygonal;
            },
            arity: toFixedArity(2),
        },
        'polygonal-nth': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), sides = _b[0], n = _b[1];
                assertNumber(sides, sourceCodeInfo, { integer: true, gte: 3 });
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                return (n * n * (sides - 2) - n * (sides - 4)) / 2;
            },
            arity: toFixedArity(2),
        },
        'polygonal?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), sides = _b[0], n = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true });
                assertNumber(sides, sourceCodeInfo, { integer: true, gte: 3 });
                if (n <= 0) {
                    return false;
                }
                var a = sides - 2;
                var b = sides - 4;
                var discriminant = 8 * a * n + b * b;
                var sqrtPart = Math.sqrt(discriminant);
                // Discriminant must yield an integer square root
                if (!Number.isInteger(sqrtPart))
                    return false;
                var numerator = sqrtPart + b;
                // Numerator must be divisible by 2*a
                if (numerator % (2 * a) !== 0)
                    return false;
                var x = numerator / (2 * a);
                // x must be a positive integer
                return Number.isInteger(x) && x > 0;
            },
            arity: toFixedArity(2),
        },
    };

    /**
     * Generates the first 'n' terms of the Recamán sequence.
     *
     * @param n - Number of terms to generate
     * @returns Array containing the first n terms of the Recamán sequence
     */
    function generateRecamanSequence(n) {
        if (n === 1)
            return [0];
        var sequence = [0];
        var seen = new Set([0]);
        for (var i = 1; i < n; i++) {
            // Try to go backward
            var next = sequence[i - 1] - i;
            // If that's not positive or already seen, go forward
            if (next <= 0 || seen.has(next)) {
                next = sequence[i - 1] + i;
            }
            sequence.push(next);
            seen.add(next);
        }
        return sequence;
    }
    var recamanSequence = {
        'recaman-seq': function (length) { return generateRecamanSequence(length); },
        'recaman-take-while': function (takeWhile) {
            if (!takeWhile(0, 0))
                return [];
            var sequence = [0];
            var seen = new Set([0]);
            for (var i = 1;; i++) {
                // Try to go backward
                var next = sequence[i - 1] - i;
                // If that's not positive or already seen, go forward
                if (next <= 0 || seen.has(next)) {
                    next = sequence[i - 1] + i;
                }
                if (!takeWhile(next, i))
                    break;
                sequence.push(next);
                seen.add(next);
            }
            return sequence;
        },
        'recaman?': function () { return true; },
    };

    var sylvesterNumbers = [
        2,
        6,
        42,
        1806,
        3263442,
        10650056950806,
    ];

    var thueMorseSequence = {
        'thue-morse-seq': function (length) {
            var thueMorse = [];
            for (var i = 0; i < length; i += 1) {
                thueMorse[i] = countSetBits(i) % 2;
            }
            return thueMorse;
        },
        'thue-morse-take-while': function (takeWhile) {
            var thueMorse = [];
            for (var i = 0;; i += 1) {
                var value = countSetBits(i) % 2;
                if (!takeWhile(value, i)) {
                    break;
                }
                thueMorse[i] = value;
            }
            return thueMorse;
        },
        'thue-morse?': function (n) { return n === 1 || n === 0; },
    };
    function countSetBits(num) {
        var count = 0;
        while (num) {
            count += num & 1;
            num >>= 1;
        }
        return count;
    }

    var tribonacciNumbers = [
        0,
        1,
        1,
        2,
        4,
        7,
        13,
        24,
        44,
        81,
        149,
        274,
        504,
        927,
        1705,
        3136,
        5768,
        10609,
        19513,
        35890,
        66012,
        121415,
        223317,
        410744,
        755476,
        1389537,
        2555757,
        4700770,
        8646064,
        15902591,
        29249425,
        53798080,
        98950096,
        181997601,
        334745777,
        615693474,
        1132436852,
        2082876103,
        3831006429,
        7046319384,
        12960201916,
        23837527729,
        43844049029,
        80641778674,
        148323355432,
        272809183135,
        501774317241,
        922906855808,
        1697490356184,
        3122171529233,
        5742568741225,
        10562230626642,
        19426970897100,
        35731770264967,
        65720971788709,
        120879712950776,
        222332455004452,
        408933139743937,
        752145307699165,
        1383410902447554,
        2544489349890656,
        4680045560037375,
        8607945812375585,
    ];

    var sequenceNormalExpressions = {};
    addSequence(abundantSequence);
    addSequence(collatzSequence);
    addSequence(compositeSequence);
    addSequence(deficientSequence);
    addSequence(golombSequence);
    addSequence(happySequence);
    addSequence(jugglerSequence);
    addSequence(lookAndSaySequence);
    addSequence(luckySequence);
    addSequence(padovanSequence);
    addSequence(perfectSquareSequence);
    addSequence(perfectCubeSequence);
    addSequence(perfectPowerSequence);
    addSequence(primeSequence);
    addSequence(recamanSequence);
    addSequence(thueMorseSequence);
    addNormalExpressions$1(getFiniteNumberSequence('tribonacci', tribonacciNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('catalan', catalanNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('factorial', factorialNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('fibonacci', fibonacciNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('lucas', lucasNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('mersenne', mersenneNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('partition', partitionNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('pell', pellNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('perfect', perfectNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('sylvester', sylvesterNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('bell', bellNumbers));
    addNormalExpressions$1(arithmeticNormalExpressions);
    addNormalExpressions$1(bernoulliNormalExpressions);
    addNormalExpressions$1(geometricNormalExpressions);
    addNormalExpressions$1(poligonalNormalExpressions);
    function addNormalExpressions$1(normalExpressions) {
        var e_1, _a;
        try {
            for (var _b = __values(Object.entries(normalExpressions)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (sequenceNormalExpressions[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                sequenceNormalExpressions[key] = value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    function getFiniteNumberSequence(name, sequence) {
        var _a;
        return _a = {},
            _a["".concat(name, "-seq")] = createSeqNormalExpression(function (length) { return sequence.slice(0, length); }, sequence.length),
            _a["".concat(name, "-take-while")] = createTakeWhileNormalExpression(function (takeWhile) {
                var i = 0;
                for (i = 0;; i += 1) {
                    if (i >= sequence.length) {
                        break;
                    }
                    if (!takeWhile(sequence[i], i)) {
                        break;
                    }
                }
                return sequence.slice(0, i);
            }, sequence.length),
            _a["".concat(name, "-nth")] = createNthNormalExpression(function () { return sequence; }, sequence.length),
            _a["".concat(name, "?")] = createNumberPredNormalExpression(function (n) { return sequence.includes(n); }),
            _a;
    }
    function addSequence(sequence) {
        var e_2, _a;
        try {
            for (var _b = __values(Object.entries(sequence)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (sequenceNormalExpressions[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                if (key.endsWith('seq')) {
                    sequenceNormalExpressions[key] = createSeqNormalExpression(value, sequence.maxLength);
                    if (!sequence.noNth) {
                        sequenceNormalExpressions[key.replace(/seq$/, 'nth')] = createNthNormalExpression(value, sequence.maxLength);
                    }
                }
                else if (key.endsWith('take-while')) {
                    sequenceNormalExpressions[key] = createTakeWhileNormalExpression(value, sequence.maxLength);
                }
                else if (key.endsWith('?')) {
                    if (sequence.string) {
                        sequenceNormalExpressions[key] = createStringPredNormalExpression(value);
                    }
                    else {
                        sequenceNormalExpressions[key] = createNumberPredNormalExpression(value);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    function createSeqNormalExpression(seqFunction, maxLength) {
        return {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                var length = (_a = params[0]) !== null && _a !== void 0 ? _a : maxLength;
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true, lte: maxLength });
                var result = seqFunction(length, sourceCodeInfo);
                if (typeof result[0] === 'number') {
                    /* v8 ignore next 3 */
                    if (result.some(function (n) { return n > Number.MAX_SAFE_INTEGER; })) {
                        throw new LitsError('Result exceeds maximum safe integer', sourceCodeInfo);
                    }
                }
                return result;
            },
            arity: typeof maxLength === 'number' ? { max: 1 } : toFixedArity(1),
        };
    }
    function createTakeWhileNormalExpression(takeWhileFunction, maxLength) {
        return {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var fn = params[0];
                assertFunctionLike(fn, sourceCodeInfo);
                var result = takeWhileFunction(function (value, index) { return !!executeFunction(fn, [value, index], contextStack); }, sourceCodeInfo);
                if (typeof result[0] === 'number') {
                    /* v8 ignore next 3 */
                    if (result.some(function (n) { return n > Number.MAX_SAFE_INTEGER; })) {
                        throw new LitsError('Result exceeds maximum safe integer', sourceCodeInfo);
                    }
                }
                return result;
            },
            arity: typeof maxLength === 'number' ? { max: 1 } : toFixedArity(1),
        };
    }
    function createNthNormalExpression(seqFunction, maxLength) {
        return {
            evaluate: function (params, sourceCodeInfo) {
                var n = params[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true, lte: maxLength });
                var sequence = seqFunction(n, sourceCodeInfo);
                if (typeof sequence[0] === 'number') {
                    /* v8 ignore next 3 */
                    if (sequence.some(function (val) { return val > Number.MAX_SAFE_INTEGER; })) {
                        throw new LitsError('Result exceeds maximum safe integer', sourceCodeInfo);
                    }
                }
                return sequence[n - 1];
            },
            arity: toFixedArity(1),
        };
    }
    function createNumberPredNormalExpression(predFunction) {
        return {
            evaluate: function (params, sourceCodeInfo) {
                var value = params[0];
                assertNumber(value, sourceCodeInfo);
                return predFunction(value, sourceCodeInfo);
            },
            arity: toFixedArity(1),
        };
    }
    function createStringPredNormalExpression(predFunction) {
        return {
            evaluate: function (params, sourceCodeInfo) {
                var value = params[0];
                assertString(value, sourceCodeInfo);
                return predFunction(value, sourceCodeInfo);
            },
            arity: toFixedArity(1),
        };
    }

    var e_1, _a;
    function gcd(a, b) {
        while (b !== 0) {
            var temp = b;
            b = a % b;
            a = temp;
        }
        return Math.abs(a);
    }
    function lcm(a, b) {
        return Math.floor((a * b) / gcd(a, b));
    }
    function mobius(n) {
        if (n === 1)
            return 1;
        var factors = primeFactors(n);
        var uniqueFactors = new Set(factors);
        // If n has a repeated prime factor (not square-free)
        if (uniqueFactors.size !== factors.length)
            return 0;
        // If square-free with even number of prime factors: return 1
        // If square-free with odd number of prime factors: return -1
        return factors.length % 2 === 0 ? 1 : -1;
    }
    /**
     * Efficiently computes (base^exponent) % modulus using the square-and-multiply algorithm
     * Based on the pseudocode algorithm for modular exponentiation
     *
     * @param base - The base number
     * @param exponent - The exponent (must be non-negative)
     * @param modulus - The modulus (must be positive)
     * @returns The result of (base^exponent) % modulus
     */
    function modExp(base, exponent, modulus) {
        // Edge case: modulus is 1
        if (modulus === 1) {
            return 0;
        }
        // Assert: (modulus - 1) * (modulus - 1) does not overflow base
        // This is a limitation of using regular JavaScript numbers instead of BigInt
        // Initialize result
        var result = 1;
        // Apply modulo to base first
        base = base % modulus;
        // Square and multiply algorithm
        while (exponent > 0) {
            // If current bit of exponent is 1, multiply result with current base
            if (exponent % 2 === 1) {
                result = (result * base) % modulus;
            }
            // Shift exponent right (divide by 2)
            exponent = exponent >> 1;
            // Square the base for next iteration
            base = (base * base) % modulus;
        }
        return result;
    }
    /**
     * Extended Euclidean Algorithm
     * Finds gcd(a,b) and coefficients x,y such that ax + by = gcd(a,b)
     */
    function extendedGcd(a, b) {
        if (b === 0) {
            return [a, 1, 0];
        }
        var _a = __read(extendedGcd(b, a % b), 3), g = _a[0], x = _a[1], y = _a[2];
        return [g, y, x - Math.floor(a / b) * y];
    }
    /**
     * Modular Multiplicative Inverse
     * Finds x such that (a * x) % m = 1
     */
    function modInverse(a, m) {
        var _a = __read(extendedGcd(a, m), 2), g = _a[0], x = _a[1];
        if (g !== 1) {
            throw new Error("Modular inverse does not exist (gcd(".concat(a, ", ").concat(m, ") = ").concat(g, ")"));
        }
        return ((x % m) + m) % m; // Ensure positive result
    }
    /**
     * Chinese Remainder Theorem
     * Solve system of congruences: x ≡ remainders[i] (mod moduli[i])
     * Returns the smallest positive integer that satisfies all congruences
     */
    function chineseRemainder(remainders, moduli) {
        // Verify moduli are pairwise coprime
        for (var i = 0; i < moduli.length; i++) {
            for (var j = i + 1; j < moduli.length; j++) {
                var extGcd = extendedGcd(moduli[i], moduli[j])[0];
                if (extGcd !== 1) {
                    throw new Error("Moduli must be pairwise coprime, but gcd(".concat(moduli[i], ", ").concat(moduli[j], ") = ").concat(extGcd));
                }
            }
        }
        // Calculate product of all moduli
        var product = moduli.reduce(function (acc, val) { return acc * val; }, 1);
        var sum = 0;
        for (var i = 0; i < remainders.length; i++) {
            var ai = remainders[i];
            var ni = moduli[i];
            var bi = product / ni;
            // Find modular multiplicative inverse of bi modulo ni
            var inverse = modInverse(bi, ni);
            // Add contribution from this congruence
            sum = (sum + ai * bi * inverse) % product;
        }
        return sum;
    }
    var combinatoricalNormalExpression = {
        'coprime?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo, { integer: true });
                assertNumber(b, sourceCodeInfo, { integer: true });
                return gcd(a, b) === 1;
            },
            arity: toFixedArity(2),
        },
        'divisible-by?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), value = _b[0], divisor = _b[1];
                assertNumber(value, sourceCodeInfo, { integer: true });
                assertNumber(divisor, sourceCodeInfo, { integer: true });
                if (divisor === 0)
                    return false;
                return value % divisor === 0;
            },
            arity: toFixedArity(2),
        },
        'gcd': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo);
                assertNumber(b, sourceCodeInfo);
                return gcd(a, b);
            },
            arity: toFixedArity(2),
        },
        'lcm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo);
                assertNumber(b, sourceCodeInfo);
                return lcm(a, b);
            },
            arity: toFixedArity(2),
        },
        'multinomial': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), args = _b.slice(0);
                assertVector(args, sourceCodeInfo);
                var sum = args.reduce(function (acc, curr) {
                    assertNumber(curr, sourceCodeInfo, { integer: true, nonNegative: true });
                    return acc + curr;
                }, 0);
                return factorialOf(sum) / args.reduce(function (acc, curr) { return acc * factorialOf(curr); }, 1);
            },
            arity: { min: 1 },
        },
        'amicable?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(b, sourceCodeInfo, { integer: true, positive: true });
                var sumA = getProperDivisors(a).reduce(function (acc, curr) { return acc + curr; }, 0);
                var sumB = getProperDivisors(b).reduce(function (acc, curr) { return acc + curr; }, 0);
                return sumA === b && sumB === a && a !== b;
            },
            arity: toFixedArity(2),
        },
        'euler-totient': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                var result = n;
                for (var p = 2; p * p <= n; p += 1) {
                    if (n % p === 0) {
                        while (n % p === 0)
                            n /= p;
                        result -= result / p;
                    }
                }
                if (n > 1)
                    result -= result / n;
                return result;
            },
            arity: toFixedArity(1),
        },
        'mobius': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                if (n === 1)
                    return 1;
                var factors = primeFactors(n);
                var uniqueFactors = new Set(factors);
                // If n has a repeated prime factor (not square-free)
                if (uniqueFactors.size !== factors.length)
                    return 0;
                // If square-free with even number of prime factors: return 1
                // If square-free with odd number of prime factors: return -1
                return factors.length % 2 === 0 ? 1 : -1;
            },
            arity: toFixedArity(1),
        },
        'mertens': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                if (n === 1)
                    return 1;
                var result = 0;
                for (var i = 1; i <= n; i++) {
                    var mobiusValue = mobius(i);
                    result += mobiusValue; // * Math.floor(n / i)
                }
                return result;
            },
            arity: toFixedArity(1),
        },
        'sigma': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                return getDivisors(n).reduce(function (acc, curr) { return acc + curr; }, 0);
            },
            arity: toFixedArity(1),
        },
        'carmichael-lambda': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_2, _b, e_3, _c;
                var _d = __read(_a, 1), n = _d[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                if (n === 1) {
                    return 1;
                }
                // Count occurrences of each prime factor
                var primes = primeFactors(n);
                var factorMap = new Map();
                try {
                    for (var primes_1 = __values(primes), primes_1_1 = primes_1.next(); !primes_1_1.done; primes_1_1 = primes_1.next()) {
                        var prime = primes_1_1.value;
                        factorMap.set(prime, (factorMap.get(prime) || 0) + 1);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (primes_1_1 && !primes_1_1.done && (_b = primes_1.return)) _b.call(primes_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                var lambdaValues = [];
                try {
                    // Calculate lambda for each prime power
                    for (var _e = __values(factorMap.entries()), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var _g = __read(_f.value, 2), p = _g[0], k = _g[1];
                        if (p === 2) {
                            if (k === 1) {
                                lambdaValues.push(1); // λ(2) = 1
                            }
                            else if (k === 2) {
                                lambdaValues.push(2); // λ(4) = 2
                            }
                            else {
                                lambdaValues.push(Math.pow(2, (k - 2))); // λ(2^k) = 2^(k-2) for k >= 3
                            }
                        }
                        else {
                            // For odd prime powers p^k: λ(p^k) = (p-1)*p^(k-1)
                            lambdaValues.push((p - 1) * Math.pow(p, (k - 1)));
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                // Find LCM of all lambda values
                return lambdaValues.reduce(function (acc, val) { return lcm(acc, val); }, 1);
            },
            arity: toFixedArity(1),
        },
        'cartesian-product': {
            evaluate: function (params, sourceCodeInfo) {
                params.forEach(function (set) {
                    assertArray(set, sourceCodeInfo);
                });
                var sets = params;
                return sets.reduce(function (acc, set) {
                    var result = [];
                    acc.forEach(function (arr) {
                        set.forEach(function (value) {
                            result.push(__spreadArray(__spreadArray([], __read(arr), false), [value], false));
                        });
                    });
                    return result;
                }, [[]]);
            },
            arity: { min: 1 },
        },
        'perfect-power': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                var result = perfectPower(n);
                return result || null;
            },
            arity: toFixedArity(1),
        },
        'mod-exp': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), base = _b[0], exponent = _b[1], modulus = _b[2];
                assertNumber(base, sourceCodeInfo, { finite: true });
                assertNumber(exponent, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(modulus, sourceCodeInfo, { integer: true, positive: true });
                return modExp(base, exponent, modulus);
            },
            arity: toFixedArity(3),
        },
        'mod-inv': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], m = _b[1];
                assertNumber(a, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(m, sourceCodeInfo, { integer: true, positive: true });
                try {
                    return modInverse(a, m);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            arity: toFixedArity(2),
        },
        'extended-gcd': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo, { integer: true });
                assertNumber(b, sourceCodeInfo, { integer: true });
                return extendedGcd(a, b);
            },
            arity: toFixedArity(2),
        },
        'chinese-remainder': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), remainders = _b[0], moduli = _b[1];
                assertVector(remainders, sourceCodeInfo);
                assertVector(moduli, sourceCodeInfo);
                if (remainders.length !== moduli.length) {
                    throw new LitsError('Remainders and moduli must have the same length.', sourceCodeInfo);
                }
                try {
                    return chineseRemainder(remainders, moduli);
                }
                catch (error) {
                    throw new LitsError(error.message, sourceCodeInfo);
                }
            },
            arity: toFixedArity(2),
        },
        'stirling-first': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], k = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(k, sourceCodeInfo, { integer: true, positive: true, lte: n });
                // Create a table to store results
                var dp = Array.from({ length: n + 1 }, function () { return Array(k + 1).fill(0); });
                // Base case
                dp[0][0] = 1;
                // Fill the table using the recurrence relation
                for (var i = 1; i <= n; i++) {
                    for (var j = 1; j <= Math.min(i, k); j++) {
                        dp[i][j] = dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j];
                    }
                }
                return dp[n][k];
            },
            arity: toFixedArity(2),
        },
        'stirling-second': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], k = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(k, sourceCodeInfo, { integer: true, positive: true, lte: n });
                if (k === 1)
                    return 1; // Only one way to put n objects into one subset
                if (k === n)
                    return 1; // Only one way to put n objects into n subsets (one object per subset)
                // Create a 2D array for memoization
                var dp = Array.from({ length: n + 1 }, function () { return Array(k + 1).fill(0); });
                // Initialize base cases
                dp[0][0] = 1;
                // Fill the dp table using the recurrence relation:
                // S(n,k) = k * S(n-1,k) + S(n-1,k-1)
                for (var i = 1; i <= n; i++) {
                    for (var j = 1; j <= Math.min(i, k); j++) {
                        dp[i][j] = j * dp[i - 1][j] + dp[i - 1][j - 1];
                    }
                }
                return dp[n][k];
            },
            arity: toFixedArity(2),
        },
    };
    addSequences(sequenceNormalExpressions);
    addNormalExpressions(factorialNormalExpressions);
    addNormalExpressions(divisorsNormalExpressions);
    addNormalExpressions(combinationsNormalExpressions);
    addNormalExpressions(permutationsNormalExpressions);
    addNormalExpressions(partitionsNormalExpressions);
    addNormalExpressions(primeFactorsNormalExpressions);
    addNormalExpressions(derangementsNormalExpressions);
    addNormalExpressions(powerSetNormalExpressions);
    function addSequences(sequences) {
        var e_4, _a;
        try {
            for (var _b = __values(Object.entries(sequences)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (combinatoricalNormalExpression[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                combinatoricalNormalExpression[key] = value;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
    function addNormalExpressions(normalExpressions) {
        var e_5, _a;
        try {
            for (var _b = __values(Object.entries(normalExpressions)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (combinatoricalNormalExpression[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                combinatoricalNormalExpression[key] = value;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    }
    try {
        for (var _b = __values(Object.entries(namespaceDocs)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), key = _d[0], docs = _d[1];
            if (combinatoricalNormalExpression[key])
                combinatoricalNormalExpression[key].docs = docs;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var numberTheoryNamespace = {
        name: 'Number-Theory',
        functions: combinatoricalNormalExpression,
    };

    var allBuiltinNamespaces = [
        assertNamespace,
        gridNamespace,
        randomNamespace,
        vectorNamespace,
        linearAlgebraNamespace,
        matrixNamespace,
        numberTheoryNamespace,
    ];

    // --- Data types used in documentation ---
    // --- Category type ---
    var categoryRecord = {
        'Special expression': true,
        'Predicate': true,
        'Sequence': true,
        'Collection': true,
        'Array': true,
        'Object': true,
        'String': true,
        'Math': true,
        'Functional': true,
        'Regular expression': true,
        'Bitwise': true,
        'Misc': true,
        'Meta': true,
        'Assert': true,
        'Vector': true,
        'Linear Algebra': true,
        'Matrix': true,
        'Grid': true,
        'Number Theory': true,
        'Random': true,
        'Shorthand': true,
        'Datatype': true,
    };
    var categories = Object.keys(categoryRecord);
    // Categories that are namespaces (require import)
    var namespaceCategories = ['Vector', 'Linear Algebra', 'Matrix', 'Grid', 'Number Theory', 'Random', 'Assert'];
    // Core categories (always available)
    categories.filter(function (c) { return !namespaceCategories.includes(c); });
    function isFunctionDocs(docs) {
        return 'args' in docs && 'variants' in docs;
    }

    var datatype = {
        '-type-number': {
            datatype: true,
            title: 'number',
            category: 'Datatype',
            description: 'A `number`',
            examples: [
                '42',
                '3.14',
            ],
        },
        '-type-string': {
            datatype: true,
            title: 'string',
            category: 'Datatype',
            description: 'A `string`',
            examples: [
                '"hello"',
                '""',
            ],
        },
        '-type-object': {
            datatype: true,
            title: 'object',
            category: 'Datatype',
            description: 'An `object`, a collection of key-value pairs where keys are `strings`',
            examples: [
                '{}',
                '{ a: 1, b: 2}',
            ],
        },
        '-type-array': {
            datatype: true,
            title: 'array',
            category: 'Datatype',
            description: 'An `array`',
            examples: [
                '[]',
                '[1, 2, 3]',
                '["a", null, true]',
            ],
        },
        '-type-vector': {
            datatype: true,
            title: 'vector',
            category: 'Datatype',
            description: 'An `array` of `numbers`',
            examples: [
                '[]',
                '[1, 2, 3]',
            ],
        },
        '-type-matrix': {
            datatype: true,
            title: 'matrix',
            category: 'Datatype',
            description: 'A `matrix`, a two-dimensional `array` with `numbers` where each row has the same number of columns. A `matrix` is also a `grid`.',
            examples: [
                '[[]]',
                '[[1, 2], [3, 4]]',
                '[[1, 2], [3, 4], [5, 6]]',
            ],
        },
        '-type-grid': {
            datatype: true,
            title: 'grid',
            category: 'Datatype',
            description: 'A `grid`, a two-dimensional `array` where each row has the same number of columns',
            examples: [
                '[[]]',
                '[[1, 2], [3, 4]]',
                '[["a", "b"], [3, 4], [5, 6]]',
            ],
        },
        '-type-boolean': {
            datatype: true,
            title: 'boolean',
            category: 'Datatype',
            description: 'A `boolean`',
            examples: [
                'true',
                'false',
            ],
        },
        '-type-function': {
            datatype: true,
            title: 'function',
            category: 'Datatype',
            description: 'A `function`',
            examples: [
                'x -> x + 1',
                '(a, b, c) -> (a + b) * c',
                '() -> 42',
                '-> $1 + $2',
            ],
        },
        '-type-integer': {
            datatype: true,
            title: 'integer',
            category: 'Datatype',
            description: 'An `integer`',
            examples: [
                '42',
                '-42',
            ],
        },
        '-type-any': {
            datatype: true,
            title: 'any',
            category: 'Datatype',
            description: '`Any` value',
            examples: [
                '42',
                '"hello"',
                'true',
                'null',
            ],
        },
        '-type-null': {
            datatype: true,
            title: 'null',
            category: 'Datatype',
            description: 'The value `null`',
            examples: [
                'null',
            ],
        },
        '-type-collection': {
            datatype: true,
            title: 'collection',
            category: 'Datatype',
            description: 'A collection, an `object`, an `array` or a `string`',
            examples: [
                '{ foo: 42 }',
                '[1, 2, 3]',
                '"hello"',
            ],
        },
        '-type-sequence': {
            datatype: true,
            title: 'sequence',
            category: 'Datatype',
            description: 'A sequence, an `array` or a `string`',
            examples: [
                '[1, 2, 3]',
                '"hello"',
            ],
        },
        '-type-regexp': {
            datatype: true,
            title: 'regexp',
            category: 'Datatype',
            description: 'A regular expression',
            examples: [
                'regexp("^\\\\s*(.*)$")',
                '#"albert"ig',
            ],
        },
        '-type-never': {
            datatype: true,
            title: 'never',
            category: 'Datatype',
            description: 'A value that can never be created',
            examples: ["\n// throw(\"error\") will never return a value\ntry throw(\"error\") catch \"never\" end",
            ],
        },
    };

    var shorthand = {
        '-short-regexp': {
            shorthand: true,
            title: '#"pattern"',
            category: 'Shorthand',
            description: 'Shorthand for `regexp(pattern)`. Only difference is that escaping is not needed.',
            examples: [
                '#"^\\s*(.*)$"',
                '#"albert"ig',
            ],
            seeAlso: ['regexp'],
        },
        '-short-fn': {
            shorthand: true,
            title: '-> expression',
            category: 'Shorthand',
            description: "\nShorthand for `(args, ...) -> expression`.\n`$1, $2, $3, ...` are shorthand for the first, second, third, ... argument.\n\nYou can reference the first argument using either `$1` or `$`.\nHowever, please note that `$1` and `$` are mutually exclusive and cannot be used simultaneously.\nE.g. `#(* $ $1)` is not valid.",
            examples: [
                '-> $1 + $2',
                '(-> $ * $)(9)',
            ],
        },
    };

    // --- Helper: derive FunctionReference from co-located docs ---
    function docsToReference(expressions) {
        var e_1, _a;
        var result = {};
        try {
            for (var _b = __values(Object.entries(expressions)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], expr = _d[1];
                var docs = expr.docs;
                if (!docs) {
                    throw new Error("Missing docs for expression \"".concat(key, "\""));
                }
                result[key] = __assign(__assign({ title: key, category: docs.category, description: docs.description, returns: docs.returns, args: docs.args, variants: docs.variants, examples: docs.examples }, (docs.seeAlso ? { seeAlso: docs.seeAlso } : {})), (docs.hideOperatorForm ? { noOperatorDocumentation: true } : {}));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    // --- Helper: derive FunctionReference from namespace co-located docs ---
    function namespacedDocsToReference(namespaceName, expressions) {
        var e_2, _a;
        var result = {};
        try {
            for (var _b = __values(Object.entries(expressions)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], expr = _d[1];
                var docs = expr.docs;
                if (!docs) {
                    throw new Error("Missing docs for ".concat(namespaceName, ".").concat(key));
                }
                var qualifiedKey = "".concat(namespaceName, ".").concat(key);
                result[qualifiedKey] = __assign(__assign({ title: qualifiedKey, category: docs.category, description: docs.description, returns: docs.returns, args: docs.args, variants: docs.variants, examples: docs.examples }, (docs.seeAlso ? { seeAlso: docs.seeAlso } : {})), (docs.hideOperatorForm ? { noOperatorDocumentation: true } : {}));
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return result;
    }
    // Derive all core category references from co-located docs
    var bitwiseReference = docsToReference(bitwiseNormalExpression);
    var arrayRef = docsToReference(arrayNormalExpression);
    var collectionRef = docsToReference(collectionNormalExpression);
    var functionalRef = docsToReference(functionalNormalExpression);
    var mathRef = docsToReference(mathNormalExpression);
    var emptyRef = {};
    var metaRef = docsToReference(getMetaNormalExpression(emptyRef));
    var miscRef = docsToReference(miscNormalExpression);
    var objectRef = docsToReference(objectNormalExpression);
    var predicatesRef = docsToReference(predicatesNormalExpression);
    var regexpRef = docsToReference(regexpNormalExpression);
    var sequenceRef = docsToReference(sequenceNormalExpression);
    var stringRef = docsToReference(stringNormalExpression);
    // --- Helper: derive special expression reference from co-located docs ---
    function specialExpressionDocsToReference() {
        var e_3, _a;
        var result = {};
        try {
            for (var _b = __values(Object.entries(specialExpressionTypes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), name_1 = _d[0], index = _d[1];
                var expr = specialExpressions[index];
                var docs = expr === null || expr === void 0 ? void 0 : expr.docs;
                if (!docs) {
                    continue; // skip undocumented special expressions
                }
                if (isFunctionDocs(docs)) {
                    result[name_1] = __assign(__assign({ title: name_1, category: docs.category, description: docs.description, returns: docs.returns, args: docs.args, variants: docs.variants, examples: docs.examples }, (docs.seeAlso ? { seeAlso: docs.seeAlso } : {})), (docs.hideOperatorForm ? { noOperatorDocumentation: true } : {}));
                }
                else {
                    result[name_1] = __assign(__assign(__assign(__assign({ title: name_1, category: docs.category, description: docs.description, customVariants: docs.customVariants }, (docs.details ? { details: docs.details } : {})), (docs.returns ? { returns: docs.returns } : {})), { examples: docs.examples }), (docs.seeAlso ? { seeAlso: docs.seeAlso } : {}));
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return result;
    }
    var specialExpressionsReference = specialExpressionDocsToReference();
    function isFunctionReference(ref) {
        return 'returns' in ref && 'args' in ref && 'variants' in ref;
    }
    var normalExpressionReference = __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, bitwiseReference), collectionRef), arrayRef), sequenceRef), mathRef), functionalRef), metaRef), miscRef), objectRef), predicatesRef), regexpRef), stringRef);
    // Namespace functions — all derived from co-located docs
    // eslint-disable-next-line ts/consistent-type-assertions
    var namespaceReference = __assign(__assign(__assign(__assign(__assign(__assign(__assign({}, namespacedDocsToReference(assertNamespace.name, assertNamespace.functions)), namespacedDocsToReference(gridNamespace.name, gridNamespace.functions)), namespacedDocsToReference(randomNamespace.name, randomNamespace.functions)), namespacedDocsToReference(vectorNamespace.name, vectorNamespace.functions)), namespacedDocsToReference(linearAlgebraNamespace.name, linearAlgebraNamespace.functions)), namespacedDocsToReference(matrixNamespace.name, matrixNamespace.functions)), namespacedDocsToReference(numberTheoryNamespace.name, numberTheoryNamespace.functions));
    Object.entries(normalExpressionReference).forEach(function (_a) {
        var _b = __read(_a, 2), key = _b[0], obj = _b[1];
        if (!normalExpressions[key]) {
            throw new Error("Missing normal expression ".concat(key, " in normalExpressions"));
        }
        var arity = normalExpressions[key].arity;
        if (!obj.noOperatorDocumentation && canBeOperator(arity)) {
            obj._isOperator = true;
            if (isSymbolicOperator(key)) {
                obj._prefereOperator = true;
            }
        }
    });
    Object.entries(specialExpressionsReference).forEach(function (_a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], obj = _c[1];
        if (isFunctionReference(obj)) {
            var arity = (_b = specialExpressions[specialExpressionTypes[key]]) === null || _b === void 0 ? void 0 : _b.arity;
            if (arity && canBeOperator(arity)) {
                obj._isOperator = true;
            }
        }
    });
    var functionReference = __assign(__assign({}, normalExpressionReference), specialExpressionsReference);
    // Core API reference (always available)
    var apiReference = __assign(__assign(__assign({}, functionReference), shorthand), datatype);
    // All references including namespaces (for search and full documentation)
    var allReference = __assign(__assign({}, apiReference), namespaceReference);
    Object.values(allReference).forEach(function (ref) {
        ref.title = ref.title.replace(/"/g, '&quot;');
    });

    /**
     * Side-effect import: wires up reference data for the `doc` builtin function.
     * Import this module before using `doc()` on built-in functions.
     *
     * In the full entry point (src/full.ts), this is done automatically.
     * In the minimal entry point (src/index.ts), `doc()` returns '' for builtins.
     */
    setNormalExpressionReference(normalExpressionReference);

    var getLits = (function () {
        var lits = new Lits({ debug: true, namespaces: allBuiltinNamespaces });
        var litsNoDebug = new Lits({ debug: false, namespaces: allBuiltinNamespaces });
        return function (forceDebug) { return forceDebug || getState('debug') ? lits : litsNoDebug; };
    })();
    var elements = {
        wrapper: document.getElementById('wrapper'),
        playground: document.getElementById('playground'),
        sidebar: document.getElementById('sidebar'),
        mainPanel: document.getElementById('main-panel'),
        contextPanel: document.getElementById('context-panel'),
        litsPanel: document.getElementById('lits-panel'),
        outputPanel: document.getElementById('output-panel'),
        moreMenu: document.getElementById('more-menu'),
        addContextMenu: document.getElementById('add-context-menu'),
        newContextName: document.getElementById('new-context-name'),
        newContextValue: document.getElementById('new-context-value'),
        newContextError: document.getElementById('new-context-error'),
        contextTextArea: document.getElementById('context-textarea'),
        outputResult: document.getElementById('output-result'),
        litsTextArea: document.getElementById('lits-textarea'),
        resizePlayground: document.getElementById('resize-playground'),
        resizeDevider1: document.getElementById('resize-divider-1'),
        resizeDevider2: document.getElementById('resize-divider-2'),
        toggleDebugMenuLabel: document.getElementById('toggle-debug-menu-label'),
        litsPanelDebugInfo: document.getElementById('lits-panel-debug-info'),
        contextUndoButton: document.getElementById('context-undo-button'),
        contextRedoButton: document.getElementById('context-redo-button'),
        litsCodeUndoButton: document.getElementById('lits-code-undo-button'),
        litsCodeRedoButton: document.getElementById('lits-code-redo-button'),
        contextTitle: document.getElementById('context-title'),
        litsCodeTitle: document.getElementById('lits-code-title'),
        litsCodeTitleString: document.getElementById('lits-code-title-string'),
    };
    var moveParams = null;
    var autoCompleter = null;
    var ignoreSelectionChange = false;
    function calculateDimensions() {
        return {
            windowHeight: window.innerHeight,
            windowWidth: window.innerWidth,
        };
    }
    function openMoreMenu() {
        elements.moreMenu.style.display = 'block';
    }
    function closeMoreMenu() {
        elements.moreMenu.style.display = 'none';
    }
    var expandedNamespaces = new Set();
    function toggleNamespaceCategory(categoryKey) {
        var sanitizedKey = categoryKey.replace(/\s+/g, '-');
        var chevron = document.getElementById("ns-chevron-".concat(sanitizedKey));
        var content = document.getElementById("ns-content-".concat(sanitizedKey));
        if (!chevron || !content)
            return;
        if (expandedNamespaces.has(categoryKey)) {
            expandedNamespaces.delete(categoryKey);
            content.style.display = 'none';
            chevron.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M10 6L8.59 7.41L13.17 12l-4.58 4.59L10 18l6-6z"/></svg>';
        }
        else {
            expandedNamespaces.add(categoryKey);
            content.style.display = 'flex';
            chevron.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6l-6-6z"/></svg>';
        }
    }
    function openAddContextMenu() {
        elements.newContextName.value = getState('new-context-name');
        elements.newContextValue.value = getState('new-context-value');
        elements.addContextMenu.style.display = 'block';
        elements.newContextName.focus();
    }
    function closeAddContextMenu() {
        elements.addContextMenu.style.display = 'none';
        elements.newContextError.style.display = 'none';
        elements.newContextError.textContent = '';
        elements.newContextName.value = '';
        elements.newContextValue.value = '';
    }
    function share() {
        addOutputSeparator();
        appendOutput('Sharable link:', 'comment');
        var href = "".concat(location.origin).concat(location.pathname, "?state=").concat(encodeState());
        var a = document.createElement('a');
        a.textContent = href;
        a.className = 'share-link';
        a.href = href;
        addOutputElement(a);
    }
    function onDocumentClick(event) {
        var target = event.target;
        if (!(target === null || target === void 0 ? void 0 : target.closest('#more-menu')) && elements.moreMenu.style.display === 'block')
            closeMoreMenu();
        if (!(target === null || target === void 0 ? void 0 : target.closest('#add-context-menu')) && elements.addContextMenu.style.display === 'block')
            closeAddContextMenu();
    }
    var layout = throttle(function () {
        var _a = calculateDimensions(), windowWidth = _a.windowWidth, windowHeight = _a.windowHeight;
        var playgroundHeight = Math.min(getState('playground-height'), windowHeight);
        var contextPanelWidth = (windowWidth * getState('resize-divider-1-percent')) / 100;
        var outputPanelWidth = (windowWidth * (100 - getState('resize-divider-2-percent'))) / 100;
        var litsPanelWidth = windowWidth - contextPanelWidth - outputPanelWidth;
        elements.playground.style.height = "".concat(playgroundHeight, "px");
        elements.contextPanel.style.width = "".concat(contextPanelWidth, "px");
        elements.litsPanel.style.width = "".concat(litsPanelWidth, "px");
        elements.outputPanel.style.width = "".concat(outputPanelWidth, "px");
        elements.sidebar.style.bottom = "".concat(playgroundHeight, "px");
        elements.mainPanel.style.bottom = "".concat(playgroundHeight, "px");
        elements.wrapper.style.display = 'block';
    });
    var undoContextHistory = throttle(function () {
        ignoreSelectionChange = true;
        if (undoContext()) {
            applyState();
            focusContext();
        }
        setTimeout(function () { return ignoreSelectionChange = false; });
    });
    var redoContextHistory = throttle(function () {
        ignoreSelectionChange = true;
        if (redoContext()) {
            applyState();
            focusContext();
        }
        setTimeout(function () { return ignoreSelectionChange = false; });
    });
    var undoLitsCodeHistory = throttle(function () {
        ignoreSelectionChange = true;
        if (undoLitsCode()) {
            applyState();
            focusLitsCode();
        }
        setTimeout(function () { return ignoreSelectionChange = false; });
    });
    var redoLitsCodeHistory = throttle(function () {
        ignoreSelectionChange = true;
        if (redoLitsCode()) {
            applyState();
            focusLitsCode();
        }
        setTimeout(function () { return ignoreSelectionChange = false; });
    });
    function resetPlayground() {
        clearAllStates();
        resetContext();
        resetLitsCode();
        resetOutput();
        Search.closeSearch();
        Search.clearSearch();
        layout();
        updateCSS();
    }
    function resetContext() {
        elements.contextTextArea.value = '';
        clearState('context', 'context-scroll-top', 'context-selection-start', 'context-selection-end');
        focusContext();
    }
    function setContext(value, pushToHistory, scroll) {
        elements.contextTextArea.value = value;
        if (pushToHistory) {
            saveState({
                'context': value,
                'context-selection-start': elements.contextTextArea.selectionStart,
                'context-selection-end': elements.contextTextArea.selectionEnd,
            }, true);
        }
        else {
            saveState({ context: value }, false);
        }
        if (scroll === 'top')
            elements.contextTextArea.scrollTo(0, 0);
        else if (scroll === 'bottom')
            elements.contextTextArea.scrollTo({ top: elements.contextTextArea.scrollHeight, behavior: 'smooth' });
    }
    function getParsedContext() {
        try {
            return asUnknownRecord(JSON.parse(getState('context')));
        }
        catch (e) {
            return {};
        }
    }
    function addContextEntry() {
        var name = elements.newContextName.value;
        if (name === '') {
            elements.newContextError.textContent = 'Name is required';
            elements.newContextError.style.display = 'block';
            elements.newContextName.focus();
            return;
        }
        var value = elements.newContextValue.value;
        try {
            var parsedValue = JSON.parse(value);
            var context = getParsedContext();
            var values = Object.assign({}, context.values);
            values[name] = parsedValue;
            context.values = values;
            setContext(JSON.stringify(context, null, 2), true);
            closeAddContextMenu();
        }
        catch (e) {
            elements.newContextError.textContent = 'Invalid JSON';
            elements.newContextError.style.display = 'block';
            elements.newContextValue.focus();
        }
        clearState('new-context-name');
        clearState('new-context-value');
    }
    function addSampleContext() {
        var context = getParsedContext();
        var values = {
            'a-number': 42,
            'a-string': 'foo bar',
            'an-array': ['foo', 'bar', 1, 2, true, false, null],
            'an-object': {
                name: 'John Doe',
                age: 42,
                married: true,
                children: ['Alice', 'Bob'],
                address: {
                    street: '123 Main St',
                    city: 'Springfield',
                    state: 'IL',
                    zip: '62701',
                },
            },
            'matrix-a': [
                [1, 2, 3],
                [4, 5, 6],
            ],
            'matrix-b': [
                [7, 8],
                [9, 10],
                [11, 12],
            ],
            'matrix-c': [
                [3, 0, 2],
                [2, 0, -2],
                [0, 1, 1],
            ],
        };
        var jsFunctions = {
            'prompt!': '(title) => prompt(title)',
        };
        context.values = Object.assign(values, context.values);
        context.jsFunctions = Object.assign(jsFunctions, context.jsFunctions);
        setContext(JSON.stringify(context, null, 2), true);
    }
    function resetLitsCode() {
        elements.litsTextArea.value = '';
        clearState('lits-code', 'lits-code-scroll-top', 'lits-code-selection-start', 'lits-code-selection-end');
        focusLitsCode();
    }
    function setLitsCode(value, pushToHistory, scroll) {
        elements.litsTextArea.value = value;
        if (pushToHistory) {
            saveState({
                'lits-code': value,
                'lits-code-selection-start': elements.litsTextArea.selectionStart,
                'lits-code-selection-end': elements.litsTextArea.selectionEnd,
            }, true);
        }
        else {
            saveState({ 'lits-code': value }, false);
        }
        if (scroll === 'top')
            elements.litsTextArea.scrollTo(0, 0);
        else if (scroll === 'bottom')
            elements.litsTextArea.scrollTo({ top: elements.litsTextArea.scrollHeight, behavior: 'smooth' });
    }
    function appendLitsCode(value) {
        var oldContent = getState('lits-code').trimEnd();
        var newContent = oldContent ? "".concat(oldContent, "\n\n").concat(value) : value.trim();
        setLitsCode(newContent, true, 'bottom');
    }
    function resetOutput() {
        elements.outputResult.innerHTML = '';
        clearState('output');
    }
    function hasOutput() {
        return getState('output').trim() !== '';
    }
    function setOutput(value, pushToHistory) {
        elements.outputResult.innerHTML = value;
        saveState({ output: value }, pushToHistory);
    }
    function appendOutput(output, className) {
        var outputElement = document.createElement('span');
        outputElement.className = className;
        outputElement.textContent = "".concat(output);
        addOutputElement(outputElement);
    }
    function addOutputSeparator() {
        if (hasOutput()) {
            var separator = document.createElement('div');
            separator.className = 'separator';
            addOutputElement(separator);
        }
    }
    function addOutputElement(element) {
        elements.outputResult.appendChild(element);
        elements.outputResult.scrollTop = elements.outputResult.scrollHeight;
        saveState({ output: elements.outputResult.innerHTML });
    }
    window.onload = function () {
        elements.contextUndoButton.classList.add('disabled');
        elements.contextRedoButton.classList.add('disabled');
        elements.litsCodeUndoButton.classList.add('disabled');
        elements.litsCodeRedoButton.classList.add('disabled');
        setContextHistoryListener(function (status) {
            if (status.canUndo) {
                elements.contextUndoButton.classList.remove('disabled');
            }
            else {
                elements.contextUndoButton.classList.add('disabled');
            }
            if (status.canRedo) {
                elements.contextRedoButton.classList.remove('disabled');
            }
            else {
                elements.contextRedoButton.classList.add('disabled');
            }
        });
        setLitsCodeHistoryListener(function (status) {
            if (status.canUndo) {
                elements.litsCodeUndoButton.classList.remove('disabled');
            }
            else {
                elements.litsCodeUndoButton.classList.add('disabled');
            }
            if (status.canRedo) {
                elements.litsCodeRedoButton.classList.remove('disabled');
            }
            else {
                elements.litsCodeRedoButton.classList.add('disabled');
            }
        });
        document.addEventListener('click', onDocumentClick, true);
        elements.resizePlayground.onmousedown = function (event) {
            moveParams = {
                id: 'playground',
                startMoveY: event.clientY,
                heightBeforeMove: getState('playground-height'),
            };
        };
        elements.resizeDevider1.onmousedown = function (event) {
            moveParams = {
                id: 'resize-divider-1',
                startMoveX: event.clientX,
                percentBeforeMove: getState('resize-divider-1-percent'),
            };
        };
        elements.resizeDevider2.onmousedown = function (event) {
            moveParams = {
                id: 'resize-divider-2',
                startMoveX: event.clientX,
                percentBeforeMove: getState('resize-divider-2-percent'),
            };
        };
        window.onresize = layout;
        window.onmouseup = function () {
            document.body.classList.remove('no-select');
            moveParams = null;
        };
        window.onmousemove = function (event) {
            var _a = calculateDimensions(), windowHeight = _a.windowHeight, windowWidth = _a.windowWidth;
            if (moveParams === null)
                return;
            document.body.classList.add('no-select');
            if (moveParams.id === 'playground') {
                var playgroundHeight = moveParams.heightBeforeMove + moveParams.startMoveY - event.clientY;
                if (playgroundHeight < 30)
                    playgroundHeight = 30;
                if (playgroundHeight > windowHeight)
                    playgroundHeight = windowHeight;
                saveState({ 'playground-height': playgroundHeight });
                layout();
            }
            else if (moveParams.id === 'resize-divider-1') {
                var resizeDivider1XPercent = moveParams.percentBeforeMove + ((event.clientX - moveParams.startMoveX) / windowWidth) * 100;
                if (resizeDivider1XPercent < 10)
                    resizeDivider1XPercent = 10;
                if (resizeDivider1XPercent > getState('resize-divider-2-percent') - 10)
                    resizeDivider1XPercent = getState('resize-divider-2-percent') - 10;
                saveState({ 'resize-divider-1-percent': resizeDivider1XPercent });
                layout();
            }
            else if (moveParams.id === 'resize-divider-2') {
                var resizeDivider2XPercent = moveParams.percentBeforeMove + ((event.clientX - moveParams.startMoveX) / windowWidth) * 100;
                if (resizeDivider2XPercent < getState('resize-divider-1-percent') + 10)
                    resizeDivider2XPercent = getState('resize-divider-1-percent') + 10;
                if (resizeDivider2XPercent > 90)
                    resizeDivider2XPercent = 90;
                saveState({ 'resize-divider-2-percent': resizeDivider2XPercent });
                layout();
            }
        };
        window.addEventListener('keydown', function (evt) {
            if (Search.handleKeyDown(evt))
                return;
            if (evt.ctrlKey) {
                switch (evt.key) {
                    case 'r':
                        evt.preventDefault();
                        run();
                        break;
                    case 'a':
                        evt.preventDefault();
                        analyze();
                        break;
                    case 't':
                        evt.preventDefault();
                        tokenize();
                        break;
                    case 'p':
                        evt.preventDefault();
                        parse();
                        break;
                    case 'f':
                        evt.preventDefault();
                        format();
                        break;
                    case 'd':
                        evt.preventDefault();
                        toggleDebug();
                        break;
                    case '1':
                        evt.preventDefault();
                        focusContext();
                        break;
                    case '2':
                        evt.preventDefault();
                        focusLitsCode();
                        break;
                }
            }
            if (evt.key === 'Escape') {
                closeMoreMenu();
                closeAddContextMenu();
                evt.preventDefault();
            }
            if (((isMac() && evt.metaKey) || (!isMac && evt.ctrlKey)) && !evt.shiftKey && evt.key === 'z') {
                evt.preventDefault();
                if (document.activeElement === elements.contextTextArea)
                    undoContextHistory();
                else if (document.activeElement === elements.litsTextArea)
                    undoLitsCodeHistory();
            }
            if (((isMac() && evt.metaKey) || (!isMac && evt.ctrlKey)) && evt.shiftKey && evt.key === 'z') {
                evt.preventDefault();
                if (document.activeElement === elements.contextTextArea)
                    redoContextHistory();
                else if (document.activeElement === elements.litsTextArea)
                    redoLitsCodeHistory();
            }
        });
        elements.contextTextArea.addEventListener('keydown', function (evt) {
            keydownHandler(evt, function () { return setContext(elements.contextTextArea.value, true); });
        });
        elements.contextTextArea.addEventListener('input', function () {
            setContext(elements.contextTextArea.value, true);
        });
        elements.contextTextArea.addEventListener('scroll', function () {
            saveState({ 'context-scroll-top': elements.contextTextArea.scrollTop });
        });
        elements.contextTextArea.addEventListener('selectionchange', function () {
            if (!ignoreSelectionChange) {
                saveState({
                    'context-selection-start': elements.contextTextArea.selectionStart,
                    'context-selection-end': elements.contextTextArea.selectionEnd,
                });
            }
        });
        elements.contextTextArea.addEventListener('focusin', function () {
            saveState({ 'focused-panel': 'context' });
            updateCSS();
        });
        elements.contextTextArea.addEventListener('focusout', function () {
            saveState({ 'focused-panel': null });
            updateCSS();
        });
        elements.litsTextArea.addEventListener('keydown', function (evt) {
            keydownHandler(evt, function () { return setLitsCode(elements.litsTextArea.value, true); });
        });
        elements.litsTextArea.addEventListener('input', function () {
            setLitsCode(elements.litsTextArea.value, true);
        });
        elements.litsTextArea.addEventListener('scroll', function () {
            saveState({ 'lits-code-scroll-top': elements.litsTextArea.scrollTop });
        });
        elements.litsTextArea.addEventListener('selectionchange', function () {
            if (!ignoreSelectionChange) {
                saveState({
                    'lits-code-selection-start': elements.litsTextArea.selectionStart,
                    'lits-code-selection-end': elements.litsTextArea.selectionEnd,
                });
            }
        });
        elements.litsTextArea.addEventListener('focusin', function () {
            saveState({ 'focused-panel': 'lits-code' });
            updateCSS();
        });
        elements.litsTextArea.addEventListener('focusout', function () {
            saveState({ 'focused-panel': null });
            updateCSS();
        });
        elements.outputResult.addEventListener('scroll', function () {
            saveState({ 'output-scroll-top': elements.outputResult.scrollTop });
        });
        elements.newContextName.addEventListener('input', function () {
            saveState({ 'new-context-name': elements.newContextName.value });
        });
        elements.newContextValue.addEventListener('input', function () {
            saveState({ 'new-context-value': elements.newContextValue.value });
        });
        applyState(true);
        var id = location.hash.substring(1) || 'index';
        showPage(id, 'instant', 'replace');
        Search.onClose(function () {
            applyState();
        });
    };
    function getDataFromUrl() {
        var urlParams = new URLSearchParams(window.location.search);
        var urlState = urlParams.get('state');
        if (urlState) {
            addOutputSeparator();
            if (applyEncodedState(urlState))
                appendOutput("Data parsed from url parameter state: ".concat(urlState), 'comment');
            else
                appendOutput("Invalid url parameter state: ".concat(urlState), 'error');
            urlParams.delete('state');
            history.replaceState(null, '', "".concat(location.pathname).concat(urlParams.toString() ? '?' : '').concat(urlParams.toString()));
        }
    }
    function keydownHandler(evt, onChange) {
        var target = evt.target;
        var start = target.selectionStart;
        var end = target.selectionEnd;
        var indexOfReturn = target.value.lastIndexOf('\n', start - 1);
        var rowLength = start - indexOfReturn - 1;
        var onTabStop = rowLength % 2 === 0;
        if ((!['Shift', 'Control', 'Meta', 'Alt', 'Escape'].includes(evt.key) && evt.code !== 'Space')
            || (evt.code === 'Space' && !evt.altKey)) {
            autoCompleter = null;
        }
        if (evt.code === 'Space' && evt.altKey) {
            evt.preventDefault();
            if (!autoCompleter) {
                autoCompleter = getLits().getAutoCompleter(target.value, start, getLitsParamsFromContext());
            }
            var suggestion = evt.shiftKey ? autoCompleter.getPreviousSuggestion() : autoCompleter.getNextSuggestion();
            if (suggestion) {
                target.value = suggestion.program;
                target.selectionStart = target.selectionEnd = suggestion.position;
                onChange();
            }
            return;
        }
        switch (evt.code) {
            case 'Tab':
                evt.preventDefault();
                if (!evt.shiftKey) {
                    target.value = target.value.substring(0, start) + (onTabStop ? '  ' : ' ') + target.value.substring(end);
                    target.selectionStart = target.selectionEnd = start + (onTabStop ? 2 : 1);
                    onChange();
                }
                break;
            case 'Escape':
                evt.preventDefault();
                if (autoCompleter) {
                    target.value = autoCompleter.originalProgram;
                    target.selectionStart = target.selectionEnd = autoCompleter.originalPosition;
                    autoCompleter = null;
                    onChange();
                }
                break;
            case 'Backspace':
                if (onTabStop && start === end && target.value.substring(start - 2, start + 2) === '  ') {
                    evt.preventDefault();
                    target.value = target.value.substring(0, start - 2) + target.value.substring(end);
                    target.selectionStart = target.selectionEnd = start - 2;
                    onChange();
                }
                break;
            case 'Enter': {
                evt.preventDefault();
                // eslint-disable-next-line regexp/optimal-quantifier-concatenation
                var spaceCount = target.value.substring(indexOfReturn + 1, start).replace(/^( *).*/, '$1').length;
                target.value = "".concat(target.value.substring(0, start), "\n").concat(' '.repeat(spaceCount)).concat(target.value.substring(end));
                target.selectionStart = target.selectionEnd = start + 1 + spaceCount;
                onChange();
                break;
            }
            case 'Delete':
                if (onTabStop && start === end && target.value.substring(start, start + 2) === '  ') {
                    evt.preventDefault();
                    target.value = target.value.substring(0, start) + target.value.substring(end + 2);
                    target.selectionStart = target.selectionEnd = start;
                    onChange();
                }
                break;
        }
    }
    window.addEventListener('popstate', function () {
        var id = location.hash.substring(1) || 'index';
        showPage(id, 'instant', 'none');
    });
    function truncateCode(code) {
        var oneLiner = getLits().tokenize(code, { minify: true }).tokens.map(function (t) { return t[0] === 'Whitespace' ? ' ' : t[1]; }).join('').trim();
        var count = 100;
        if (oneLiner.length <= count)
            return oneLiner;
        else
            return "".concat(oneLiner.substring(0, count - 3), "...");
    }
    function run() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Run selection' : 'Run';
        appendOutput("".concat(title, ": ").concat(truncateCode(code)), 'comment');
        var litsParams = getLitsParamsFromContext();
        var hijacker = hijackConsole();
        try {
            var result = getLits().run(code, litsParams);
            var content = stringifyValue(result, false);
            appendOutput(content, 'result');
        }
        catch (error) {
            appendOutput(error, 'error');
        }
        finally {
            hijacker.releaseConsole();
            focusLitsCode();
        }
    }
    function analyze() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Analyze selection' : 'Analyze';
        appendOutput("".concat(title, ": ").concat(truncateCode(code)), 'comment');
        var litsParams = getLitsParamsFromContext();
        var hijacker = hijackConsole();
        try {
            var result = getLits('debug').getUndefinedSymbols(code, litsParams);
            var unresolvedSymbols = __spreadArray([], __read(result), false).join(', ');
            var unresolvedSymbolsOutput = "Unresolved symbols: ".concat(unresolvedSymbols || '-');
            appendOutput("".concat(unresolvedSymbolsOutput), 'analyze');
        }
        catch (error) {
            appendOutput(error, 'error');
        }
        finally {
            hijacker.releaseConsole();
            focusLitsCode();
        }
    }
    function parse() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Parse selection' : 'Parse';
        appendOutput("".concat(title).concat(getState('debug') ? ' (debug):' : ':', " ").concat(truncateCode(code)), 'comment');
        var hijacker = hijackConsole();
        try {
            var tokens = getLits().tokenize(code);
            var result = getLits().parse(tokens);
            var content = JSON.stringify(result, null, 2);
            appendOutput(content, 'parse');
            hijacker.releaseConsole();
            console.log(result);
        }
        catch (error) {
            appendOutput(error, 'error');
            hijacker.releaseConsole();
        }
        finally {
            focusLitsCode();
        }
    }
    function tokenize() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Tokenize selection' : 'Tokenize';
        appendOutput("".concat(title).concat(getState('debug') ? ' (debug):' : ':', " ").concat(truncateCode(code)), 'comment');
        var hijacker = hijackConsole();
        try {
            var result = getLits().tokenize(code);
            var content = JSON.stringify(result, null, 2);
            appendOutput(content, 'tokenize');
            hijacker.releaseConsole();
            console.log(result);
        }
        catch (error) {
            appendOutput(error, 'error');
            hijacker.releaseConsole();
            return;
        }
        finally {
            focusLitsCode();
        }
    }
    function format() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Format selection' : 'Format';
        appendOutput("".concat(title, ": ").concat(truncateCode(code)), 'comment');
        setLitsCode(code, true);
        if (selectedCode.code) {
            saveState({
                'focused-panel': 'lits-code',
                'lits-code-selection-start': selectedCode.selectionStart,
                'lits-code-selection-end': selectedCode.selectionStart + code.length,
            });
        }
        else {
            saveState({
                'focused-panel': 'lits-code',
                'lits-code-selection-start': selectedCode.selectionStart,
                'lits-code-selection-end': selectedCode.selectionEnd,
            });
        }
        applyState();
    }
    function toggleDebug() {
        var debug = !getState('debug');
        saveState({ debug: debug });
        updateCSS();
        addOutputSeparator();
        appendOutput("Debug mode toggled ".concat(debug ? 'ON' : 'OFF'), 'comment');
        focusLitsCode();
    }
    function focusContext() {
        elements.contextTextArea.focus();
    }
    function focusLitsCode() {
        elements.litsTextArea.focus();
    }
    function getLitsParamsFromContext() {
        var _a, _b;
        var contextString = getState('context');
        try {
            var parsedContext = contextString.trim().length > 0
                ? JSON.parse(contextString)
                : {};
            var parsedJsFunctions = asUnknownRecord((_a = parsedContext.jsFunctions) !== null && _a !== void 0 ? _a : {});
            var values = asUnknownRecord((_b = parsedContext.values) !== null && _b !== void 0 ? _b : {});
            var jsFunctions = Object.entries(parsedJsFunctions).reduce(function (acc, _a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                if (typeof value !== 'string') {
                    console.log(key, value);
                    throw new TypeError("Invalid jsFunction value. \"".concat(key, "\" should be a javascript function string"));
                }
                // eslint-disable-next-line no-eval
                var fn = eval(value);
                if (typeof fn !== 'function') {
                    throw new TypeError("Invalid jsFunction value. \"".concat(key, "\" should be a javascript function"));
                }
                acc[key] = {
                    fn: fn,
                };
                return acc;
            }, {});
            return {
                values: values,
                jsFunctions: jsFunctions,
            };
        }
        catch (err) {
            appendOutput("Error: ".concat(err.message, "\nCould not parse context:\n").concat(contextString), 'error');
            return {};
        }
    }
    function getSelectedLitsCode() {
        var selectionStart = getState('lits-code-selection-start');
        var selectionEnd = getState('lits-code-selection-end');
        return {
            leadingCode: elements.litsTextArea.value.substring(0, selectionStart),
            trailingCode: elements.litsTextArea.value.substring(selectionEnd),
            code: elements.litsTextArea.value.substring(selectionStart, selectionEnd),
            selectionStart: selectionStart,
            selectionEnd: selectionEnd,
        };
    }
    function applyState(scrollToTop) {
        if (scrollToTop === void 0) { scrollToTop = false; }
        var contextTextAreaSelectionStart = getState('context-selection-start');
        var contextTextAreaSelectionEnd = getState('context-selection-end');
        var litsTextAreaSelectionStart = getState('lits-code-selection-start');
        var litsTextAreaSelectionEnd = getState('lits-code-selection-end');
        setOutput(getState('output'), false);
        getDataFromUrl();
        setContext(getState('context'), false);
        elements.contextTextArea.selectionStart = contextTextAreaSelectionStart;
        elements.contextTextArea.selectionEnd = contextTextAreaSelectionEnd;
        setLitsCode(getState('lits-code'), false, scrollToTop ? 'top' : undefined);
        elements.litsTextArea.selectionStart = litsTextAreaSelectionStart;
        elements.litsTextArea.selectionEnd = litsTextAreaSelectionEnd;
        updateCSS();
        layout();
        setTimeout(function () {
            if (getState('focused-panel') === 'context')
                focusContext();
            else if (getState('focused-panel') === 'lits-code')
                focusLitsCode();
            elements.contextTextArea.scrollTop = getState('context-scroll-top');
            elements.litsTextArea.scrollTop = getState('lits-code-scroll-top');
            elements.outputResult.scrollTop = getState('output-scroll-top');
        }, 0);
    }
    function updateCSS() {
        var debug = getState('debug');
        elements.toggleDebugMenuLabel.textContent = debug ? 'Debug: ON' : 'Debug: OFF';
        elements.litsPanelDebugInfo.style.display = debug ? 'flex' : 'none';
        elements.litsCodeTitle.style.color = (getState('focused-panel') === 'lits-code') ? 'white' : '';
        elements.litsCodeTitleString.textContent = 'Lits Code';
        elements.contextTitle.style.color = (getState('focused-panel') === 'context') ? 'white' : '';
    }
    function showPage(id, scroll, historyEvent) {
        if (historyEvent === void 0) { historyEvent = 'push'; }
        setTimeout(function () {
            inactivateAll();
            Search.closeSearch();
            var page = document.getElementById(id);
            var linkElementId = "".concat((!id || id === 'index') ? 'home-page' : id, "_link");
            var link = document.getElementById(linkElementId);
            if (!id || id === 'index' || id === 'example-page')
                elements.mainPanel.scrollTo({ top: 0 });
            if (!page) {
                showPage('index', scroll, 'replace');
                return;
            }
            page.classList.add('active-content');
            if (link) {
                link.classList.add('active-sidebar-entry');
                if (scroll !== 'none')
                    link.scrollIntoView({ block: 'center', behavior: scroll });
            }
            if (id === 'index')
                history.replaceState(null, 'Lits', window.location.pathname + window.location.search);
            else if (historyEvent === 'replace')
                history.replaceState(null, '', "#".concat(id));
            else if (historyEvent !== 'none')
                history.pushState(null, '', "#".concat(id));
        }, 0);
    }
    function inactivateAll() {
        var els = document.getElementsByClassName('active-content');
        while (els[0])
            els[0].classList.remove('active-content');
        els = document.getElementsByClassName('active-sidebar-entry');
        while (els[0])
            els[0].classList.remove('active-sidebar-entry');
    }
    function addToPlayground(name, encodedExample) {
        var example = decodeURIComponent(atob(encodedExample));
        appendLitsCode("// Example - ".concat(name, "\n\n").concat(example, ";\n"));
        saveState({ 'focused-panel': 'lits-code' });
        applyState();
    }
    function setPlayground(name, encodedExample) {
        var example = JSON.parse(decodeURIComponent(atob(encodedExample)));
        var context = example.context
            // eslint-disable-next-line ts/no-unsafe-return
            ? JSON.stringify(example.context, function (_k, v) { return (v === undefined ? null : v); }, 2)
            : '';
        setContext(context, true, 'top');
        var code = example.code ? example.code : '';
        var size = Math.max(name.length + 10, 40);
        var paddingLeft = Math.floor((size - name.length) / 2);
        var paddingRight = Math.ceil((size - name.length) / 2);
        setLitsCode("\n".concat("/*".concat('*'.repeat(size), "**"), "\n").concat(" *".concat(' '.repeat(paddingLeft)).concat(name).concat(' '.repeat(paddingRight), " *"), "\n").concat(" *".concat('*'.repeat(size), "**/"), "\n\n").concat(code, "\n").trimStart(), true, 'top');
        saveState({ 'focused-panel': 'lits-code' });
        applyState();
    }
    function hijackConsole() {
        var oldLog = console.log;
        console.log = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var logRow = args.map(function (arg) { return stringifyValue(arg); }).join(' ');
            appendOutput(logRow, 'output');
        };
        var oldWarn = console.warn;
        console.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            oldWarn.apply(console, args);
            appendOutput(args[0], 'warn');
        };
        var oldError = console.error;
        console.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            oldError.apply(console, args);
            appendOutput(args[0], 'error');
        };
        return {
            releaseConsole: function () {
                console.log = oldLog;
                console.warn = oldWarn;
            },
        };
    }

    exports.Search = Search;
    exports.addContextEntry = addContextEntry;
    exports.addSampleContext = addSampleContext;
    exports.addToPlayground = addToPlayground;
    exports.analyze = analyze;
    exports.closeAddContextMenu = closeAddContextMenu;
    exports.closeMoreMenu = closeMoreMenu;
    exports.focusContext = focusContext;
    exports.focusLitsCode = focusLitsCode;
    exports.format = format;
    exports.openAddContextMenu = openAddContextMenu;
    exports.openMoreMenu = openMoreMenu;
    exports.parse = parse;
    exports.redoContextHistory = redoContextHistory;
    exports.redoLitsCodeHistory = redoLitsCodeHistory;
    exports.resetContext = resetContext;
    exports.resetLitsCode = resetLitsCode;
    exports.resetOutput = resetOutput;
    exports.resetPlayground = resetPlayground;
    exports.run = run;
    exports.setPlayground = setPlayground;
    exports.share = share;
    exports.showPage = showPage;
    exports.toggleDebug = toggleDebug;
    exports.toggleNamespaceCategory = toggleNamespaceCategory;
    exports.tokenize = tokenize;
    exports.undoContextHistory = undoContextHistory;
    exports.undoLitsCodeHistory = undoLitsCodeHistory;

    return exports;

})({});
