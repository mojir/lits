var Playground = (function (exports) {
    'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    var StateHistory = /** @class */ (function () {
        function StateHistory(initial, listener) {
            this.history = [];
            this.lastStatus = { canUndo: false, canRedo: false };
            this.history.push(initial);
            this.index = 0;
            this.listener = listener;
        }
        Object.defineProperty(StateHistory.prototype, "canUndo", {
            get: function () {
                return this.index > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StateHistory.prototype, "canRedo", {
            get: function () {
                return this.index < this.history.length - 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StateHistory.prototype, "current", {
            get: function () {
                return this.history[this.index];
            },
            enumerable: false,
            configurable: true
        });
        StateHistory.prototype.push = function (entry) {
            if (entry.text !== this.current.text) {
                this.history.splice(this.index + 1);
                this.history.push(entry);
                this.index = this.history.length - 1;
                this.notify();
            }
            else {
                this.replace(entry);
            }
        };
        StateHistory.prototype.replace = function (entry) {
            this.current.text = entry.text;
            this.current.selectionStart = entry.selectionStart;
            this.current.selectionEnd = entry.selectionEnd;
            this.notify();
        };
        StateHistory.prototype.undo = function () {
            if (!this.canUndo)
                throw new Error('Cannot undo');
            this.index -= 1;
            this.notify();
            return this.history[this.index];
        };
        StateHistory.prototype.redo = function () {
            if (!this.canRedo)
                throw new Error('Cannot redo');
            this.index += 1;
            this.notify();
            return this.current;
        };
        StateHistory.prototype.peek = function () {
            return this.current;
        };
        StateHistory.prototype.reset = function (initialState) {
            this.history = [initialState];
            this.index = 0;
            this.notify();
        };
        StateHistory.prototype.notify = function () {
            var _this = this;
            var status = { canUndo: this.canUndo, canRedo: this.canRedo };
            if (status.canUndo !== this.lastStatus.canUndo || status.canRedo !== this.lastStatus.canRedo) {
                this.lastStatus = status;
                setTimeout(function () { return _this.listener(status); }, 0);
            }
        };
        return StateHistory;
    }());

    var defaultState = {
        'playground-height': 350,
        'resize-divider-1-percent': 20,
        'resize-divider-2-percent': 60,
        'context': '',
        'context-scroll-top': 0,
        'context-selection-start': 0,
        'context-selection-end': 0,
        'lits-code': '',
        'lits-code-scroll-top': 0,
        'lits-code-selection-start': 0,
        'lits-code-selection-end': 0,
        'output': '',
        'output-scroll-top': 0,
        'new-context-name': '',
        'new-context-value': '',
        'debug': false,
        'focused-panel': null,
    };
    var contextHistoryListener;
    var litsCodeHistoryListener;
    var state = __assign({}, defaultState);
    Object.keys(defaultState).forEach(function (key) {
        var value = localStorage.getItem(getStorageKey(key));
        state[key] = typeof value === 'string' ? JSON.parse(value) : defaultState[key];
    });
    var contextHistory = new StateHistory(createContextHistoryEntry(), function (status) {
        contextHistoryListener === null || contextHistoryListener === void 0 ? void 0 : contextHistoryListener(status);
    });
    var litsCodeHistory = new StateHistory(createLitsCodeHistoryEntry(), function (status) {
        litsCodeHistoryListener === null || litsCodeHistoryListener === void 0 ? void 0 : litsCodeHistoryListener(status);
    });
    function createContextHistoryEntry() {
        return {
            text: state.context,
            selectionStart: state['context-selection-start'],
            selectionEnd: state['context-selection-end'],
        };
    }
    function createLitsCodeHistoryEntry() {
        return {
            text: state['lits-code'],
            selectionStart: state['lits-code-selection-start'],
            selectionEnd: state['lits-code-selection-end'],
        };
    }
    function pushHistory() {
        contextHistory.push(createContextHistoryEntry());
        litsCodeHistory.push(createLitsCodeHistoryEntry());
    }
    function setContextHistoryListener(listener) {
        contextHistoryListener = listener;
    }
    function setLitsCodeHistoryListener(listener) {
        litsCodeHistoryListener = listener;
    }
    function saveState(newState, pushToHistory) {
        if (pushToHistory === void 0) { pushToHistory = true; }
        Object.entries(newState).forEach(function (entry) {
            var key = entry[0];
            var value = entry[1];
            setState(key, value);
            localStorage.setItem(getStorageKey(key), JSON.stringify(value));
        });
        if (pushToHistory) {
            pushHistory();
        }
    }
    function setState(key, value) {
        state[key] = value;
    }
    function clearAllStates() {
        localStorage.clear();
        Object.assign(state, defaultState);
        litsCodeHistory.reset(createLitsCodeHistoryEntry());
        contextHistory.reset(createContextHistoryEntry());
    }
    function clearState() {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        keys.forEach(function (key) {
            localStorage.removeItem(getStorageKey(key));
            state[key] = defaultState[key];
        });
        pushHistory();
    }
    function getState(key) {
        return state[key];
    }
    function encodeState() {
        var sharedState = {
            'lits-code': state['lits-code'],
            'context': state.context,
        };
        return btoa(encodeURIComponent(JSON.stringify(sharedState)));
    }
    function applyEncodedState(encodedState) {
        try {
            saveState(JSON.parse(decodeURIComponent(atob(encodedState))), true);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    function undoContext() {
        try {
            var historyEntry = contextHistory.undo();
            saveState({
                'context': historyEntry.text,
                'context-selection-start': historyEntry.selectionStart,
                'context-selection-end': historyEntry.selectionEnd,
            }, false);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function redoContext() {
        try {
            var historyEntry = contextHistory.redo();
            saveState({
                'context': historyEntry.text,
                'context-selection-start': historyEntry.selectionStart,
                'context-selection-end': historyEntry.selectionEnd,
            }, false);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function undoLitsCode() {
        try {
            var historyEntry = litsCodeHistory.undo();
            saveState({
                'lits-code': historyEntry.text,
                'lits-code-selection-start': historyEntry.selectionStart,
                'lits-code-selection-end': historyEntry.selectionEnd,
            }, false);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function redoLitsCode() {
        try {
            var historyEntry = litsCodeHistory.redo();
            saveState({
                'lits-code': historyEntry.text,
                'lits-code-selection-start': historyEntry.selectionStart,
                'lits-code-selection-end': historyEntry.selectionEnd,
            }, false);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function getStorageKey(key) {
        return "playground-".concat(key);
    }

    function isNotNull(value) {
        return value !== null && value !== undefined;
    }
    function assertNotNull(value) {
        if (!isNotNull(value))
            throw new Error('Value is null or undefined');
    }
    function asNotNull(value) {
        assertNotNull(value);
        return value;
    }
    function throttle(func) {
        var openForBusiness = true;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (openForBusiness) {
                requestAnimationFrame(function () { return openForBusiness = true; });
                openForBusiness = false;
                func.apply(this, args);
            }
        };
    }
    function isMac() {
        return navigator.platform.includes('Mac');
    }

    var ctrlKeyTimer = 0;
    var ctrlKeyStarted = null;
    var selectedIndex = null;
    var onCloseCallback = null;
    var previouslyFocusedPanel = getState('focused-panel');
    var searchInput = asNotNull(document.getElementById('search-input'));
    var searchResult = asNotNull(document.getElementById('search-result'));
    var noSearchResult = asNotNull(document.getElementById('no-search-result'));
    var searchOverlay = asNotNull(document.getElementById('search-dialog-overlay'));
    var searchDialog = asNotNull(document.getElementById('search-dialog'));
    searchInput.addEventListener('input', onSearch);
    searchOverlay.addEventListener('click', closeSearch);
    searchDialog.addEventListener('click', function (event) {
        searchInput.focus();
        event.stopPropagation();
    });
    function onClose(callback) {
        onCloseCallback = callback;
    }
    function handleKeyDown(event) {
        var _a;
        if (event.key === 'Control')
            handleCtrlKey();
        if (isOpen()) {
            switch (event.key) {
                case 'Escape':
                    event.preventDefault();
                    if (selectedIndex !== null && selectedIndex > 0)
                        resetSelection();
                    else if (((_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('#search-input')) && searchInput.value)
                        clearSearch();
                    else
                        closeSearch();
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    selectNext();
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    selectPrevious();
                    break;
                case 'PageDown':
                    event.preventDefault();
                    selectPageDown();
                    break;
                case 'PageUp':
                    event.preventDefault();
                    selectPageUp();
                    break;
                case 'Home':
                    event.preventDefault();
                    selectFirst();
                    break;
                case 'End':
                    event.preventDefault();
                    selectLast();
                    break;
                case 'Enter':
                    event.preventDefault();
                    if (typeof selectedIndex === 'number') {
                        var x = searchResult.children[selectedIndex];
                        x === null || x === void 0 ? void 0 : x.click();
                    }
                    break;
                case 'k':
                case 'K':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        openSearch();
                    }
                    break;
                case 'F3':
                    event.preventDefault();
                    openSearch();
                    break;
            }
            return 'stop';
        }
        else {
            switch (event.key) {
                case 'k':
                case 'K':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        openSearch();
                    }
                    break;
                case 'F3':
                    event.preventDefault();
                    openSearch();
                    break;
            }
        }
    }
    function handleCtrlKey() {
        if (ctrlKeyStarted === null) {
            ctrlKeyStarted = Date.now();
            ctrlKeyTimer = window.setTimeout(resetCtrlKey, 400);
        }
        else {
            resetCtrlKey();
            if (isOpen())
                closeSearch();
            else
                openSearch();
        }
    }
    function resetCtrlKey() {
        window.clearTimeout(ctrlKeyTimer);
        ctrlKeyStarted = null;
        ctrlKeyTimer = 0;
    }
    function openSearch() {
        previouslyFocusedPanel = getState('focused-panel');
        searchOverlay.style.display = 'block';
        if (searchResult.children.length === 0)
            updateSearchResult(searchInput.value);
        searchInput.focus();
    }
    function closeSearch() {
        if (searchOverlay.style.display === 'block') {
            searchOverlay.style.display = 'none';
            saveState({ 'focused-panel': previouslyFocusedPanel });
            onCloseCallback === null || onCloseCallback === void 0 ? void 0 : onCloseCallback();
        }
    }
    function isOpen() {
        return searchOverlay.style.display === 'block';
    }
    function clearSearch() {
        searchInput.value = '';
        updateSearchResult('');
    }
    function resetSelection() {
        if (searchInput.value)
            selectedIndex = 0;
        else
            selectedIndex = null;
        updateSelection();
        searchResult.scrollTo(0, 0);
    }
    function updateSelection() {
        Array.from(searchResult.getElementsByClassName('selected'))
            .forEach(function (el) { return el.classList.remove('selected'); });
        if (selectedIndex !== null) {
            var count = searchResult.children.length;
            if (count) {
                if (selectedIndex >= count)
                    selectedIndex = count - 1;
                else if (selectedIndex < 0)
                    selectedIndex = 0;
                var element = searchResult.children[selectedIndex];
                element.classList.add('selected');
                element.scrollIntoView({ block: 'center' });
            }
            else {
                selectedIndex = null;
            }
        }
    }
    function selectPrevious() {
        if (selectedIndex !== null)
            selectedIndex -= 1;
        updateSelection();
    }
    function selectNext() {
        if (selectedIndex !== null)
            selectedIndex += 1;
        else
            selectedIndex = 0;
        updateSelection();
    }
    function selectPageUp() {
        if (selectedIndex !== null)
            selectedIndex -= 10;
        updateSelection();
    }
    function selectPageDown() {
        if (selectedIndex !== null)
            selectedIndex += 10;
        else
            selectedIndex = 10;
        updateSelection();
    }
    function selectFirst() {
        selectedIndex = 0;
        updateSelection();
    }
    function selectLast() {
        selectedIndex = searchResult.children.length - 1;
        updateSelection();
    }
    function onSearch(event) {
        var _a;
        var target = event.target;
        var searchString = (_a = target === null || target === void 0 ? void 0 : target.value) !== null && _a !== void 0 ? _a : '';
        updateSearchResult(searchString);
    }
    function updateSearchResult(searchString) {
        searchResult.style.display = 'none';
        noSearchResult.style.display = 'none';
        searchResult.innerHTML = '';
        // eslint-disable-next-line ts/no-unsafe-member-access
        var searchResults = window.Playground.allSearchResultEntries.filter(function (entry) { return entry.search.toLowerCase().includes(searchString.toLowerCase()); });
        if (searchResults.length === 0) {
            noSearchResult.style.display = 'flex';
        }
        else {
            searchResult.style.display = 'flex';
            searchResult.innerHTML = searchResults.map(function (entry) { return entry.html; }).join('');
        }
        resetSelection();
    }
    var Search = {
        openSearch: openSearch,
        closeSearch: closeSearch,
        clearSearch: clearSearch,
        handleKeyDown: handleKeyDown,
        onClose: onClose,
    };

    const defaultConfig = {
        spaceSeparation: false,
        precision: 8,
        epsilon: 1e-10,
    };
    const CONFIG = {
        spaceSeparation: false,
        precision: 8,
        epsilon: 1e-10,
    };
    function setConfig(newConfig) {
        CONFIG.spaceSeparation = newConfig.spaceSeparation ?? defaultConfig.spaceSeparation;
        CONFIG.precision = newConfig.precision ?? defaultConfig.precision;
        CONFIG.epsilon = newConfig.epsilon ?? defaultConfig.epsilon;
    }
    /**
     * Mathematical constants used for symbolic representation
     */
    const CONSTANTS = [
        { getSymbol: () => 'π', value: Math.PI },
        { getSymbol: () => 'e', value: Math.E },
        { getSymbol: () => 'φ', value: (1 + Math.sqrt(5)) / 2 },
        { getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? '√(2)' : '√2', value: Math.sqrt(2) },
        { getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? '√(3)' : '√3', value: Math.sqrt(3) },
        { getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? '√(5)' : '√5', value: Math.sqrt(5) },
        { getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? '√(7)' : '√7', value: Math.sqrt(7) },
        { getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? '√(11)' : '√11', value: Math.sqrt(11) },
        { getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? '√(13)' : '√13', value: Math.sqrt(13) },
        { getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? '√(17)' : '√17', value: Math.sqrt(17) },
        { getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? '√(19)' : '√19', value: Math.sqrt(19) },
        { getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? '√(π)' : '√π', value: Math.sqrt(Math.PI) },
        { getSymbol: () => 'ln(2)', value: Math.LN2 },
        { getSymbol: () => 'ln(10)', value: Math.LN10 },
        { getSymbol: () => 'log₂(e)', value: Math.LOG2E },
        { getSymbol: () => 'log₁₀(e)', value: Math.LOG10E },
    ];
    /**
     * Trigonometric values with their exact symbolic representations
     */
    const TRIG_VALUES = [
        // sin values
        { value: Math.sin(Math.PI / 6), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'sin(π / 6)' : 'sin(π/6)', getExactForm: () => CONFIG.spaceSeparation ? '1 / 2' : '1/2' },
        { value: Math.sin(Math.PI / 4), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'sin(π / 4)' : 'sin(π/4)', getExactForm: () => CONFIG.spaceSeparation ? '√2 / 2' : '√2/2' },
        { value: Math.sin(Math.PI / 3), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'sin(π / 3)' : 'sin(π/3)', getExactForm: () => CONFIG.spaceSeparation ? '√3 / 2' : '√3/2' },
        { value: Math.sin(Math.PI / 2), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'sin(π / 2)' : 'sin(π/2)', getExactForm: () => '1' },
        // cos values
        { value: Math.cos(0), getSymbol: () => 'cos(0)', getExactForm: () => '1' },
        { value: Math.cos(Math.PI / 6), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'cos(π / 6)' : 'cos(π/6)', getExactForm: () => CONFIG.spaceSeparation ? '√(3) / 2' : '√3/2' },
        { value: Math.cos(Math.PI / 4), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'cos(π / 4)' : 'cos(π/4)', getExactForm: () => CONFIG.spaceSeparation ? '√(2) / 2' : '√2/2' },
        { value: Math.cos(Math.PI / 3), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'cos(π / 3)' : 'cos(π/3)', getExactForm: () => CONFIG.spaceSeparation ? '1 / 2' : '1/2' },
        { value: Math.cos(Math.PI / 2), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'cos(π / 2)' : 'cos(π/2)', getExactForm: () => '0' },
        // tan values
        { value: Math.tan(Math.PI / 6), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'tan(π / 6)' : 'tan(π/6)', getExactForm: () => CONFIG.spaceSeparation ? '1 / √(3)' : '1/√3' },
        { value: Math.tan(Math.PI / 4), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'tan(π / 4)' : 'tan(π/4)', getExactForm: () => '1' },
        { value: Math.tan(Math.PI / 3), getSymbol: noSpaceSeparation => CONFIG.spaceSeparation && !noSpaceSeparation ? 'tan(π / 3)' : 'tan(π/3)', getExactForm: () => CONFIG.spaceSeparation ? '√(3)' : '√3' },
    ];

    /**
     * Factorizes a number under a radical to extract perfect square factors
     * @param n The number to factorize
     * @returns Object containing the coefficient and remaining radicand
     */
    function factorizeRadicand(n) {
        // Find largest perfect square factor
        let coefficient = 1;
        let i = 2;
        while (i * i <= n) {
            // Check if i² is a factor of n
            if (n % (i * i) === 0) {
                coefficient *= i;
                n /= (i * i);
                // Continue with the same i to check for multiple powers
                continue;
            }
            i++;
        }
        return { coefficient, radicand: n };
    }
    /**
     * Finds the greatest common divisor of two numbers
     * @param a First number
     * @param b Second number
     * @returns The GCD of a and b
     */
    function findGCD(a, b) {
        a = Math.abs(a);
        b = Math.abs(b);
        while (b !== 0) {
            const temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    /**
     * Checks if a number is prime
     * @param n The number to check
     * @returns True if n is prime, false otherwise
     */
    function isPrime$1(n) {
        if (n <= 1)
            return false;
        if (n <= 3)
            return true;
        if (n % 2 === 0 || n % 3 === 0)
            return false;
        let i = 5;
        while (i * i <= n) {
            if (n % i === 0 || n % (i + 2) === 0)
                return false;
            i += 6;
        }
        return true;
    }
    /**
     * Determines if a number's square root should be preserved in direct form
     * @param n The number to check
     * @returns True if the square root should be kept in direct form
     */
    function shouldPreserveDirectRadical(n) {
        // Always preserve direct form for prime numbers
        if (isPrime$1(n))
            return true;
        // Always preserve direct form for small integers
        if (n <= 30)
            return true;
        // Check if n has any perfect square factors
        const factorized = factorizeRadicand(n);
        // If no perfect square factors were found, preserve direct form
        return factorized.coefficient === 1;
    }

    function isNumberNode(node) {
        return node.type === 'Number';
    }
    function isUnaryOpNode(node) {
        return node.type === 'UnaryOp';
    }
    function isBinaryOpNode(node) {
        return node.type === 'BinaryOp';
    }
    function isRootNode(node) {
        return node.type === 'Root';
    }
    function isConstantNode(node) {
        return node.type === 'Constant';
    }
    function isPowerNode(node) {
        return node.type === 'Power';
    }

    /**
     * Helper function to determine expression type priority for ordering
     * @returns A priority number (lower number = higher priority)
     */
    function getExpressionPriority(node) {
        // Priority order: Number < Root/Power < Constant < Other
        if (isNumberNode(node))
            return 1;
        if (isRootNode(node))
            return 2;
        // Handle other node types here
        return 6; // Default for other types
    }
    /**
     * Determines if two expressions should be swapped in multiplication
     * @returns true if expressions should be swapped
     */
    function shouldSwapInMultiplication(left, right) {
        const leftPriority = getExpressionPriority(left);
        const rightPriority = getExpressionPriority(right);
        // Lower priority number should come first
        return leftPriority > rightPriority;
    }

    /**
     * Base abstract class for all expression nodes
     */
    class ExprNode {
    }

    /**
     * Checks if a node represents exactly zero within epsilon tolerance
     */
    function isZero(node) {
        return isNumberNode(node) && Math.abs(node.evaluate()) < 1e-10;
    }
    /**
     * Checks if a node represents exactly one within epsilon tolerance
     */
    function isOne(node) {
        return isNumberNode(node) && Math.abs(node.evaluate() - 1) < 1e-10;
    }
    /**
     * Node for numeric constants (integers, simple fractions, etc.)
     */
    class NumberNode extends ExprNode {
        constructor(value) {
            super();
            Object.defineProperty(this, "value", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: value
            });
            Object.defineProperty(this, "type", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'Number'
            });
        }
        evaluate() {
            return this.value;
        }
        toString() {
            // Round values extremely close to zero to exactly zero
            if (Math.abs(this.value) < CONFIG.epsilon) {
                return "0";
            }
            if (this.value === Number.POSITIVE_INFINITY) {
                return "∞";
            }
            if (this.value === Number.NEGATIVE_INFINITY) {
                return "-∞";
            }
            if (Number.isInteger(this.value)) {
                return this.value.toString();
            }
            // Handle fractions if it's a "nice" fraction
            const MAX_DENOMINATOR = 1000;
            for (let denominator = 2; denominator <= MAX_DENOMINATOR; denominator++) {
                const numerator = Math.round(this.value * denominator);
                if (Math.abs(this.value - numerator / denominator) < CONFIG.epsilon) {
                    const gcd = findGCD(Math.abs(numerator), denominator);
                    return CONFIG.spaceSeparation ? `${numerator / gcd} / ${denominator / gcd}` : `${numerator / gcd}/${denominator / gcd}`;
                }
            }
            // Just return the decimal representation
            const valueStr = this.value.toString();
            if (valueStr.includes('.')) {
                const [, decimalPart] = valueStr.split('.');
                if (decimalPart.length > 8) {
                    return this.value.toFixed(CONFIG.precision);
                }
            }
            return this.value.toString();
        }
        simplify() {
            return this; // Numbers are already in simplest form
        }
        equals(other) {
            if (!(isNumberNode(other)))
                return false;
            return Math.abs(this.value - other.evaluate()) < CONFIG.epsilon;
        }
    }

    /**
     * Node for binary operations (+, -, *, /)
     */
    class BinaryOpNode extends ExprNode {
        constructor(op, left, right) {
            super();
            Object.defineProperty(this, "op", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: op
            });
            Object.defineProperty(this, "left", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: left
            });
            Object.defineProperty(this, "right", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: right
            });
            Object.defineProperty(this, "type", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'BinaryOp'
            });
            // Apply automatic ordering for multiplication operations
            if (this.op === '*' && shouldSwapInMultiplication(left, right)) {
                // Swap the operands if they're in the wrong order
                this.left = right;
                this.right = left;
            }
        }
        evaluate() {
            const leftVal = this.left.evaluate();
            const rightVal = this.right.evaluate();
            switch (this.op) {
                case '+': return leftVal + rightVal;
                case '-': return leftVal - rightVal;
                case '*': return leftVal * rightVal;
                case '/': return leftVal / rightVal;
            }
        }
        toString() {
            let leftStr = this.left.toString();
            let rightStr = this.right.toString();
            // Add parentheses if needed
            if ((this.op === '+' || this.op === '-')
                && (isBinaryOpNode(this.left) && (this.left.getOp() === '+' || this.left.getOp() === '-'))) {
                leftStr = `(${leftStr})`;
            }
            else if ((this.op === '+' || this.op === '-')
                && (isBinaryOpNode(this.right) && (this.right.getOp() === '+' || this.right.getOp() === '-'))) {
                rightStr = `(${rightStr})`;
            }
            if (this.op === '*') {
                // Double-check order at display time
                if (shouldSwapInMultiplication(this.left, this.right)) {
                    return CONFIG.spaceSeparation
                        ? `${this.right.toString()} · ${this.left.toString()}`
                        : `${this.right.toString()}·${this.left.toString()}`;
                }
                return CONFIG.spaceSeparation
                    ? `${this.left.toString()} · ${this.right.toString()}`
                    : `${this.left.toString()}·${this.right.toString()}`;
            }
            else {
                return CONFIG.spaceSeparation
                    ? `${leftStr} ${this.op} ${rightStr}`
                    : `${leftStr}${this.op}${rightStr}`;
            }
        }
        getOp() {
            return this.op;
        }
        getLeft() {
            return this.left;
        }
        getRight() {
            return this.right;
        }
        simplify() {
            // First simplify both children
            const left = this.left.simplify();
            const right = this.right.simplify();
            // If both are numbers, perform the operation
            if (isNumberNode(left) && isNumberNode(right)) {
                return new NumberNode(this.evaluate());
            }
            // Simplification rules for addition
            if (this.op === '+') {
                // a + 0 = a
                if (isNumberNode(right) && right.evaluate() === 0) {
                    return left;
                }
                // 0 + a = a
                if (isNumberNode(left) && left.evaluate() === 0) {
                    return right;
                }
            }
            // Simplification rules for subtraction
            if (this.op === '-') {
                // a - 0 = a
                if (isNumberNode(right) && right.evaluate() === 0) {
                    return left;
                }
                // 0 - a = -a
                if (isNumberNode(left) && left.evaluate() === 0) {
                    return new UnaryOpNode('-', right);
                }
                // a - a = 0
                if (left.equals(right)) {
                    return new NumberNode(0);
                }
            }
            // Simplification rules for multiplication
            if (this.op === '*') {
                // a * 0 = 0
                if (isZero(left) || isZero(right)) {
                    return new NumberNode(0);
                }
                // a * 1 = a
                if (isOne(right)) {
                    return left;
                }
                // 1 * a = a
                if (isOne(left)) {
                    return right;
                }
                // Special case for n·√m/2 (12·√3/2 case)
                if (isNumberNode(left)
                    && isBinaryOpNode(right)
                    && right.getOp() === '/'
                    && isNumberNode(right.getRight())
                    && right.getRight().evaluate() === 2
                    && isRootNode(right.getLeft())) {
                    const n = left.evaluate();
                    const rootNode = right.getLeft();
                    return new BinaryOpNode('*', new NumberNode(n / 2), rootNode);
                }
                // Handle multiplications with fractions
                if (isBinaryOpNode(left) && left.getOp() === '/') {
                    // (a/b) * c = (a*c)/b
                    const fraction = left;
                    const numerator = fraction.getLeft();
                    const denominator = fraction.getRight();
                    return new BinaryOpNode('/', new BinaryOpNode('*', numerator, right), denominator).simplify();
                }
                if (isBinaryOpNode(right) && right.getOp() === '/') {
                    // c * (a/b) = (c*a)/b
                    const fraction = right;
                    const numerator = fraction.getLeft();
                    const denominator = fraction.getRight();
                    return new BinaryOpNode('/', new BinaryOpNode('*', left, numerator), denominator).simplify();
                }
                // Multiple numeric factors: (2·3)·π = 6·π
                if (isNumberNode(left)
                    && isBinaryOpNode(right)
                    && right.getOp() === '*'
                    && isNumberNode(right.getLeft())) {
                    const n1 = left.evaluate();
                    const n2 = (right).getLeft().evaluate();
                    const restTerm = right.getRight();
                    return new BinaryOpNode('*', new NumberNode(n1 * n2), restTerm).simplify();
                }
                // Consolidate products of square roots: √a·√b = √(a·b)
                if (isRootNode(left) && isRootNode(right)) {
                    const leftOperand = getRootOperand(left);
                    const rightOperand = getRootOperand(right);
                    // Create √(a·b) instead of √a·√b
                    if (isNumberNode(leftOperand) && isNumberNode(rightOperand)) {
                        const newRadicand = leftOperand.evaluate() * rightOperand.evaluate();
                        return new RootNode(new NumberNode(newRadicand)).simplify();
                    }
                }
            }
            // Simplification rules for division
            if (this.op === '/') {
                // 0 / a = 0
                if (isZero(left)) {
                    return new NumberNode(0);
                }
                // a / 1 = a
                if (isOne(right)) {
                    return left;
                }
                // a / a = 1
                if (left.equals(right)) {
                    return new NumberNode(1);
                }
                // Simplify numeric fractions
                if (isNumberNode(left) && isNumberNode(right)) {
                    const num = left.evaluate();
                    const denom = right.evaluate();
                    if (Number.isInteger(num) && Number.isInteger(denom)) {
                        const gcd = findGCD(Math.abs(num), Math.abs(denom));
                        if (gcd > 1) {
                            return new BinaryOpNode('/', new NumberNode(num / gcd), new NumberNode(denom / gcd));
                        }
                    }
                }
                // (a*b) / b = a
                if (isBinaryOpNode(left) && left.getOp() === '*') {
                    const product = left;
                    // Case for n·something / n = something (6·√3/6 = √3)
                    if (isNumberNode(product.getLeft())
                        && isNumberNode(right)
                        && Math.abs(product.getLeft().evaluate() - right.evaluate()) < 1e-10) {
                        return product.getRight();
                    }
                    if (isNumberNode(product.getRight())
                        && isNumberNode(right)
                        && Math.abs(product.getRight().evaluate() - right.evaluate()) < 1e-10) {
                        return product.getLeft();
                    }
                    // General case
                    if (product.getLeft().equals(right)) {
                        return product.getRight();
                    }
                    if (product.getRight().equals(right)) {
                        return product.getLeft();
                    }
                }
            }
            // If no simplification rules apply, return a new node with simplified children
            return new BinaryOpNode(this.op, left, right);
        }
        equals(other) {
            if (!(isBinaryOpNode(other)))
                return false;
            const otherOp = other;
            return this.op === otherOp.getOp()
                && this.left.equals(otherOp.getLeft())
                && this.right.equals(otherOp.getRight());
        }
    }
    /**
     * Extracts the radicand from a square root expression
     */
    function getRootOperand(node) {
        if (isRootNode(node)) {
            return node.getOperand();
        }
        if (isUnaryOpNode(node) && node.getOp() === 'sqrt') {
            return node.getOperand();
        }
        throw new Error('Not a root node');
    }
    /**
     * Checks if a node represents a square root expression
     */
    function isRootLikeNode(node) {
        return isRootNode(node)
            || (isUnaryOpNode(node) && node.getOp() === 'sqrt');
    }
    /**
     * Specialized node for square roots for nicer formatting
     */
    class RootNode extends ExprNode {
        constructor(operand) {
            super();
            Object.defineProperty(this, "operand", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: operand
            });
            Object.defineProperty(this, "type", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'Root'
            });
        }
        evaluate() {
            return Math.sqrt(this.operand.evaluate());
        }
        toString() {
            if (CONFIG.spaceSeparation) {
                const operandStr = this.operand.toString();
                if (!isNumberNode(this.operand) || operandStr.includes('/')) {
                    return `√(${operandStr})`;
                }
                else {
                    return `√${operandStr}`;
                }
            }
            else {
                return `√${this.operand.toString()}`;
            }
        }
        simplify() {
            const operand = this.operand.simplify();
            // Simplify sqrt of perfect squares
            if (isNumberNode(operand)) {
                const val = operand.evaluate();
                const sqrtVal = Math.sqrt(val);
                // If it's a perfect square, return the number
                if (Number.isInteger(sqrtVal)) {
                    return new NumberNode(sqrtVal);
                }
                // Otherwise, check if we can simplify the radicand
                const factorized = factorizeRadicand(val);
                if (factorized.coefficient > 1) {
                    // If there's a perfect square factor, extract it
                    return new BinaryOpNode('*', new NumberNode(factorized.coefficient), new RootNode(new NumberNode(factorized.radicand)));
                }
            }
            // Handle product of radicands under a root
            if (isBinaryOpNode(operand) && operand.getOp() === '*') {
                const left = operand.getLeft();
                const right = operand.getRight();
                // We can't simplify if they aren't both numbers
                if (isNumberNode(left) && isNumberNode(right)) {
                    const leftVal = left.evaluate();
                    const rightVal = right.evaluate();
                    // Try to factorize the product
                    const factorized = factorizeRadicand(leftVal * rightVal);
                    if (factorized.coefficient > 1) {
                        // If there's a perfect square factor, extract it
                        return new BinaryOpNode('*', new NumberNode(factorized.coefficient), new RootNode(new NumberNode(factorized.radicand))).simplify();
                    }
                }
            }
            return new RootNode(operand);
        }
        getOperand() {
            return this.operand;
        }
        equals(other) {
            if (!(isRootLikeNode(other)))
                return false;
            return this.operand.equals(other.getOperand());
        }
    }
    /**
     * Specialized node for power expressions
     */
    class PowerNode extends ExprNode {
        constructor(base, exponent) {
            super();
            Object.defineProperty(this, "base", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: base
            });
            Object.defineProperty(this, "exponent", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: exponent
            });
            Object.defineProperty(this, "type", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'Power'
            });
        }
        evaluate() {
            return this.base.evaluate() ** this.exponent.evaluate();
        }
        toString() {
            const baseStr = this.base.toString();
            const expVal = this.exponent.evaluate();
            // Use superscript for powers 2 and 3
            if (expVal === 2)
                return `${baseStr}²`;
            if (expVal === 3)
                return `${baseStr}³`;
            return CONFIG.spaceSeparation ? `${baseStr} ^ ${this.exponent.toString()}` : `${baseStr}^${this.exponent.toString()}`;
        }
        simplify() {
            const base = this.base.simplify();
            const exponent = this.exponent.simplify();
            // Anything to the power of 0 is 1
            if (isNumberNode(exponent) && exponent.evaluate() === 0) {
                return new NumberNode(1);
            }
            // Anything to the power of 1 is itself
            if (isNumberNode(exponent) && exponent.evaluate() === 1) {
                return base;
            }
            // 0 to any positive power is 0
            if (isNumberNode(base) && base.evaluate() === 0
                && isNumberNode(exponent) && exponent.evaluate() > 0) {
                return new NumberNode(0);
            }
            // 1 to any power is 1
            if (isNumberNode(base) && base.evaluate() === 1) {
                return new NumberNode(1);
            }
            // If both are numbers, compute the power
            if (isNumberNode(base) && isNumberNode(exponent)) {
                return new NumberNode(base.evaluate() ** exponent.evaluate());
            }
            return new PowerNode(base, exponent);
        }
        equals(other) {
            if (!(isPowerNode(other)))
                return false;
            const otherPower = other;
            return this.base.equals(otherPower.base)
                && this.exponent.equals(otherPower.exponent);
        }
        getBase() {
            return this.base;
        }
        getExponent() {
            return this.exponent;
        }
    }
    /**
     * Node for unary operations (-, sqrt, cbrt, etc.)
     */
    class UnaryOpNode extends ExprNode {
        constructor(op, operand) {
            super();
            Object.defineProperty(this, "op", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: op
            });
            Object.defineProperty(this, "operand", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: operand
            });
            Object.defineProperty(this, "type", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UnaryOp'
            });
        }
        evaluate() {
            const val = this.operand.evaluate();
            switch (this.op) {
                case '-': return -val;
                case 'sqrt': return Math.sqrt(val);
                case 'cbrt': return Math.cbrt(val);
            }
        }
        toString() {
            const operandStr = this.operand.toString();
            if (operandStr === '0') {
                return '0';
            }
            switch (this.op) {
                case '-': return CONFIG.spaceSeparation && (!isNumberNode(this.operand) || operandStr.includes('/')) ? `-(${operandStr})` : `-${operandStr}`;
                case 'sqrt': return CONFIG.spaceSeparation ? `√(${operandStr})` : `√${operandStr}`;
                case 'cbrt': return CONFIG.spaceSeparation ? `∛(${operandStr})` : `∛${operandStr}`;
            }
        }
        simplify() {
            const operand = this.operand.simplify();
            // Double negation: --a = a
            if (this.op === '-' && isUnaryOpNode(operand)
                && operand.getOp() === '-') {
                return operand.getOperand();
            }
            // Simplify sqrt of perfect squares
            if (this.op === 'sqrt' && isNumberNode(operand)) {
                const val = operand.evaluate();
                const sqrtVal = Math.sqrt(val);
                if (Number.isInteger(sqrtVal)) {
                    return new NumberNode(sqrtVal);
                }
            }
            // Simplify cbrt of perfect cubes
            if (this.op === 'cbrt' && isNumberNode(operand)) {
                const val = operand.evaluate();
                const cbrtVal = Math.cbrt(val);
                if (Number.isInteger(cbrtVal)) {
                    return new NumberNode(cbrtVal);
                }
            }
            return new UnaryOpNode(this.op, operand);
        }
        getOp() {
            return this.op;
        }
        getOperand() {
            return this.operand;
        }
        equals(other) {
            if (!(isUnaryOpNode(other)))
                return false;
            const otherOp = other;
            return this.op === otherOp.getOp()
                && this.operand.equals(otherOp.getOperand());
        }
    }

    /**
     * Node for mathematical constants (π, e, etc.)
     */
    class ConstantNode extends ExprNode {
        constructor(symbol, value) {
            super();
            Object.defineProperty(this, "symbol", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: symbol
            });
            Object.defineProperty(this, "value", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: value
            });
            Object.defineProperty(this, "type", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'Constant'
            });
        }
        evaluate() {
            return this.value;
        }
        toString() {
            return this.symbol;
        }
        simplify() {
            return this; // Constants are already in simplest form
        }
        equals(other) {
            if (!(isConstantNode(other)))
                return false;
            return this.symbol === other.symbol;
        }
        getSymbol() {
            return this.symbol;
        }
    }

    /**
     * Converts a number to its continued fraction representation
     * @param x The number to convert
     * @param maxTerms Maximum number of terms to compute
     * @returns Array of continued fraction terms [a0, a1, a2, ...]
     */
    function toContinuedFraction(x, maxTerms = 20) {
        const terms = [];
        for (let i = 0; i < maxTerms; i++) {
            const a = Math.floor(x);
            terms.push(a);
            // If we've reached a very small remainder, we're done
            if (Math.abs(x - a) < CONFIG.epsilon) {
                break;
            }
            // Prevent division by zero and avoid floating point issues
            const remainder = x - a;
            if (Math.abs(remainder) < CONFIG.epsilon) {
                break;
            }
            x = 1 / remainder;
        }
        return terms;
    }
    /**
     * Converts continued fraction terms to a fraction [numerator, denominator]
     * @param terms Array of continued fraction terms
     * @returns [numerator, denominator]
     */
    function fromContinuedFraction(terms) {
        if (terms.length === 0)
            return [0, 1];
        if (terms.length === 1)
            return [terms[0], 1];
        // Start with the last term
        let numerator = terms[terms.length - 1];
        let denominator = 1;
        // Work backwards through the terms
        for (let i = terms.length - 2; i >= 0; i--) {
            // For each term, compute the new fraction 
            // a_i + 1/previous
            const newNumerator = terms[i] * numerator + denominator;
            const newDenominator = numerator;
            // Update for next iteration
            numerator = newNumerator;
            denominator = newDenominator;
        }
        return [numerator, denominator];
    }
    /**
     * Generates all convergents (approximations) from continued fraction terms
     * @param terms Array of continued fraction terms
     * @returns Array of [numerator, denominator] pairs
     */
    function getConvergents(terms) {
        const convergents = [];
        for (let i = 1; i <= terms.length; i++) {
            convergents.push(fromContinuedFraction(terms.slice(0, i)));
        }
        return convergents;
    }
    /**
     * Tries to identify if a number is a simple quadratic irrational
     * @param x The number to check
     * @returns The identified form or null if not recognized
     */
    function identifyQuadraticIrrational(x) {
        // Direct checks for common values
        // Check for square roots of integers
        for (let n = 2; n <= 20; n++) {
            if (Math.abs(x - Math.sqrt(n)) < CONFIG.epsilon) {
                return `√${n}`;
            }
        }
        // Check for golden ratio and its conjugate
        if (Math.abs(x - (1 + Math.sqrt(5)) / 2) < CONFIG.epsilon) {
            return "φ"; // Already defined as a constant
        }
        if (Math.abs(x - (Math.sqrt(5) - 1) / 2) < CONFIG.epsilon) {
            return "(√5-1)/2";
        }
        // Check for expressions of form (√n ± m)/k where n, m, k are small integers
        for (let n = 2; n <= 30; n++) {
            const sqrtN = Math.sqrt(n);
            for (let m = 1; m <= 10; m++) {
                for (let k = 2; k <= 10; k++) {
                    // Check (√n + m)/k
                    if (Math.abs(x - (sqrtN + m) / k) < CONFIG.epsilon) {
                        if (m === 1 && k === 2) {
                            return `(√${n}+1)/2`;
                        }
                        else {
                            return `(√${n}+${m})/${k}`;
                        }
                    }
                    // Check (√n - m)/k
                    if (Math.abs(x - (sqrtN - m) / k) < CONFIG.epsilon) {
                        if (m === 1 && k === 2) {
                            return `(√${n}-1)/2`;
                        }
                        else {
                            return `(√${n}-${m})/${k}`;
                        }
                    }
                }
            }
        }
        // Get continued fraction for pattern analysis
        const terms = toContinuedFraction(x, 30);
        // Analyze the continued fraction for periodic patterns
        const period = detectPeriod(terms);
        if (period) {
            // For purely periodic CFs (√D): [a0; a1, a2, ..., aN, a1, a2, ...]
            // where a0 = floor(√D) and the sequence after a0 is periodic
            // For √2: [1; 2, 2, 2, ...]
            if (period.length === 1 && period[0] === 2 && terms[0] === 1) {
                return "√2";
            }
            // For √3: [1; 1, 2, 1, 2, ...]
            if (period.length === 2 && period[0] === 1 && period[1] === 2 && terms[0] === 1) {
                return "√3";
            }
            // For √5: [2; 4, 4, 4, ...]
            if (period.length === 1 && period[0] === 4 && terms[0] === 2) {
                return "√5";
            }
            // For √6: [2; 2, 4, 2, 4, ...] 
            if (period.length === 2 && period[0] === 2 && period[1] === 4 && terms[0] === 2) {
                return "√6";
            }
            // For √7: [2; 1, 1, 1, 4, 1, 1, 1, 4, ...] 
            if (period.length === 4 &&
                period[0] === 1 && period[1] === 1 &&
                period[2] === 1 && period[3] === 4 &&
                terms[0] === 2) {
                return "√7";
            }
            // For √8: [2; 1, 4, 1, 4, ...]
            if (period.length === 2 && period[0] === 1 && period[1] === 4 && terms[0] === 2) {
                return "√8";
            }
            // Try to reconstruct the quadratic form from the pattern
            // (Complex algorithm that would determine D from periodic CF)
            const D = reconstructD(terms[0], period);
            if (D > 0 && Math.abs(x - Math.sqrt(D)) < CONFIG.epsilon) {
                return `√${D}`;
            }
        }
        return null; // Could not identify
    }
    // Helper function to detect periodic patterns in continued fractions
    function detectPeriod(terms) {
        // Need at least a few terms to detect patterns
        if (terms.length < 6)
            return null;
        // Check for single repeating digit (like √2 = [1; 2, 2, 2, ...])
        const allSameAfterFirst = terms.slice(1).every(t => t === terms[1]);
        if (allSameAfterFirst) {
            return [terms[1]];
        }
        // For period of length 2
        const periodLength2 = terms.slice(1, 3).every((val, idx) => {
            for (let i = 1; i < Math.floor((terms.length - 1) / 2); i++) {
                if (terms[1 + idx + 2 * i] !== val)
                    return false;
            }
            return true;
        });
        if (periodLength2) {
            return terms.slice(1, 3);
        }
        // For period of length 4
        if (terms.length >= 9) {
            const periodLength4 = terms.slice(1, 5).every((val, idx) => {
                return terms[1 + idx + 4] === val && (terms.length >= 13 ? terms[1 + idx + 8] === val : true);
            });
            if (periodLength4) {
                return terms.slice(1, 5);
            }
        }
        // Could add more pattern detection logic here
        return null;
    }
    // Helper function to reconstruct D from continued fraction pattern
    function reconstructD(a0, period) {
        // Simple cases
        if (period.length === 1 && period[0] === 2)
            return 2;
        if (period.length === 2 && period[0] === 1 && period[1] === 2)
            return 3;
        if (period.length === 1 && period[0] === 4)
            return 5;
        if (period.length === 2 && period[0] === 2 && period[1] === 4)
            return 6;
        if (period.length === 4 &&
            period[0] === 1 && period[1] === 1 &&
            period[2] === 1 && period[3] === 4)
            return 7;
        if (period.length === 2 && period[0] === 1 && period[1] === 4)
            return 8;
        // For purely periodic CFs, D = a0² + P where P depends on the period
        // This is a simplified heuristic approach
        if (period.length === 1) {
            // If period has form [n], then D ≈ a0² + 1/n
            return Math.round(a0 * a0 + 1 / period[0]);
        }
        // Generalized approach for reconstructing D would be more complex
        // and would involve solving the Pell equation
        return -1; // Couldn't determine D
    }

    /**
     * Parser to convert numeric values to expression trees
     */
    class ExpressionParser {
        /**
         * Main parsing function that converts a number to an expression tree
         */
        parseNumber(num, depth = 0) {
            const MAX_DEPTH = 3;
            // Handle zero
            if (Math.abs(num) < CONFIG.epsilon) {
                return new NumberNode(0);
            }
            // Handle negative numbers
            if (num < 0) {
                return new UnaryOpNode('-', this.parseNumber(-num, depth));
            }
            // Handle integers
            if (Math.abs(num - Math.round(num)) < CONFIG.epsilon) {
                return new NumberNode(Math.round(num));
            }
            const cfTerms = toContinuedFraction(num, 20);
            const convergents = getConvergents(cfTerms);
            for (const [numerator, denominator] of convergents) {
                // Only consider fractions with reasonably-sized components
                if (denominator <= 1000 && Math.abs(numerator) <= 10000) {
                    // Verify the approximation is within our epsilon
                    if (Math.abs(num - numerator / denominator) < CONFIG.epsilon) {
                        const gcd = this.findGCD(Math.abs(numerator), denominator);
                        return new BinaryOpNode('/', new NumberNode(numerator / gcd), new NumberNode(denominator / gcd));
                    }
                }
            }
            // Try direct matches to constants
            for (const constant of CONSTANTS) {
                if (Math.abs(num - constant.value) < CONFIG.epsilon) {
                    return new ConstantNode(constant.getSymbol(), constant.value);
                }
            }
            // Try direct matches to trig values
            for (const trigValue of TRIG_VALUES) {
                if (Math.abs(num - trigValue.value) < CONFIG.epsilon) {
                    // If it has an exact form, parse that instead
                    if (trigValue.getExactForm) {
                        return this.parseExactForm(trigValue.getExactForm());
                    }
                    return new ConstantNode(trigValue.getSymbol(), trigValue.value);
                }
            }
            const quadraticForm = identifyQuadraticIrrational(num);
            if (quadraticForm) {
                // If we identified something like "√7" or "(√13-3)/2"
                return this.parseExactForm(quadraticForm);
            }
            // Direct check for square roots before other decompositions
            // This ensures square roots of integers are handled directly
            for (let i = 2; i <= 100; i++) {
                if (Math.abs(num - Math.sqrt(i)) < CONFIG.epsilon) {
                    // Use our enhanced check to determine if we should keep direct form
                    if (shouldPreserveDirectRadical(i)) {
                        return new RootNode(new NumberNode(i));
                    }
                    // Only factorize if appropriate
                    const factorized = factorizeRadicand(i);
                    if (factorized.coefficient > 1) {
                        return new BinaryOpNode('*', new NumberNode(factorized.coefficient), new RootNode(new NumberNode(factorized.radicand)));
                    }
                    // Default to direct representation
                    return new RootNode(new NumberNode(i));
                }
            }
            // Check for powers
            for (const constant of [...CONSTANTS, ...TRIG_VALUES]) {
                for (let power = 2; power <= 3; power++) {
                    if (Math.abs(num - constant.value ** power) < CONFIG.epsilon) {
                        const baseNode = constant.getExactForm
                            ? this.parseExactForm(constant.getExactForm())
                            : new ConstantNode(constant.getSymbol(), constant.value);
                        return new PowerNode(baseNode, new NumberNode(power));
                    }
                }
            }
            // Recursive decomposition with extra care for square roots
            if (depth < MAX_DEPTH) {
                // Check for π/n pattern
                for (const constant of CONSTANTS) {
                    for (let denominator = 2; denominator <= 12; denominator++) {
                        if (Math.abs(num - constant.value / denominator) < CONFIG.epsilon) {
                            return new BinaryOpNode('/', constant.getExactForm
                                ? this.parseExactForm(constant.getExactForm())
                                : new ConstantNode(constant.getSymbol(), constant.value), new NumberNode(denominator));
                        }
                    }
                }
                // Check for products with more careful handling of square roots
                for (const constant of [...CONSTANTS, ...TRIG_VALUES]) {
                    if (Math.abs(constant.value) > CONFIG.epsilon) {
                        const multiplier = num / constant.value;
                        // Skip square root decomposition attempts for prime square roots
                        if (constant.getSymbol() && constant.getSymbol().startsWith('√')
                            && isPrime$1(Number.parseInt(constant.getSymbol(true).substring(1)))) {
                            continue;
                        }
                        // Skip common fractions that might be misidentified as complex expressions
                        if ((Math.abs(multiplier - 0.75) < CONFIG.epsilon)
                            || (Math.abs(multiplier - 0.5) < CONFIG.epsilon)
                            || (Math.abs(multiplier - 0.25) < CONFIG.epsilon)
                            || (Math.abs(multiplier - 0.3333333333333333) < CONFIG.epsilon)
                            || (Math.abs(multiplier - 0.6666666666666666) < CONFIG.epsilon)) {
                            continue;
                        }
                        if (this.isNiceValue(multiplier)) {
                            const multiplierNode = this.parseNumber(multiplier, depth + 1);
                            const valueNode = constant.getExactForm
                                ? this.parseExactForm(constant.getExactForm())
                                : new ConstantNode(constant.getSymbol(), constant.value);
                            // If multiplier is 1, just return the constant
                            if (isNumberNode(multiplierNode)
                                && Math.abs(multiplierNode.evaluate() - 1) < CONFIG.epsilon) {
                                return valueNode;
                            }
                            // Create the product node with canonical ordering
                            let productNode;
                            // Define a priority order for constants
                            // Lower number = higher priority (should appear first)
                            const getConstantPriority = (node) => {
                                if (!(isConstantNode(node)))
                                    return 100;
                                const symbol = node.getSymbol();
                                if (symbol === 'e')
                                    return 1;
                                if (symbol === 'π')
                                    return 2;
                                if (symbol === 'φ')
                                    return 3;
                                if (symbol.startsWith('√'))
                                    return 10;
                                return 50; // Other constants
                            };
                            // Apply the priority ordering
                            if (isConstantNode(multiplierNode) && isConstantNode(valueNode)) {
                                // When multiplying two constants, order them by priority
                                const multiplierPriority = getConstantPriority(multiplierNode);
                                const valuePriority = getConstantPriority(valueNode);
                                if (multiplierPriority <= valuePriority) {
                                    productNode = new BinaryOpNode('*', multiplierNode, valueNode);
                                }
                                else {
                                    productNode = new BinaryOpNode('*', valueNode, multiplierNode);
                                }
                            }
                            else if (isNumberNode(multiplierNode)) {
                                // Number multiplier always goes first
                                productNode = new BinaryOpNode('*', multiplierNode, valueNode);
                            }
                            else if (getConstantPriority(valueNode) < 50) {
                                // Special constants (e, π, φ) go before other expressions
                                productNode = new BinaryOpNode('*', valueNode, multiplierNode);
                            }
                            else {
                                // Default ordering
                                productNode = new BinaryOpNode('*', multiplierNode, valueNode);
                            }
                            // Check if this product is part of a sum
                            // Try to see if the product plus a nice value equals our number
                            for (let addend = 1; addend <= 10; addend++) {
                                const productValue = productNode.evaluate();
                                const sum = productValue + addend;
                                if (Math.abs(num - sum) < CONFIG.epsilon) {
                                    return new BinaryOpNode('+', productNode, new NumberNode(addend));
                                }
                            }
                            return productNode;
                        }
                    }
                }
                // Check for sums and differences with base constants
                for (const constant of [...CONSTANTS, ...TRIG_VALUES]) {
                    const remainder = num - constant.value;
                    if (this.isNiceValue(remainder)) {
                        const remainderNode = this.parseNumber(remainder, depth + 1);
                        const valueNode = constant.getExactForm
                            ? this.parseExactForm(constant.getExactForm())
                            : new ConstantNode(constant.getSymbol(), constant.value);
                        // If remainder is 0, just return the constant
                        if (isNumberNode(remainderNode)
                            && Math.abs(remainderNode.evaluate()) < CONFIG.epsilon) {
                            return valueNode;
                        }
                        // If remainder is negative, use subtraction
                        if (remainder < 0) {
                            return new BinaryOpNode('-', valueNode, this.parseNumber(-remainder, depth + 1));
                        }
                        return new BinaryOpNode('+', valueNode, remainderNode);
                    }
                }
                // Check for sums and differences with multiples of constants
                for (const constant of [...CONSTANTS, ...TRIG_VALUES]) {
                    for (let multiplier = 2; multiplier <= 5; multiplier++) {
                        const multipleValue = multiplier * constant.value;
                        const remainder = num - multipleValue;
                        if (this.isNiceValue(remainder)) {
                            // Create the multiple constant node
                            const constantNode = constant.getExactForm
                                ? this.parseExactForm(constant.getExactForm())
                                : new ConstantNode(constant.getSymbol(), constant.value);
                            const multipleNode = new BinaryOpNode('*', new NumberNode(multiplier), constantNode);
                            // Create the remainder node
                            const remainderNode = this.parseNumber(remainder, depth + 1);
                            // If remainder is 0, just return the multiple
                            if (isNumberNode(remainderNode)
                                && Math.abs(remainderNode.evaluate()) < CONFIG.epsilon) {
                                return multipleNode;
                            }
                            // If remainder is negative, use subtraction
                            if (remainder < 0) {
                                return new BinaryOpNode('-', multipleNode, this.parseNumber(-remainder, depth + 1));
                            }
                            return new BinaryOpNode('+', multipleNode, remainderNode);
                        }
                    }
                }
                // Check for cube roots of integers
                for (let i = 2; i <= 100; i++) {
                    if (Math.abs(num - Math.cbrt(i)) < CONFIG.epsilon) {
                        return new UnaryOpNode('cbrt', new NumberNode(i));
                    }
                }
            }
            // Final direct check for square roots before giving up
            // This ensures we catch any square roots we might have missed
            const possibleRadicand = Math.round(num * num);
            if (Math.abs(num - Math.sqrt(possibleRadicand)) < CONFIG.epsilon) {
                return new RootNode(new NumberNode(possibleRadicand));
            }
            // Fallback to decimal representation
            return new NumberNode(num);
        }
        /**
         * Helper method to parse exact forms like "√2/2"
         */
        parseExactForm(exactForm) {
            // Handle fractions
            if (exactForm.includes('/')) {
                const [numerator, denominator] = exactForm.split('/');
                return new BinaryOpNode('/', this.parseExactForm(numerator), this.parseExactForm(denominator));
            }
            // Handle square roots
            if (exactForm.startsWith('√')) {
                const argument = exactForm.substring(1);
                return new RootNode(this.parseExactForm(argument));
            }
            // Handle simple numbers
            if (/^\d+$/.test(exactForm)) {
                return new NumberNode(Number.parseInt(exactForm));
            }
            // Handle known constants
            for (const constant of CONSTANTS) {
                if (exactForm === constant.getSymbol()) {
                    return new ConstantNode(constant.getSymbol(), constant.value);
                }
            }
            // If we don't recognize it, treat it as a symbol
            return new ConstantNode(exactForm, Number.NaN);
        }
        /**
         * Helper to determine if a value is "nice"
         */
        isNiceValue(num) {
            // Check if it's close to an integer
            if (Math.abs(num - Math.round(num)) < CONFIG.epsilon) {
                return true;
            }
            const cfTerms = toContinuedFraction(num, 10);
            const convergents = getConvergents(cfTerms);
            // Check if any convergent is a good approximation and reasonably simple
            for (const [numerator, denominator] of convergents) {
                // Only consider "nice" fractions (reasonable size numerator/denominator)
                if (denominator <= 20 && Math.abs(numerator) <= 50) {
                    if (Math.abs(num - numerator / denominator) < CONFIG.epsilon) {
                        return true;
                    }
                }
            }
            // Check if it's a square root of a small integer (highest priority)
            // This helps prefer direct √n forms
            for (let i = 2; i <= 30; i++) {
                if (Math.abs(num - Math.sqrt(i)) < CONFIG.epsilon) {
                    // Give very high priority to prime square roots
                    if (isPrime$1(i)) {
                        return true;
                    }
                    // Also prioritize other small square roots
                    if (i <= 20) {
                        return true;
                    }
                }
            }
            // Check if it's close to a common constant
            for (const constant of CONSTANTS) {
                if (Math.abs(num - constant.value) < CONFIG.epsilon) {
                    return true;
                }
            }
            // Check trig values
            for (const value of TRIG_VALUES) {
                if (Math.abs(num - value.value) < CONFIG.epsilon) {
                    return true;
                }
            }
            // Other common values with lower priority
            const COMMON_VALUES = [
                Math.sin(Math.PI / 3),
                Math.cos(Math.PI / 4),
            ];
            for (const value of COMMON_VALUES) {
                if (Math.abs(num - value) < CONFIG.epsilon) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Find greatest common divisor helper method
         */
        findGCD(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b !== 0) {
                const temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }
    }

    /**
     * Symbolic Number Printer using Expression Tree Representation
     *
     * This implementation uses a proper expression tree to represent mathematical
     * expressions, enabling more sophisticated simplification and consistent formatting.
     */
    /**
     * Main function to convert a number to its symbolic representation
     * @param num The number to convert to symbolic form
     * @returns A string containing the symbolic representation
     */
    function prettyPi(num, config = {}) {
        if (!isFinite(num)) {
            if (isNaN(num)) {
                return "NaN";
            }
            return num > 0 ? "∞" : "-∞";
        }
        setConfig(config);
        const parser = new ExpressionParser();
        const exprTree = parser.parseNumber(num);
        const simplified = exprTree.simplify();
        return simplified.toString();
    }

    function getCodeMarker(sourceCodeInfo) {
        if (!sourceCodeInfo.position || !sourceCodeInfo.code)
            return '';
        var leftPadding = sourceCodeInfo.position.column - 1;
        var rightPadding = sourceCodeInfo.code.length - leftPadding - 1;
        return "".concat(' '.repeat(Math.max(leftPadding, 0)), "^").concat(' '.repeat(Math.max(rightPadding, 0)));
    }

    function getLitsErrorMessage(message, sourceCodeInfo) {
        if (!sourceCodeInfo) {
            return message;
        }
        var location = "".concat(sourceCodeInfo.position.line, ":").concat(sourceCodeInfo.position.column);
        var filePathLine = sourceCodeInfo.filePath
            ? "\n".concat(sourceCodeInfo.filePath, ":").concat(location)
            : "\nLocation ".concat(location);
        var codeLine = "\n".concat(sourceCodeInfo.code);
        var codeMarker = "\n".concat(getCodeMarker(sourceCodeInfo));
        return "".concat(message).concat(filePathLine).concat(codeLine).concat(codeMarker);
    }
    var RecurSignal = /** @class */ (function (_super) {
        __extends(RecurSignal, _super);
        function RecurSignal(params) {
            var _this = _super.call(this, "recur, params: ".concat(params)) || this;
            Object.setPrototypeOf(_this, RecurSignal.prototype);
            _this.name = 'RecurSignal';
            _this.params = params;
            return _this;
        }
        return RecurSignal;
    }(Error));
    var LitsError = /** @class */ (function (_super) {
        __extends(LitsError, _super);
        function LitsError(err, sourceCodeInfo) {
            var _this = this;
            var message = err instanceof Error
                ? err.message
                : "".concat(err);
            _this = _super.call(this, getLitsErrorMessage(message, sourceCodeInfo)) || this;
            _this.shortMessage = message;
            _this.sourceCodeInfo = sourceCodeInfo;
            Object.setPrototypeOf(_this, LitsError.prototype);
            _this.name = 'LitsError';
            return _this;
        }
        LitsError.prototype.getCodeMarker = function () {
            return this.sourceCodeInfo && getCodeMarker(this.sourceCodeInfo);
        };
        return LitsError;
    }(Error));
    var UserDefinedError = /** @class */ (function (_super) {
        __extends(UserDefinedError, _super);
        function UserDefinedError(message, sourceCodeInfo) {
            var _this = _super.call(this, message, sourceCodeInfo) || this;
            _this.userMessage = message;
            Object.setPrototypeOf(_this, UserDefinedError.prototype);
            _this.name = 'UserDefinedError';
            return _this;
        }
        return UserDefinedError;
    }(LitsError));
    var AssertionError = /** @class */ (function (_super) {
        __extends(AssertionError, _super);
        function AssertionError(message, sourceCodeInfo) {
            var _this = _super.call(this, message, sourceCodeInfo) || this;
            Object.setPrototypeOf(_this, AssertionError.prototype);
            _this.name = 'AssertionError';
            return _this;
        }
        return AssertionError;
    }(LitsError));
    var UndefinedSymbolError = /** @class */ (function (_super) {
        __extends(UndefinedSymbolError, _super);
        function UndefinedSymbolError(symbolName, sourceCodeInfo) {
            var _this = this;
            var message = "Undefined symbol '".concat(symbolName, "'.");
            _this = _super.call(this, message, sourceCodeInfo) || this;
            _this.symbol = symbolName;
            Object.setPrototypeOf(_this, UndefinedSymbolError.prototype);
            _this.name = 'UndefinedSymbolError';
            return _this;
        }
        return UndefinedSymbolError;
    }(LitsError));

    var NodeTypes = {
        Number: 1,
        String: 2,
        NormalExpression: 3,
        SpecialExpression: 4,
        UserDefinedSymbol: 5,
        NormalBuiltinSymbol: 6,
        SpecialBuiltinSymbol: 7,
        ReservedSymbol: 8,
        Binding: 9,
        Spread: 10,
    };
    var NodeTypesSet = new Set(Object.values(NodeTypes));
    function getNodeTypeName(type) {
        return Object.keys(NodeTypes).find(function (key) { return NodeTypes[key] === type; });
    }
    // TODO, is this needed?
    function isNodeType(type) {
        return typeof type === 'number' && NodeTypesSet.has(type);
    }
    var functionTypes = [
        'UserDefined',
        'Partial',
        'Comp',
        'Constantly',
        'Juxt',
        'Complement',
        'EveryPred',
        'SomePred',
        'Fnull',
        'Builtin',
        'SpecialBuiltin',
        'NativeJsFunction',
    ];
    var functionTypeSet = new Set(functionTypes);
    function isFunctionType(type) {
        return typeof type === 'string' && functionTypeSet.has(type);
    }

    var FUNCTION_SYMBOL = '^^fn^^';
    var REGEXP_SYMBOL = '^^re^^';

    function isLitsFunction$1(func) {
        if (func === null || typeof func !== 'object')
            return false;
        return FUNCTION_SYMBOL in func && 'functionType' in func && isFunctionType(func.functionType);
    }
    function isNode(value) {
        if (!Array.isArray(value) || value.length < 2)
            return false;
        return isNodeType(value[0]);
    }
    function valueToString(value) {
        if (isLitsFunction$1(value))
            // eslint-disable-next-line ts/no-unsafe-member-access
            return "<function ".concat(value.name || '\u03BB', ">");
        if (isNode(value))
            return "".concat(getNodeTypeName(value[0]), "-node");
        if (value === null)
            return 'null';
        if (typeof value === 'object' && value instanceof RegExp)
            return "".concat(value);
        if (typeof value === 'object' && value instanceof Error)
            return value.toString();
        return JSON.stringify(value);
    }

    function getSourceCodeInfo(anyValue, sourceCodeInfo) {
        var _a;
        // eslint-disable-next-line ts/no-unsafe-return, ts/no-unsafe-member-access
        return (_a = anyValue === null || anyValue === void 0 ? void 0 : anyValue.sourceCodeInfo) !== null && _a !== void 0 ? _a : sourceCodeInfo;
    }

    function getAssertionError(typeName, value, sourceCodeInfo) {
        return new LitsError("Expected ".concat(typeName, ", got ").concat(valueToString(value), "."), getSourceCodeInfo(value, sourceCodeInfo));
    }

    function assertNumberOfParams(count, node) {
        var length = node[1][1].length;
        if (typeof count === 'number') {
            if (length !== count) {
                var name_1 = getNodeTypeName(node[0]);
                throw new LitsError("Wrong number of arguments to \"".concat(name_1, "\", expected ").concat(count, ", got ").concat(valueToString(length), "."), node[2]);
            }
        }
        else {
            var min = count.min, max = count.max, even = count.even, odd = count.odd;
            if (even) {
                var name_2 = getNodeTypeName(node[0]);
                if (length % 2 !== 0) {
                    throw new LitsError("Wrong number of arguments to \"".concat(name_2, "\",, expected an even number, got ").concat(valueToString(length), "."), node[2]);
                }
            }
            if (odd) {
                if (length % 2 !== 1) {
                    var name_3 = getNodeTypeName(node[0]);
                    throw new LitsError("Wrong number of arguments to \"".concat(name_3, "\",, expected an odd number, got ").concat(valueToString(length), "."), node[2]);
                }
            }
            if (typeof min === 'number' && length < min) {
                var name_4 = getNodeTypeName(node[0]);
                throw new LitsError("Wrong number of arguments to \"".concat(name_4, "\", expected at least ").concat(min, ", got ").concat(valueToString(length), "."), node[2]);
            }
            if (typeof max === 'number' && length > max) {
                var name_5 = getNodeTypeName(node[0]);
                throw new LitsError("Wrong number of arguments to \"".concat(name_5, "\", expected at most ").concat(max, ", got ").concat(valueToString(length), "."), node[2]);
            }
        }
    }
    function isNonUndefined(value) {
        return value !== undefined;
    }
    function asNonUndefined(value, sourceCodeInfo) {
        assertNonUndefined(value, sourceCodeInfo);
        return value;
    }
    function assertNonUndefined(value, sourceCodeInfo) {
        if (!isNonUndefined(value))
            throw new LitsError('Unexpected undefined', getSourceCodeInfo(value, sourceCodeInfo));
    }
    function isUnknownRecord(value) {
        return value !== null && typeof value === 'object' && !Array.isArray(value);
    }
    function assertUnknownRecord(value, sourceCodeInfo) {
        if (!isUnknownRecord(value)) {
            throw new LitsError("Expected ".concat('UnknownRecord', ", got ").concat(valueToString(value), "."), getSourceCodeInfo(value, sourceCodeInfo));
        }
    }
    function asUnknownRecord(value, sourceCodeInfo) {
        assertUnknownRecord(value, sourceCodeInfo);
        return value;
    }
    function canBeOperator(count) {
        if (typeof count === 'number') {
            return count === 2;
        }
        if (count.odd) {
            return false;
        }
        if (typeof count.max === 'number' && count.max < 2) {
            return false;
        }
        if (typeof count.min === 'number' && count.min > 2) {
            return false;
        }
        return true;
    }

    function isLitsFunction(value) {
        if (value === null || typeof value !== 'object')
            return false;
        return !!value[FUNCTION_SYMBOL];
    }

    function isAny(value) {
        // TODO weak test
        return value !== undefined;
    }
    function asAny(value, sourceCodeInfo) {
        assertAny(value, sourceCodeInfo);
        return value;
    }
    function assertAny(value, sourceCodeInfo) {
        if (!isAny(value))
            throw getAssertionError('not undefined', value, sourceCodeInfo);
    }
    function isSeq(value) {
        return Array.isArray(value) || typeof value === 'string';
    }
    function asSeq(value, sourceCodeInfo) {
        assertSeq(value, sourceCodeInfo);
        return value;
    }
    function assertSeq(value, sourceCodeInfo) {
        if (!isSeq(value))
            throw getAssertionError('string or array', value, sourceCodeInfo);
    }
    function isObj(value) {
        return !(value === null
            || typeof value !== 'object'
            || Array.isArray(value)
            || value instanceof RegExp
            || isLitsFunction(value)
            || isRegularExpression(value));
    }
    function assertObj(value, sourceCodeInfo) {
        if (!isObj(value))
            throw getAssertionError('object', value, sourceCodeInfo);
    }
    function isColl(value) {
        return isSeq(value) || isObj(value);
    }
    function asColl(value, sourceCodeInfo) {
        assertColl(value, sourceCodeInfo);
        return value;
    }
    function assertColl(value, sourceCodeInfo) {
        if (!isColl(value))
            throw getAssertionError('string, array or object', value, sourceCodeInfo);
    }
    function isRegularExpression(regexp) {
        if (regexp === null || typeof regexp !== 'object')
            return false;
        return !!regexp[REGEXP_SYMBOL];
    }
    function assertRegularExpression(value, sourceCodeInfo) {
        if (!isRegularExpression(value))
            throw getAssertionError('RegularExpression', value, sourceCodeInfo);
    }
    function isStringOrRegularExpression(value) {
        return isRegularExpression(value) || typeof value === 'string';
    }
    function assertStringOrRegularExpression(value, sourceCodeInfo) {
        if (!isStringOrRegularExpression(value))
            throw getAssertionError('string or RegularExpression', value, sourceCodeInfo);
    }
    function isFunctionLike(value) {
        if (typeof value === 'number')
            return true;
        if (isColl(value))
            return true;
        if (isLitsFunction(value))
            return true;
        return false;
    }
    function asFunctionLike(value, sourceCodeInfo) {
        assertFunctionLike(value, sourceCodeInfo);
        return value;
    }
    function assertFunctionLike(value, sourceCodeInfo) {
        if (!isFunctionLike(value))
            throw getAssertionError('FunctionLike', value, sourceCodeInfo);
    }

    function getRangeString(options) {
        var hasUpperAndLowerBound = (typeof options.gt === 'number' || typeof options.gte === 'number')
            && (typeof options.lt === 'number' || typeof options.lte === 'number');
        if (hasUpperAndLowerBound) {
            return "".concat(typeof options.gt === 'number' ? "".concat(options.gt, " < n ") : "".concat(options.gte, " <= n ")).concat(typeof options.lt === 'number' ? "< ".concat(options.lt) : "<= ".concat(options.lte));
        }
        else if (typeof options.gt === 'number' || typeof options.gte === 'number') {
            return "".concat(typeof options.gt === 'number' ? "n > ".concat(options.gt) : "n >= ".concat(options.gte));
        }
        else if (typeof options.lt === 'number' || typeof options.lte === 'number') {
            return "".concat(typeof options.lt === 'number' ? "n < ".concat(options.lt) : "n <= ".concat(options.lte));
        }
        else {
            return '';
        }
    }
    function getSignString(options) {
        return options.positive
            ? 'positive'
            : options.negative
                ? 'negative'
                : options.nonNegative
                    ? 'non negative'
                    : options.nonPositive
                        ? 'non positive'
                        : options.nonZero
                            ? 'non zero'
                            : '';
    }
    function getNumberTypeName(options) {
        if (options.zero)
            return 'zero';
        var sign = getSignString(options);
        var numberType = options.integer ? 'integer' : 'number';
        var finite = options.finite ? 'finite' : '';
        var range = getRangeString(options);
        return [sign, finite, numberType, range].filter(function (x) { return !!x; }).join(' ');
    }
    function isNumber(value, options) {
        if (options === void 0) { options = {}; }
        if (typeof value !== 'number')
            return false;
        if (Number.isNaN(value))
            return false;
        if (options.integer && !Number.isInteger(value))
            return false;
        if (options.finite && !Number.isFinite(value))
            return false;
        if (options.zero && value !== 0)
            return false;
        if (options.nonZero && value === 0)
            return false;
        if (options.positive && value <= 0)
            return false;
        if (options.negative && value >= 0)
            return false;
        if (options.nonPositive && value > 0)
            return false;
        if (options.nonNegative && value < 0)
            return false;
        if (typeof options.gt === 'number' && value <= options.gt)
            return false;
        if (typeof options.gte === 'number' && value < options.gte)
            return false;
        if (typeof options.lt === 'number' && value >= options.lt)
            return false;
        if (typeof options.lte === 'number' && value > options.lte)
            return false;
        return true;
    }
    function assertNumber(value, sourceCodeInfo, options) {
        if (options === void 0) { options = {}; }
        if (!isNumber(value, options)) {
            throw new LitsError("Expected ".concat(getNumberTypeName(options), ", got ").concat(valueToString(value), "."), getSourceCodeInfo(value, sourceCodeInfo));
        }
    }
    function asNumber(value, sourceCodeInfo, options) {
        if (options === void 0) { options = {}; }
        assertNumber(value, sourceCodeInfo, options);
        return value;
    }

    var annotatedArrays = new WeakSet();
    var vectors = new WeakSet();
    var matrices = new WeakSet();
    var grids = new WeakSet();
    function annotate(value) {
        if (!Array.isArray(value)) {
            return value;
        }
        if (annotatedArrays.has(value)) {
            return value;
        }
        isVector(value);
        if (!isMatrix(value)) {
            isGrid(value);
        }
        return value;
    }
    function isVector(vector) {
        if (!Array.isArray(vector)) {
            return false;
        }
        if (vectors.has(vector)) {
            return true;
        }
        if (vector.every(function (elem) { return isNumber(elem); })) {
            annotatedArrays.add(vector);
            vectors.add(vector);
            return true;
        }
        return false;
    }
    function assertVector(vector, sourceCodeInfo) {
        if (!isVector(vector)) {
            throw new LitsError("Expected a vector, but got ".concat(vector), sourceCodeInfo);
        }
    }
    function is2dVector(vector) {
        if (!isVector(vector)) {
            return false;
        }
        return vector.length === 2;
    }
    function assert2dVector(vector, sourceCodeInfo) {
        if (!is2dVector(vector)) {
            throw new LitsError("Expected a 2d vector, but got ".concat(vector), sourceCodeInfo);
        }
    }
    function is3dVector(vector) {
        if (!isVector(vector)) {
            return false;
        }
        return vector.length === 3;
    }
    function assert3dVector(vector, sourceCodeInfo) {
        if (!is3dVector(vector)) {
            throw new LitsError("Expected a 3d vector, but got ".concat(vector), sourceCodeInfo);
        }
    }
    function assertNonEmptyVector(vector, sourceCodeInfo) {
        assertVector(vector, sourceCodeInfo);
        if (vector.length === 0) {
            throw new LitsError("Expected a non empty vector, but got ".concat(vector), sourceCodeInfo);
        }
    }
    function isGrid(grid) {
        var e_1, _a;
        if (!Array.isArray(grid)) {
            return false;
        }
        if (grids.has(grid)) {
            return true;
        }
        if (grid.length === 0) {
            return false;
        }
        if (!Array.isArray(grid[0])) {
            return false;
        }
        var nbrOfCols = grid[0].length;
        try {
            for (var _b = __values(grid.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                if (!Array.isArray(row)) {
                    return false;
                }
                if (row.length !== nbrOfCols) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        annotatedArrays.add(grid);
        grids.add(grid);
        return true;
    }
    function assertGrid(grid, sourceCodeInfo) {
        if (!isGrid(grid)) {
            throw new LitsError("Expected a grid, but got ".concat(grid), sourceCodeInfo);
        }
    }
    function isMatrix(matrix) {
        var e_2, _a;
        if (!Array.isArray(matrix)) {
            return false;
        }
        if (matrices.has(matrix)) {
            return true;
        }
        if (matrix.length === 0) {
            return false;
        }
        if (!Array.isArray(matrix[0])) {
            return false;
        }
        if (matrix[0].length === 0) {
            return false;
        }
        var nbrOfCols = matrix[0].length;
        try {
            for (var _b = __values(matrix.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var row = _c.value;
                if (!Array.isArray(row)) {
                    return false;
                }
                if (row.length !== nbrOfCols) {
                    return false;
                }
                if (row.some(function (cell) { return !isNumber(cell); })) {
                    return false;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        annotatedArrays.add(matrix);
        grids.add(matrix);
        matrices.add(matrix);
        return true;
    }
    function assertMatrix(matrix, sourceCodeInfo) {
        if (!isMatrix(matrix)) {
            throw new LitsError("Expected a matrix, but got ".concat(matrix), sourceCodeInfo);
        }
    }
    function assertSquareMatrix(matrix, sourceCodeInfo) {
        if (!isMatrix(matrix)) {
            throw new LitsError("Expected a matrix, but got ".concat(matrix), sourceCodeInfo);
        }
        if (matrix.length !== matrix[0].length) {
            throw new LitsError("Expected square matrix, but got ".concat(matrix.length, " and ").concat(matrix[0].length), sourceCodeInfo);
        }
    }
    function isSquareMatrix(matrix) {
        if (!isMatrix(matrix)) {
            return false;
        }
        if (matrix.length !== matrix[0].length) {
            return false;
        }
        return true;
    }

    function stringifyValue(value, html) {
        var _a;
        var gt = '>';
        var lt = '<';
        if (isLitsFunction(value)) {
            if (value.functionType === 'Builtin')
                return "".concat(lt, "builtin function ").concat(value.normalBuitinSymbolType).concat(gt);
            else
                return "".concat(lt, "function ").concat((_a = value.n) !== null && _a !== void 0 ? _a : '\u03BB').concat(gt);
        }
        if (value === null)
            return 'null';
        if (typeof value === 'object' && value instanceof Error)
            return value.toString();
        if (typeof value === 'object' && value instanceof RegExp)
            return "".concat(value);
        if (typeof value === 'number') {
            return prettyPi(value);
        }
        if (isRegularExpression(value))
            return "/".concat(value.s, "/").concat(value.f);
        if (typeof value === 'string')
            return "\"".concat(value, "\"");
        if (Array.isArray(value) && isMatrix(value))
            return stringifyMatrix(value);
        if (Array.isArray(value) && isVector(value)) {
            if (value.length === 0)
                return '[]';
            if (value.length > 8) {
                return "[\n  ".concat(value.map(function (cell) {
                    return prettyPi(cell);
                }).join(',\n  '), "\n]");
            }
            else {
                return "[".concat(value.map(function (cell) {
                    return prettyPi(cell);
                }).join(', '), "]");
            }
        }
        return JSON.stringify(replaceInfinities(value), null, 2);
    }
    function replaceInfinities(value) {
        var e_1, _a;
        if (value === Number.POSITIVE_INFINITY) {
            return '∞';
        }
        if (value === Number.NEGATIVE_INFINITY) {
            return '-∞';
        }
        if (Array.isArray(value)) {
            return value.map(replaceInfinities);
        }
        if (typeof value === 'object' && value !== null) {
            var result = {};
            try {
                for (var _b = __values(Object.entries(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), key = _d[0], val = _d[1];
                    result[key] = replaceInfinities(val);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        }
        return value;
    }
    function prettyIfNumber(value) {
        if (typeof value === 'number') {
            return prettyPi(value);
        }
        return "".concat(value);
    }
    function stringifyMatrix(matrix) {
        var padding = matrix.flat().reduce(function (max, cell) { return Math.max(max, prettyIfNumber(cell).length); }, 0) + 1;
        var rows = matrix.map(function (row) { return "[".concat(row.map(function (cell) { return prettyIfNumber(cell).padStart(padding); }).join(' '), " ]"); });
        return rows.join('\n');
    }

    var bitwiseNormalExpression = {
        '<<': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], count = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                return num << count;
            },
            paramCount: 2,
        },
        '>>': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], count = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                return num >> count;
            },
            paramCount: 2,
        },
        '>>>': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], count = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                return num >>> count;
            },
            paramCount: 2,
        },
        'bit-not': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), num = _b[0];
                assertNumber(num, sourceCodeInfo, { integer: true });
                return ~num;
            },
            paramCount: 1,
        },
        '&': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo, { integer: true });
                return rest.reduce(function (result, value) {
                    assertNumber(value, sourceCodeInfo, { integer: true });
                    return result & value;
                }, first);
            },
            paramCount: { min: 2 },
        },
        'bit-and-not': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo, { integer: true });
                return rest.reduce(function (result, value) {
                    assertNumber(value, sourceCodeInfo, { integer: true });
                    return result & ~value;
                }, first);
            },
            paramCount: { min: 2 },
        },
        '|': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo, { integer: true });
                return rest.reduce(function (result, value) {
                    assertNumber(value, sourceCodeInfo, { integer: true });
                    return result | value;
                }, first);
            },
            paramCount: { min: 2 },
        },
        'xor': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo, { integer: true });
                return rest.reduce(function (result, value) {
                    assertNumber(value, sourceCodeInfo, { integer: true });
                    return result ^ value;
                }, first);
            },
            paramCount: { min: 2 },
        },
        'bit-flip': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], index = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
                var mask = 1 << index;
                return (num ^= mask);
            },
            paramCount: 2,
        },
        'bit-set': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], index = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
                var mask = 1 << index;
                return (num |= mask);
            },
            paramCount: 2,
        },
        'bit-clear': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], index = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
                var mask = 1 << index;
                return (num &= ~mask);
            },
            paramCount: 2,
        },
        'bit-test': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), num = _b[0], index = _b[1];
                assertNumber(num, sourceCodeInfo, { integer: true });
                assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
                var mask = 1 << index;
                return !!(num & mask);
            },
            paramCount: 2,
        },
    };

    function isString(value, options) {
        if (options === void 0) { options = {}; }
        if (typeof value !== 'string')
            return false;
        if (options.nonEmpty && value.length === 0)
            return false;
        if (options.char && value.length !== 1)
            return false;
        return true;
    }
    function assertString(value, sourceCodeInfo, options) {
        if (options === void 0) { options = {}; }
        if (!isString(value, options)) {
            throw getAssertionError("".concat(options.nonEmpty ? 'non empty string' : options.char ? 'character' : 'string'), value, sourceCodeInfo);
        }
    }
    function asString(value, sourceCodeInfo, options) {
        if (options === void 0) { options = {}; }
        assertString(value, sourceCodeInfo, options);
        return value;
    }
    function isStringOrNumber(value) {
        return typeof value === 'string' || typeof value === 'number';
    }
    function asStringOrNumber(value, sourceCodeInfo) {
        assertStringOrNumber(value, sourceCodeInfo);
        return value;
    }
    function assertStringOrNumber(value, sourceCodeInfo) {
        if (!isStringOrNumber(value))
            throw getAssertionError('string or number', value, sourceCodeInfo);
    }

    function collHasKey(coll, key) {
        if (!isColl(coll))
            return false;
        if (typeof coll === 'string' || Array.isArray(coll)) {
            if (!isNumber(key, { integer: true }))
                return false;
            return key >= 0 && key < coll.length;
        }
        return !!Object.getOwnPropertyDescriptor(coll, key);
    }
    function compare(a, b, sourceCodeInfo) {
        assertStringOrNumber(a, sourceCodeInfo);
        assertStringOrNumber(b, sourceCodeInfo);
        if (typeof a === 'string' && typeof b === 'string') {
            return a < b ? -1 : a > b ? 1 : 0;
        }
        if (typeof a === 'number' && typeof b === 'number') {
            return Math.sign((a) - (b));
        }
        throw new LitsError("Cannot compare values of different types: ".concat(typeof a, " and ").concat(typeof b), sourceCodeInfo);
    }
    function deepEqual(a, b, sourceCodeInfo) {
        if (a === b)
            return true;
        if (typeof a === 'number' && typeof b === 'number')
            return approxEqual(a, b);
        if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length)
                return false;
            for (var i = 0; i < a.length; i += 1) {
                if (!deepEqual(asAny(a[i], sourceCodeInfo), asAny(b[i], sourceCodeInfo), sourceCodeInfo))
                    return false;
            }
            return true;
        }
        if (isRegularExpression(a) && isRegularExpression(b))
            return a.s === b.s && a.f === b.f;
        if (isUnknownRecord(a) && isUnknownRecord(b)) {
            var aKeys = Object.keys(a);
            var bKeys = Object.keys(b);
            if (aKeys.length !== bKeys.length)
                return false;
            for (var i = 0; i < aKeys.length; i += 1) {
                var key = asString(aKeys[i], sourceCodeInfo);
                if (!deepEqual(a[key], b[key], sourceCodeInfo))
                    return false;
            }
            return true;
        }
        return false;
    }
    function toNonNegativeInteger(num) {
        return Math.max(0, Math.ceil(num));
    }
    function toAny(value) {
        return (value !== null && value !== void 0 ? value : null);
    }
    function clone(value) {
        if (isObj(value)) {
            return Object.entries(value).reduce(function (result, entry) {
                var _a = __read(entry, 2), key = _a[0], val = _a[1];
                result[key] = clone(val);
                return result;
            }, {});
        }
        if (Array.isArray(value))
            // eslint-disable-next-line ts/no-unsafe-return
            return value.map(function (item) { return clone(item); });
        return value;
    }
    function cloneColl(value) {
        return clone(value);
    }
    function joinSets() {
        var e_1, _a;
        var results = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            results[_i] = arguments[_i];
        }
        var result = new Set();
        try {
            for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
                var symbols = results_1_1.value;
                symbols.forEach(function (symbol) { return result.add(symbol); });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (results_1_1 && !results_1_1.done && (_a = results_1.return)) _a.call(results_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    function addToSet(target, source) {
        source.forEach(function (symbol) { return target.add(symbol); });
    }
    var EPSILON = 1e-10;
    function approxEqual(a, b, epsilon) {
        if (epsilon === void 0) { epsilon = EPSILON; }
        if (a === b) {
            return true;
        }
        var diff = Math.abs(a - b);
        if (a === 0 || b === 0 || diff < epsilon) {
            // Use absolute error for values near zero
            return diff < epsilon;
        }
        var absA = Math.abs(a);
        var absB = Math.abs(b);
        // Use relative error for larger values
        return diff / (absA + absB) < epsilon;
    }
    function approxZero(value) {
        return Math.abs(value) < EPSILON;
    }

    // isArray not needed, use Array.isArary
    function asArray(value, sourceCodeInfo) {
        assertArray(value, sourceCodeInfo);
        return value;
    }
    function assertArray(value, sourceCodeInfo) {
        if (!Array.isArray(value))
            throw getAssertionError('array', value, sourceCodeInfo);
    }
    function isStringArray(value) {
        return Array.isArray(value) && value.every(function (v) { return typeof v === 'string'; });
    }
    function assertStringArray(value, sourceCodeInfo) {
        if (!isStringArray(value))
            throw getAssertionError('array of strings', value, sourceCodeInfo);
    }
    function isCharArray(value) {
        return Array.isArray(value) && value.every(function (v) { return typeof v === 'string' && v.length === 1; });
    }
    function assertCharArray(value, sourceCodeInfo) {
        if (!isCharArray(value))
            throw getAssertionError('array of strings', value, sourceCodeInfo);
    }

    function mapObjects(_a) {
        var colls = _a.colls, contextStack = _a.contextStack, executeFunction = _a.executeFunction, fn = _a.fn, sourceCodeInfo = _a.sourceCodeInfo;
        assertObj(colls[0], sourceCodeInfo);
        var keys = Object.keys(colls[0]);
        var params = {};
        colls.forEach(function (obj) {
            assertObj(obj, sourceCodeInfo);
            var objKeys = Object.keys(obj);
            if (objKeys.length !== keys.length) {
                throw new LitsError("All objects must have the same keys. Expected: ".concat(keys.join(', '), ". Found: ").concat(objKeys.join(', ')), sourceCodeInfo);
            }
            if (!objKeys.every(function (key) { return keys.includes(key); })) {
                throw new LitsError("All objects must have the same keys. Expected: ".concat(keys.join(', '), ". Found: ").concat(objKeys.join(', ')), sourceCodeInfo);
            }
            Object.entries(obj).forEach(function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                if (!params[key])
                    params[key] = [];
                params[key].push(value);
            });
        });
        return keys.reduce(function (result, key) {
            result[key] = executeFunction(fn, params[key], contextStack, sourceCodeInfo);
            return result;
        }, {});
    }
    function cloneAndGetMeta(originalColl, keys, sourceCodeInfo) {
        var coll = cloneColl(originalColl);
        var butLastKeys = keys.slice(0, keys.length - 1);
        var innerCollMeta = butLastKeys.reduce(function (result, key) {
            var resultColl = result.coll;
            var newResultColl;
            if (Array.isArray(resultColl)) {
                assertNumber(key, sourceCodeInfo);
                newResultColl = asColl(resultColl[key], sourceCodeInfo);
            }
            else {
                assertObj(resultColl, sourceCodeInfo);
                assertString(key, sourceCodeInfo);
                if (!collHasKey(result.coll, key))
                    resultColl[key] = {};
                newResultColl = asColl(resultColl[key], sourceCodeInfo);
            }
            return { coll: newResultColl, parent: resultColl };
        }, { coll: coll, parent: {} });
        return { coll: coll, innerCollMeta: innerCollMeta };
    }
    function get(coll, key) {
        if (isObj(coll)) {
            if (typeof key === 'string' && collHasKey(coll, key))
                return toAny(coll[key]);
        }
        else {
            if (isNumber(key, { nonNegative: true, integer: true }) && key >= 0 && key < coll.length)
                return toAny(coll[key]);
        }
        return undefined;
    }
    function update(coll, key, fn, params, contextStack, executeFunction, sourceCodeInfo) {
        if (isObj(coll)) {
            assertString(key, sourceCodeInfo);
            var result = __assign({}, coll);
            result[key] = executeFunction(fn, __spreadArray([result[key]], __read(params), false), contextStack, sourceCodeInfo);
            return result;
        }
        else {
            assertNumber(key, sourceCodeInfo);
            var intKey_1 = toNonNegativeInteger(key);
            assertNumber(intKey_1, sourceCodeInfo, { lte: coll.length });
            if (Array.isArray(coll)) {
                var result = coll.map(function (elem, index) {
                    if (intKey_1 === index)
                        return executeFunction(fn, __spreadArray([elem], __read(params), false), contextStack, sourceCodeInfo);
                    return elem;
                });
                if (intKey_1 === coll.length)
                    result[intKey_1] = executeFunction(fn, __spreadArray([undefined], __read(params), false), contextStack, sourceCodeInfo);
                return result;
            }
            else {
                var result = coll.split('').map(function (elem, index) {
                    if (intKey_1 === index) {
                        return asString(executeFunction(fn, __spreadArray([elem], __read(params), false), contextStack, sourceCodeInfo), sourceCodeInfo, {
                            char: true,
                        });
                    }
                    return elem;
                });
                if (intKey_1 === coll.length) {
                    result[intKey_1] = asString(executeFunction(fn, __spreadArray([undefined], __read(params), false), contextStack, sourceCodeInfo), sourceCodeInfo, {
                        char: true,
                    });
                }
                return result.join('');
            }
        }
    }
    function assoc(coll, key, value, sourceCodeInfo) {
        assertColl(coll, sourceCodeInfo);
        assertStringOrNumber(key, sourceCodeInfo);
        if (Array.isArray(coll) || typeof coll === 'string') {
            assertNumber(key, sourceCodeInfo, { integer: true });
            assertNumber(key, sourceCodeInfo, { gte: 0 });
            assertNumber(key, sourceCodeInfo, { lte: coll.length });
            if (typeof coll === 'string') {
                assertString(value, sourceCodeInfo, { char: true });
                return "".concat(coll.slice(0, key)).concat(value).concat(coll.slice(key + 1));
            }
            var copy_1 = __spreadArray([], __read(coll), false);
            copy_1[key] = value;
            return copy_1;
        }
        assertString(key, sourceCodeInfo);
        var copy = __assign({}, coll);
        copy[key] = value;
        return copy;
    }
    var collectionNormalExpression = {
        'filter': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(coll)) {
                    var result = coll.filter(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                    return result;
                }
                if (isString(coll)) {
                    return coll
                        .split('')
                        .filter(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); })
                        .join('');
                }
                return Object.entries(coll)
                    .filter(function (_a) {
                    var _b = __read(_a, 2), value = _b[1];
                    return executeFunction(fn, [value], contextStack, sourceCodeInfo);
                })
                    .reduce(function (result, _a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    result[key] = value;
                    return result;
                }, {});
            },
            paramCount: 2,
        },
        'filteri': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(coll)) {
                    var result = coll.filter(function (elem, index) { return executeFunction(fn, [elem, index], contextStack, sourceCodeInfo); });
                    return result;
                }
                if (isString(coll)) {
                    return coll
                        .split('')
                        .filter(function (elem, index) { return executeFunction(fn, [elem, index], contextStack, sourceCodeInfo); })
                        .join('');
                }
                return Object.entries(coll)
                    .filter(function (_a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    return executeFunction(fn, [value, key], contextStack, sourceCodeInfo);
                })
                    .reduce(function (result, _a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    result[key] = value;
                    return result;
                }, {});
            },
            paramCount: 2,
        },
        'map': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var fn = asFunctionLike(params.at(-1), sourceCodeInfo);
                if (isObj(params[0])) {
                    return mapObjects({
                        colls: params.slice(0, -1),
                        fn: fn,
                        sourceCodeInfo: sourceCodeInfo,
                        contextStack: contextStack,
                        executeFunction: executeFunction,
                    });
                }
                var seqs = params.slice(0, -1);
                assertSeq(seqs[0], sourceCodeInfo);
                var isStr = typeof seqs[0] === 'string';
                var len = seqs[0].length;
                seqs.slice(1).forEach(function (seq) {
                    if (isStr) {
                        assertString(seq, sourceCodeInfo);
                    }
                    else {
                        assertArray(seq, sourceCodeInfo);
                    }
                    len = Math.min(len, seq.length);
                });
                var paramArray = [];
                var _loop_1 = function (i) {
                    paramArray.push(seqs.map(function (seq) { return seq[i]; }));
                };
                for (var i = 0; i < len; i++) {
                    _loop_1(i);
                }
                var mapped = paramArray.map(function (p) { return executeFunction(fn, p, contextStack, sourceCodeInfo); });
                if (!isStr) {
                    return mapped;
                }
                mapped.forEach(function (char) { return assertString(char, sourceCodeInfo); });
                return mapped.join('');
            },
            paramCount: { min: 2 },
        },
        'mapi': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(coll)) {
                    return coll.map(function (elem, index) { return executeFunction(fn, [elem, index], contextStack, sourceCodeInfo); });
                }
                if (isString(coll)) {
                    return coll
                        .split('')
                        .map(function (elem, index) { return executeFunction(fn, [elem, index], contextStack, sourceCodeInfo); })
                        .join('');
                }
                return Object.entries(coll)
                    .reduce(function (acc, _a) {
                    var _b = __read(_a, 2), key = _b[0], value = _b[1];
                    acc[key] = executeFunction(fn, [value, key], contextStack, sourceCodeInfo);
                    return acc;
                }, {});
            },
            paramCount: 2,
        },
        'reduce': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    assertString(initial, sourceCodeInfo);
                    if (coll.length === 0)
                        return initial;
                    return coll.split('').reduce(function (result, elem) {
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return initial;
                    return coll.reduce(function (result, elem) {
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return initial;
                    return Object.entries(coll).reduce(function (result, _a) {
                        var _b = __read(_a, 2), elem = _b[1];
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
            },
            paramCount: 3,
        },
        'reducei': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    assertString(initial, sourceCodeInfo);
                    if (coll.length === 0)
                        return initial;
                    return coll.split('').reduce(function (result, elem, index) {
                        return executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return initial;
                    return coll.reduce(function (result, elem, index) {
                        return executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return initial;
                    return Object.entries(coll).reduce(function (result, _a) {
                        var _b = __read(_a, 2), key = _b[0], elem = _b[1];
                        return executeFunction(fn, [result, elem, key], contextStack, sourceCodeInfo);
                    }, initial);
                }
            },
            paramCount: 3,
        },
        'reduce-right': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    if (coll.length === 0)
                        return initial;
                    return coll.split('').reduceRight(function (result, elem) {
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return initial;
                    return coll.reduceRight(function (result, elem) {
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return initial;
                    return Object.entries(coll).reduceRight(function (result, _a) {
                        var _b = __read(_a, 2), elem = _b[1];
                        return executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                    }, initial);
                }
            },
            paramCount: 3,
        },
        'reducei-right': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    if (coll.length === 0)
                        return initial;
                    return coll.split('').reduceRight(function (result, elem, index) {
                        return executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return initial;
                    return coll.reduceRight(function (result, elem, index) {
                        return executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                    }, initial);
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return initial;
                    return Object.entries(coll).reduceRight(function (result, _a) {
                        var _b = __read(_a, 2), key = _b[0], elem = _b[1];
                        return executeFunction(fn, [result, elem, key], contextStack, sourceCodeInfo);
                    }, initial);
                }
            },
            paramCount: 3,
        },
        'reductions': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    assertString(initial, sourceCodeInfo);
                    if (coll.length === 0)
                        return [initial];
                    var resultArray_1 = [initial];
                    coll.split('').reduce(function (result, elem) {
                        var newVal = executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                        resultArray_1.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_1;
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return [initial];
                    var resultArray_2 = [initial];
                    coll.reduce(function (result, elem) {
                        var newVal = executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                        resultArray_2.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_2;
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return [initial];
                    var resultArray_3 = [initial];
                    Object.entries(coll).reduce(function (result, _a) {
                        var _b = __read(_a, 2), elem = _b[1];
                        var newVal = executeFunction(fn, [result, elem], contextStack, sourceCodeInfo);
                        resultArray_3.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_3;
                }
            },
            paramCount: 3,
        },
        'reductionsi': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), coll = _c[0], fn = _c[1], initial = _c[2];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                assertAny(initial, sourceCodeInfo);
                if (typeof coll === 'string') {
                    assertString(initial, sourceCodeInfo);
                    if (coll.length === 0)
                        return [initial];
                    var resultArray_4 = [initial];
                    coll.split('').reduce(function (result, elem, index) {
                        var newVal = executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                        resultArray_4.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_4;
                }
                else if (Array.isArray(coll)) {
                    if (coll.length === 0)
                        return [initial];
                    var resultArray_5 = [initial];
                    coll.reduce(function (result, elem, index) {
                        var newVal = executeFunction(fn, [result, elem, index], contextStack, sourceCodeInfo);
                        resultArray_5.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_5;
                }
                else {
                    if (Object.keys(coll).length === 0)
                        return [initial];
                    var resultArray_6 = [initial];
                    Object.entries(coll).reduce(function (result, _a) {
                        var _b = __read(_a, 2), key = _b[0], elem = _b[1];
                        var newVal = executeFunction(fn, [result, elem, key], contextStack, sourceCodeInfo);
                        resultArray_6.push(newVal);
                        return newVal;
                    }, initial);
                    return resultArray_6;
                }
            },
            paramCount: 3,
        },
        'get': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params, 2), coll = _a[0], key = _a[1];
                var defaultValue = toAny(params[2]);
                assertStringOrNumber(key, sourceCodeInfo);
                if (coll === null)
                    return defaultValue;
                assertColl(coll, sourceCodeInfo);
                var result = get(coll, key);
                return result === undefined ? defaultValue : result;
            },
            paramCount: { min: 2, max: 3 },
        },
        'get-in': {
            evaluate: function (params, sourceCodeInfo) {
                var e_1, _a;
                var _b;
                var coll = toAny(params[0]);
                var keys = (_b = params[1]) !== null && _b !== void 0 ? _b : []; // null behaves as empty array
                var defaultValue = toAny(params[2]);
                assertArray(keys, sourceCodeInfo);
                try {
                    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                        var key = keys_1_1.value;
                        assertStringOrNumber(key, sourceCodeInfo);
                        if (isColl(coll)) {
                            var nextValue = get(coll, key);
                            if (nextValue !== undefined)
                                coll = nextValue;
                            else
                                return defaultValue;
                        }
                        else {
                            return defaultValue;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return coll;
            },
            paramCount: { min: 2, max: 3 },
        },
        'count': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), coll = _b[0];
                if (coll === null)
                    return 0;
                if (typeof coll === 'string')
                    return coll.length;
                assertColl(coll, sourceCodeInfo);
                if (Array.isArray(coll))
                    return coll.length;
                return Object.keys(coll).length;
            },
            paramCount: 1,
        },
        'contains?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), coll = _b[0], key = _b[1];
                if (coll === null)
                    return false;
                assertColl(coll, sourceCodeInfo);
                if (isString(coll)) {
                    assertString(key, sourceCodeInfo);
                    return coll.includes(key);
                }
                if (isSeq(coll)) {
                    assertAny(key, sourceCodeInfo);
                    return !!coll.find(function (elem) { return deepEqual(asAny(elem), key, sourceCodeInfo); });
                }
                assertString(key, sourceCodeInfo);
                return key in coll;
            },
            paramCount: 2,
        },
        'assoc': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), coll = _b[0], key = _b[1], value = _b[2];
                assertColl(coll, sourceCodeInfo);
                assertStringOrNumber(key, sourceCodeInfo);
                assertAny(value, sourceCodeInfo);
                return assoc(coll, key, value, sourceCodeInfo);
            },
            paramCount: 3,
        },
        'assoc-in': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), originalColl = _b[0], keys = _b[1], value = _b[2];
                assertColl(originalColl, sourceCodeInfo);
                assertArray(keys, sourceCodeInfo);
                assertAny(value, sourceCodeInfo);
                if (keys.length === 1) {
                    assertStringOrNumber(keys[0], sourceCodeInfo);
                    return assoc(originalColl, keys[0], value, sourceCodeInfo);
                }
                var _c = cloneAndGetMeta(originalColl, keys, sourceCodeInfo), coll = _c.coll, innerCollMeta = _c.innerCollMeta;
                var lastKey = asStringOrNumber(keys[keys.length - 1], sourceCodeInfo);
                var parentKey = asStringOrNumber(keys[keys.length - 2], sourceCodeInfo);
                if (Array.isArray(innerCollMeta.parent)) {
                    assertNumber(parentKey, sourceCodeInfo);
                    innerCollMeta.parent[parentKey] = assoc(innerCollMeta.coll, lastKey, value, sourceCodeInfo);
                }
                else {
                    assertString(parentKey, sourceCodeInfo);
                    innerCollMeta.parent[parentKey] = assoc(innerCollMeta.coll, lastKey, value, sourceCodeInfo);
                }
                return coll;
            },
            paramCount: 3,
        },
        'update': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a), coll = _c[0], key = _c[1], fn = _c[2], params = _c.slice(3);
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertStringOrNumber(key, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                return update(coll, key, fn, params, contextStack, executeFunction, sourceCodeInfo);
            },
            paramCount: { min: 3 },
        },
        'update-in': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a), originalColl = _c[0], keys = _c[1], fn = _c[2], params = _c.slice(3);
                var executeFunction = _b.executeFunction;
                assertColl(originalColl, sourceCodeInfo);
                assertArray(keys, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (keys.length === 1) {
                    assertStringOrNumber(keys[0], sourceCodeInfo);
                    return update(originalColl, keys[0], fn, params, contextStack, executeFunction, sourceCodeInfo);
                }
                var _d = cloneAndGetMeta(originalColl, keys, sourceCodeInfo), coll = _d.coll, innerCollMeta = _d.innerCollMeta;
                var lastKey = asStringOrNumber(keys[keys.length - 1], sourceCodeInfo);
                var parentKey = asStringOrNumber(keys[keys.length - 2], sourceCodeInfo);
                if (Array.isArray(innerCollMeta.parent)) {
                    assertNumber(parentKey, sourceCodeInfo);
                    innerCollMeta.parent[parentKey] = update(innerCollMeta.coll, lastKey, fn, params, contextStack, executeFunction, sourceCodeInfo);
                }
                else {
                    assertString(parentKey, sourceCodeInfo);
                    innerCollMeta.parent[parentKey] = update(innerCollMeta.coll, lastKey, fn, params, contextStack, executeFunction, sourceCodeInfo);
                }
                return coll;
            },
            paramCount: { min: 3 },
        },
        '++': {
            evaluate: function (params, sourceCodeInfo) {
                if (!isNumber(params[0])) {
                    assertColl(params[0], sourceCodeInfo);
                }
                if (Array.isArray(params[0])) {
                    return params.reduce(function (result, arr) {
                        assertArray(arr, sourceCodeInfo);
                        return result.concat(arr);
                    }, []);
                }
                else if (isStringOrNumber(params[0])) {
                    return params.reduce(function (result, s) {
                        assertStringOrNumber(s, sourceCodeInfo);
                        return "".concat(result).concat(s);
                    }, '');
                }
                else {
                    return params.reduce(function (result, obj) {
                        assertObj(obj, sourceCodeInfo);
                        return Object.assign(result, obj);
                    }, {});
                }
            },
            paramCount: { min: 1 },
            aliases: ['concat'],
        },
        'not-empty': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), coll = _b[0];
                if (coll === null)
                    return null;
                assertColl(coll, sourceCodeInfo);
                if (typeof coll === 'string')
                    return coll.length > 0 ? coll : null;
                if (Array.isArray(coll))
                    return coll.length > 0 ? coll : null;
                return Object.keys(coll).length > 0 ? coll : null;
            },
            paramCount: 1,
        },
        'every?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertColl(coll, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(coll))
                    return coll.every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (typeof coll === 'string')
                    return coll.split('').every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return Object.entries(coll).every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
            },
            paramCount: 2,
        },
        'any?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertColl(coll, sourceCodeInfo);
                if (Array.isArray(coll))
                    return coll.some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (typeof coll === 'string')
                    return coll.split('').some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return Object.entries(coll).some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
            },
            paramCount: 2,
        },
        'not-any?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertColl(coll, sourceCodeInfo);
                if (Array.isArray(coll))
                    return !coll.some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (typeof coll === 'string')
                    return !coll.split('').some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return !Object.entries(coll).some(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
            },
            paramCount: 2,
        },
        'not-every?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), coll = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertColl(coll, sourceCodeInfo);
                if (Array.isArray(coll))
                    return !coll.every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (typeof coll === 'string')
                    return !coll.split('').every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return !Object.entries(coll).every(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
            },
            paramCount: 2,
        },
    };

    var arrayNormalExpression = {
        'range': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params, 3), first = _a[0], second = _a[1], third = _a[2];
                var from;
                var to;
                var step;
                assertNumber(first, sourceCodeInfo, { finite: true });
                if (params.length === 1) {
                    from = 0;
                    to = first;
                    step = to >= 0 ? 1 : -1;
                }
                else if (params.length === 2) {
                    assertNumber(second, sourceCodeInfo, { finite: true });
                    from = first;
                    to = second;
                    step = to >= from ? 1 : -1;
                }
                else {
                    assertNumber(second, sourceCodeInfo, { finite: true });
                    assertNumber(third, sourceCodeInfo, { finite: true });
                    from = first;
                    to = second;
                    step = third;
                    if (to > from)
                        assertNumber(step, sourceCodeInfo, { positive: true });
                    else if (to < from)
                        assertNumber(step, sourceCodeInfo, { negative: true });
                    else
                        assertNumber(step, sourceCodeInfo, { nonZero: true });
                }
                var result = [];
                for (var i = from; step < 0 ? i > to : i < to; i += step)
                    result.push(i);
                return result;
            },
            paramCount: { min: 1, max: 3 },
        },
        'repeat': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), value = _b[0], count = _b[1];
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                var result = [];
                for (var i = 0; i < count; i += 1)
                    result.push(value);
                return result;
            },
            paramCount: 2,
        },
        'flatten': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], depth = _b[1];
                assertArray(seq, sourceCodeInfo);
                var actualDepth = depth === undefined || depth === Number.POSITIVE_INFINITY
                    ? Number.POSITIVE_INFINITY
                    : asNumber(depth, sourceCodeInfo, { integer: true, nonNegative: true });
                return seq.flat(actualDepth);
            },
            paramCount: { min: 1, max: 2 },
        },
        'mapcat': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), arr = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertArray(arr, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                return arr.map(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); }).flat(1);
            },
            paramCount: 2,
        },
        'moving-fn': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), arr = _c[0], windowSize = _c[1], fn = _c[2];
                var executeFunction = _b.executeFunction;
                assertArray(arr, sourceCodeInfo);
                assertNumber(windowSize, sourceCodeInfo, { integer: true, lte: arr.length });
                assertFunctionLike(fn, sourceCodeInfo);
                var result = [];
                for (var i = 0; i <= arr.length - windowSize; i++) {
                    var window_1 = arr.slice(i, i + windowSize);
                    var value = executeFunction(fn, [window_1], contextStack, sourceCodeInfo);
                    result.push(value);
                }
                return result;
            },
            paramCount: 3,
        },
        'running-fn': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), arr = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertArray(arr, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var result = [];
                for (var i = 0; i < arr.length; i += 1) {
                    var subArr = arr.slice(0, i + 1);
                    result.push(executeFunction(fn, [subArr], contextStack, sourceCodeInfo));
                }
                return result;
            },
            paramCount: 2,
        },
    };

    var sequenceNormalExpression = {
        'nth': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params, 2), seq = _a[0], i = _a[1];
                var defaultValue = toAny(params[2]);
                assertNumber(i, sourceCodeInfo, { integer: true });
                if (seq === null)
                    return defaultValue;
                assertSeq(seq, sourceCodeInfo);
                if (i >= 0 && i < seq.length) {
                    var result = toAny(seq[i]);
                    return result;
                }
                else {
                    return defaultValue;
                }
            },
            paramCount: { min: 2, max: 3 },
        },
        'first': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), array = _b[0];
                if (array === null)
                    return null;
                assertSeq(array, sourceCodeInfo);
                var result = toAny(array[0]);
                return result;
            },
            paramCount: 1,
        },
        'last': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), array = _b[0];
                if (array === null)
                    return null;
                assertSeq(array, sourceCodeInfo);
                var result = toAny(array.at(-1));
                return result;
            },
            paramCount: 1,
        },
        'pop': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    return seq.substring(0, seq.length - 1);
                }
                return seq.slice(0, seq.length - 1);
            },
            paramCount: 1,
        },
        'position': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    var index = seq.split('').findIndex(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                    return index !== -1 ? index : null;
                }
                else {
                    var index = seq.findIndex(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                    return index !== -1 ? index : null;
                }
            },
            paramCount: 2,
        },
        'index-of': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], value = _b[1];
                assertAny(value, sourceCodeInfo);
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertString(value, sourceCodeInfo);
                    var index = seq.indexOf(value);
                    return index !== -1 ? index : null;
                }
                else {
                    var index = seq.findIndex(function (item) { return deepEqual(asAny(item, sourceCodeInfo), value); }, sourceCodeInfo);
                    return index !== -1 ? index : null;
                }
            },
            paramCount: 2,
        },
        'last-index-of': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], value = _b[1];
                assertAny(value, sourceCodeInfo);
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertString(value, sourceCodeInfo);
                    var index = seq.lastIndexOf(value);
                    return index !== -1 ? index : null;
                }
                else {
                    var index = seq.findLastIndex(function (item) { return deepEqual(asAny(item, sourceCodeInfo), value); }, sourceCodeInfo);
                    return index !== -1 ? index : null;
                }
            },
            paramCount: 2,
        },
        'push': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), seq = _b[0], values = _b.slice(1);
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertCharArray(values, sourceCodeInfo);
                    return __spreadArray([seq], __read(values), false).join('');
                }
                else {
                    return __spreadArray(__spreadArray([], __read(seq), false), __read(values), false);
                }
            },
            paramCount: { min: 2 },
        },
        'rest': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                if (Array.isArray(seq)) {
                    if (seq.length <= 1)
                        return [];
                    return seq.slice(1);
                }
                return seq.substring(1);
            },
            paramCount: 1,
        },
        'next': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                if (Array.isArray(seq)) {
                    if (seq.length <= 1)
                        return null;
                    return seq.slice(1);
                }
                if (seq.length <= 1)
                    return null;
                return seq.substring(1);
            },
            paramCount: 1,
        },
        'reverse': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (Array.isArray(seq)) {
                    return __spreadArray([], __read(seq), false).reverse();
                }
                return seq.split('').reverse().join('');
            },
            paramCount: 1,
        },
        'second': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                return toAny(seq[1]);
            },
            paramCount: 1,
        },
        'shift': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string')
                    return seq.substring(1);
                var copy = __spreadArray([], __read(seq), false);
                copy.shift();
                return copy;
            },
            paramCount: 1,
        },
        'slice': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params, 3), seq = _a[0], from = _a[1], to = _a[2];
                assertSeq(seq, sourceCodeInfo);
                assertNumber(from, sourceCodeInfo, { integer: true });
                if (params.length === 2) {
                    if (Array.isArray(seq)) {
                        return seq.slice(from);
                    }
                    return seq.slice(from);
                }
                assertNumber(to, sourceCodeInfo, { integer: true });
                if (Array.isArray(seq)) {
                    return seq.slice(from, to);
                }
                return seq.slice(from, to);
            },
            paramCount: { min: 2, max: 3 },
        },
        'splice': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(params), seq = _a[0], start = _a[1], deleteCount = _a[2], rest = _a.slice(3);
                assertSeq(seq, sourceCodeInfo);
                assertNumber(start, sourceCodeInfo, { integer: true });
                assertNumber(deleteCount, sourceCodeInfo, { integer: true, nonNegative: true });
                var from = start < 0 ? seq.length + start : start;
                if (Array.isArray(seq)) {
                    return __spreadArray(__spreadArray(__spreadArray([], __read(seq.slice(0, from)), false), __read(rest), false), __read(seq.slice(from + deleteCount)), false);
                }
                rest.forEach(function (elem) { return assertString(elem, sourceCodeInfo); });
                return "".concat(seq.substring(0, from)).concat(rest.join('')).concat(seq.substring(from + deleteCount));
            },
            paramCount: { min: 3 },
        },
        'some': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c;
                var _d = __read(_a, 2), seq = _d[0], fn = _d[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                if (seq === null)
                    return null;
                assertSeq(seq, sourceCodeInfo);
                if (seq.length === 0)
                    return null;
                if (typeof seq === 'string')
                    return (_c = seq.split('').find(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); })) !== null && _c !== void 0 ? _c : null;
                return toAny(seq.find(function (elem) { return executeFunction(fn, [elem], contextStack, sourceCodeInfo); }));
            },
            paramCount: 2,
        },
        'sort': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var _b = __read(params, 1), seq = _b[0];
                var defaultComparer = params.length === 1;
                var comparer = defaultComparer ? null : params[1];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    var result_1 = seq.split('');
                    if (defaultComparer) {
                        result_1.sort(function (a, b) { return compare(a, b, sourceCodeInfo); });
                    }
                    else {
                        assertFunctionLike(comparer, sourceCodeInfo);
                        result_1.sort(function (a, b) {
                            var compareValue = executeFunction(comparer, [a, b], contextStack, sourceCodeInfo);
                            assertNumber(compareValue, sourceCodeInfo, { finite: true });
                            return compareValue;
                        });
                    }
                    return result_1.join('');
                }
                var result = __spreadArray([], __read(seq), false);
                if (defaultComparer) {
                    result.sort(function (a, b) {
                        assertStringOrNumber(a, sourceCodeInfo);
                        assertStringOrNumber(b, sourceCodeInfo);
                        return compare(a, b, sourceCodeInfo);
                    });
                }
                else {
                    result.sort(function (a, b) {
                        assertFunctionLike(comparer, sourceCodeInfo);
                        var compareValue = executeFunction(comparer, [a, b], contextStack, sourceCodeInfo);
                        assertNumber(compareValue, sourceCodeInfo, { finite: true });
                        return compareValue;
                    });
                }
                return result;
            },
            paramCount: { min: 1, max: 2 },
        },
        'sort-by': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var _b = __read(params, 2), seq = _b[0], keyfn = _b[1];
                var defaultComparer = params.length === 2;
                assertSeq(seq, sourceCodeInfo);
                assertFunctionLike(keyfn, sourceCodeInfo);
                var comparer = defaultComparer ? null : params[2];
                if (typeof seq === 'string') {
                    var result_2 = seq.split('');
                    if (defaultComparer) {
                        result_2.sort(function (a, b) {
                            var aKey = executeFunction(keyfn, [a], contextStack, sourceCodeInfo);
                            assertStringOrNumber(aKey, sourceCodeInfo);
                            var bKey = executeFunction(keyfn, [b], contextStack, sourceCodeInfo);
                            assertStringOrNumber(bKey, sourceCodeInfo);
                            return compare(aKey, bKey, sourceCodeInfo);
                        });
                    }
                    else {
                        assertFunctionLike(comparer, sourceCodeInfo);
                        result_2.sort(function (a, b) {
                            var aKey = executeFunction(keyfn, [a], contextStack, sourceCodeInfo);
                            var bKey = executeFunction(keyfn, [b], contextStack, sourceCodeInfo);
                            var compareValue = executeFunction(comparer, [aKey, bKey], contextStack, sourceCodeInfo);
                            assertNumber(compareValue, sourceCodeInfo, { finite: true });
                            return compareValue;
                        });
                    }
                    return result_2.join('');
                }
                var result = __spreadArray([], __read(seq), false);
                if (defaultComparer) {
                    result.sort(function (a, b) {
                        var aKey = executeFunction(keyfn, [a], contextStack, sourceCodeInfo);
                        assertStringOrNumber(aKey, sourceCodeInfo);
                        var bKey = executeFunction(keyfn, [b], contextStack, sourceCodeInfo);
                        assertStringOrNumber(bKey, sourceCodeInfo);
                        return compare(aKey, bKey, sourceCodeInfo);
                    });
                }
                else {
                    assertFunctionLike(comparer, sourceCodeInfo);
                    result.sort(function (a, b) {
                        var aKey = executeFunction(keyfn, [a], contextStack, sourceCodeInfo);
                        var bKey = executeFunction(keyfn, [b], contextStack, sourceCodeInfo);
                        var compareValue = executeFunction(comparer, [aKey, bKey], contextStack, sourceCodeInfo);
                        assertNumber(compareValue, sourceCodeInfo, { finite: true });
                        return compareValue;
                    });
                }
                return result;
            },
            paramCount: { min: 2, max: 3 },
        },
        'take': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), input = _b[0], n = _b[1];
                assertNumber(n, sourceCodeInfo);
                assertSeq(input, sourceCodeInfo);
                var num = Math.max(Math.ceil(n), 0);
                return input.slice(0, num);
            },
            paramCount: 2,
        },
        'take-last': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], n = _b[1];
                assertSeq(array, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo);
                var num = Math.max(Math.ceil(n), 0);
                var from = array.length - num;
                return array.slice(from);
            },
            paramCount: 2,
        },
        'take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_1, _c;
                var _d = __read(_a, 2), seq = _d[0], fn = _d[1];
                var executeFunction = _b.executeFunction;
                assertSeq(seq, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var result = [];
                try {
                    for (var seq_1 = __values(seq), seq_1_1 = seq_1.next(); !seq_1_1.done; seq_1_1 = seq_1.next()) {
                        var item = seq_1_1.value;
                        if (executeFunction(fn, [item], contextStack, sourceCodeInfo))
                            result.push(item);
                        else
                            break;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (seq_1_1 && !seq_1_1.done && (_c = seq_1.return)) _c.call(seq_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return typeof seq === 'string' ? result.join('') : result;
            },
            paramCount: 2,
        },
        'drop': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), input = _b[0], n = _b[1];
                assertNumber(n, sourceCodeInfo);
                var num = Math.max(Math.ceil(n), 0);
                assertSeq(input, sourceCodeInfo);
                return input.slice(num);
            },
            paramCount: 2,
        },
        'drop-last': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], n = _b[1];
                assertSeq(array, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo);
                var num = Math.max(Math.ceil(n), 0);
                var from = array.length - num;
                return array.slice(0, from);
            },
            paramCount: 2,
        },
        'drop-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertSeq(seq, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                if (Array.isArray(seq)) {
                    var from_1 = seq.findIndex(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                    return seq.slice(from_1);
                }
                var charArray = seq.split('');
                var from = charArray.findIndex(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return charArray.slice(from).join('');
            },
            paramCount: 2,
        },
        'unshift': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), seq = _b[0], values = _b.slice(1);
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertCharArray(values, sourceCodeInfo);
                    return __spreadArray(__spreadArray([], __read(values), false), [seq], false).join('');
                }
                var copy = __spreadArray([], __read(seq), false);
                copy.unshift.apply(copy, __spreadArray([], __read(values), false));
                return copy;
            },
            paramCount: { min: 2 },
        },
        'distinct': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_2, _b;
                var _c = __read(_a, 1), input = _c[0];
                assertSeq(input, sourceCodeInfo);
                if (Array.isArray(input)) {
                    var result = [];
                    var _loop_1 = function (item) {
                        assertAny(item, sourceCodeInfo);
                        if (!result.some(function (existingItem) { return deepEqual(existingItem, item, sourceCodeInfo); })) {
                            result.push(item);
                        }
                    };
                    try {
                        for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
                            var item = input_1_1.value;
                            _loop_1(item);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (input_1_1 && !input_1_1.done && (_b = input_1.return)) _b.call(input_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    return result;
                }
                return Array.from(new Set(input.split(''))).join('');
            },
            paramCount: 1,
        },
        'remove': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), input = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertSeq(input, sourceCodeInfo);
                if (Array.isArray(input))
                    return input.filter(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                return input
                    .split('')
                    .filter(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); })
                    .join('');
            },
            paramCount: 2,
        },
        'remove-at': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), input = _b[0], index = _b[1];
                assertNumber(index, sourceCodeInfo, { integer: true });
                assertSeq(input, sourceCodeInfo);
                var at = index < 0 ? input.length + index : index;
                if (at < 0 || at >= input.length)
                    return input;
                if (Array.isArray(input)) {
                    return input.filter(function (_, i) { return i !== at; });
                }
                return "".concat(input.substring(0, at)).concat(input.substring(at + 1));
            },
            paramCount: 2,
        },
        'split-at': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], pos = _b[1];
                assertNumber(pos, sourceCodeInfo, { integer: true });
                assertSeq(seq, sourceCodeInfo);
                var at = pos < 0 ? seq.length + pos : pos;
                return [seq.slice(0, at), seq.slice(at)];
            },
            paramCount: 2,
        },
        'split-with': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertSeq(seq, sourceCodeInfo);
                var seqIsArray = Array.isArray(seq);
                var arr = seqIsArray ? seq : seq.split('');
                var index = arr.findIndex(function (elem) { return !executeFunction(fn, [elem], contextStack, sourceCodeInfo); });
                if (index === -1)
                    return [seq, seqIsArray ? [] : ''];
                return [seq.slice(0, index), seq.slice(index)];
            },
            paramCount: 2,
        },
        'frequencies': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), seq = _b[0];
                assertSeq(seq, sourceCodeInfo);
                var arr = typeof seq === 'string' ? seq.split('') : seq;
                return arr.reduce(function (result, val) {
                    assertString(val, sourceCodeInfo);
                    if (collHasKey(result, val))
                        result[val] = result[val] + 1;
                    else
                        result[val] = 1;
                    return result;
                }, {});
            },
            paramCount: 1,
        },
        'group-by': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertSeq(seq, sourceCodeInfo);
                var arr = Array.isArray(seq) ? seq : seq.split('');
                return arr.reduce(function (result, val) {
                    var key = executeFunction(fn, [val], contextStack, sourceCodeInfo);
                    assertString(key, sourceCodeInfo);
                    if (!collHasKey(result, key))
                        result[key] = [];
                    result[key].push(val);
                    return result;
                }, {});
            },
            paramCount: 2,
        },
        'partition': {
            evaluate: function (params, sourceCodeInfo) {
                var seq = asSeq(params[0], sourceCodeInfo);
                var n = toNonNegativeInteger(asNumber(params[1], sourceCodeInfo));
                var step = params.length >= 3 ? toNonNegativeInteger(asNumber(params[2], sourceCodeInfo)) : n;
                var pad = params.length === 4
                    ? params[3] === null ? [] : asArray(params[3], sourceCodeInfo)
                    : undefined;
                return partition(n, step, seq, pad, sourceCodeInfo);
            },
            paramCount: { min: 2, max: 4 },
        },
        'partition-all': {
            evaluate: function (params, sourceCodeInfo) {
                var seq = asSeq(params[0], sourceCodeInfo);
                var n = toNonNegativeInteger(asNumber(params[1], sourceCodeInfo));
                var step = params.length === 3 ? toNonNegativeInteger(asNumber(params[2], sourceCodeInfo)) : n;
                return partition(n, step, seq, [], sourceCodeInfo);
            },
            paramCount: { min: 2, max: 3 },
        },
        'partition-by': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), seq = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                assertSeq(seq, sourceCodeInfo);
                var isStringSeq = typeof seq === 'string';
                var oldValue;
                var result = (isStringSeq ? seq.split('') : seq).reduce(function (acc, elem) {
                    var value = executeFunction(fn, [elem], contextStack, sourceCodeInfo);
                    if (value !== oldValue) {
                        acc.push([]);
                        oldValue = value;
                    }
                    acc[acc.length - 1].push(elem);
                    return acc;
                }, []);
                return isStringSeq ? result.map(function (elem) { return elem.join(''); }) : result;
            },
            paramCount: 2,
        },
        'ends-with?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), str = _b[0], search = _b[1];
                assertSeq(str, sourceCodeInfo);
                if (typeof str === 'string') {
                    assertString(search, sourceCodeInfo);
                    return str.endsWith(search);
                }
                return deepEqual(asAny(str.at(-1), sourceCodeInfo), asAny(search, sourceCodeInfo), sourceCodeInfo);
            },
            paramCount: 2,
        },
        'starts-with?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], search = _b[1];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertString(search, sourceCodeInfo);
                    return seq.startsWith(search);
                }
                return deepEqual(asAny(seq[0], sourceCodeInfo), asAny(search, sourceCodeInfo), sourceCodeInfo);
            },
            paramCount: 2,
        },
        'interleave': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_3, _b;
                var _c = __read(_a), seqs = _c.slice(0);
                var isStringSeq = typeof seqs[0] === 'string';
                var seqsArr = isStringSeq
                    ? seqs.map(function (seq) {
                        assertString(seq, sourceCodeInfo);
                        return seq.split('');
                    })
                    : seqs.map(function (seq) {
                        assertArray(seq, sourceCodeInfo);
                        return seq;
                    });
                var maxLength = Math.min.apply(Math, __spreadArray([], __read(seqsArr.map(function (seq) { return seq.length; })), false));
                var result = [];
                for (var i = 0; i < maxLength; i += 1) {
                    try {
                        for (var seqsArr_1 = (e_3 = void 0, __values(seqsArr)), seqsArr_1_1 = seqsArr_1.next(); !seqsArr_1_1.done; seqsArr_1_1 = seqsArr_1.next()) {
                            var seq = seqsArr_1_1.value;
                            if (i < seq.length)
                                result.push(seq[i]);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (seqsArr_1_1 && !seqsArr_1_1.done && (_b = seqsArr_1.return)) _b.call(seqsArr_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
                return isStringSeq ? result.join('') : result;
            },
            paramCount: { min: 1 },
        },
        'interpose': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), seq = _b[0], separator = _b[1];
                assertSeq(seq, sourceCodeInfo);
                if (typeof seq === 'string') {
                    assertString(separator, sourceCodeInfo);
                    return seq.split('').join(separator);
                }
                if (seq.length === 0)
                    return [];
                var result = [];
                for (var i = 0; i < seq.length - 1; i += 1) {
                    result.push(seq[i], separator);
                }
                result.push(seq[seq.length - 1]);
                return result;
            },
            paramCount: 2,
        },
    };
    function partition(n, step, seq, pad, sourceCodeInfo) {
        assertNumber(step, sourceCodeInfo, { positive: true });
        var isStringSeq = typeof seq === 'string';
        var result = [];
        var start = 0;
        outer: while (start < seq.length) {
            var innerArr = [];
            for (var i = start; i < start + n; i += 1) {
                if (i >= seq.length) {
                    var padIndex = i - seq.length;
                    if (!pad) {
                        start += step;
                        continue outer;
                    }
                    if (padIndex >= pad.length)
                        break;
                    innerArr.push(pad[padIndex]);
                }
                else {
                    innerArr.push(seq[i]);
                }
            }
            result.push(innerArr);
            start += step;
        }
        return isStringSeq ? result.map(function (x) { return x.join(''); }) : result;
    }

    function getNumberVectorOrMatrixOperation(params, sourceCodeInfo) {
        var e_1, _a, e_2, _b, e_3, _c;
        var hasVector = false;
        var hasMatrix = false;
        try {
            for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                var param = params_1_1.value;
                if (isVector(param)) {
                    hasVector = true;
                }
                else if (isMatrix(param)) {
                    hasMatrix = true;
                }
                else if (!isNumber(param)) {
                    throw new LitsError("Invalid parameter type: ".concat(typeof param), sourceCodeInfo);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (hasMatrix) {
            if (hasVector) {
                throw new LitsError('Cannot mix vector and matrix types', sourceCodeInfo);
            }
            var rows_1 = null;
            var cold_1 = null;
            try {
                for (var params_2 = __values(params), params_2_1 = params_2.next(); !params_2_1.done; params_2_1 = params_2.next()) {
                    var param = params_2_1.value;
                    if (isMatrix(param)) {
                        if (rows_1 === null) {
                            rows_1 = param.length;
                            cold_1 = param[0].length;
                        }
                        else {
                            if (param.length !== rows_1 || param[0].length !== cold_1) {
                                throw new LitsError('Matrix dimensions do not match', sourceCodeInfo);
                            }
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (params_2_1 && !params_2_1.done && (_b = params_2.return)) _b.call(params_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var matrices = params.map(function (param) {
                if (isMatrix(param)) {
                    return param;
                }
                return Array.from({ length: rows_1 }, function () { return Array.from({ length: cold_1 }, function () { return param; }); });
            });
            return ['matrix', matrices];
        }
        if (hasVector) {
            var length_1 = null;
            try {
                for (var params_3 = __values(params), params_3_1 = params_3.next(); !params_3_1.done; params_3_1 = params_3.next()) {
                    var param = params_3_1.value;
                    if (isVector(param)) {
                        if (length_1 === null) {
                            length_1 = param.length;
                        }
                        else {
                            if (param.length !== length_1) {
                                throw new LitsError('Vector lengths do not match', sourceCodeInfo);
                            }
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (params_3_1 && !params_3_1.done && (_c = params_3.return)) _c.call(params_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
            var vectors = params.map(function (param) {
                if (isVector(param)) {
                    return param;
                }
                return Array.from({ length: length_1 }, function () { return param; });
            });
            return ['vector', vectors];
        }
        return ['number', params];
    }
    var mathNormalExpression = {
        'inc': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands[0] + 1;
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    return firstVector.map(function (val) { return val + 1; });
                }
                else {
                    var firstMatrix = operands[0];
                    return firstMatrix.map(function (row) { return row.map(function (val) { return val + 1; }); });
                }
            },
            paramCount: 1,
        },
        'dec': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands[0] - 1;
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    return firstVector.map(function (val) { return val - 1; });
                }
                else {
                    var firstMatrix = operands[0];
                    return firstMatrix.map(function (row) { return row.map(function (val) { return val - 1; }); });
                }
            },
            paramCount: 1,
        },
        '+': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0) {
                    return 0;
                }
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands.reduce(function (result, param) { return result + (param); }, 0);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var restVectors = operands.slice(1);
                    return restVectors.reduce(function (acc, vector) { return acc.map(function (val, i) { return val + vector[i]; }); }, firstVector);
                }
                else {
                    var firstMatrix = operands[0];
                    var restMatrices = operands.slice(1);
                    return restMatrices.reduce(function (acc, matrix) { return acc.map(function (row, i) { return row.map(function (val, j) { return val + matrix[i][j]; }); }); }, firstMatrix);
                }
            },
            paramCount: {},
        },
        '*': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0) {
                    return 1;
                }
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands.reduce(function (result, param) { return result * (param); }, 1);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var restVectors = operands.slice(1);
                    return restVectors.reduce(function (acc, vector) { return acc.map(function (val, i) { return val * vector[i]; }); }, firstVector);
                }
                else {
                    var firstMatrix = operands[0];
                    var restMatrices = operands.slice(1);
                    return restMatrices.reduce(function (acc, matrix) { return acc.map(function (row, i) { return row.map(function (val, j) { return val * matrix[i][j]; }); }); }, firstMatrix);
                }
            },
            aliases: ['·'],
            paramCount: {},
        },
        '/': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0) {
                    return 1;
                }
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    var _b = __read(operands), first = _b[0], rest = _b.slice(1);
                    if (rest.length === 0) {
                        return 1 / first;
                    }
                    return rest.reduce(function (result, param) {
                        return result / param;
                    }, first);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var restVectors = operands.slice(1);
                    return restVectors.reduce(function (acc, vector) { return acc.map(function (val, i) { return val / vector[i]; }); }, firstVector);
                }
                else {
                    var firstMatrix = operands[0];
                    var restMatrices = operands.slice(1);
                    return restMatrices.reduce(function (acc, matrix) { return acc.map(function (row, i) { return row.map(function (val, j) { return val / matrix[i][j]; }); }); }, firstMatrix);
                }
            },
            paramCount: {},
        },
        '-': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0) {
                    return 0;
                }
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    var _b = __read(operands), first = _b[0], rest = _b.slice(1);
                    if (rest.length === 0)
                        return -first;
                    return rest.reduce(function (result, param) {
                        return result - param;
                    }, first);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var restVectors = operands.slice(1);
                    return restVectors.reduce(function (acc, vector) { return acc.map(function (val, i) { return val - vector[i]; }); }, firstVector);
                }
                else {
                    var firstMatrix = operands[0];
                    var restMatrices = operands.slice(1);
                    return restMatrices.reduce(function (acc, matrix) { return acc.map(function (row, i) { return row.map(function (val, j) { return val - matrix[i][j]; }); }); }, firstMatrix);
                }
            },
            paramCount: {},
        },
        'quot': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.trunc(operands[0] / operands[1]);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var secondVector_1 = operands[1];
                    return firstVector.map(function (val, i) { return Math.trunc(val / secondVector_1[i]); });
                }
                else {
                    var firstMatrix = operands[0];
                    var secondMatrix_1 = operands[1];
                    return firstMatrix.map(function (row, i) { return row.map(function (val, j) { return Math.trunc(val / secondMatrix_1[i][j]); }); });
                }
            },
            paramCount: 2,
        },
        'mod': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    var quotient = Math.floor(operands[0] / operands[1]);
                    return operands[0] - operands[1] * quotient;
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var secondVector_2 = operands[1];
                    return firstVector.map(function (dividend, i) {
                        var divisor = secondVector_2[i];
                        var quotient = Math.floor(dividend / divisor);
                        return dividend - divisor * quotient;
                    });
                }
                else {
                    var firstMatrix = operands[0];
                    var secondMatrix_2 = operands[1];
                    return firstMatrix.map(function (row, i) { return row.map(function (val, j) {
                        var quotient = Math.floor(val / secondMatrix_2[i][j]);
                        return val - secondMatrix_2[i][j] * quotient;
                    }); });
                }
            },
            paramCount: 2,
        },
        '%': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return operands[0] % operands[1];
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var secondVector_3 = operands[1];
                    return firstVector.map(function (dividend, i) { return dividend % secondVector_3[i]; });
                }
                else {
                    var firstMatrix = operands[0];
                    var secondMatrix_3 = operands[1];
                    return firstMatrix.map(function (row, i) { return row.map(function (dividend, j) { return dividend % secondMatrix_3[i][j]; }); });
                }
            },
            paramCount: 2,
            aliases: ['rem'],
        },
        'sqrt': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.sqrt(operands[0]);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    return firstVector.map(function (val) { return Math.sqrt(val); });
                }
                else {
                    var firstMatrix = operands[0];
                    return firstMatrix.map(function (row) { return row.map(function (val) { return Math.sqrt(val); }); });
                }
            },
            paramCount: 1,
            aliases: ['√'],
        },
        'cbrt': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.cbrt(operands[0]);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    return firstVector.map(function (val) { return Math.cbrt(val); });
                }
                else {
                    var firstMatrix = operands[0];
                    return firstMatrix.map(function (row) { return row.map(function (val) { return Math.cbrt(val); }); });
                }
            },
            paramCount: 1,
            aliases: ['∛'],
        },
        '^': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.pow(operands[0], operands[1]);
                }
                else if (operation === 'vector') {
                    var firstVector = operands[0];
                    var secondVector_4 = operands[1];
                    return firstVector.map(function (base, i) { return Math.pow(base, secondVector_4[i]); });
                }
                else {
                    var firstMatrix = operands[0];
                    var secondMatrix_4 = operands[1];
                    return firstMatrix.map(function (row, i) { return row.map(function (base, j) { return Math.pow(base, secondMatrix_4[i][j]); }); });
                }
            },
            paramCount: 2,
        },
        'round': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), value = _b[0], decimals = _b[1];
                var _c = __read(getNumberVectorOrMatrixOperation([value], sourceCodeInfo), 2), operation = _c[0], operands = _c[1];
                if (operation === 'number') {
                    if (decimals === undefined || decimals === 0) {
                        return Math.round(operands[0]);
                    }
                    else {
                        assertNumber(decimals, sourceCodeInfo, { integer: true, positive: true });
                        var factor = Math.pow(10, decimals);
                        return Math.round(operands[0] * factor) / factor;
                    }
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    if (decimals === undefined || decimals === 0) {
                        return vector.map(function (val) { return Math.round(val); });
                    }
                    else {
                        assertNumber(decimals, sourceCodeInfo, { integer: true, positive: true });
                        var factor_1 = Math.pow(10, decimals);
                        return vector.map(function (val) { return Math.round(val * factor_1) / factor_1; });
                    }
                }
                else {
                    var matrix = operands[0];
                    if (decimals === undefined || decimals === 0) {
                        return matrix.map(function (row) { return row.map(function (val) { return Math.round(val); }); });
                    }
                    else {
                        assertNumber(decimals, sourceCodeInfo, { integer: true, positive: true });
                        var factor_2 = Math.pow(10, decimals);
                        return matrix.map(function (row) { return row.map(function (val) { return Math.round(val * factor_2) / factor_2; }); });
                    }
                }
            },
            paramCount: { min: 1, max: 2 },
        },
        'trunc': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.trunc(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.trunc(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.trunc(val); }); });
                }
            },
            paramCount: 1,
        },
        'floor': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.floor(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.floor(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.floor(val); }); });
                }
            },
            paramCount: 1,
        },
        'ceil': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.ceil(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.ceil(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.ceil(val); }); });
                }
            },
            paramCount: 1,
        },
        'min': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo);
                if (rest.length === 0)
                    return first;
                return rest.reduce(function (min, value) {
                    assertNumber(value, sourceCodeInfo);
                    return Math.min(min, value);
                }, first);
            },
            paramCount: { min: 1 },
        },
        'max': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), first = _b[0], rest = _b.slice(1);
                assertNumber(first, sourceCodeInfo);
                if (rest.length === 0)
                    return first;
                return rest.reduce(function (min, value) {
                    assertNumber(value, sourceCodeInfo);
                    return Math.max(min, value);
                }, first);
            },
            paramCount: { min: 1 },
        },
        'abs': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.abs(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.abs(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.abs(val); }); });
                }
            },
            paramCount: 1,
        },
        'sign': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.sign(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.sign(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.sign(val); }); });
                }
            },
            paramCount: 1,
        },
        'ln': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.log(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.log(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.log(val); }); });
                }
            },
            paramCount: 1,
        },
        'log2': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.log2(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.log2(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.log2(val); }); });
                }
            },
            paramCount: 1,
            aliases: ['log₂'],
        },
        'log10': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.log10(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.log10(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.log10(val); }); });
                }
            },
            paramCount: 1,
            aliases: ['log₁₀'],
        },
        'sin': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.sin(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.sin(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.sin(val); }); });
                }
            },
            paramCount: 1,
        },
        'asin': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.asin(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.asin(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.asin(val); }); });
                }
            },
            paramCount: 1,
        },
        'sinh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.sinh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.sinh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.sinh(val); }); });
                }
            },
            paramCount: 1,
        },
        'asinh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.asinh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.asinh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.asinh(val); }); });
                }
            },
            paramCount: 1,
        },
        'cos': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.cos(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.cos(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.cos(val); }); });
                }
            },
            paramCount: 1,
        },
        'acos': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.acos(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.acos(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.acos(val); }); });
                }
            },
            paramCount: 1,
        },
        'cosh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.cosh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.cosh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.cosh(val); }); });
                }
            },
            paramCount: 1,
        },
        'acosh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.acosh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.acosh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.acosh(val); }); });
                }
            },
            paramCount: 1,
        },
        'tan': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.tan(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.tan(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.tan(val); }); });
                }
            },
            paramCount: 1,
        },
        'atan': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.atan(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.atan(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.atan(val); }); });
                }
            },
            paramCount: 1,
        },
        'tanh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.tanh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.tanh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.tanh(val); }); });
                }
            },
            paramCount: 1,
        },
        'atanh': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return Math.atanh(operands[0]);
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return Math.atanh(val); });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return Math.atanh(val); }); });
                }
            },
            paramCount: 1,
        },
        'to-rad': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return (operands[0] * Math.PI) / 180;
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return (val * Math.PI) / 180; });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return (val * Math.PI) / 180; }); });
                }
            },
            paramCount: 1,
        },
        'to-deg': {
            evaluate: function (params, sourceCodeInfo) {
                var _a = __read(getNumberVectorOrMatrixOperation(params, sourceCodeInfo), 2), operation = _a[0], operands = _a[1];
                if (operation === 'number') {
                    return (operands[0] * 180) / Math.PI;
                }
                else if (operation === 'vector') {
                    var vector = operands[0];
                    return vector.map(function (val) { return (val * 180) / Math.PI; });
                }
                else {
                    var matrix = operands[0];
                    return matrix.map(function (row) { return row.map(function (val) { return (val * 180) / Math.PI; }); });
                }
            },
            paramCount: 1,
        },
    };

    function isEqual(_a, sourceCodeInfo) {
        var e_1, _b;
        var _c = __read(_a), first = _c[0], rest = _c.slice(1);
        var firstAny = asAny(first, sourceCodeInfo);
        try {
            for (var rest_1 = __values(rest), rest_1_1 = rest_1.next(); !rest_1_1.done; rest_1_1 = rest_1.next()) {
                var param = rest_1_1.value;
                if (!deepEqual(firstAny, asAny(param, sourceCodeInfo), sourceCodeInfo))
                    return false;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (rest_1_1 && !rest_1_1.done && (_b = rest_1.return)) _b.call(rest_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    }
    function isIdentical(_a) {
        var e_2, _b;
        var _c = __read(_a), first = _c[0], rest = _c.slice(1);
        try {
            for (var rest_2 = __values(rest), rest_2_1 = rest_2.next(); !rest_2_1.done; rest_2_1 = rest_2.next()) {
                var param = rest_2_1.value;
                if (param !== first)
                    return false;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (rest_2_1 && !rest_2_1.done && (_b = rest_2.return)) _b.call(rest_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return true;
    }
    var miscNormalExpression = {
        '==': {
            evaluate: function (params, sourceCodeInfo) {
                return isEqual(params, sourceCodeInfo);
            },
            paramCount: { min: 1 },
        },
        '≠': {
            evaluate: function (params, sourceCodeInfo) {
                return !isEqual(params, sourceCodeInfo);
            },
            paramCount: { min: 1 },
            aliases: ['!='],
        },
        'identical?': {
            evaluate: function (params) {
                return isIdentical(params);
            },
            paramCount: { min: 1 },
        },
        '>': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_3, _b;
                var _c = __read(_a), first = _c[0], rest = _c.slice(1);
                var currentValue = asStringOrNumber(first);
                try {
                    for (var rest_3 = __values(rest), rest_3_1 = rest_3.next(); !rest_3_1.done; rest_3_1 = rest_3.next()) {
                        var param = rest_3_1.value;
                        if (compare(currentValue, asStringOrNumber(param), sourceCodeInfo) <= 0)
                            return false;
                        currentValue = asStringOrNumber(param);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (rest_3_1 && !rest_3_1.done && (_b = rest_3.return)) _b.call(rest_3);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return true;
            },
            paramCount: { min: 1 },
        },
        '<': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_4, _b;
                var _c = __read(_a), first = _c[0], rest = _c.slice(1);
                var currentValue = asStringOrNumber(first);
                try {
                    for (var rest_4 = __values(rest), rest_4_1 = rest_4.next(); !rest_4_1.done; rest_4_1 = rest_4.next()) {
                        var param = rest_4_1.value;
                        if (compare(currentValue, asStringOrNumber(param), sourceCodeInfo) >= 0)
                            return false;
                        currentValue = asStringOrNumber(param);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (rest_4_1 && !rest_4_1.done && (_b = rest_4.return)) _b.call(rest_4);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                return true;
            },
            paramCount: { min: 1 },
        },
        '≥': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_5, _b;
                var _c = __read(_a), first = _c[0], rest = _c.slice(1);
                var currentValue = asStringOrNumber(first);
                try {
                    for (var rest_5 = __values(rest), rest_5_1 = rest_5.next(); !rest_5_1.done; rest_5_1 = rest_5.next()) {
                        var param = rest_5_1.value;
                        if (compare(currentValue, asStringOrNumber(param), sourceCodeInfo) < 0)
                            return false;
                        currentValue = asStringOrNumber(param);
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (rest_5_1 && !rest_5_1.done && (_b = rest_5.return)) _b.call(rest_5);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                return true;
            },
            paramCount: { min: 1 },
            aliases: ['>='],
        },
        '≤': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_6, _b;
                var _c = __read(_a), first = _c[0], rest = _c.slice(1);
                var currentValue = asStringOrNumber(first);
                try {
                    for (var rest_6 = __values(rest), rest_6_1 = rest_6.next(); !rest_6_1.done; rest_6_1 = rest_6.next()) {
                        var param = rest_6_1.value;
                        if (compare(currentValue, asStringOrNumber(param), sourceCodeInfo) > 0)
                            return false;
                        currentValue = asStringOrNumber(param);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (rest_6_1 && !rest_6_1.done && (_b = rest_6.return)) _b.call(rest_6);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                return true;
            },
            paramCount: { min: 1 },
            aliases: ['<='],
        },
        '!': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return !first;
            },
            paramCount: 1,
        },
        'epoch->iso-date': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), ms = _b[0];
                assertNumber(ms, sourceCodeInfo);
                return new Date(ms).toISOString();
            },
            paramCount: 1,
        },
        'iso-date->epoch': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), dateTime = _b[0];
                assertString(dateTime, sourceCodeInfo);
                var ms = new Date(dateTime).valueOf();
                assertNumber(ms, sourceCodeInfo, { finite: true });
                return ms;
            },
            paramCount: 1,
        },
        'write!': {
            evaluate: function (params, sourceCodeInfo) {
                // eslint-disable-next-line no-console
                console.log.apply(console, __spreadArray([], __read(params), false));
                if (params.length > 0)
                    return asAny(params[params.length - 1], sourceCodeInfo);
                return null;
            },
            paramCount: {},
        },
        'boolean': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return !!value;
            },
            paramCount: 1,
        },
        'compare': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertStringOrNumber(a, sourceCodeInfo);
                assertStringOrNumber(b, sourceCodeInfo);
                return compare(a, b, sourceCodeInfo);
            },
            paramCount: 2,
        },
        'json-parse': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertString(first, sourceCodeInfo);
                // eslint-disable-next-line ts/no-unsafe-return
                return JSON.parse(first);
            },
            paramCount: 1,
        },
        'json-stringify': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], second = _b[1];
                assertAny(first, sourceCodeInfo);
                if (second === undefined)
                    return JSON.stringify(first);
                assertNumber(second, sourceCodeInfo);
                return JSON.stringify(first, null, second);
            },
            paramCount: { min: 1, max: 2 },
        },
    };

    var assertNormalExpression = {
        'assert': {
            evaluate: function (params, sourceCodeInfo) {
                var value = params[0];
                var message = params.length === 2 ? params[1] : "".concat(value);
                assertString(message, sourceCodeInfo);
                if (!value)
                    throw new AssertionError(message, sourceCodeInfo);
                return asAny(value, sourceCodeInfo);
            },
            paramCount: { min: 1, max: 2 },
        },
        'assert=': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (!deepEqual(asAny(first, sourceCodeInfo), asAny(second, sourceCodeInfo), sourceCodeInfo)) {
                    throw new AssertionError("Expected ".concat(JSON.stringify(first, null, 2), " to deep equal ").concat(JSON.stringify(second, null, 2), ".").concat(message), sourceCodeInfo);
                }
                return null;
            },
            paramCount: { min: 2, max: 3 },
        },
        'assert!=': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (deepEqual(asAny(first, sourceCodeInfo), asAny(second, sourceCodeInfo), sourceCodeInfo)) {
                    throw new AssertionError("Expected ".concat(JSON.stringify(first), " not to deep equal ").concat(JSON.stringify(second), ".").concat(message), sourceCodeInfo);
                }
                return null;
            },
            paramCount: { min: 2, max: 3 },
        },
        'assert-gt': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                assertStringOrNumber(first, sourceCodeInfo);
                assertStringOrNumber(second, sourceCodeInfo);
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (compare(first, second, sourceCodeInfo) <= 0)
                    throw new AssertionError("Expected ".concat(first, " to be grater than ").concat(second, ".").concat(message), sourceCodeInfo);
                return null;
            },
            paramCount: { min: 2, max: 3 },
        },
        'assert-gte': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                assertStringOrNumber(first, sourceCodeInfo);
                assertStringOrNumber(second, sourceCodeInfo);
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (compare(first, second, sourceCodeInfo) < 0)
                    throw new AssertionError("Expected ".concat(first, " to be grater than or equal to ").concat(second, ".").concat(message), sourceCodeInfo);
                return null;
            },
            paramCount: { min: 2, max: 3 },
        },
        'assert-lt': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                assertStringOrNumber(first, sourceCodeInfo);
                assertStringOrNumber(second, sourceCodeInfo);
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (compare(first, second, sourceCodeInfo) >= 0)
                    throw new AssertionError("Expected ".concat(first, " to be less than ").concat(second, ".").concat(message), sourceCodeInfo);
                return null;
            },
            paramCount: { min: 2, max: 3 },
        },
        'assert-lte': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), first = _b[0], second = _b[1], message = _b[2];
                assertStringOrNumber(first, sourceCodeInfo);
                assertStringOrNumber(second, sourceCodeInfo);
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (compare(first, second, sourceCodeInfo) > 0)
                    throw new AssertionError("Expected ".concat(first, " to be less than or equal to ").concat(second, ".").concat(message), sourceCodeInfo);
                return null;
            },
            paramCount: { min: 2, max: 3 },
        },
        'assert-true': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (first !== true)
                    throw new AssertionError("Expected ".concat(first, " to be true.").concat(message), sourceCodeInfo);
                return null;
            },
            paramCount: { min: 1, max: 2 },
        },
        'assert-false': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (first !== false)
                    throw new AssertionError("Expected ".concat(first, " to be false.").concat(message), sourceCodeInfo);
                return null;
            },
            paramCount: { min: 1, max: 2 },
        },
        'assert-truthy': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (!first)
                    throw new AssertionError("Expected ".concat(first, " to be truthy.").concat(message), sourceCodeInfo);
                return null;
            },
            paramCount: { min: 1, max: 2 },
        },
        'assert-falsy': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (first)
                    throw new AssertionError("Expected ".concat(first, " to be falsy.").concat(message), sourceCodeInfo);
                return null;
            },
            paramCount: { min: 1, max: 2 },
        },
        'assert-null': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), first = _b[0], message = _b[1];
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                if (first !== null)
                    throw new AssertionError("Expected ".concat(first, " to be null.").concat(message), sourceCodeInfo);
                return null;
            },
            paramCount: { min: 1, max: 2 },
        },
        'assert-throws': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), func = _c[0], message = _c[1];
                var executeFunction = _b.executeFunction;
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                assertFunctionLike(func, sourceCodeInfo);
                try {
                    executeFunction(func, [], contextStack, sourceCodeInfo);
                }
                catch (_d) {
                    return null;
                }
                throw new AssertionError("Expected function to throw.".concat(message), sourceCodeInfo);
            },
            paramCount: { min: 1, max: 2 },
        },
        'assert-throws-error': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), func = _c[0], throwMessage = _c[1], message = _c[2];
                var executeFunction = _b.executeFunction;
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                assertString(throwMessage, sourceCodeInfo);
                assertFunctionLike(func, sourceCodeInfo);
                try {
                    executeFunction(func, [], contextStack, sourceCodeInfo);
                }
                catch (error) {
                    var errorMessage = error.shortMessage;
                    if (errorMessage !== throwMessage) {
                        throw new AssertionError("Expected function to throw \"".concat(throwMessage, "\", but thrown \"").concat(errorMessage, "\".").concat(message), sourceCodeInfo);
                    }
                    return null;
                }
                throw new AssertionError("Expected function to throw \"".concat(throwMessage, "\".").concat(message), sourceCodeInfo);
            },
            paramCount: { min: 2, max: 3 },
        },
        'assert-not-throws': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), func = _c[0], message = _c[1];
                var executeFunction = _b.executeFunction;
                if (message !== undefined) {
                    assertString(message, sourceCodeInfo);
                }
                message !== null && message !== void 0 ? message : (message = '');
                assertFunctionLike(func, sourceCodeInfo);
                try {
                    executeFunction(func, [], contextStack, sourceCodeInfo);
                }
                catch (_d) {
                    throw new AssertionError("Expected function not to throw.".concat(message), sourceCodeInfo);
                }
                return null;
            },
            paramCount: { min: 1, max: 2 },
        },
    };

    var objectNormalExpression = {
        'keys': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), obj = _b[0];
                assertObj(obj, sourceCodeInfo);
                return Object.keys(obj);
            },
            paramCount: 1,
        },
        'vals': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), obj = _b[0];
                assertObj(obj, sourceCodeInfo);
                return Object.values(obj);
            },
            paramCount: 1,
        },
        'entries': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), obj = _b[0];
                assertObj(obj, sourceCodeInfo);
                return Object.entries(obj);
            },
            paramCount: 1,
        },
        'find': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), obj = _b[0], key = _b[1];
                assertObj(obj, sourceCodeInfo);
                assertString(key, sourceCodeInfo);
                if (collHasKey(obj, key))
                    return [key, obj[key]];
                return null;
            },
            paramCount: 2,
        },
        'dissoc': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), obj = _b[0], key = _b[1];
                assertObj(obj, sourceCodeInfo);
                assertString(key, sourceCodeInfo);
                var newObj = __assign({}, obj);
                delete newObj[key];
                return newObj;
            },
            paramCount: 2,
        },
        'merge': {
            evaluate: function (params, sourceCodeInfo) {
                if (params.length === 0)
                    return null;
                var _a = __read(params), first = _a[0], rest = _a.slice(1);
                assertObj(first, sourceCodeInfo);
                return rest.reduce(function (result, obj) {
                    assertObj(obj, sourceCodeInfo);
                    return __assign(__assign({}, result), obj);
                }, __assign({}, first));
            },
            paramCount: { min: 0 },
        },
        'merge-with': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var first = params[0];
                var fn = params.at(-1);
                var rest = params.slice(1, -1);
                assertObj(first, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                return rest.reduce(function (result, obj) {
                    assertObj(obj, sourceCodeInfo);
                    Object.entries(obj).forEach(function (entry) {
                        var key = asString(entry[0], sourceCodeInfo);
                        var val = toAny(entry[1]);
                        if (collHasKey(result, key))
                            result[key] = executeFunction(fn, [result[key], val], contextStack, sourceCodeInfo);
                        else
                            result[key] = val;
                    });
                    return result;
                }, __assign({}, first));
            },
            paramCount: { min: 2 },
        },
        'zipmap': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), keys = _b[0], values = _b[1];
                assertStringArray(keys, sourceCodeInfo);
                assertArray(values, sourceCodeInfo);
                var length = Math.min(keys.length, values.length);
                var result = {};
                for (var i = 0; i < length; i += 1) {
                    var key = asString(keys[i], sourceCodeInfo);
                    result[key] = toAny(values[i]);
                }
                return result;
            },
            paramCount: 2,
        },
        'select-keys': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), obj = _b[0], keys = _b[1];
                assertStringArray(keys, sourceCodeInfo);
                assertObj(obj, sourceCodeInfo);
                return keys.reduce(function (result, key) {
                    if (collHasKey(obj, key))
                        result[key] = toAny(obj[key]);
                    return result;
                }, {});
            },
            paramCount: 2,
        },
    };

    var predicatesNormalExpression = {
        'function?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return isLitsFunction(first);
            },
            paramCount: 1,
        },
        'string?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return typeof first === 'string';
            },
            paramCount: 1,
        },
        'number?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return typeof first === 'number';
            },
            paramCount: 1,
        },
        'integer?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return typeof first === 'number' && isNumber(first, { integer: true });
            },
            paramCount: 1,
        },
        'boolean?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return typeof first === 'boolean';
            },
            paramCount: 1,
        },
        'null?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return first === null || first === undefined;
            },
            paramCount: 1,
        },
        'zero?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertNumber(value, sourceCodeInfo, { finite: true });
                return Math.abs(value) < EPSILON;
            },
            paramCount: 1,
        },
        'pos?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertNumber(first, sourceCodeInfo, { finite: true });
                return first > 0;
            },
            paramCount: 1,
        },
        'neg?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertNumber(first, sourceCodeInfo, { finite: true });
                return first < 0;
            },
            paramCount: 1,
        },
        'even?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertNumber(first, sourceCodeInfo, { finite: true });
                return first % 2 === 0;
            },
            paramCount: 1,
        },
        'odd?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), first = _b[0];
                assertNumber(first, sourceCodeInfo, { finite: true });
                return isNumber(first, { integer: true }) && first % 2 !== 0;
            },
            paramCount: 1,
        },
        'array?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return Array.isArray(first);
            },
            paramCount: 1,
        },
        'coll?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return isColl(first);
            },
            paramCount: 1,
        },
        'seq?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return isSeq(first);
            },
            paramCount: 1,
        },
        'object?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), first = _b[0];
                return isObj(first);
            },
            paramCount: 1,
        },
        'regexp?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return isRegularExpression(value);
            },
            paramCount: 1,
        },
        'finite?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertNumber(value, sourceCodeInfo);
                return Number.isFinite(value);
            },
            paramCount: 1,
        },
        'positive-infinity?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertNumber(value, sourceCodeInfo);
                return value === Number.POSITIVE_INFINITY;
            },
            paramCount: 1,
        },
        'negative-infinity?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertNumber(value, sourceCodeInfo);
                return value === Number.NEGATIVE_INFINITY;
            },
            paramCount: 1,
        },
        'true?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return value === true;
            },
            paramCount: 1,
        },
        'false?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return value === false;
            },
            paramCount: 1,
        },
        'empty?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), coll = _b[0];
                if (coll === null)
                    return true;
                assertColl(coll, sourceCodeInfo);
                if (typeof coll === 'string')
                    return coll.length === 0;
                if (Array.isArray(coll))
                    return coll.length === 0;
                return Object.keys(coll).length === 0;
            },
            paramCount: 1,
        },
        'not-empty?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), coll = _b[0];
                if (coll === null)
                    return false;
                assertColl(coll, sourceCodeInfo);
                if (typeof coll === 'string')
                    return coll.length > 0;
                if (Array.isArray(coll))
                    return coll.length > 0;
                return Object.keys(coll).length > 0;
            },
            paramCount: 1,
        },
        'vector?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), vector = _b[0];
                return isVector(vector);
            },
            paramCount: 1,
        },
        'matrix?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), matrix = _b[0];
                return isMatrix(matrix);
            },
            paramCount: 1,
        },
        'grid?': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), table = _b[0];
                return isGrid(table);
            },
            paramCount: 1,
        },
    };

    var regexpNormalExpression = {
        'regexp': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a, 2), sourceArg = _c[0], flagsArg = _c[1];
                assertString(sourceArg, sourceCodeInfo);
                var source = sourceArg || '(?:)';
                var flags = typeof flagsArg === 'string' ? flagsArg : '';
                try {
                    // eslint-disable-next-line no-new
                    new RegExp(source, flags); // Throws if invalid regexp
                }
                catch (e) {
                    throw new LitsError("Invalid regular expression: ".concat(source, " ").concat(flags), sourceCodeInfo);
                }
                return _b = {},
                    _b[REGEXP_SYMBOL] = true,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b.s = source,
                    _b.f = flags,
                    _b;
            },
            paramCount: { min: 1, max: 2 },
        },
        'match': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), text = _b[0], regexp = _b[1];
                assertRegularExpression(regexp, sourceCodeInfo);
                if (!isString(text))
                    return null;
                var regExp = new RegExp(regexp.s, regexp.f);
                var match = regExp.exec(text);
                if (match)
                    return __spreadArray([], __read(match), false);
                return null;
            },
            paramCount: 2,
        },
        'replace': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], regexp = _b[1], value = _b[2];
                assertString(str, sourceCodeInfo);
                assertStringOrRegularExpression(regexp, sourceCodeInfo);
                assertString(value, sourceCodeInfo);
                var matcher = isRegularExpression(regexp) ? new RegExp(regexp.s, "".concat(regexp.f)) : regexp;
                return str.replace(matcher, value);
            },
            paramCount: 3,
        },
        'replace-all': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], regexp = _b[1], value = _b[2];
                assertString(str, sourceCodeInfo);
                assertStringOrRegularExpression(regexp, sourceCodeInfo);
                assertString(value, sourceCodeInfo);
                var matcher = isRegularExpression(regexp) ? new RegExp(regexp.s, "".concat(regexp.f.includes('g') ? regexp.f : "".concat(regexp.f, "g"))) : regexp;
                return str.replaceAll(matcher, value);
            },
            paramCount: 3,
        },
    };

    var blankRegexp = /^\s*$/;
    var stringNormalExpression = {
        'string-repeat': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), str = _b[0], count = _b[1];
                assertString(str, sourceCodeInfo);
                assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                return str.repeat(count);
            },
            paramCount: 2,
        },
        'str': {
            evaluate: function (params) {
                return params.reduce(function (result, param) {
                    var paramStr = param === undefined || param === null
                        ? ''
                        : isObj(param)
                            ? JSON.stringify(param)
                            : Array.isArray(param)
                                ? JSON.stringify(param)
                                : "".concat(param);
                    return result + paramStr;
                }, '');
            },
            paramCount: {},
        },
        'number': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                var number = Number(str);
                if (Number.isNaN(number))
                    throw new LitsError("Could not convert '".concat(str, "' to a number."), sourceCodeInfo);
                return number;
            },
            paramCount: 1,
        },
        'from-char-code': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), num = _b[0];
                assertNumber(num, sourceCodeInfo, { finite: true });
                var int = toNonNegativeInteger(num);
                try {
                    return String.fromCodePoint(int);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 1,
        },
        'to-char-code': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo, { nonEmpty: true });
                return asNonUndefined(str.codePointAt(0), sourceCodeInfo);
            },
            paramCount: 1,
        },
        'lower-case': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.toLowerCase();
            },
            paramCount: 1,
        },
        'upper-case': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.toUpperCase();
            },
            paramCount: 1,
        },
        'trim': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.trim();
            },
            paramCount: 1,
        },
        'trim-left': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.replace(/^\s+/, '');
            },
            paramCount: 1,
        },
        'trim-right': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.replace(/\s+$/, '');
            },
            paramCount: 1,
        },
        'join': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), stringList = _b[0], delimiter = _b[1];
                assertArray(stringList, sourceCodeInfo);
                stringList.forEach(function (str) { return assertStringOrNumber(str, sourceCodeInfo); });
                assertString(delimiter, sourceCodeInfo);
                return stringList.join(delimiter);
            },
            paramCount: 2,
        },
        'split': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], stringOrRegExpValue = _b[1], limit = _b[2];
                assertString(str, sourceCodeInfo);
                assertStringOrRegularExpression(stringOrRegExpValue, sourceCodeInfo);
                if (limit !== undefined)
                    assertNumber(limit, sourceCodeInfo, { integer: true, nonNegative: true });
                var delimiter = typeof stringOrRegExpValue === 'string'
                    ? stringOrRegExpValue
                    : new RegExp(stringOrRegExpValue.s, stringOrRegExpValue.f);
                return str.split(delimiter, limit);
            },
            paramCount: { min: 2, max: 3 },
        },
        'split-lines': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.split((/\r\n|\n|\r/)).filter(function (line) { return line !== ''; });
            },
            paramCount: 1,
        },
        'pad-left': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], length = _b[1], padString = _b[2];
                assertString(str, sourceCodeInfo);
                assertNumber(length, sourceCodeInfo, { integer: true });
                if (padString !== undefined)
                    assertString(padString, sourceCodeInfo);
                return str.padStart(length, padString);
            },
            paramCount: { min: 2, max: 3 },
        },
        'pad-right': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), str = _b[0], length = _b[1], padString = _b[2];
                assertString(str, sourceCodeInfo);
                assertNumber(length, sourceCodeInfo, { integer: true });
                if (padString !== undefined)
                    assertString(padString, sourceCodeInfo);
                return str.padEnd(length, padString);
            },
            paramCount: { min: 2, max: 3 },
        },
        'template': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), templateString = _b[0], placeholders = _b.slice(1);
                assertString(templateString, sourceCodeInfo);
                assertArray(placeholders, sourceCodeInfo);
                var templateStrings = templateString.split('||||');
                if (templateStrings.length <= 1) {
                    return applyPlaceholders(templateStrings[0], placeholders, sourceCodeInfo);
                }
                else {
                    // Pluralisation
                    var count = placeholders[0];
                    assertNumber(count, sourceCodeInfo, { integer: true, nonNegative: true });
                    var stringPlaceholders = __spreadArray(["".concat(count)], __read(placeholders.slice(1)), false);
                    if (templateStrings.length === 2) {
                        // Exactly two valiants.
                        // First variant (singular) for count = 1, Second variant (plural) for count = 0 or count > 1
                        var placehoder = templateStrings[count === 1 ? 0 : 1];
                        return applyPlaceholders(placehoder, stringPlaceholders, sourceCodeInfo);
                    }
                    else {
                        // More than two variant:
                        // Use count as index
                        // If count >= number of variants, use last variant
                        var placehoder = templateStrings[Math.min(count, templateStrings.length - 1)];
                        return applyPlaceholders(placehoder, stringPlaceholders, sourceCodeInfo);
                    }
                }
            },
            paramCount: { min: 1, max: 10 },
        },
        'encode-base64': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertString(value, sourceCodeInfo);
                return btoa(encodeURIComponent(value).replace(/%([0-9A-F]{2})/g, function (_match, p1) {
                    // eslint-disable-next-line ts/no-unsafe-argument
                    return String.fromCharCode(Number.parseInt(p1, 16));
                }));
            },
            paramCount: 1,
        },
        'decode-base64': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertString(value, sourceCodeInfo);
                try {
                    return decodeURIComponent(Array.prototype.map
                        .call(atob(value), function (c) {
                        // eslint-disable-next-line ts/no-unsafe-call, ts/no-unsafe-member-access
                        return "%".concat(("00".concat(c.charCodeAt(0).toString(16))).slice(-2));
                    })
                        .join(''));
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 1,
        },
        'encode-uri-component': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertString(value, sourceCodeInfo);
                return encodeURIComponent(value);
            },
            paramCount: 1,
        },
        'decode-uri-component': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                assertString(value, sourceCodeInfo);
                try {
                    return decodeURIComponent(value);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 1,
        },
        'blank?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), value = _b[0];
                if (value === null) {
                    return true;
                }
                assertString(value, sourceCodeInfo);
                return blankRegexp.test(value);
            },
            paramCount: 1,
        },
        'capitalize': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), str = _b[0];
                assertString(str, sourceCodeInfo);
                return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
            },
            paramCount: 1,
        },
    };
    var doubleDollarRegexp = /\$\$/g;
    function applyPlaceholders(templateString, placeholders, sourceCodeInfo) {
        for (var i = 0; i < 9; i += 1) {
            // Matches $1, $2, ..., $9
            // Does not match $$1
            // But does match $$$1, (since the two first '$' will later be raplaced with a single '$'
            var re = new RegExp("(\\$\\$|[^$]|^)\\$".concat(i + 1), 'g');
            if (re.test(templateString)) {
                var placeHolder = asStringOrNumber(placeholders[i], sourceCodeInfo);
                templateString = templateString.replace(re, "$1".concat(placeHolder));
            }
        }
        templateString = templateString.replace(doubleDollarRegexp, '$');
        return templateString;
    }

    var functionalNormalExpression = {
        '|>': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), value = _c[0], func = _c[1];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(func, sourceCodeInfo);
                return executeFunction(func, [value], contextStack, sourceCodeInfo);
            },
            paramCount: 2,
        },
        'apply': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a), func = _c[0], params = _c.slice(1);
                var executeFunction = _b.executeFunction;
                assertFunctionLike(func, sourceCodeInfo);
                var paramsLength = params.length;
                var last = params[paramsLength - 1];
                assertArray(last, sourceCodeInfo);
                var applyArray = __spreadArray(__spreadArray([], __read(params.slice(0, -1)), false), __read(last), false);
                return executeFunction(func, applyArray, contextStack, sourceCodeInfo);
            },
            paramCount: { min: 2 },
        },
        'identity': {
            evaluate: function (_a) {
                var _b = __read(_a, 1), value = _b[0];
                return toAny(value);
            },
            paramCount: 1,
        },
        'comp': {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                return _a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a.functionType = 'Comp',
                    _a.params = params,
                    _a;
            },
            paramCount: {},
        },
        'constantly': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a, 1), value = _c[0];
                return _b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b.functionType = 'Constantly',
                    _b.value = toAny(value),
                    _b;
            },
            paramCount: 1,
        },
        'juxt': {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                return _a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a.functionType = 'Juxt',
                    _a.params = params,
                    _a;
            },
            paramCount: { min: 1 },
        },
        'complement': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a, 1), fn = _c[0];
                return _b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b.functionType = 'Complement',
                    _b.function = asFunctionLike(fn, sourceCodeInfo),
                    _b;
            },
            paramCount: 1,
        },
        'every-pred': {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                return _a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a.functionType = 'EveryPred',
                    _a.params = params,
                    _a;
            },
            paramCount: { min: 1 },
        },
        'some-pred': {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                return _a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a.functionType = 'SomePred',
                    _a.params = params,
                    _a;
            },
            paramCount: { min: 1 },
        },
        'fnull': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a), fn = _c[0], params = _c.slice(1);
                return _b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b.functionType = 'Fnull',
                    _b.function = asFunctionLike(fn, sourceCodeInfo),
                    _b.params = params,
                    _b;
            },
            paramCount: { min: 2 },
        },
    };

    /**
     * Creates a grid from a flat array with specified dimensions
     *
     * @param flatArray The flat array of values
     * @param rows Number of rows in the resulting grid
     * @returns A 2D array representing the grid
     */
    function fromArray(flatArray, rows) {
        // Create the grid
        var grid = [];
        var cols = flatArray.length / rows;
        // Reshape the flat array into rows and columns
        for (var i = 0; i < rows; i++) {
            var start = i * cols;
            var end = start + cols;
            grid.push(flatArray.slice(start, end));
        }
        return grid;
    }

    function transpose(grid) {
        var result = [];
        for (var i = 0; i < grid[0].length; i += 1) {
            var row = [];
            for (var j = 0; j < grid.length; j += 1) {
                row.push(grid[j][i]);
            }
            result.push(row);
        }
        return result;
    }

    var gridNormalExpression = {
        'grid:every?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_1, _c, e_2, _d;
                var _e = __read(_a, 2), grid = _e[0], predicate = _e[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                try {
                    for (var grid_1 = __values(grid), grid_1_1 = grid_1.next(); !grid_1_1.done; grid_1_1 = grid_1.next()) {
                        var row = grid_1_1.value;
                        try {
                            for (var row_1 = (e_2 = void 0, __values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                                var cell = row_1_1.value;
                                if (!executeFunction(predicate, [cell], contextStack, sourceCodeInfo)) {
                                    return false;
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (row_1_1 && !row_1_1.done && (_d = row_1.return)) _d.call(row_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (grid_1_1 && !grid_1_1.done && (_c = grid_1.return)) _c.call(grid_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return true;
            },
            paramCount: 2,
        },
        'grid:some?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_3, _c, e_4, _d;
                var _e = __read(_a, 2), grid = _e[0], predicate = _e[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                try {
                    for (var grid_2 = __values(grid), grid_2_1 = grid_2.next(); !grid_2_1.done; grid_2_1 = grid_2.next()) {
                        var row = grid_2_1.value;
                        try {
                            for (var row_2 = (e_4 = void 0, __values(row)), row_2_1 = row_2.next(); !row_2_1.done; row_2_1 = row_2.next()) {
                                var cell = row_2_1.value;
                                if (executeFunction(predicate, [cell], contextStack, sourceCodeInfo)) {
                                    return true;
                                }
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (row_2_1 && !row_2_1.done && (_d = row_2.return)) _d.call(row_2);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (grid_2_1 && !grid_2_1.done && (_c = grid_2.return)) _c.call(grid_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return false;
            },
            paramCount: 2,
        },
        'grid:every-row?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_5, _c;
                var _d = __read(_a, 2), grid = _d[0], predicate = _d[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                try {
                    for (var grid_3 = __values(grid), grid_3_1 = grid_3.next(); !grid_3_1.done; grid_3_1 = grid_3.next()) {
                        var row = grid_3_1.value;
                        if (!executeFunction(predicate, [row], contextStack, sourceCodeInfo)) {
                            return false;
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (grid_3_1 && !grid_3_1.done && (_c = grid_3.return)) _c.call(grid_3);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                return true;
            },
            paramCount: 2,
        },
        'grid:some-row?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_6, _c;
                var _d = __read(_a, 2), grid = _d[0], predicate = _d[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                try {
                    for (var grid_4 = __values(grid), grid_4_1 = grid_4.next(); !grid_4_1.done; grid_4_1 = grid_4.next()) {
                        var row = grid_4_1.value;
                        if (executeFunction(predicate, [row], contextStack, sourceCodeInfo)) {
                            return true;
                        }
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (grid_4_1 && !grid_4_1.done && (_c = grid_4.return)) _c.call(grid_4);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
                return false;
            },
            paramCount: 2,
        },
        'grid:every-col?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_7, _c;
                var _d = __read(_a, 2), grid = _d[0], predicate = _d[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                var transposed = transpose(grid);
                try {
                    for (var transposed_1 = __values(transposed), transposed_1_1 = transposed_1.next(); !transposed_1_1.done; transposed_1_1 = transposed_1.next()) {
                        var row = transposed_1_1.value;
                        if (!executeFunction(predicate, [row], contextStack, sourceCodeInfo)) {
                            return false;
                        }
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (transposed_1_1 && !transposed_1_1.done && (_c = transposed_1.return)) _c.call(transposed_1);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                return true;
            },
            paramCount: 2,
        },
        'grid:some-col?': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_8, _c;
                var _d = __read(_a, 2), grid = _d[0], predicate = _d[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(predicate, sourceCodeInfo);
                var transposed = transpose(grid);
                try {
                    for (var transposed_2 = __values(transposed), transposed_2_1 = transposed_2.next(); !transposed_2_1.done; transposed_2_1 = transposed_2.next()) {
                        var row = transposed_2_1.value;
                        if (executeFunction(predicate, [row], contextStack, sourceCodeInfo)) {
                            return true;
                        }
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (transposed_2_1 && !transposed_2_1.done && (_c = transposed_2.return)) _c.call(transposed_2);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
                return false;
            },
            paramCount: 2,
        },
        'grid:row': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), grid = _b[0], row = _b[1];
                assertGrid(grid, sourceCodeInfo);
                assertNumber(row, sourceCodeInfo, { integer: true, nonNegative: true, lt: grid.length });
                return grid[row];
            },
            paramCount: 2,
        },
        'grid:col': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), grid = _b[0], col = _b[1];
                assertGrid(grid, sourceCodeInfo);
                assertNumber(col, sourceCodeInfo, { integer: true, nonNegative: true, lt: grid[0].length });
                return grid.map(function (row) { return row[col]; });
            },
            paramCount: 2,
        },
        'grid:shape': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return [grid.length, grid[0].length];
            },
            paramCount: 1,
        },
        'grid:fill': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), rows = _b[0], cols = _b[1], value = _b[2];
                assertNumber(rows, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(cols, sourceCodeInfo, { integer: true, positive: true });
                assertAny(value, sourceCodeInfo);
                var result = [];
                for (var i = 0; i < rows; i += 1) {
                    var row = [];
                    for (var j = 0; j < cols; j += 1) {
                        row.push(value);
                    }
                    result.push(row);
                }
                return result;
            },
            paramCount: 3,
        },
        'grid:generate': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), rows = _c[0], cols = _c[1], generator = _c[2];
                var executeFunction = _b.executeFunction;
                assertNumber(rows, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(cols, sourceCodeInfo, { integer: true, positive: true });
                assertFunctionLike(generator, sourceCodeInfo);
                var result = [];
                for (var i = 0; i < rows; i += 1) {
                    var row = [];
                    for (var j = 0; j < cols; j += 1) {
                        var value = executeFunction(generator, [i, j], contextStack, sourceCodeInfo);
                        assertAny(value, sourceCodeInfo);
                        row.push(value);
                    }
                    result.push(row);
                }
                return result;
            },
            paramCount: 3,
        },
        'grid:reshape': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), grid = _b[0], rows = _b[1];
                assertGrid(grid, sourceCodeInfo);
                assertNumber(rows, sourceCodeInfo, { integer: true, positive: true });
                var flatTable = grid.flat();
                if (flatTable.length % rows !== 0) {
                    throw new LitsError("The number of elements in the grid must be divisible by rows, but got ".concat(flatTable.length, " and ").concat(rows), sourceCodeInfo);
                }
                var cols = flatTable.length / rows;
                var result = [];
                for (var i = 0; i < rows; i += 1) {
                    var row = [];
                    for (var j = 0; j < cols; j += 1) {
                        row.push(flatTable[i * cols + j]);
                    }
                    result.push(row);
                }
                return result;
            },
            paramCount: 2,
        },
        'grid:transpose': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return transpose(grid);
            },
            paramCount: 1,
            aliases: ['grid:tr'],
        },
        'grid:flip-h': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return grid.map(function (row) { return row.reverse(); });
            },
            paramCount: 1,
        },
        'grid:flip-v': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return grid.reverse();
            },
            paramCount: 1,
        },
        'grid:rotate': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), grid = _b[0], times = _b[1];
                assertGrid(grid, sourceCodeInfo);
                assertNumber(times, sourceCodeInfo, { integer: true });
                // Normalize times to be between 0 and 3
                times = ((times % 4) + 4) % 4;
                // If times is 0, return the original grid
                if (times === 0 || grid.length === 0) {
                    return grid.map(function (row) { return __spreadArray([], __read(row), false); });
                }
                var height = grid.length;
                var width = grid[0].length;
                var result;
                switch (times) {
                    case 1: // 90 degrees clockwise
                        result = Array(width).fill(null).map(function () { return Array(height).fill(null); });
                        for (var y = 0; y < height; y++) {
                            for (var x = 0; x < width; x++) {
                                result[x][height - 1 - y] = grid[y][x];
                            }
                        }
                        break;
                    case 2: // 180 degrees
                        result = Array(height).fill(null).map(function () { return Array(width).fill(null); });
                        for (var y = 0; y < height; y++) {
                            for (var x = 0; x < width; x++) {
                                result[height - 1 - y][width - 1 - x] = grid[y][x];
                            }
                        }
                        break;
                    case 3: // 270 degrees clockwise (or 90 degrees counter-clockwise)
                        result = Array(width).fill(null).map(function () { return Array(height).fill(null); });
                        for (var y = 0; y < height; y++) {
                            for (var x = 0; x < width; x++) {
                                result[width - 1 - x][y] = grid[y][x];
                            }
                        }
                        break;
                }
                return result;
            },
            paramCount: 2,
        },
        'grid:reverse-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return grid.reverse();
            },
            paramCount: 1,
        },
        'grid:reverse-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                return grid.map(function (row) { return row.reverse(); });
            },
            paramCount: 1,
        },
        'grid:slice': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), grid = _b[0], start = _b[1], end = _b[2];
                assertGrid(grid, sourceCodeInfo);
                assertVector(start, sourceCodeInfo);
                if (start.length !== 2) {
                    throw new LitsError("The start vector must have 2 elements, but got ".concat(start.length), sourceCodeInfo);
                }
                var _c = __read(start, 2), rowStart = _c[0], colStart = _c[1];
                assertNumber(rowStart, sourceCodeInfo, { integer: true, nonNegative: true, lt: grid.length });
                assertNumber(colStart, sourceCodeInfo, { integer: true, nonNegative: true, lt: grid[0].length });
                end !== null && end !== void 0 ? end : (end = [grid.length, grid[0].length]);
                assertVector(end, sourceCodeInfo);
                if (end.length !== 2) {
                    throw new LitsError("The end vector must have 2 elements, but got ".concat(end.length), sourceCodeInfo);
                }
                var _d = __read(end, 2), rowEnd = _d[0], colEnd = _d[1];
                assertNumber(rowEnd, sourceCodeInfo, { gt: rowStart, lte: grid.length });
                assertNumber(colEnd, sourceCodeInfo, { gt: colStart, lte: grid[0].length });
                var result = [];
                for (var i = rowStart; i < rowEnd; i += 1) {
                    var row = [];
                    for (var j = colStart; j < colEnd; j += 1) {
                        row.push(grid[i][j]);
                    }
                    result.push(row);
                }
                return result;
            },
            paramCount: { min: 2, max: 3 },
        },
        'grid:slice-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), grid = _b[0], rowStart = _b[1], rowEnd = _b[2];
                assertGrid(grid, sourceCodeInfo);
                if (typeof rowEnd === 'undefined') {
                    assertNumber(rowStart, sourceCodeInfo, { integer: true, lte: grid.length, gte: -grid.length });
                    if (rowStart < 0) {
                        return grid.slice(grid.length + rowStart);
                    }
                    return grid.slice(rowStart);
                }
                assertNumber(rowStart, sourceCodeInfo, { integer: true, nonNegative: true, lte: grid.length });
                assertNumber(rowEnd, sourceCodeInfo, { integer: true });
                rowEnd = rowEnd < 0 ? grid.length + rowEnd : rowEnd;
                assertNumber(rowEnd, sourceCodeInfo, { gt: rowStart, lte: grid.length });
                return grid.slice(rowStart, rowEnd);
            },
            paramCount: { min: 2, max: 3 },
        },
        'grid:slice-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), grid = _b[0], colStart = _b[1], colEnd = _b[2];
                assertGrid(grid, sourceCodeInfo);
                var trMatrix = transpose(grid);
                if (typeof colEnd === 'undefined') {
                    assertNumber(colStart, sourceCodeInfo, { integer: true, lte: trMatrix.length, gte: -trMatrix.length });
                    if (colStart < 0) {
                        return transpose(trMatrix.slice(trMatrix.length + colStart));
                    }
                    return transpose(trMatrix.slice(colStart));
                }
                assertNumber(colStart, sourceCodeInfo, { integer: true, nonNegative: true, lte: trMatrix.length });
                assertNumber(colEnd, sourceCodeInfo, { integer: true });
                colEnd = colEnd < 0 ? trMatrix.length + colEnd : colEnd;
                assertNumber(colEnd, sourceCodeInfo, { gt: colStart, lte: trMatrix.length });
                return transpose(trMatrix.slice(colStart, colEnd));
            },
            paramCount: { min: 2, max: 3 },
        },
        'grid:splice-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], rowStart = _b[1], rowDeleteCount = _b[2], rows = _b.slice(3);
                assertGrid(grid, sourceCodeInfo);
                assertNumber(rowStart, sourceCodeInfo, { integer: true, nonNegative: true, lte: grid.length });
                assertNumber(rowDeleteCount, sourceCodeInfo, { integer: true, nonNegative: true });
                if (rows.length !== 0) {
                    assertGrid(rows, sourceCodeInfo);
                    rows.every(function (row) {
                        assertArray(row, sourceCodeInfo);
                        if (grid[0].length !== row.length) {
                            throw new LitsError("All rows must have the same length as the number of columns in grid, but got ".concat(row.length), sourceCodeInfo);
                        }
                        return true;
                    });
                }
                var result = [];
                for (var i = 0; i < rowStart; i += 1) {
                    result.push(grid[i]);
                }
                if (rows.length > 0) {
                    result.push.apply(result, __spreadArray([], __read(rows), false));
                }
                for (var i = rowStart + rowDeleteCount; i < grid.length; i += 1) {
                    result.push(grid[i]);
                }
                return result;
            },
            paramCount: { min: 3 },
        },
        'grid:splice-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], colStart = _b[1], colDeleteCount = _b[2], cols = _b.slice(3);
                assertGrid(grid, sourceCodeInfo);
                var trMatrix = transpose(grid);
                assertNumber(colStart, sourceCodeInfo, { integer: true, nonNegative: true, lte: trMatrix.length });
                assertNumber(colDeleteCount, sourceCodeInfo, { integer: true, nonNegative: true });
                if (cols.length !== 0) {
                    assertGrid(cols, sourceCodeInfo);
                    cols.every(function (row) {
                        assertArray(row, sourceCodeInfo);
                        if (trMatrix[0].length !== row.length) {
                            throw new LitsError("All rows must have the same length as the number of rows in grid, but got ".concat(row.length), sourceCodeInfo);
                        }
                        return true;
                    });
                }
                var result = [];
                for (var i = 0; i < colStart; i += 1) {
                    result.push(trMatrix[i]);
                }
                result.push.apply(result, __spreadArray([], __read(cols), false));
                for (var i = colStart + colDeleteCount; i < trMatrix.length; i += 1) {
                    result.push(trMatrix[i]);
                }
                return transpose(result);
            },
            paramCount: { min: 3 },
        },
        'grid:concat-rows': {
            evaluate: function (params, sourceCodeInfo) {
                assertArray(params, sourceCodeInfo);
                params.every(function (grid) { return assertGrid(grid, sourceCodeInfo); });
                var cols = params[0][0].length;
                params.slice(1).every(function (grid) {
                    if (grid[0].length !== cols) {
                        throw new LitsError("All matrices must have the same number of columns, but got ".concat(cols, " and ").concat(grid[0].length), sourceCodeInfo);
                    }
                    return true;
                });
                var result = [];
                params.forEach(function (grid) {
                    grid.forEach(function (row) {
                        result.push(row);
                    });
                });
                return result;
            },
            paramCount: { min: 1 },
        },
        'grid:concat-cols': {
            evaluate: function (params, sourceCodeInfo) {
                assertArray(params, sourceCodeInfo);
                params.every(function (grid) { return assertGrid(grid, sourceCodeInfo); });
                var rows = params[0].length;
                params.slice(1).every(function (grid) {
                    if (grid.length !== rows) {
                        throw new LitsError("All matrices must have the same number of rows, but got ".concat(rows, " and ").concat(grid.length), sourceCodeInfo);
                    }
                    return true;
                });
                var result = [];
                var _loop_1 = function (i) {
                    var row = [];
                    params.forEach(function (grid) {
                        row.push.apply(row, __spreadArray([], __read(grid[i]), false));
                    });
                    result.push(row);
                };
                for (var i = 0; i < rows; i += 1) {
                    _loop_1(i);
                }
                return result;
            },
            paramCount: { min: 1 },
        },
        'grid:map': {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var fn = asFunctionLike(params.at(-1), sourceCodeInfo);
                var grids = params.slice(0, -1);
                assertGrid(grids[0], sourceCodeInfo);
                var rows = grids[0].length;
                var cols = grids[0][0].length;
                grids.slice(1).forEach(function (grid) {
                    assertGrid(grid, sourceCodeInfo);
                    if (grid.length !== rows) {
                        throw new LitsError("All matrices must have the same number of rows, but got ".concat(rows, " and ").concat(grid.length), sourceCodeInfo);
                    }
                    if (grid[0].length !== cols) {
                        throw new LitsError("All matrices must have the same number of columns, but got ".concat(cols, " and ").concat(grid[0].length), sourceCodeInfo);
                    }
                });
                var result = [];
                var _loop_2 = function (i) {
                    var row = [];
                    var _loop_3 = function (j) {
                        var args = grids.map(function (grid) { return grid[i][j]; });
                        row.push(asAny(executeFunction(fn, args, contextStack, sourceCodeInfo)));
                    };
                    for (var j = 0; j < cols; j += 1) {
                        _loop_3(j);
                    }
                    result.push(row);
                };
                for (var i = 0; i < rows; i += 1) {
                    _loop_2(i);
                }
                return result;
            },
            paramCount: { min: 2 },
        },
        'grid:mapi': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), grid = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var rows = grid.length;
                var cols = grid[0].length;
                var result = [];
                for (var i = 0; i < rows; i += 1) {
                    var row = [];
                    for (var j = 0; j < cols; j += 1) {
                        row.push(asAny(executeFunction(fn, [grid[i][j], i, j], contextStack, sourceCodeInfo)));
                    }
                    result.push(row);
                }
                return result;
            },
            paramCount: 2,
        },
        'grid:reduce': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var e_9, _c, e_10, _d;
                var _e = __read(_a, 3), grid = _e[0], fn = _e[1], initialValue = _e[2];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var accumulator = asAny(initialValue);
                try {
                    for (var grid_5 = __values(grid), grid_5_1 = grid_5.next(); !grid_5_1.done; grid_5_1 = grid_5.next()) {
                        var row = grid_5_1.value;
                        try {
                            for (var row_3 = (e_10 = void 0, __values(row)), row_3_1 = row_3.next(); !row_3_1.done; row_3_1 = row_3.next()) {
                                var cell = row_3_1.value;
                                accumulator = executeFunction(fn, [accumulator, cell], contextStack, sourceCodeInfo);
                            }
                        }
                        catch (e_10_1) { e_10 = { error: e_10_1 }; }
                        finally {
                            try {
                                if (row_3_1 && !row_3_1.done && (_d = row_3.return)) _d.call(row_3);
                            }
                            finally { if (e_10) throw e_10.error; }
                        }
                    }
                }
                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                finally {
                    try {
                        if (grid_5_1 && !grid_5_1.done && (_c = grid_5.return)) _c.call(grid_5);
                    }
                    finally { if (e_9) throw e_9.error; }
                }
                return accumulator;
            },
            paramCount: 3,
        },
        'grid:reducei': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), grid = _c[0], fn = _c[1], initialValue = _c[2];
                var executeFunction = _b.executeFunction;
                assertGrid(grid, sourceCodeInfo);
                assertFunctionLike(fn, sourceCodeInfo);
                var accumulator = asAny(initialValue);
                for (var i = 0; i < grid.length; i += 1) {
                    for (var j = 0; j < grid[i].length; j += 1) {
                        accumulator = executeFunction(fn, [accumulator, grid[i][j], i, j], contextStack, sourceCodeInfo);
                    }
                }
                return accumulator;
            },
            paramCount: 3,
        },
        'grid:push-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], rows = _b.slice(1);
                assertGrid(grid, sourceCodeInfo);
                assertGrid(rows, sourceCodeInfo);
                if (grid[0].length !== rows[0].length) {
                    throw new LitsError("All rows must have the same length as the number of columns in grid, but got ".concat(grid[0].length, " and ").concat(rows[0].length), sourceCodeInfo);
                }
                return __spreadArray(__spreadArray([], __read(grid), false), __read(rows), false);
            },
            paramCount: { min: 2 },
        },
        'grid:unshift-rows': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], rows = _b.slice(1);
                assertGrid(grid, sourceCodeInfo);
                assertGrid(rows, sourceCodeInfo);
                if (grid[0].length !== rows[0].length) {
                    throw new LitsError("All rows must have the same length as the number of columns in grid, but got ".concat(grid[0].length, " and ").concat(rows[0].length), sourceCodeInfo);
                }
                return __spreadArray(__spreadArray([], __read(rows), false), __read(grid), false);
            },
            paramCount: { min: 2 },
        },
        'grid:pop-row': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                if (grid.length === 1) {
                    return null;
                }
                return grid.slice(0, -1);
            },
            paramCount: 1,
        },
        'grid:shift-row': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                if (grid.length === 1) {
                    return null;
                }
                return grid.slice(1);
            },
            paramCount: 1,
        },
        'grid:push-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], cols = _b.slice(1);
                assertGrid(grid, sourceCodeInfo);
                assertGrid(cols, sourceCodeInfo);
                if (grid.length !== cols[0].length) {
                    throw new LitsError("All columns must have the same length as the number of rows in grid, but got ".concat(cols.length), sourceCodeInfo);
                }
                var result = [];
                var _loop_4 = function (i) {
                    var row = [];
                    row.push.apply(row, __spreadArray([], __read(grid[i]), false));
                    cols.forEach(function (col) {
                        row.push(col[i]);
                    });
                    result.push(row);
                };
                for (var i = 0; i < grid.length; i += 1) {
                    _loop_4(i);
                }
                return result;
            },
            paramCount: { min: 2 },
        },
        'grid:unshift-cols': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), grid = _b[0], cols = _b.slice(1);
                assertGrid(grid, sourceCodeInfo);
                assertGrid(cols, sourceCodeInfo);
                if (grid.length !== cols[0].length) {
                    throw new LitsError("All columns must have the same length as the number of rows in grid, but got ".concat(cols.length), sourceCodeInfo);
                }
                var result = [];
                var _loop_5 = function (i) {
                    var row = [];
                    cols.forEach(function (col) {
                        row.push(col[i]);
                    });
                    row.push.apply(row, __spreadArray([], __read(grid[i]), false));
                    result.push(row);
                };
                for (var i = 0; i < grid.length; i += 1) {
                    _loop_5(i);
                }
                return result;
            },
            paramCount: { min: 2 },
        },
        'grid:pop-col': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                if (grid[0].length === 1) {
                    return null;
                }
                return grid.map(function (row) { return row.slice(0, -1); });
            },
            paramCount: 1,
        },
        'grid:shift-col': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), grid = _b[0];
                assertGrid(grid, sourceCodeInfo);
                if (grid[0].length === 1) {
                    return null;
                }
                return grid.map(function (row) { return row.slice(1); });
            },
            paramCount: 1,
        },
        'grid:from-array': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], rows = _b[1];
                assertArray(array, sourceCodeInfo);
                assertNumber(rows, sourceCodeInfo, { integer: true, positive: true });
                if (array.length % rows !== 0) {
                    throw new LitsError("The number of elements in the array must be divisible by rows, but got ".concat(array.length, " and ").concat(rows), sourceCodeInfo);
                }
                return fromArray(array, rows);
            },
            paramCount: 2,
        },
    };

    /**
     * Counts occurrences of each integer value in an array of non-negative integers.
     *
     * @param array - Array of non-negative integers to count
     * @param minLength - Minimum length of the output array (default: 0)
     * @param weights - Optional array of weights (same length as input array)
     * @returns An array where index i contains the count of occurrences of i in the input array
     */
    function bincount(array, minLength, weights) {
        if (minLength === void 0) { minLength = 0; }
        if (array.length === 0) {
            return Array.from({ length: minLength }, function () { return 0; });
        }
        // Find the maximum value to determine output array size
        var maxValue = Math.max.apply(Math, __spreadArray([], __read(array), false));
        var outputLength = Math.max(maxValue + 1, minLength);
        var counts = Array.from({ length: outputLength }, function () { return 0; });
        // Count occurrences (or sum weights if provided)
        for (var i = 0; i < array.length; i++) {
            var value = Math.floor(array[i]);
            if (value < outputLength) {
                // If weights provided, add weight; otherwise add 1
                counts[value] += weights ? weights[i] : 1;
            }
        }
        return counts;
    }

    /**
     * Creates a histogram from an array of numbers, returning bin ranges and counts.
     * Each bin is represented as a tuple of [minValue, maxValue, count].
     *
     * @param vector - Array of numeric values
     * @param bins - Number of bins to divide the data into
     * @returns Array of tuples, each containing [binStart, binEnd, count]
     */
    function calcHistogram(vector, bins) {
        var e_1, _a;
        if (vector.length === 0) {
            // Return empty bins with zero counts if input is empty
            var result = [];
            for (var i = 0; i < bins; i++) {
                result.push([0, 0, 0]);
            }
            return result;
        }
        // Find min and max values
        var min = Math.min.apply(Math, __spreadArray([], __read(vector), false));
        var max = Math.max.apply(Math, __spreadArray([], __read(vector), false));
        // Handle the case where all values are the same
        if (min === max) {
            var result = [];
            // Create bins with the same min/max and zero counts
            for (var i = 0; i < bins; i++) {
                result.push([min, min, 0]);
            }
            // Put all values in the first bin
            result[0][2] = vector.length;
            return result;
        }
        // Calculate bin size
        var binSize = (max - min) / bins;
        // Initialize histogram array with bin boundaries and zero counts
        var histogram = [];
        for (var i = 0; i < bins; i++) {
            var binStart = min + i * binSize;
            var binEnd = i === bins - 1 ? max : min + (i + 1) * binSize;
            histogram.push([binStart, binEnd, 0]);
        }
        try {
            // Count values in each bin
            for (var vector_1 = __values(vector), vector_1_1 = vector_1.next(); !vector_1_1.done; vector_1_1 = vector_1.next()) {
                var value = vector_1_1.value;
                if (value === max) {
                    // Place maximum value in the last bin
                    histogram[bins - 1][2] += 1;
                }
                else {
                    var binIndex = Math.min(Math.floor((value - min) / binSize), bins - 1);
                    histogram[binIndex][2] += 1;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vector_1_1 && !vector_1_1.done && (_a = vector_1.return)) _a.call(vector_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return histogram;
    }

    /**
     * Calculates the mode (most frequent value(s)) of a dataset
     * @param values An array of values of any type
     * @returns An array containing the mode(s) of the dataset
     */
    function mode(values) {
        var e_1, _a, e_2, _b, e_3, _c;
        // Create a frequency map
        var frequencyMap = new Map();
        try {
            // Count occurrences of each value
            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                var value = values_1_1.value;
                frequencyMap.set(value, (frequencyMap.get(value) || 0) + 1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Find the maximum frequency
        var maxFrequency = 0;
        try {
            for (var _d = __values(frequencyMap.values()), _e = _d.next(); !_e.done; _e = _d.next()) {
                var frequency = _e.value;
                if (frequency > maxFrequency) {
                    maxFrequency = frequency;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // If all values appear only once, there is no mode
        if (maxFrequency === 1) {
            return values;
        }
        // Collect all values that appear with the maximum frequency
        var modes = [];
        try {
            for (var _f = __values(frequencyMap.entries()), _g = _f.next(); !_g.done; _g = _f.next()) {
                var _h = __read(_g.value, 2), value = _h[0], frequency = _h[1];
                if (frequency === maxFrequency) {
                    modes.push(value);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return modes;
    }

    /**
     * Checks if a vector has no extreme outliers using the IQR method
     * @param vector An array of numbers to check for extreme outliers
     * @returns true if there are no extreme outliers, false otherwise
     */
    function hasOutliers(vector) {
        return outliers(vector).length > 0;
    }
    function outliers(vector) {
        // Handle edge cases
        if (vector.length <= 1)
            return [];
        // Sort the vector to calculate quartiles
        var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
        // Calculate Q1 (25th percentile)
        var q1Index = Math.floor(sorted.length * 0.25);
        var q1 = sorted.length % 4 === 0
            ? (sorted[q1Index - 1] + sorted[q1Index]) / 2
            : sorted[q1Index];
        // Calculate Q3 (75th percentile)
        var q3Index = Math.floor(sorted.length * 0.75);
        var q3 = sorted.length % 4 === 0
            ? (sorted[q3Index - 1] + sorted[q3Index]) / 2
            : sorted[q3Index];
        // Calculate IQR (Interquartile Range)
        var iqr = q3 - q1;
        // Define bounds for outliers (using 1.5*IQR for mild outliers and 3*IQR for extreme outliers)
        var lowerBound = q1 - iqr * 1.5;
        var upperBound = q3 + iqr * 1.5;
        // Filter the vector to find outliers
        return vector.filter(function (val) { return val < lowerBound || val > upperBound; });
    }

    /**
     * Calculate the percentile value from an array of numbers
     * @param data Array of numbers to calculate percentile from
     * @param percentile The percentile to calculate (0-100)
     * @returns The value at the specified percentile
     */
    function calcPercentile(data, percentile) {
        // Sort the data in ascending order
        var sortedData = __spreadArray([], __read(data), false).sort(function (a, b) { return a - b; });
        // If percentile is 0, return the minimum value
        if (percentile === 0) {
            return sortedData[0];
        }
        // If percentile is 100, return the maximum value
        if (percentile === 100) {
            return sortedData[sortedData.length - 1];
        }
        // Calculate the index
        var index = (percentile / 100) * (sortedData.length - 1);
        // If index is an integer, return the value at that index
        if (Number.isInteger(index)) {
            return sortedData[index];
        }
        // Otherwise, interpolate between the two adjacent values
        var lowerIndex = Math.floor(index);
        var upperIndex = Math.ceil(index);
        var weight = index - lowerIndex;
        return sortedData[lowerIndex] * (1 - weight) + sortedData[upperIndex] * weight;
    }

    function quartiles(vector) {
        var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
        // Median calculation (Q2)
        var midIndex = sorted.length / 2;
        var q2;
        if (sorted.length % 2 === 0) {
            // Even length - average the two middle values
            q2 = (sorted[midIndex - 1] + sorted[midIndex]) / 2;
        }
        else {
            // Odd length - take the middle value
            q2 = sorted[Math.floor(midIndex)];
        }
        // Lower half for Q1
        var lowerHalf = sorted.slice(0, Math.floor(sorted.length / 2));
        // Upper half for Q3
        var upperHalf = sorted.slice(Math.ceil(sorted.length / 2));
        // Calculate Q1 and Q3 using the same median logic on the halves
        var q1, q3;
        if (lowerHalf.length % 2 === 0) {
            var midLower = lowerHalf.length / 2;
            q1 = (lowerHalf[midLower - 1] + lowerHalf[midLower]) / 2;
        }
        else {
            q1 = lowerHalf[Math.floor(lowerHalf.length / 2)];
        }
        if (upperHalf.length % 2 === 0) {
            var midUpper = upperHalf.length / 2;
            q3 = (upperHalf[midUpper - 1] + upperHalf[midUpper]) / 2;
        }
        else {
            q3 = upperHalf[Math.floor(upperHalf.length / 2)];
        }
        return [q1, q2, q3];
    }

    var maxReductionFunction = {
        'vec:max': function (vector) { return Math.max.apply(Math, __spreadArray([], __read(vector), false)); },
        'padding': -Number.MAX_VALUE,
    };

    function calcMean(vector) {
        if (vector.length === 0) {
            return 0;
        }
        var sum = vector.reduce(function (acc, val) { return acc + val; }, 0);
        return sum / vector.length;
    }

    var meanReductionFunction = {
        'vec:mean': function (vector) { return calcMean(vector); },
    };
    var geometricMeanReductionFunction = {
        'vec:geometric-mean': function (vector) {
            if (vector.some(function (val) { return val < 0; })) {
                throw new Error('Geometric mean is not defined for non-positive numbers');
            }
            return Math.exp(vector.reduce(function (acc, val) { return acc + Math.log(val); }, 0) / vector.length);
        },
    };
    var harmonicMeanReductionFunction = {
        'vec:harmonic-mean': function (vector) { return vector.length / vector.reduce(function (acc, val) { return acc + 1 / val; }, 0); },
    };

    function calcMedian(vector) {
        var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
        var mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0
            ? (sorted[mid - 1] + sorted[mid]) / 2
            : sorted[mid];
    }

    var medianReductionFunction = {
        'vec:median': function (vector) { return calcMedian(vector); },
    };

    var minReductionFunction = {
        'vec:min': function (vector) { return Math.min.apply(Math, __spreadArray([], __read(vector), false)); },
        'padding': Number.MAX_VALUE,
    };

    var prodReductionFunction = {
        'vec:prod': function (vector) { return vector.reduce(function (acc, val) { return acc * val; }, 1); },
        'padding': 1,
        'minLength': 0,
    };

    var sumReductionFunction = {
        'vec:sum': function (vector) { return vector.reduce(function (acc, val) { return acc + val; }, 0); },
        'minLength': 0,
    };

    function calcVariance(vector, optionalMean) {
        var mean = optionalMean !== null && optionalMean !== void 0 ? optionalMean : calcMean(vector);
        return vector.reduce(function (acc, val) { return acc + Math.pow((val - mean), 2); }, 0) / vector.length;
    }
    function calcSampleVariance(vector, optionalMean) {
        var mean = calcMean(vector);
        return vector.reduce(function (acc, val) { return acc + Math.pow((val - mean), 2); }, 0) / (vector.length - 1);
    }

    var varianceReductionFunction = {
        'vec:variance': function (vector) { return calcVariance(vector); },
    };
    var sampleVarianceReductionFunction = {
        'vec:sample-variance': function (vector) { return calcSampleVariance(vector); },
        'minLength': 2,
    };

    function calcStdDev(vector, optionalMean) {
        var variance = calcVariance(vector, optionalMean);
        return Math.sqrt(variance);
    }
    function calcSampleStdDev(vector, optionalMean) {
        var variance = calcVariance(vector, optionalMean);
        return Math.sqrt(variance * (vector.length / (vector.length - 1)));
    }

    var stdevReductionFunction = {
        'vec:stdev': function (vector) { return calcStdDev(vector); },
    };
    var sampleStdevReductionFunction = {
        'vec:sample-stdev': function (vector) { return calcSampleStdDev(vector); },
        'minLength': 2,
    };

    var iqrReductionFunction = {
        'vec:iqr': function (vector) {
            var _a = __read(quartiles(vector), 3), q1 = _a[0], q3 = _a[2];
            return q3 - q1;
        },
        'minLength': 4,
    };

    var spanReductionFunction = {
        'vec:span': function (vector) { return vector.length === 0 ? 0 : Math.max.apply(Math, __spreadArray([], __read(vector), false)) - Math.min.apply(Math, __spreadArray([], __read(vector), false)); },
        'minLength': 0,
    };

    function skewness(vector) {
        var mean = calcMean(vector);
        var stdDev = calcStdDev(vector);
        if (stdDev === 0) {
            throw new Error('Standard deviation is zero, skewness is undefined');
        }
        return vector.reduce(function (acc, val) { return acc + (Math.pow((val - mean), 3)); }, 0) / (vector.length * Math.pow(stdDev, 3));
    }
    function sampleSkewness(vector) {
        var e_1, _a;
        var n = vector.length;
        // Calculate the mean
        var mean = vector.reduce(function (acc, val) { return acc + val; }, 0) / n;
        // Calculate sum of squared differences and sum of cubed differences
        var sumSquaredDiffs = 0;
        var sumCubedDiffs = 0;
        try {
            for (var vector_1 = __values(vector), vector_1_1 = vector_1.next(); !vector_1_1.done; vector_1_1 = vector_1.next()) {
                var val = vector_1_1.value;
                var diff = val - mean;
                sumSquaredDiffs += diff * diff;
                sumCubedDiffs += diff * diff * diff;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vector_1_1 && !vector_1_1.done && (_a = vector_1.return)) _a.call(vector_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Calculate sample standard deviation (using n-1)
        var sampleVariance = sumSquaredDiffs / (n - 1);
        var sampleStdDev = Math.sqrt(sampleVariance);
        // If standard deviation is 0, skewness is undefined
        if (sampleStdDev === 0) {
            throw new Error('Cannot calculate sample skewness when standard deviation is 0');
        }
        // Calculate sample skewness with Fisher's adjustment
        return (n / ((n - 1) * (n - 2))) * sumCubedDiffs / Math.pow(sampleStdDev, 3);
    }
    var skewnessReductionFunction = {
        'vec:skewness': function (vector) { return skewness(vector); },
        'minLength': 3,
    };
    var sampleSkewnessReductionFunction = {
        'vec:sample-skewness': function (vector) { return sampleSkewness(vector); },
        'minLength': 3,
    };

    function kurtosis(vector) {
        var mean = calcMean(vector);
        var stdDev = calcStdDev(vector);
        if (stdDev === 0) {
            throw new Error('Standard deviation is zero, kurtosis is undefined');
        }
        return vector.reduce(function (acc, val) { return acc + (Math.pow((val - mean), 4)); }, 0) / (vector.length * Math.pow(stdDev, 4));
    }
    function excessKurtosis(vector) {
        return kurtosis(vector) - 3;
    }
    /**
     * Calculates the sample kurtosis (bias-corrected)
     * @param vector Array of numeric values
     * @returns The sample kurtosis
     * @throws Error if sample size is less than 4 or if variance is zero
     */
    function sampleKurtosis(vector) {
        var n = vector.length;
        var mean = vector.reduce(function (sum, val) { return sum + val; }, 0) / n;
        var sumSquaredDeviations = vector.reduce(function (sum, val) { return sum + Math.pow((val - mean), 2); }, 0);
        var variance = sumSquaredDeviations / (n - 1);
        if (variance === 0) {
            throw new Error('Variance is zero, kurtosis is undefined');
        }
        var fourthMomentSum = vector.reduce(function (sum, val) { return sum + Math.pow((val - mean), 4); }, 0);
        // Correct formula for sample kurtosis
        return (n * (n + 1) * fourthMomentSum) / ((n - 1) * (n - 2) * (n - 3) * Math.pow(variance, 2));
    }
    /**
     * Calculates the sample excess kurtosis (bias-corrected)
     * @param vector Array of numeric values
     * @returns The sample excess kurtosis
     * @throws Error if sample size is less than 4 or if variance is zero
     */
    function sampleExcessKurtosis(vector) {
        var n = vector.length;
        var mean = vector.reduce(function (sum, val) { return sum + val; }, 0) / n;
        var sumSquaredDeviations = vector.reduce(function (sum, val) { return sum + Math.pow((val - mean), 2); }, 0);
        var variance = sumSquaredDeviations / (n - 1);
        if (variance === 0) {
            throw new Error('Variance is zero, kurtosis is undefined');
        }
        var fourthMomentSum = vector.reduce(function (sum, val) { return sum + Math.pow((val - mean), 4); }, 0);
        var rawKurtosis = (n * (n + 1) * fourthMomentSum) / ((n - 1) * (n - 2) * (n - 3) * Math.pow(variance, 2));
        // Compute excess kurtosis by subtracting 3 times the bias correction factor
        return rawKurtosis - (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3));
    }
    var kurtosisReductionFunction = {
        'vec:kurtosis': function (vector) { return kurtosis(vector); },
        'minLength': 4,
    };
    var eccessKurtosisReductionFunction = {
        'vec:excess-kurtosis': function (vector) { return excessKurtosis(vector); },
        'minLength': 4,
    };
    var sampleKurtosisReductionFunction = {
        'vec:sample-kurtosis': function (vector) { return sampleKurtosis(vector); },
        'minLength': 4,
    };
    var sampleExcessKurtosisReductionFunction = {
        'vec:sample-excess-kurtosis': function (vector) { return sampleExcessKurtosis(vector); },
        'minLength': 4,
    };

    var rmsReductionFunction = {
        'vec:rms': function (vector) { return Math.sqrt(vector.reduce(function (acc, val) { return acc + Math.pow(val, 2); }, 0) / vector.length); },
    };

    function calcMad(vector) {
        var median = calcMedian(vector);
        // Calculate mean absolute deviation
        return vector.reduce(function (acc, val) { return acc + Math.abs(val - median); }, 0) / vector.length;
    }

    var madReductionFunction = {
        'vec:mad': function (vector) { return calcMad(vector); },
    };

    function calcMedad(vector) {
        var median = calcMedian(vector);
        // Calculate absolute deviations from the median
        var absoluteDeviations = vector.map(function (val) { return Math.abs(val - median); });
        // Calculate the median of the absolute deviations
        var medianOfDeviations = calcMedian(absoluteDeviations);
        var scaleFactor = 1.4826; // Scale factor for robust scaling
        return medianOfDeviations * scaleFactor;
    }

    var medadReductionFunction = {
        'vec:medad': function (vector) { return calcMedad(vector); },
    };

    var giniCoefficientReductionFunction = {
        'vec:gini-coefficient': function (vector) {
            if (vector.some(function (x) { return x < 0; })) {
                throw new Error('Gini coefficient is not defined for negative values');
            }
            var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
            var n = sorted.length;
            var sum = sorted.reduce(function (acc, val) { return acc + val; }, 0);
            if (sum === 0) {
                return 0;
            }
            var gini = (2 * sorted.reduce(function (acc, val, i) { return acc + (i + 1) * val; }, 0)) / (n * sum) - (n + 1) / n;
            return gini;
        },
        'minLength': 1,
    };

    /**
     * Calculates the Shannon entropy of a vector.
     * Entropy measures the amount of uncertainty or randomness in the data.
     *
     * @param vector - An array of values to calculate entropy for
     * @returns The entropy value (in bits) or 0 for empty arrays
     */
    function calculateEntropy(vector) {
        var e_1, _a, e_2, _b;
        // Count occurrences of each value
        var frequencies = new Map();
        try {
            for (var vector_1 = __values(vector), vector_1_1 = vector_1.next(); !vector_1_1.done; vector_1_1 = vector_1.next()) {
                var value = vector_1_1.value;
                frequencies.set(value, (frequencies.get(value) || 0) + 1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vector_1_1 && !vector_1_1.done && (_a = vector_1.return)) _a.call(vector_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Get the total number of elements
        var total = vector.length;
        // Calculate entropy using Shannon's formula
        var entropy = 0;
        try {
            for (var _c = __values(frequencies.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var frequency = _d.value;
                var probability = frequency / total;
                // Skip cases where probability is 0 (log(0) is undefined)
                if (probability > 0) {
                    entropy -= probability * Math.log2(probability);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return entropy;
    }

    var entropyReductionFunction = {
        'vec:entropy': function (vector) { return calculateEntropy(vector); },
        'minLength': 1,
    };

    var reductionFunctionNormalExpressions = {};
    addReductionFunctions$1(meanReductionFunction);
    addReductionFunctions$1(geometricMeanReductionFunction);
    addReductionFunctions$1(harmonicMeanReductionFunction);
    addReductionFunctions$1(medianReductionFunction);
    addReductionFunctions$1(sumReductionFunction);
    addReductionFunctions$1(prodReductionFunction);
    addReductionFunctions$1(minReductionFunction);
    addReductionFunctions$1(maxReductionFunction);
    addReductionFunctions$1(varianceReductionFunction);
    addReductionFunctions$1(sampleVarianceReductionFunction);
    addReductionFunctions$1(stdevReductionFunction);
    addReductionFunctions$1(sampleStdevReductionFunction);
    addReductionFunctions$1(iqrReductionFunction);
    addReductionFunctions$1(spanReductionFunction);
    addReductionFunctions$1(skewnessReductionFunction);
    addReductionFunctions$1(sampleSkewnessReductionFunction);
    addReductionFunctions$1(eccessKurtosisReductionFunction);
    addReductionFunctions$1(kurtosisReductionFunction);
    addReductionFunctions$1(sampleExcessKurtosisReductionFunction);
    addReductionFunctions$1(sampleKurtosisReductionFunction);
    addReductionFunctions$1(rmsReductionFunction);
    addReductionFunctions$1(madReductionFunction);
    addReductionFunctions$1(medadReductionFunction);
    addReductionFunctions$1(giniCoefficientReductionFunction);
    addReductionFunctions$1(entropyReductionFunction);
    function addReductionFunctions$1(fns) {
        var e_1, _a;
        var _b, _c;
        try {
            for (var _d = __values(Object.entries(fns)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var _f = __read(_e.value, 2), key = _f[0], value = _f[1];
                /* v8 ignore next 3 */
                if (reductionFunctionNormalExpressions[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                if (key.startsWith('vec:')) {
                    var movingKey = key.replace('vec:', 'vec:moving-');
                    var centeredMovingKey = key.replace('vec:', 'vec:centered-moving-');
                    var runningKey = key.replace('vec:', 'vec:running-');
                    var minLength = (_b = fns.minLength) !== null && _b !== void 0 ? _b : 1;
                    assertNumber(minLength, undefined, { integer: true, finite: true, gte: 0 });
                    reductionFunctionNormalExpressions[key] = createReductionNormalExpression(value, minLength);
                    reductionFunctionNormalExpressions[movingKey] = createMovingNormalExpression(value, minLength);
                    reductionFunctionNormalExpressions[centeredMovingKey] = createCenteredMovingNormalExpression(value, minLength, (_c = fns.padding) !== null && _c !== void 0 ? _c : null);
                    reductionFunctionNormalExpressions[runningKey] = createRunningNormalExpression(value, minLength);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    function createReductionNormalExpression(reductionFunction, minLength) {
        return {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < minLength) {
                    throw new LitsError("Vector length must be at least ".concat(minLength), sourceCodeInfo);
                }
                try {
                    return reductionFunction(vector);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 1,
        };
    }
    function createMovingNormalExpression(reductionFunction, minLength) {
        return {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], windowSize = _b[1];
                assertVector(vector, sourceCodeInfo);
                assertNumber(windowSize, sourceCodeInfo, { integer: true, finite: true, gte: minLength, lte: vector.length });
                if (vector.length === 0) {
                    return [];
                }
                try {
                    if (windowSize >= vector.length) {
                        return [reductionFunction(vector)];
                    }
                    var result = [];
                    for (var i = 0; i < vector.length - windowSize + 1; i += 1) {
                        result.push(reductionFunction(vector.slice(i, i + windowSize)));
                    }
                    return result;
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 2,
        };
    }
    function createCenteredMovingNormalExpression(reductionFunction, minLength, padding) {
        return {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 4), vector = _b[0], windowSize = _b[1], leftPadding = _b[2], rightPadding = _b[3];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < minLength) {
                    throw new LitsError("Vector length must be at least ".concat(minLength), sourceCodeInfo);
                }
                assertNumber(windowSize, sourceCodeInfo, { integer: true, finite: true, gte: minLength, lte: vector.length });
                leftPadding = leftPadding !== null && leftPadding !== void 0 ? leftPadding : padding;
                if (leftPadding !== null) {
                    assertNumber(leftPadding, sourceCodeInfo, { finite: true });
                }
                rightPadding = rightPadding !== null && rightPadding !== void 0 ? rightPadding : padding;
                if (rightPadding !== null) {
                    assertNumber(rightPadding, sourceCodeInfo, { finite: true });
                }
                if (vector.length === 0) {
                    return [];
                }
                var halfWindowSize = Math.floor(windowSize / 2);
                var paddedVector = __spreadArray(__spreadArray(__spreadArray([], __read(Array(halfWindowSize).fill(leftPadding)), false), __read(vector), false), __read(Array(halfWindowSize).fill(rightPadding)), false);
                var start = typeof leftPadding === 'number' ? 0 : halfWindowSize;
                var end = vector.length - (typeof rightPadding === 'number' ? 0 : (windowSize - halfWindowSize - 1));
                var result = __spreadArray([], __read(Array(start).fill(null)), false);
                try {
                    for (var i = start; i < end; i += 1) {
                        result.push(reductionFunction(paddedVector.slice(i, i + windowSize)));
                    }
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
                result.push.apply(result, __spreadArray([], __read(Array(vector.length - end).fill(null)), false));
                return result;
            },
            paramCount: { min: 2, max: 4 },
        };
    }
    function createRunningNormalExpression(reductionFunction, minLength) {
        return {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < minLength) {
                    throw new LitsError("Vector length must be at least ".concat(minLength), sourceCodeInfo);
                }
                if (vector.length === 0) {
                    return [];
                }
                try {
                    var nullsCount = Math.max(minLength - 1, 0);
                    var result = Array(nullsCount).fill(null);
                    for (var i = nullsCount; i < vector.length; i += 1) {
                        result.push(reductionFunction(vector.slice(0, i + 1)));
                    }
                    return result;
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 1,
        };
    }

    var vectorNormalExpression = {
        'vec:monotonic?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val >= vector[i - 1]; })
                    || vector.every(function (val, i) { return i === 0 || val <= vector[i - 1]; });
            },
            paramCount: 1,
        },
        'vec:strictly-monotonic?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val > vector[i - 1]; })
                    || vector.every(function (val, i) { return i === 0 || val < vector[i - 1]; });
            },
            paramCount: 1,
        },
        'vec:increasing?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val >= vector[i - 1]; });
            },
            paramCount: 1,
        },
        'vec:decreasing?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val <= vector[i - 1]; });
            },
            paramCount: 1,
        },
        'vec:strictly-increasing?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val > vector[i - 1]; });
            },
            paramCount: 1,
        },
        'vec:strictly-decreasing?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.every(function (val, i) { return i === 0 || val < vector[i - 1]; });
            },
            paramCount: 1,
        },
        'vec:mode': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return mode(vector);
            },
            paramCount: 1,
        },
        'vec:min-index': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val, i) { return (val < vector[acc] ? i : acc); }, 0);
            },
            paramCount: 1,
        },
        'vec:max-index': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val, i) { return (val > vector[acc] ? i : acc); }, 0);
            },
            paramCount: 1,
        },
        'vec:sort-indices': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return __spreadArray([], __read(vector.keys()), false).sort(function (a, b) { return vector[a] - vector[b]; });
            },
            paramCount: 1,
        },
        'vec:count-values': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_1, _b;
                var _c = __read(_a, 1), vector = _c[0];
                assertVector(vector, sourceCodeInfo);
                var frequencyMap = new Map();
                try {
                    for (var vector_1 = __values(vector), vector_1_1 = vector_1.next(); !vector_1_1.done; vector_1_1 = vector_1.next()) {
                        var value = vector_1_1.value;
                        frequencyMap.set(value, (frequencyMap.get(value) || 0) + 1);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (vector_1_1 && !vector_1_1.done && (_b = vector_1.return)) _b.call(vector_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return __spreadArray([], __read(frequencyMap.entries()), false).sort(function (a, b) {
                    // First compare by count (descending)
                    var countDiff = b[1] - a[1];
                    if (countDiff !== 0)
                        return countDiff;
                    // If counts are equal, sort by value (ascending)
                    return a[0] - b[0];
                });
            },
            paramCount: 1,
        },
        'vec:linspace': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], end = _b[1], numPoints = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(end, sourceCodeInfo, { finite: true });
                assertNumber(numPoints, sourceCodeInfo, { integer: true, nonNegative: true });
                if (numPoints === 0) {
                    return [];
                }
                if (numPoints === 1) {
                    return [start];
                }
                var step = (end - start) / (numPoints - 1);
                return Array.from({ length: numPoints }, function (_, i) { return start + i * step; });
            },
            paramCount: 3,
        },
        'vec:ones': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), length = _b[0];
                assertNumber(length, sourceCodeInfo, { integer: true, nonNegative: true });
                return Array.from({ length: length }, function () { return 1; });
            },
            paramCount: 1,
        },
        'vec:zeros': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), length = _b[0];
                assertNumber(length, sourceCodeInfo, { integer: true, nonNegative: true });
                return Array.from({ length: length }, function () { return 0; });
            },
            paramCount: 1,
        },
        'vec:fill': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), length = _b[0], value = _b[1];
                assertNumber(length, sourceCodeInfo, { integer: true, nonNegative: true });
                return Array.from({ length: length }, function () { return value; });
            },
            paramCount: 2,
        },
        'vec:generate': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), length = _c[0], generator = _c[1];
                var executeFunction = _b.executeFunction;
                assertNumber(length, sourceCodeInfo, { integer: true, nonNegative: true });
                assertFunctionLike(generator, sourceCodeInfo);
                return Array.from({ length: length }, function (_, i) {
                    var value = executeFunction(generator, [i], contextStack, sourceCodeInfo);
                    assertNumber(value, sourceCodeInfo, { finite: true });
                    return value;
                });
            },
            paramCount: 2,
        },
        'vec:cumsum': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val) {
                    var _a;
                    var last = (_a = acc[acc.length - 1]) !== null && _a !== void 0 ? _a : 0;
                    acc.push(last + val);
                    return acc;
                }, []);
            },
            paramCount: 1,
        },
        'vec:cumprod': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val) {
                    var _a;
                    var last = (_a = acc[acc.length - 1]) !== null && _a !== void 0 ? _a : 1;
                    acc.push(last * val);
                    return acc;
                }, []);
            },
            paramCount: 1,
        },
        'vec:quartiles': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < 4) {
                    throw new LitsError('Quartiles require at least four values', sourceCodeInfo);
                }
                return quartiles(vector);
            },
            paramCount: 1,
        },
        'vec:percentile': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], percentile = _b[1];
                assertNonEmptyVector(vector, sourceCodeInfo);
                assertNumber(percentile, sourceCodeInfo, { finite: true, nonNegative: true, lte: 100 });
                return calcPercentile(vector, percentile);
            },
            paramCount: 2,
        },
        'vec:quantile': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], quantile = _b[1];
                assertVector(vector, sourceCodeInfo);
                assertNumber(quantile, sourceCodeInfo, { finite: true, nonNegative: true, lte: 1 });
                return calcPercentile(vector, quantile * 100);
            },
            paramCount: 2,
        },
        'vec:histogram': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], bins = _b[1];
                assertVector(vector, sourceCodeInfo);
                assertNumber(bins, sourceCodeInfo, { integer: true, positive: true });
                return calcHistogram(vector, bins);
            },
            paramCount: 2,
        },
        'vec:ecdf': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], value = _b[1];
                assertNonEmptyVector(vector, sourceCodeInfo);
                assertNumber(value, sourceCodeInfo, { finite: true });
                var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
                var index = sorted.findIndex(function (val) { return val > value; });
                return index === -1 ? 1 : index / sorted.length;
            },
            paramCount: 2,
        },
        'vec:outliers?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return hasOutliers(vector);
            },
            paramCount: 1,
        },
        'vec:outliers': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return outliers(vector);
            },
            paramCount: 1,
        },
        'vec:bincount': {
            evaluate: function (params, sourceCodeInfo) {
                var _a, _b;
                var vector = params[0];
                assertVector(vector, sourceCodeInfo);
                vector.forEach(function (val) { return assertNumber(val, sourceCodeInfo, { finite: true, integer: true, nonNegative: true }); });
                var minSize = (_a = params[1]) !== null && _a !== void 0 ? _a : 0;
                assertNumber(minSize, sourceCodeInfo, { integer: true, nonNegative: true });
                var weights = (_b = params[2]) !== null && _b !== void 0 ? _b : undefined;
                if (weights !== undefined) {
                    assertVector(weights, sourceCodeInfo);
                    if (weights.length !== vector.length) {
                        throw new LitsError('Weights vector must be the same length as the input vector', sourceCodeInfo);
                    }
                    weights.forEach(function (val) { return assertNumber(val, sourceCodeInfo, { finite: true }); });
                }
                return bincount(vector, minSize, weights);
            },
            paramCount: { min: 1, max: 3 },
        },
        'vec:winsorize': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vector = _b[0], lowerQuantile = _b[1], upperQuantile = _b[2];
                assertVector(vector, sourceCodeInfo);
                assertNumber(lowerQuantile, sourceCodeInfo, { finite: true, gte: 0, lte: 1 });
                upperQuantile !== null && upperQuantile !== void 0 ? upperQuantile : (upperQuantile = lowerQuantile > 0.5 ? 1 : (1 - lowerQuantile));
                assertNumber(upperQuantile, sourceCodeInfo, { finite: true, gte: lowerQuantile, lte: 1 });
                if (vector.length === 0)
                    return [];
                var sorted = __spreadArray([], __read(vector), false).sort(function (a, b) { return a - b; });
                var lowerIndex = Math.max(0, Math.floor(lowerQuantile * vector.length));
                var upperIndex = Math.min(vector.length - 1, Math.max(0, Math.floor(upperQuantile * vector.length) - 1));
                var lowerBound = sorted[lowerIndex];
                var upperBound = sorted[upperIndex];
                return vector.map(function (val) { return Math.max(lowerBound, Math.min(val, upperBound)); });
            },
            paramCount: { min: 2, max: 3 },
        },
        'vec:mse': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) { return acc + Math.pow((val - vectorB[i]), 2); }, 0) / vectorA.length;
            },
            paramCount: 2,
        },
        'vec:rmse': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return Math.sqrt(vectorA.reduce(function (acc, val, i) { return acc + Math.pow((val - vectorB[i]), 2); }, 0) / vectorA.length);
            },
            paramCount: 2,
        },
        'vec:mae': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) { return acc + Math.abs(val - vectorB[i]); }, 0) / vectorA.length;
            },
            paramCount: 2,
        },
        'vec:smape': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) {
                    var diff = Math.abs(val - vectorB[i]);
                    var denom = (Math.abs(val) + Math.abs(vectorB[i])) / 2;
                    return acc + (denom === 0 ? 0 : diff / denom);
                }, 0) / vectorA.length;
            },
            paramCount: 2,
        },
    };
    addReductionFunctions(reductionFunctionNormalExpressions);
    function addReductionFunctions(sequences) {
        var e_2, _a;
        try {
            for (var _b = __values(Object.entries(sequences)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (vectorNormalExpression[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                vectorNormalExpression[key] = value;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }

    /**
     * Performs Gauss-Jordan elimination on a matrix, transforming it to reduced row echelon form
     *
     * @param matrix - The input matrix
     * @returns A tuple containing the reduced row echelon form matrix and the rank
     */
    function gaussJordanElimination(matrix) {
        var _a;
        // Create a copy of the matrix to avoid modifying the original
        var m = matrix.map(function (row) { return __spreadArray([], __read(row), false); });
        var rows = m.length;
        var cols = m[0].length;
        var rank = 0;
        var rowsProcessed = 0;
        // Row reduction to reduced row echelon form
        for (var col = 0; col < cols; col++) {
            // Find the pivot
            var pivotRow = -1;
            for (var row = rowsProcessed; row < rows; row++) {
                if (!approxZero(m[row][col])) {
                    pivotRow = row;
                    break;
                }
            }
            if (pivotRow === -1)
                continue; // No pivot in this column
            // Increase rank
            rank += 1;
            // Swap rows
            if (pivotRow !== rowsProcessed) {
                _a = __read([m[rowsProcessed], m[pivotRow]], 2), m[pivotRow] = _a[0], m[rowsProcessed] = _a[1];
            }
            // Get the pivot value
            var pivotValue = m[rowsProcessed][col];
            // Normalize the pivot row (always, for RREF)
            for (var j = col; j < cols; j++) {
                m[rowsProcessed][j] /= pivotValue;
            }
            // Eliminate above and below (full Gauss-Jordan)
            for (var row = 0; row < rows; row++) {
                if (row !== rowsProcessed && !approxZero(m[row][col])) {
                    var factor = m[row][col];
                    for (var j = col; j < cols; j++) {
                        m[row][j] -= factor * m[rowsProcessed][j];
                    }
                }
            }
            rowsProcessed++;
            if (rowsProcessed === rows)
                break;
        }
        return [m, rank];
    }

    /**
     * Solves a system of linear equations Ax = b
     *
     * @param A - The coefficient matrix
     * @param b - The constant vector
     * @returns The solution vector x, or null if no unique solution exists
     */
    function solve(A, b) {
        var n = A.length;
        // Create augmented matrix [A|b]
        var augmented = A.map(function (row, i) { return __spreadArray(__spreadArray([], __read(row), false), [b[i]], false); });
        // Convert to row echelon form using your existing function
        var _a = __read(gaussJordanElimination(augmented), 1), echelon = _a[0];
        // Check if the system has a unique solution
        for (var i = 0; i < n; i += 1) {
            if (approxZero(echelon[i][i])) {
                return null; // No unique solution
            }
        }
        // Back substitution
        var x = Array.from({ length: n }, function () { return 0; });
        for (var i = n - 1; i >= 0; i--) {
            var sum = 0;
            for (var j = i + 1; j < n; j++) {
                sum += echelon[i][j] * x[j];
            }
            x[i] = (echelon[i][n] - sum) / echelon[i][i];
        }
        return x;
    }

    function areVectorsCollinear(vectorA, vectorB) {
        // Check if either vector is zero
        var isZeroVector = function (vec) {
            return vec.every(function (component) { return approxZero(component); });
        };
        if (isZeroVector(vectorA) || isZeroVector(vectorB)) {
            return true; // Zero vector is technically collinear to all vectors
        }
        // Find the first non-zero component in vectorA
        var index = 0;
        while (index < vectorA.length && approxZero(vectorA[index])) {
            index++;
        }
        // Calculate the scale factor
        var ratio = vectorB[index] / vectorA[index];
        // Check if all other components maintain the same ratio
        for (var i = 0; i < vectorA.length; i++) {
            // Skip components where both vectors have (near) zero values
            if (approxZero(vectorA[i]) && approxZero(vectorB[i]))
                continue;
            // If vectorA component is near zero but vectorB is not, vectors are not collinear
            if (approxZero(vectorA[i]))
                return false;
            // Check if the ratio is consistent
            if (!approxEqual(vectorB[i] / vectorA[i], ratio)) {
                return false;
            }
        }
        return true;
    }
    function areVectorsParallel(vectorA, vectorB) {
        if (!areVectorsCollinear(vectorA, vectorB)) {
            return false;
        }
        // Then verify they point in the same direction
        // Find first non-zero component in both vectors
        for (var i = 0; i < vectorA.length; i++) {
            if (!approxZero(vectorA[i]) && !approxZero(vectorB[i])) {
                return Math.sign(vectorA[i]) === Math.sign(vectorB[i]);
            }
        }
        // If we get here, one of the vectors must be zero
        return true;
    }

    function isZeroVector(vector) {
        return vector.every(function (component) { return approxZero(component); });
    }

    function pearsonCorr(vectorA, vectorB) {
        var meanA = calcMean(vectorA);
        var meanB = calcMean(vectorB);
        var sumNumerator = 0;
        var sumSquareA = 0;
        var sumSquareB = 0;
        for (var i = 0; i < vectorA.length; i++) {
            var diffA = vectorA[i] - meanA;
            var diffB = vectorB[i] - meanB;
            sumNumerator += diffA * diffB;
            sumSquareA += diffA * diffA;
            sumSquareB += diffB * diffB;
        }
        // Check if either vector has zero variance
        if (sumSquareA === 0 || sumSquareB === 0) {
            throw new Error('Cannot calculate Pearson correlation coefficient: one of the vectors has zero variance.');
        }
        return sumNumerator / (Math.sqrt(sumSquareA) * Math.sqrt(sumSquareB));
    }

    function calcFractionalRanks(vector) {
        // Create array of indices and sort by values
        var indices = __spreadArray([], __read(vector.keys()), false).sort(function (a, b) { return vector[a] - vector[b]; });
        // Create ranks array (same size as input vector)
        var ranks = Array.from({ length: vector.length }).fill(0);
        // Assign ranks, handling ties properly
        var currentRank = 1;
        var i = 0;
        while (i < indices.length) {
            var value = vector[indices[i]];
            var j = i;
            // Find all indices with the same value
            while (j < indices.length && vector[indices[j]] === value) {
                j++;
            }
            // Calculate average rank for ties
            var averageRank = currentRank + (j - i - 1) / 2;
            // Assign average rank to all tied elements
            for (var k = i; k < j; k++) {
                ranks[indices[k]] = averageRank;
            }
            // Update current rank and index
            currentRank += j - i;
            i = j;
        }
        return ranks;
    }

    /**
     * Calculates Kendall's Tau-b rank correlation coefficient between two vectors
     * This implementation handles ties and uses an epsilon value for floating-point comparisons
     *
     * @param vectorA - First vector of numbers
     * @param vectorB - Second vector of numbers
     * @param epsilon - Threshold for considering two values as equal (default: 1e-10)
     * @returns The Kendall's Tau-b correlation coefficient
     */
    function kendallTau(vectorA, vectorB, epsilon) {
        if (epsilon === void 0) { epsilon = 1e-10; }
        var concordant = 0;
        var discordant = 0;
        var tiesInA = 0;
        var tiesInB = 0;
        // Compare all pairs
        for (var i = 0; i < vectorA.length; i++) {
            for (var j = i + 1; j < vectorA.length; j++) {
                // Calculate differences
                var diffA = vectorA[i] - vectorA[j];
                var diffB = vectorB[i] - vectorB[j];
                // Check for ties using epsilon
                var isTieA = Math.abs(diffA) < epsilon;
                var isTieB = Math.abs(diffB) < epsilon;
                if (isTieA && isTieB) {
                    // Tied in both vectors
                    continue;
                }
                else if (isTieA) {
                    // Tied in vector A only
                    tiesInA += 1;
                }
                else if (isTieB) {
                    // Tied in vector B only
                    tiesInB += 1;
                }
                else if (diffA * diffB > 0) {
                    // Concordant pair
                    concordant += 1;
                }
                else {
                    // Discordant pair
                    discordant += 1;
                }
            }
        }
        var n1 = concordant + discordant + tiesInA;
        var n2 = concordant + discordant + tiesInB;
        // Handle edge cases to avoid division by zero
        if (n1 === 0 || n2 === 0) {
            throw new Error('Not enough data to calculate Kendall\'s Tau');
        }
        // Kendall's Tau-b formula
        return (concordant - discordant) / Math.sqrt(n1 * n2);
    }

    /**
     * Calculate covariance between two segments
     */
    function calcCovariance(segmentA, segmentB) {
        var meanA = calcMean(segmentA);
        var meanB = calcMean(segmentB);
        var sum = 0;
        for (var i = 0; i < segmentA.length; i++) {
            sum += (segmentA[i] - meanA) * (segmentB[i] - meanB);
        }
        return sum / segmentA.length;
    }

    /**
     * Calculate Pearson correlation between two segments
     */
    function calcCorrelation(segmentA, segmentB) {
        var meanA = calcMean(segmentA);
        var meanB = calcMean(segmentB);
        var stdA = calcStdDev(segmentA, meanA);
        var stdB = calcStdDev(segmentB, meanB);
        // Handle zero variance
        if (stdA === 0 || stdB === 0) {
            // If both have zero variance and are the same constant, they're perfectly correlated
            if (stdA === 0 && stdB === 0 && meanA === meanB) {
                return 1;
            }
            // Otherwise, no meaningful correlation can be established
            return 0;
        }
        var covariance = calcCovariance(segmentA, segmentB);
        return covariance / (stdA * stdB);
    }
    /**
     * Extract overlapping segments from two vectors based on lag
     */
    function extractOverlappingSegments(vectorA, vectorB, lag) {
        var absLag = Math.abs(lag);
        var overlapLength = vectorA.length - absLag;
        var segmentA = [];
        var segmentB = [];
        if (lag >= 0) {
            segmentA = vectorA.slice(0, overlapLength);
            segmentB = vectorB.slice(lag, lag + overlapLength);
        }
        else {
            segmentA = vectorA.slice(absLag);
            segmentB = vectorB.slice(0, overlapLength);
        }
        return [segmentA, segmentB];
    }

    function getUnit(value, sourceCodeInfo) {
        if (value.length === 0) {
            return value;
        }
        var length = Math.sqrt(value.reduce(function (acc, item) { return acc + Math.pow(item, 2); }, 0));
        if (approxZero(length)) {
            throw new LitsError('The vector must not be zero', sourceCodeInfo);
        }
        return value.map(function (item) { return item / length; });
    }

    function dot(vector1, vector2) {
        return vector1.reduce(function (acc, item, index) { return acc + item * vector2[index]; }, 0);
    }

    function subtract(vector1, vector2) {
        return vector1.map(function (item, index) { return item - vector2[index]; });
    }

    function scale(vector, scalar) {
        return vector.map(function (item) { return item * scalar; });
    }

    function length(vector) {
        return Math.sqrt(vector.reduce(function (acc, item) { return acc + Math.pow(item, 2); }, 0));
    }

    var linearAlgebraNormalExpression = {
        'lin:rotate2d': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], radians = _b[1];
                assert2dVector(vector, sourceCodeInfo);
                if (isZeroVector(vector)) {
                    return vector;
                }
                assertNumber(radians, sourceCodeInfo, { finite: true });
                var cosTheta = Math.cos(radians);
                var sinTheta = Math.sin(radians);
                return [
                    vector[0] * cosTheta - vector[1] * sinTheta,
                    vector[0] * sinTheta + vector[1] * cosTheta,
                ];
            },
            paramCount: 2,
        },
        'lin:rotate3d': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vector = _b[0], axis = _b[1], radians = _b[2];
                assert3dVector(vector, sourceCodeInfo);
                if (isZeroVector(vector)) {
                    return vector;
                }
                assertNumber(radians, sourceCodeInfo, { finite: true });
                assert3dVector(axis, sourceCodeInfo);
                if (isZeroVector(axis)) {
                    throw new LitsError('Rotation axis must not be zero', sourceCodeInfo);
                }
                var cosTheta = Math.cos(radians);
                var sinTheta = Math.sin(radians);
                var _c = __read(getUnit(axis, sourceCodeInfo), 3), u = _c[0], v = _c[1], w = _c[2];
                var dotProduct = vector[0] * u + vector[1] * v + vector[2] * w;
                return [
                    dotProduct * u * (1 - cosTheta) + vector[0] * cosTheta + (-w * vector[1] + v * vector[2]) * sinTheta,
                    dotProduct * v * (1 - cosTheta) + vector[1] * cosTheta + (w * vector[0] - u * vector[2]) * sinTheta,
                    dotProduct * w * (1 - cosTheta) + vector[2] * cosTheta + (-v * vector[0] + u * vector[1]) * sinTheta,
                ];
            },
            paramCount: 3,
        },
        'lin:reflect': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], normal = _b[1];
                assertVector(vector, sourceCodeInfo);
                assertVector(normal, sourceCodeInfo);
                if (vector.length !== normal.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                if (isZeroVector(normal)) {
                    throw new LitsError('Reflection normal must not be zero', sourceCodeInfo);
                }
                if (isZeroVector(vector)) {
                    return vector;
                }
                var unitNormal = getUnit(normal, sourceCodeInfo);
                var doubleDot = 2 * dot(vector, unitNormal);
                return subtract(vector, scale(unitNormal, doubleDot));
            },
            paramCount: 2,
        },
        'lin:refract': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vector = _b[0], normal = _b[1], eta = _b[2];
                assertVector(vector, sourceCodeInfo);
                assertVector(normal, sourceCodeInfo);
                assertNumber(eta, sourceCodeInfo, { finite: true, positive: true });
                if (vector.length !== normal.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                if (isZeroVector(normal)) {
                    throw new LitsError('Refraction normal must not be zero', sourceCodeInfo);
                }
                if (isZeroVector(vector)) {
                    return vector;
                }
                // Make sure vectors are normalized
                var normalizedV = getUnit(vector, sourceCodeInfo);
                var normalizedNormal = getUnit(normal, sourceCodeInfo);
                // Calculate dot product between incident vector and normal
                var dotProduct = dot(normalizedV, normalizedNormal);
                // Calculate discriminant
                var discriminant = 1 - eta * eta * (1 - dotProduct * dotProduct);
                // Check for total internal reflection
                if (discriminant < 0) {
                    return vector; // Total internal reflection occurs
                }
                // Calculate the refracted vector
                var scaledIncident = scale(normalizedV, eta);
                var scaledNormal = scale(normalizedNormal, eta * dotProduct + Math.sqrt(discriminant));
                return subtract(scaledIncident, scaledNormal);
            },
            paramCount: 3,
        },
        'lin:lerp': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vectorA = _b[0], vectorB = _b[1], t = _b[2];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                assertNumber(t, sourceCodeInfo, { finite: true });
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.map(function (val, i) { return val + (vectorB[i] - val) * t; });
            },
            paramCount: 3,
        },
        'lin:dot': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return dot(vectorA, vectorB);
            },
            paramCount: 2,
        },
        'lin:cross': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== 3 || vectorB.length !== 3) {
                    throw new LitsError('Cross product is only defined for 3D vectors', sourceCodeInfo);
                }
                return [
                    vectorA[1] * vectorB[2] - vectorA[2] * vectorB[1],
                    vectorA[2] * vectorB[0] - vectorA[0] * vectorB[2],
                    vectorA[0] * vectorB[1] - vectorA[1] * vectorB[0],
                ];
            },
            paramCount: 2,
        },
        'lin:normalize-minmax': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                var min = vector.reduce(function (acc, val) { return (val < acc ? val : acc); }, vector[0]);
                var max = vector.reduce(function (acc, val) { return (val > acc ? val : acc); }, vector[0]);
                if (min === max) {
                    return vector.map(function () { return 0; });
                }
                return vector.map(function (val) { return (val - min) / (max - min); });
            },
            paramCount: 1,
        },
        'lin:normalize-robust': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length === 0) {
                    return [];
                }
                var median = calcMedian(vector);
                var medad = calcMedad(vector);
                if (medad === 0) {
                    return vector.map(function (val) { return val - median; });
                }
                return vector.map(function (val) { return (val - median) / medad; });
            },
            paramCount: 1,
        },
        'lin:normalize-zscore': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                var mean = calcMean(vector);
                var stdDev = calcStdDev(vector);
                if (stdDev === 0) {
                    return vector.map(function () { return 0; });
                }
                return vector.map(function (val) { return (val - mean) / stdDev; });
            },
            paramCount: 1,
        },
        'lin:normalize-l1': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length === 0) {
                    return [];
                }
                var norm = vector.reduce(function (acc, val) { return acc + Math.abs(val); }, 0);
                if (norm === 0) {
                    return vector.map(function () { return 0; });
                }
                return vector.map(function (val) { return val / norm; });
            },
            paramCount: 1,
        },
        'lin:normalize-l2': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                return getUnit(vector, sourceCodeInfo);
            },
            paramCount: 1,
            aliases: ['lin:unit', 'lin:normalize'],
        },
        'lin:normalize-log': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                if (vector.length === 0) {
                    return [];
                }
                var min = Math.min.apply(Math, __spreadArray([], __read(vector), false));
                if (min <= 0) {
                    throw new LitsError('Log normalization requires all values to be positive', sourceCodeInfo);
                }
                return vector.map(function (val) { return Math.log(val / min); });
            },
            paramCount: 1,
        },
        'lin:angle': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (isZeroVector(vectorA) || isZeroVector(vectorB)) {
                    throw new LitsError('Cannot calculate angle with zero-length vector', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var dotProduct = vectorA.reduce(function (acc, val, i) { return acc + val * vectorB[i]; }, 0);
                var magnitudeA = Math.sqrt(vectorA.reduce(function (acc, val) { return acc + val * val; }, 0));
                var magnitudeB = Math.sqrt(vectorB.reduce(function (acc, val) { return acc + val * val; }, 0));
                return Math.acos(dotProduct / (magnitudeA * magnitudeB));
            },
            paramCount: 2,
        },
        'lin:projection': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (isZeroVector(vectorB)) {
                    throw new LitsError('Cannot project onto zero-length vector', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var dotProduct = vectorA.reduce(function (acc, val, i) { return acc + val * vectorB[i]; }, 0);
                var magnitudeB = Math.sqrt(vectorB.reduce(function (acc, val) { return acc + val * val; }, 0));
                return vectorB.map(function (val) { return (dotProduct / (Math.pow(magnitudeB, 2))) * val; });
            },
            paramCount: 2,
        },
        'lin:orthogonal?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var dotProduct = vectorA.reduce(function (acc, val, i) { return acc + val * vectorB[i]; }, 0);
                return dotProduct === 0;
            },
            paramCount: 2,
        },
        'lin:parallel?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return areVectorsParallel(vectorA, vectorB);
            },
            paramCount: 2,
        },
        'lin:collinear?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return areVectorsCollinear(vectorA, vectorB);
            },
            paramCount: 2,
        },
        'lin:cosine-similarity': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (isZeroVector(vectorA) || isZeroVector(vectorB)) {
                    throw new LitsError('Cannot calculate cosine similarity with zero-length vector', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var dotProduct = vectorA.reduce(function (acc, val, i) { return acc + val * vectorB[i]; }, 0);
                var magnitudeA = Math.sqrt(vectorA.reduce(function (acc, val) { return acc + val * val; }, 0));
                var magnitudeB = Math.sqrt(vectorB.reduce(function (acc, val) { return acc + val * val; }, 0));
                return dotProduct / (magnitudeA * magnitudeB);
            },
            paramCount: 2,
        },
        'lin:euclidean-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return Math.sqrt(vectorA.reduce(function (acc, val, i) { return acc + Math.pow((val - vectorB[i]), 2); }, 0));
            },
            aliases: ['lin:distance', 'lin:l2-distance'],
            paramCount: 2,
        },
        'lin:euclidean-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return length(vector);
            },
            paramCount: 1,
            aliases: ['lin:l2-norm', 'lin:length'],
        },
        'lin:manhattan-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) { return acc + Math.abs(val - vectorB[i]); }, 0);
            },
            paramCount: 2,
            aliases: ['lin:l1-distance', 'lin:cityblock-distance'],
        },
        'lin:manhattan-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val) { return acc + Math.abs(val); }, 0);
            },
            paramCount: 1,
            aliases: ['lin:l1-norm', 'lin:cityblock-norm'],
        },
        'lin:hamming-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return vectorA.reduce(function (acc, val, i) { return acc + (val !== vectorB[i] ? 1 : 0); }, 0);
            },
            paramCount: 2,
        },
        'lin:hamming-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return vector.reduce(function (acc, val) { return acc + (val !== 0 ? 1 : 0); }, 0);
            },
            paramCount: 1,
        },
        'lin:chebyshev-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return Math.max.apply(Math, __spreadArray([], __read(vectorA.map(function (val, i) { return Math.abs(val - vectorB[i]); })), false));
            },
            paramCount: 2,
        },
        'lin:chebyshev-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertNonEmptyVector(vector, sourceCodeInfo);
                return Math.max.apply(Math, __spreadArray([], __read(vector.map(function (val) { return Math.abs(val); })), false));
            },
            paramCount: 1,
        },
        'lin:minkowski-distance': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vectorA = _b[0], vectorB = _b[1], p = _b[2];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                assertNumber(p, sourceCodeInfo, { finite: true, positive: true });
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                return Math.pow(vectorA.reduce(function (acc, val, i) { return acc + Math.pow(Math.abs(val - vectorB[i]), p); }, 0), (1 / p));
            },
            paramCount: 3,
        },
        'lin:minkowski-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], p = _b[1];
                assertNonEmptyVector(vector, sourceCodeInfo);
                assertNumber(p, sourceCodeInfo, { finite: true, positive: true });
                return Math.pow(vector.reduce(function (acc, val) { return acc + Math.pow(Math.abs(val), p); }, 0), (1 / p));
            },
            paramCount: 2,
        },
        // TODO consider for Set namespace. E.g. 'set:jaccard-distance'
        // 'lin:jaccard-distance': {
        //   evaluate: ([vectorA, vectorB], sourceCodeInfo): number => {
        //     assertNonEmptyVector(vectorA, sourceCodeInfo)
        //     assertNonEmptyVector(vectorB, sourceCodeInfo)
        //     const intersection = vectorA.filter(val => vectorB.includes(val)).length
        //     const union = new Set([...vectorA, ...vectorB]).size
        //     return 1 - intersection / union
        //   },
        //   paramCount: 2,
        // },
        // TODO consider for Set namespace. E.g. 'set:dice-coefficient'
        // 'lin:dice-coefficient': {
        //   evaluate: ([vectorA, vectorB], sourceCodeInfo): number => {
        //     assertNonEmptyVector(vectorA, sourceCodeInfo)
        //     assertNonEmptyVector(vectorB, sourceCodeInfo)
        //     const intersection = vectorA.filter(val => vectorB.includes(val)).length
        //     return (2 * intersection) / (vectorA.length + vectorB.length)
        //   },
        //   paramCount: 2,
        // },
        // TODO consider for String namespace. E.g. 'str:levenshtein-distance'
        // 'lin:levenshtein-distance': {
        //   evaluate: ([stringA, stringB], sourceCodeInfo): number => {
        //   },
        //   paramCount: 2,
        // },
        'lin:cov': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertNonEmptyVector(vectorA, sourceCodeInfo);
                assertNonEmptyVector(vectorB, sourceCodeInfo);
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                if (vectorA.length === 1) {
                    return 0;
                }
                return calcCovariance(vectorA, vectorB);
            },
            paramCount: 2,
        },
        'lin:corr': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length <= 1) {
                    throw new LitsError('Vectors must have at least 2 elements for lin:corr', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var meanA = calcMean(vectorA);
                var meanB = calcMean(vectorB);
                var numerator = vectorA.reduce(function (acc, val, i) { return acc + (val - meanA) * (vectorB[i] - meanB); }, 0);
                var denominator = Math.sqrt(vectorA.reduce(function (acc, val) { return acc + Math.pow((val - meanA), 2); }, 0) * vectorB.reduce(function (acc, val) { return acc + Math.pow((val - meanB), 2); }, 0));
                return numerator / denominator;
            },
            paramCount: 2,
        },
        'lin:spearman-corr': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length <= 1) {
                    throw new LitsError('Vectors must have at least 2 elements for lin:corr', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                var ranksA = calcFractionalRanks(vectorA);
                var ranksB = calcFractionalRanks(vectorB);
                try {
                    return pearsonCorr(ranksA, ranksB);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 2,
            aliases: ['lin:spearman-rho'],
        },
        'lin:pearson-corr': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length <= 1) {
                    throw new LitsError('Vectors must have at least 2 elements for lin:pearson-corr', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                try {
                    return pearsonCorr(vectorA, vectorB);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 2,
        },
        'lin:kendall-tau': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vectorA = _b[0], vectorB = _b[1];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length < 2) {
                    throw new LitsError('Vectors must have at least 2 elements for lin:kendall-tau', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                try {
                    return kendallTau(vectorA, vectorB);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 2,
        },
        'lin:autocorrelation': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), vector = _b[0], lag = _b[1];
                assertVector(vector, sourceCodeInfo);
                if (vector.length < 2) {
                    throw new LitsError('Vector must have at least 2 elements for lin:autocorrelation', sourceCodeInfo);
                }
                assertNumber(lag, sourceCodeInfo, {
                    integer: true,
                    lt: vector.length,
                    gt: -vector.length,
                });
                // For lag 0, return 1 (a series is perfectly correlated with itself)
                if (lag === 0) {
                    return 1;
                }
                var absLag = Math.abs(lag);
                var mean = calcMean(vector);
                // Calculate the numerator (sum of products of deviations)
                var numerator = 0;
                var n = vector.length;
                // If lag is positive, correlate current with past values
                // If lag is negative, correlate current with future values (same calculation, different interpretation)
                for (var i = 0; i < n - absLag; i++) {
                    var currentIndex = lag < 0 ? i + absLag : i;
                    var laggedIndex = lag < 0 ? i : i + absLag;
                    numerator += (vector[currentIndex] - mean) * (vector[laggedIndex] - mean);
                }
                // Calculate the denominator (sum of squared deviations)
                var denominator = 0;
                for (var i = 0; i < n; i++) {
                    denominator += Math.pow((vector[i] - mean), 2);
                }
                // Handle edge case of zero variance
                if (denominator === 0) {
                    return 0; // Conventional definition
                }
                // Return the autocorrelation coefficient
                return numerator / denominator;
            },
            paramCount: 2,
            aliases: ['lin:acf'],
        },
        'lin:cross-correlation': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), vectorA = _b[0], vectorB = _b[1], lag = _b[2];
                assertVector(vectorA, sourceCodeInfo);
                assertVector(vectorB, sourceCodeInfo);
                if (vectorA.length < 2) {
                    throw new LitsError('Vectors must have at least 2 elements', sourceCodeInfo);
                }
                if (vectorA.length !== vectorB.length) {
                    throw new LitsError('Vectors must be of the same length', sourceCodeInfo);
                }
                assertNumber(lag, sourceCodeInfo, {
                    integer: true,
                    lt: vectorA.length,
                    gt: -vectorA.length,
                });
                // For lag 0 between identical vectors, return 1
                if (lag === 0
                    && vectorA.length === vectorB.length
                    && vectorA.every(function (v, i) { return v === vectorB[i]; })) {
                    return 1;
                }
                var _c = __read(extractOverlappingSegments(vectorA, vectorB, lag), 2), segmentA = _c[0], segmentB = _c[1];
                return calcCorrelation(segmentA, segmentB);
            },
            paramCount: 3,
            aliases: ['lin:ccf'],
        },
        'lin:rref': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                // Reduced Row Echelon Form (RREF)
                var _c = __read(gaussJordanElimination(matrix), 1), rref = _c[0];
                return rref;
            },
            paramCount: 1,
        },
        'lin:solve': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), matrix = _b[0], vector = _b[1];
                assertSquareMatrix(matrix, sourceCodeInfo);
                assertVector(vector, sourceCodeInfo);
                if (matrix.length !== vector.length) {
                    throw new LitsError("The number of rows in the matrix must be equal to the length of the vector, but got ".concat(matrix.length, " and ").concat(vector.length), sourceCodeInfo);
                }
                return solve(matrix, vector);
            },
            paramCount: 2,
        },
        'lin:to-polar': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assert2dVector(vector, sourceCodeInfo);
                if (isZeroVector(vector)) {
                    return [0, 0];
                }
                var r = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
                var theta = Math.atan2(vector[1], vector[0]);
                return [r, theta];
            },
            paramCount: 1,
        },
        'lin:from-polar': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), polar = _b[0];
                assert2dVector(polar, sourceCodeInfo);
                var _c = __read(polar, 2), r = _c[0], theta = _c[1];
                if (r === 0) {
                    return [0, 0];
                }
                return [r * Math.cos(theta), r * Math.sin(theta)];
            },
            paramCount: 1,
        },
    };

    /**
     * Calculates the determinant of a matrix using Gaussian Elimination
     * @param matrix A square matrix represented as a 2D array
     * @returns The determinant of the matrix
     */
    function determinant(matrix) {
        var _a;
        // First, make a deep copy of the matrix to avoid modifying the original
        var n = matrix.length;
        var A = [];
        for (var i = 0; i < n; i++) {
            A[i] = __spreadArray([], __read(matrix[i]), false);
        }
        // Handle special cases for small matrices
        if (n === 1) {
            return A[0][0];
        }
        if (n === 2) {
            return A[0][0] * A[1][1] - A[0][1] * A[1][0];
        }
        // For larger matrices, use Gaussian elimination
        var sign = 1; // Track sign changes from row swaps
        // Perform Gaussian elimination to get an upper triangular matrix
        for (var i = 0; i < n - 1; i += 1) {
            // Find pivot (maximum element in current column)
            var maxRow = i;
            for (var j = i + 1; j < n; j += 1) {
                if (Math.abs(A[j][i]) > Math.abs(A[maxRow][i])) {
                    maxRow = j;
                }
            }
            // If the pivot is zero, the determinant is zero
            if (approxZero(A[maxRow][i])) {
                return 0;
            }
            // Swap rows if necessary
            if (maxRow !== i) {
                _a = __read([A[maxRow], A[i]], 2), A[i] = _a[0], A[maxRow] = _a[1]; // ES6 array destructuring for swap
                sign = -sign; // Each row swap changes the sign
            }
            // Eliminate entries below the pivot
            for (var j = i + 1; j < n; j += 1) {
                var factor = A[j][i] / A[i][i];
                // Subtract (factor * pivot row) from current row
                for (var k = i; k < n; k++) {
                    A[j][k] -= factor * A[i][k];
                }
            }
        }
        // Calculate determinant as the product of diagonal elements
        var det = sign;
        for (var i = 0; i < n; i++) {
            det *= A[i][i];
        }
        return det;
    }

    function minor(matrix, row, col) {
        var n = matrix.length;
        var result = [];
        for (var i = 0; i < n; i++) {
            if (i !== row) {
                var minorRow = [];
                for (var j = 0; j < n; j++) {
                    if (j !== col) {
                        minorRow.push(matrix[i][j]);
                    }
                }
                result.push(minorRow);
            }
        }
        return result;
    }

    function adjugate(matrix) {
        var n = matrix.length;
        var adj = [];
        for (var i = 0; i < n; i++) {
            adj[i] = [];
            for (var j = 0; j < n; j++) {
                var min = minor(matrix, j, i);
                var sign = Math.pow((-1), (i + j));
                var cofactor = sign * determinant(min);
                adj[i][j] = cofactor;
            }
        }
        return adj;
    }

    /**
     * Creates a band matrix with specified lower and upper bandwidths
     *
     * @param n Size of the square matrix
     * @param lband Lower bandwidth (number of non-zero diagonals below main diagonal)
     * @param uband Upper bandwidth (number of non-zero diagonals above main diagonal)
     * @returns A 2D array representing the band matrix with 1s in the band and 0s elsewhere
     */
    function band(n, lband, uband) {
        // Create an n×n matrix filled with zeros
        var matrix = Array.from({ length: n }, function () { return Array.from({ length: n }, function () { return 0; }); });
        // Fill the band with 1s
        for (var i = 0; i < n; i++) {
            for (var j = Math.max(0, i - lband); j <= Math.min(n - 1, i + uband); j++) {
                matrix[i][j] = 1;
            }
        }
        return matrix;
    }

    function cofactor(matrix) {
        var n = matrix.length;
        var cofactors = [];
        // Create a new matrix to store cofactors
        for (var i = 0; i < n; i++) {
            cofactors[i] = [];
            for (var j = 0; j < n; j++) {
                // Get the minor by removing row i and column j
                var min = minor(matrix, i, j);
                var sign = Math.pow((-1), (i + j));
                cofactors[i][j] = sign * determinant(min);
            }
        }
        return cofactors;
    }

    /**
     * Calculate the inverse of a matrix using the adjugate method
     * @param matrix The input matrix
     * @returns The inverse matrix or null if the matrix is not invertible
     */
    function inverse(matrix) {
        var n = matrix.length;
        // Special case for 1x1 matrix - handle it directly
        if (n === 1) {
            var element = matrix[0][0];
            if (approxZero(element)) {
                return null; // Not invertible
            }
            return [[1 / element]];
        }
        // Calculate determinant
        var det = determinant(matrix);
        // Check if matrix is invertible
        if (approxZero(det)) {
            return null; // Matrix is not invertible
        }
        // Get the adjugate matrix
        var adj = adjugate(matrix);
        // Calculate the inverse: inverse = adjugate / determinant
        var inverseMatrix = [];
        for (var i = 0; i < n; i++) {
            inverseMatrix[i] = [];
            for (var j = 0; j < n; j++) {
                inverseMatrix[i][j] = adj[i][j] / det;
            }
        }
        return inverseMatrix;
    }

    /**
     * Checks if a matrix is banded with the given lower and upper bandwidth.
     * A matrix is banded if all non-zero elements are within 'lower' diagonals
     * below the main diagonal and 'upper' diagonals above the main diagonal.
     *
     * @param matrix - The matrix to check, represented as a 2D array of numbers
     * @param lower - Number of non-zero diagonals below the main diagonal
     * @param upper - Number of non-zero diagonals above the main diagonal
     * @returns true if the matrix is banded with the given parameters, false otherwise
     */
    function isBanded(matrix, lower, upper) {
        var rows = matrix.length;
        var cols = matrix[0].length;
        // Check each element in the matrix
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
                // If we find a non-zero element outside the band, return false
                if (matrix[i][j] !== 0 && (i - j > lower || j - i > upper)) {
                    return false;
                }
            }
        }
        // All elements outside the band are zero
        return true;
    }

    function isSquare(matrix) {
        return matrix.length === matrix[0].length;
    }

    /**
     * Checks if a given matrix is diagonal.
     *
     * A matrix is considered diagonal if it is square (i.e., the number of rows equals the number of columns)
     * and all elements outside the main diagonal are zero.
     *
     * @param matrix - A two-dimensional array of numbers representing the matrix to check.
     * @returns `true` if the matrix is diagonal, otherwise `false`.
     */
    function isDiagonal(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var rows = matrix.length;
        for (var i = 0; i < rows; i += 1) {
            for (var j = 0; j < rows; j += 1) {
                if (i !== j && matrix[i][j] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }

    function isIdentity(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var n = matrix.length;
        for (var i = 0; i < n; i++) {
            for (var j = 0; j < n; j++) {
                if (i === j) {
                    if (!approxEqual(matrix[i][j], 1)) {
                        return false;
                    }
                }
                else {
                    if (!approxZero(matrix[i][j])) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    /**
     * Performs cache-optimized matrix multiplication.
     * @param A The first input matrix (m x n)
     * @param B The second input matrix (n x p)
     * @returns The result matrix C (m x p) where C = A × B
     */
    function matrixMultiply(A, B) {
        // Check if matrices can be multiplied
        if (A.length === 0 || B.length === 0 || A[0].length !== B.length) {
            throw new Error('Matrix dimensions do not match for multiplication');
        }
        var m = A.length; // Number of rows in A
        var n = A[0].length; // Number of columns in A / Number of rows in B
        var p = B[0].length; // Number of columns in B
        // Initialize result matrix C with zeros
        var C = Array(m).fill(0).map(function () { return Array(p).fill(0); });
        // Perform multiplication with cache-optimized loop order (i-k-j)
        for (var i = 0; i < m; i++) {
            for (var k = 0; k < n; k++) {
                var aik = A[i][k]; // Cache this value to avoid repeated lookups
                for (var j = 0; j < p; j++) {
                    C[i][j] += aik * B[k][j];
                }
            }
        }
        return C;
    }

    function isOrthogonal(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        // Calculate matrix transpose
        var transposed = transpose(matrix);
        // Check if matrix * transpose = Identity
        var product = matrixMultiply(matrix, transposed);
        // Check if the product is an identity matrix
        return isIdentity(product);
    }

    /**
     * Checks if a given matrix is symmetric.
     * A matrix is symmetric if it is square and its transpose is equal to itself.
     *
     * @param matrix - A 2D array representing the matrix.
     * @returns `true` if the matrix is symmetric, otherwise `false`.
     */
    function isSymetric(matrix) {
        var rows = matrix.length;
        // Check if the matrix is square
        if (!isSquare(matrix)) {
            return false;
        }
        // Check symmetry
        for (var i = 0; i < rows; i += 1) {
            for (var j = 0; j < i; j += 1) {
                if (matrix[i][j] !== matrix[j][i]) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Determines whether a given matrix is triangular.
     *
     * A triangular matrix is a square matrix where all elements
     * below or above the main diagonal are zero. This function
     * checks if the matrix is square and symmetric.
     *
     * @param matrix - A two-dimensional array of numbers representing the matrix.
     * @returns `true` if the matrix is triangular, otherwise `false`.
     */
    function isTriangular(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var rows = matrix.length;
        var isUpperTriangular = true;
        var isLowerTriangular = true;
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < rows; j++) {
                if (i > j && matrix[i][j] !== 0) {
                    isUpperTriangular = false;
                    if (!isLowerTriangular) {
                        return false;
                    }
                }
                if (i < j && matrix[i][j] !== 0) {
                    isLowerTriangular = false;
                }
            }
        }
        return isUpperTriangular || isLowerTriangular;
    }
    function isTriangularUpper(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var rows = matrix.length;
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < i; j++) {
                if (matrix[i][j] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }
    function isTriangularLower(matrix) {
        if (!isSquare(matrix)) {
            return false;
        }
        var rows = matrix.length;
        // Check if the matrix is square
        if (!matrix.every(function (row) { return row.length === rows; })) {
            return false;
        }
        for (var i = 0; i < rows; i++) {
            for (var j = i + 1; j < rows; j++) {
                if (matrix[i][j] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }

    // Assuming a matrix is represented as a 2D array
    function norm1(matrix) {
        var numRows = matrix.length;
        var numCols = matrix[0].length;
        var maxColSum = 0;
        // Iterate through each column
        for (var j = 0; j < numCols; j += 1) {
            var colSum = 0;
            // Sum the absolute values of all elements in this column
            for (var i = 0; i < numRows; i += 1) {
                colSum += Math.abs(matrix[i][j]);
            }
            // Update the maximum column sum if necessary
            maxColSum = Math.max(maxColSum, colSum);
        }
        return maxColSum;
    }

    /**
     * Calculates the trace of a square matrix.
     * The trace is defined as the sum of the elements on the main diagonal.
     *
     * @param matrix - A 2D array representing a square matrix.
     * @returns The trace of the matrix.
     */
    function trace(matrix) {
        return matrix.reduce(function (sum, row, i) { return sum + row[i]; }, 0);
    }

    var matrixNormalExpression = {
        'mat:mul': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), matrix1 = _b[0], matrix2 = _b[1];
                assertMatrix(matrix1, sourceCodeInfo);
                assertMatrix(matrix2, sourceCodeInfo);
                try {
                    return matrixMultiply(matrix1, matrix2);
                }
                catch (error) {
                    throw new LitsError("The number of columns in the first matrix must be equal to the number of rows in the second matrix, but got ".concat(matrix1[0].length, " and ").concat(matrix2.length), sourceCodeInfo);
                }
            },
            paramCount: 2,
        },
        'mat:det': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                return determinant(matrix);
            },
            paramCount: 1,
        },
        'mat:inv': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                var result = inverse(matrix);
                if (result === null) {
                    throw new LitsError('The matrix must be invertible', sourceCodeInfo);
                }
                return result;
            },
            paramCount: 1,
        },
        'mat:adj': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                return adjugate(matrix);
            },
            paramCount: 1,
        },
        'mat:cofactor': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                return cofactor(matrix);
            },
            paramCount: 1,
        },
        'mat:minor': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), matrix = _b[0], row = _b[1], col = _b[2];
                assertMatrix(matrix, sourceCodeInfo);
                assertNumber(row, sourceCodeInfo, { integer: true, nonNegative: true, lte: matrix.length });
                assertNumber(col, sourceCodeInfo, { integer: true, nonNegative: true, lte: matrix[0].length });
                return minor(matrix, row, col);
            },
            paramCount: 3,
        },
        'mat:trace': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertSquareMatrix(matrix, sourceCodeInfo);
                return trace(matrix);
            },
            paramCount: 1,
        },
        'mat:symmetric?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isSymetric(matrix);
            },
            paramCount: 1,
        },
        'mat:triangular?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isTriangular(matrix);
            },
            paramCount: 1,
        },
        'mat:upper-triangular?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isTriangularUpper(matrix);
            },
            paramCount: 1,
        },
        'mat:lower-triangular?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isTriangularLower(matrix);
            },
            paramCount: 1,
        },
        'mat:diagonal?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isDiagonal(matrix);
            },
            paramCount: 1,
        },
        'mat:square?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isSquare(matrix);
            },
            paramCount: 1,
        },
        'mat:orthogonal?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isOrthogonal(matrix);
            },
            paramCount: 1,
        },
        'mat:identity?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return isIdentity(matrix);
            },
            paramCount: 1,
        },
        'mat:invertible?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                if (!isSquareMatrix(matrix)) {
                    return false;
                }
                return !approxZero(determinant(matrix));
            },
            paramCount: 1,
        },
        'mat:hilbert': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), size = _b[0];
                assertNumber(size, sourceCodeInfo, { integer: true, positive: true });
                var result = [];
                for (var i = 0; i < size; i += 1) {
                    var row = [];
                    for (var j = 0; j < size; j += 1) {
                        row.push(1 / (i + j + 1));
                    }
                    result.push(row);
                }
                return result;
            },
            paramCount: 1,
        },
        'mat:vandermonde': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), vector = _b[0];
                assertVector(vector, sourceCodeInfo);
                var result = [];
                for (var i = 0; i < vector.length; i += 1) {
                    var row = [];
                    for (var j = 0; j < vector.length; j += 1) {
                        row.push(Math.pow((vector[i]), j));
                    }
                    result.push(row);
                }
                return result;
            },
            paramCount: 1,
        },
        'mat:band': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), n = _b[0], lband = _b[1], uband = _b[2];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(lband, sourceCodeInfo, { integer: true, nonNegative: true, lt: n });
                assertNumber(uband, sourceCodeInfo, { integer: true, nonNegative: true, lte: n });
                return band(n, lband, uband);
            },
            paramCount: 3,
        },
        'mat:banded?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), matrix = _b[0], lband = _b[1], uband = _b[2];
                assertMatrix(matrix, sourceCodeInfo);
                var maxBand = Math.max(matrix.length, matrix[0].length);
                assertNumber(lband, sourceCodeInfo, { integer: true, nonNegative: true, lt: maxBand });
                assertNumber(uband, sourceCodeInfo, { integer: true, nonNegative: true, lt: maxBand });
                return isBanded(matrix, lband, uband);
            },
            paramCount: 3,
        },
        'mat:rank': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                var _c = __read(gaussJordanElimination(matrix), 2), result = _c[1];
                return result;
            },
            paramCount: 1,
        },
        // Frobenius norm
        'mat:frobenius-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return Math.sqrt(matrix.reduce(function (sum, row) { return sum + row.reduce(function (rowSum, cell) { return rowSum + cell * cell; }, 0); }, 0));
            },
            paramCount: 1,
        },
        // 1-norm
        'mat:1-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return norm1(matrix);
            },
            paramCount: 1,
        },
        // Infinity norm
        'mat:inf-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return matrix.reduce(function (max, row) { return Math.max(max, row.reduce(function (sum, cell) { return sum + Math.abs(cell); }, 0)); }, 0);
            },
            paramCount: 1,
            aliases: ['mat:row-norm'],
        },
        // Max norm
        'mat:max-norm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), matrix = _b[0];
                assertMatrix(matrix, sourceCodeInfo);
                return matrix.reduce(function (maxVal, row) {
                    var rowMax = row.reduce(function (max, val) { return Math.max(max, Math.abs(val)); }, 0);
                    return Math.max(maxVal, rowMax);
                }, 0);
            },
            paramCount: 1,
        },
    };

    function binomialCoefficient(n, k) {
        if (k === 0 || k === n)
            return 1;
        var result = 1;
        for (var i = 0; i < k; i++)
            result *= (n - i) / (i + 1);
        return result;
    }

    /**
     * Generates all possible combinations of a specified size from a collection.
     * @param collection The input collection to generate combinations from
     * @param size The size of each combination
     * @returns An array of arrays, where each inner array is a combination of the specified size
     */
    function combinations(collection, size) {
        var e_1, _a;
        // Base case: if size is 1, return each element as its own combination
        if (size === 1) {
            return collection.map(function (item) { return [item]; });
        }
        var result = [];
        // Recursive approach to build combinations
        for (var i = 0; i <= collection.length - size; i++) {
            // Take the current element
            var current = collection[i];
            // Get all combinations of size-1 from the rest of the elements
            var subCombinations = combinations(collection.slice(i + 1), size - 1);
            try {
                // Add the current element to each sub-combination
                for (var subCombinations_1 = (e_1 = void 0, __values(subCombinations)), subCombinations_1_1 = subCombinations_1.next(); !subCombinations_1_1.done; subCombinations_1_1 = subCombinations_1.next()) {
                    var subComb = subCombinations_1_1.value;
                    result.push(__spreadArray([current], __read(subComb), false));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (subCombinations_1_1 && !subCombinations_1_1.done && (_a = subCombinations_1.return)) _a.call(subCombinations_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return result;
    }
    var combinationsNormalExpressions = {
        'nth:combinations': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), set = _b[0], n = _b[1];
                assertArray(set, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true, lte: set.length });
                if (n === 0)
                    return [[]];
                return combinations(set, n);
            },
            paramCount: 2,
        },
        'nth:count-combinations': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], k = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                assertNumber(k, sourceCodeInfo, { integer: true, nonNegative: true, lte: n });
                return binomialCoefficient(n, k);
            },
            aliases: ['nth:binomial'],
            paramCount: 2,
        },
    };

    function getAllDerangements(arr) {
        var n = arr.length;
        var result = [];
        var used = Array.from({ length: n }, function () { return false; });
        var temp = Array.from({ length: n });
        function generateDerangements(pos) {
            if (pos === n) {
                result.push(__spreadArray([], __read(temp), false));
                return;
            }
            for (var i = 0; i < n; i++) {
                // Skip if element is already used or would be in its original position
                if (used[i] || i === pos) {
                    continue;
                }
                used[i] = true;
                temp[pos] = arr[i];
                generateDerangements(pos + 1);
                used[i] = false;
            }
        }
        generateDerangements(0);
        return result;
    }
    function countDerangements(n) {
        if (n === 1)
            return 0;
        var a = 1; // !0
        var b = 0; // !1
        var result = 0;
        for (var i = 2; i <= n; i++) {
            result = (i - 1) * (a + b);
            a = b;
            b = result;
        }
        return result;
    }
    var derangementsNormalExpressions = {
        'nth:derangements': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), set = _b[0];
                assertArray(set, sourceCodeInfo);
                return getAllDerangements(set);
            },
            paramCount: 1,
        },
        'nth:count-derangements': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return countDerangements(n);
            },
            paramCount: 1,
        },
    };

    function calcUnsortedDivisors(number) {
        var divisors = [];
        for (var i = 1; i <= Math.sqrt(number); i++) {
            if (number % i === 0) {
                divisors.push(i);
                if (i !== number / i) {
                    divisors.push(number / i);
                }
            }
        }
        return divisors;
    }
    function getDivisors(n) {
        var unsortedDivisors = calcUnsortedDivisors(n);
        var sortedDivisors = unsortedDivisors.sort(function (a, b) { return a - b; });
        return sortedDivisors;
    }
    function getProperDivisors(n) {
        return getDivisors(n).slice(0, -1); // Exclude the number itself
    }
    var divisorsNormalExpressions = {
        'nth:divisors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return getDivisors(number);
            },
            paramCount: 1,
        },
        'nth:count-divisors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return calcUnsortedDivisors(number).length;
            },
            paramCount: 1,
        },
        'nth:proper-divisors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return getProperDivisors(number);
            },
            paramCount: 1,
        },
        'nth:count-proper-divisors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return calcUnsortedDivisors(number).length - 1; // Exclude the number itself
            },
            paramCount: 1,
        },
    };

    var factorialNumbers = [
        1,
        1,
        2,
        6,
        24,
        120,
        720,
        5040,
        40320,
        362880,
        3628800,
        39916800,
        479001600,
        6227020800,
        87178291200,
        1307674368000,
        20922789888000,
        355687428096000,
        6402373705728000,
    ];

    function factorialOf(n) {
        if (n < 0)
            throw new Error('Factorial is not defined for negative numbers');
        if (n === 0 || n === 1)
            return 1;
        if (n <= 18) {
            return factorialNumbers[n];
        }
        var result = factorialNumbers[18];
        for (var i = 19; i <= n; i++)
            result *= i;
        return result;
    }
    var factorialNormalExpressions = {
        'nth:factorial': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true, lte: 170 });
                return factorialOf(n);
            },
            aliases: ['nth:!'],
            paramCount: 1,
        },
    };

    var partitionNumbers = [
        1,
        2,
        3,
        5,
        7,
        11,
        15,
        22,
        30,
        42,
        56,
        77,
        101,
        135,
        176,
        231,
        297,
        385,
        490,
        627,
        792,
        1002,
        1255,
        1575,
        1958,
        2436,
        3010,
        3718,
        4565,
        5604,
        6842,
        8349,
        10143,
        12310,
        14883,
        17977,
        21637,
        26015,
        31185,
        37338,
        44583,
        53174,
        63261,
        75175,
        89134,
        105558,
        124754,
        147273,
        173525,
        204226,
        239943,
        281589,
        329931,
        386155,
        451276,
        526823,
        614154,
        715220,
        831820,
        966467,
        1121505,
        1300156,
        1505499,
        1741630,
        2012558,
        2323520,
        2679689,
        3087735,
        3554345,
        4087968,
        4697205,
        5392783,
        6185689,
        7089500,
        8118264,
        9289091,
        10619863,
        12132164,
        13848650,
        15796476,
        18004327,
        20506255,
        23338469,
        26543660,
        30167357,
        34262962,
        38887673,
        44108109,
        49995925,
        56634173,
        64112359,
        72533807,
        82010177,
        92669720,
        104651419,
        118114304,
        133230930,
        150198136,
        169229875,
        190569292,
        214481126,
        241265379,
        271248950,
        304801365,
        342325709,
        384276336,
        431149389,
        483502844,
        541946240,
        607163746,
        679903203,
        761002156,
        851376628,
        952050665,
        1064144451,
        1188908248,
        1327710076,
        1482074143,
        1653668665,
        1844349560,
        2056148051,
        2291320912,
        2552338241,
        2841940500,
        3163127352,
        3519222692,
        3913864295,
        4351078600,
        4835271870,
        5371315400,
        5964539504,
        6620830889,
        7346629512,
        8149040695,
        9035836076,
        10015581680,
        11097645016,
        12292341831,
        13610949895,
        15065878135,
        16670689208,
        18440293320,
        20390982757,
        22540654445,
        24908858009,
        27517052599,
        30388671978,
        33549419497,
        37027355200,
        40853235313,
        45060624582,
        49686288421,
        54770336324,
        60356673280,
        66493182097,
        73232243759,
        80630964769,
        88751778802,
        97662728555,
        107438159466,
        118159068427,
        129913904637,
        142798995930,
        156919475295,
        172389800255,
        189334822579,
        207890420102,
        228204732751,
        250438925115,
        274768617130,
        301384802048,
        330495499613,
        362326859895,
        397125074750,
        435157697830,
        476715857290,
        522115831195,
        571701605655,
        625846753120,
        684957390936,
        749474411781,
        819876908323,
        896684817527,
        980462880430,
        1071823774337,
        1171432692373,
        1280011042268,
        1398341745571,
        1527273599625,
        1667727404093,
        1820701100652,
        1987276856363,
        2168627105469,
        2366022741845,
        2580840212973,
        2814570987591,
        3068829878530,
        3345365983698,
        3646072432125,
        3972999029388,
        4328363658647,
        4714566886083,
        5134205287973,
        5590088317495,
        6085253859260,
        6622987708040,
        7206841706490,
        7840656226137,
        8528581302375,
        9275102575355,
        10085065885767,
        10963707205259,
        11916681236278,
        12950095925895,
        14070545699287,
        15285151248481,
        16601598107914,
        18028182516671,
        19573856161145,
        21248279009367,
        23061871173849,
        25025873760111,
        27152408925615,
        29454549941750,
        31946390696157,
        34643126322519,
        37561133582570,
        40718063627362,
        44132934884255,
        47826239745920,
        51820051838712,
        56138148670947,
        60806135438329,
        65851585970275,
        71304185514919,
        77195892663512,
        83561103925871,
        90436839668817,
        97862933703585,
        105882246722733,
        114540884553038,
        123888443077259,
        133978259344888,
        144867692496445,
        156618412527946,
        169296722391554,
        182973889854026,
        197726516681672,
        213636919820625,
        230793554364681,
        249291451168559,
        269232701252579,
        290726957916112,
        313891991306665,
        338854264248680,
        365749566870782,
        394723676655357,
        425933084409356,
        459545750448675,
        495741934760846,
        534715062908609,
        576672674947168,
        621837416509615,
        670448123060170,
        722760953690372,
        779050629562167,
        839611730366814,
        904760108316360,
        974834369944625,
        1050197489931117,
        1131238503938606,
        1218374349844333,
        1312051800816215,
        1412749565173450,
        1520980492851175,
        1637293969337171,
        1762278433057269,
        1896564103591584,
        2040825852575075,
        2195786311682516,
        2362219145337711,
        2540952590045698,
        2732873183547535,
        2938929793929555,
        3160137867148997,
        3397584011986773,
        3652430836071053,
        3925922161489422,
        4219388528587095,
        4534253126900886,
        4872038056472084,
        5234371069753672,
        5622992691950605,
        6039763882095515,
        6486674127079088,
        6965850144195831,
        7479565078510584,
        8030248384943040,
        8620496275465025,
    ];

    function partitions(n) {
        // Base cases
        if (n <= 0)
            return [[]];
        if (n === 1)
            return [[1]];
        var result = [];
        // Helper function to generate partitions recursively
        function generatePartitions(remaining, max, current) {
            if (remaining === 0) {
                result.push(__spreadArray([], __read(current), false));
                return;
            }
            // Try all possible numbers from 1 up to max
            for (var i = Math.min(max, remaining); i >= 1; i--) {
                current.push(i);
                generatePartitions(remaining - i, i, current);
                current.pop();
            }
        }
        generatePartitions(n, n, []);
        return result;
    }
    var partitionsNormalExpressions = {
        'nth:partitions': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                return partitions(n);
            },
            paramCount: 1,
        },
        'nth:count-partitions': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                if (n === 0)
                    return 1;
                if (n > partitionNumbers.length) {
                    throw new LitsError("n is too large. The maximum value is ".concat(partitionNumbers.length - 1, "."), sourceCodeInfo);
                }
                return partitionNumbers[n - 1];
            },
            paramCount: 1,
        },
    };

    /**
     * Generates all possible permutations of a collection.
     * @param collection The input collection to generate permutations from
     * @returns An array of arrays, where each inner array is a permutation of the input collection
     */
    function permutations(collection) {
        var e_1, _a;
        // Base case: empty array has one permutation - itself
        if (collection.length === 0) {
            return [[]];
        }
        var result = [];
        // For each element in the array
        for (var i = 0; i < collection.length; i++) {
            // Extract the current element
            var current = collection[i];
            // Create a new array without the current element
            var remainingElements = __spreadArray(__spreadArray([], __read(collection.slice(0, i)), false), __read(collection.slice(i + 1)), false);
            // Generate all permutations of the remaining elements
            var subPermutations = permutations(remainingElements);
            try {
                // Add the current element to the beginning of each sub-permutation
                for (var subPermutations_1 = (e_1 = void 0, __values(subPermutations)), subPermutations_1_1 = subPermutations_1.next(); !subPermutations_1_1.done; subPermutations_1_1 = subPermutations_1.next()) {
                    var subPerm = subPermutations_1_1.value;
                    result.push(__spreadArray([current], __read(subPerm), false));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (subPermutations_1_1 && !subPermutations_1_1.done && (_a = subPermutations_1.return)) _a.call(subPermutations_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return result;
    }
    var permutationsNormalExpressions = {
        'nth:permutations': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), set = _b[0];
                assertArray(set, sourceCodeInfo);
                return permutations(set);
            },
            paramCount: 1,
        },
        'nth:count-permutations': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], k = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                assertNumber(k, sourceCodeInfo, { integer: true, nonNegative: true, lte: n });
                return factorialOf(n) / factorialOf(n - k);
            },
            paramCount: 2,
        },
    };

    function powerSet(set) {
        var e_1, _a;
        var result = [[]];
        var _loop_1 = function (value) {
            var newSubsets = result.map(function (subset) { return __spreadArray(__spreadArray([], __read(subset), false), [value], false); });
            result.push.apply(result, __spreadArray([], __read(newSubsets), false));
        };
        try {
            for (var set_1 = __values(set), set_1_1 = set_1.next(); !set_1_1.done; set_1_1 = set_1.next()) {
                var value = set_1_1.value;
                _loop_1(value);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (set_1_1 && !set_1_1.done && (_a = set_1.return)) _a.call(set_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    var powerSetNormalExpressions = {
        'nth:power-set': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), set = _b[0];
                assertArray(set, sourceCodeInfo);
                return powerSet(set);
            },
            paramCount: 1,
        },
        'nth:count-power-set': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                if (n >= 53) {
                    // Number.MAX_SAFE_INTEGER is 2^53 - 1
                    return Infinity;
                }
                return Math.pow(2, n);
            },
            paramCount: 1,
        },
    };

    /**
     * Returns the prime factorization of a number as an array of its prime factors.
     * For example, factors(12) returns [2, 2, 3].
     * Special case: factors(1) returns an empty array [].
     *
     * @param n - A positive integer to factorize
     * @returns An array of prime factors in ascending order
     */
    function primeFactors(n) {
        // Special case: 1 has no prime factors
        if (n === 1) {
            return [];
        }
        var factors = [];
        var divisor = 2;
        // Find factors by trial division
        while (n > 1) {
            // If divisor divides n evenly
            if (n % divisor === 0) {
                // Add divisor to the factors list
                factors.push(divisor);
                // Divide n by the found factor
                n /= divisor;
            }
            else {
                // Move to the next potential divisor
                divisor++;
            }
        }
        return factors;
    }
    var primeFactorsNormalExpressions = {
        'nth:prime-factors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), number = _b[0];
                assertNumber(number, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return primeFactors(number);
            },
            paramCount: 1,
        },
        'nth:distinct-prime-factors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { finite: true, integer: true, positive: true });
                var factors = primeFactors(n);
                var distinctFactors = new Set(factors);
                return Array.from(distinctFactors);
            },
            paramCount: 1,
        },
        'nth:count-prime-factors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { finite: true, integer: true, positive: true });
                return primeFactors(n).length;
            },
            paramCount: 1,
        },
        'nth:count-distinct-prime-factors': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { finite: true, integer: true, positive: true });
                var factors = primeFactors(n);
                var distinctFactors = new Set(factors);
                return distinctFactors.size;
            },
            paramCount: 1,
        },
    };

    function isAbundant(num) {
        var properDivisors = getProperDivisors(num);
        var sum = properDivisors.reduce(function (acc, curr) { return acc + curr; }, 0);
        return sum > num;
    }
    var abundantSequence = {
        'nth:abundant-seq': function (length) {
            var abundants = [];
            var num = 2;
            while (abundants.length < length) {
                if (isAbundant(num)) {
                    abundants.push(num);
                }
                num += 1;
            }
            return abundants;
        },
        'nth:abundant?': function (n) { return isAbundant(n); },
        'nth:abundant-take-while': function (takeWhile) {
            var abundants = [];
            for (var i = 2;; i += 1) {
                if (!isAbundant(i)) {
                    continue;
                }
                if (!takeWhile(i, abundants.length)) {
                    break;
                }
                abundants.push(i);
            }
            return abundants;
        },
    };

    /**
     * Checks if a number is a member of an arithmetic sequence.
     * @param start The first term of the sequence
     * @param step The common difference between terms
     * @param n The number to check
     * @returns true if the number is in the sequence, false otherwise
     */
    function isInArithmeticSequence(start, step, n) {
        // Special case: If step is 0, n must equal start
        if (step === 0) {
            return approxEqual(n, start);
        }
        // Calculate position in sequence
        var position = (n - start) / step;
        // Position must be non-negative
        if (position < 0) {
            return false;
        }
        // Find nearest integer position
        var roundedPosition = Math.round(position);
        // Calculate the value at that position
        var calculatedValue = start + step * roundedPosition;
        // Check both if position is close to an integer and if the
        // calculated value is close to the input value
        return approxEqual(position, roundedPosition) && approxEqual(calculatedValue, n);
    }
    var arithmeticNormalExpressions = {
        'nth:arithmetic-seq': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], step = _b[1], length = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(step, sourceCodeInfo, { finite: true });
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                return Array.from({ length: length }, function (_, i) { return start + i * step; });
            },
            paramCount: 3,
        },
        'nth:arithmetic-take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), start = _c[0], step = _c[1], fn = _c[2];
                var executeFunction = _b.executeFunction;
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(step, sourceCodeInfo, { finite: true });
                assertFunctionLike(fn, sourceCodeInfo);
                var arithmetic = [];
                for (var i = 0;; i += 1) {
                    var value = start + i * step;
                    if (!executeFunction(fn, [value, i], contextStack, sourceCodeInfo)) {
                        break;
                    }
                    arithmetic[i] = value;
                }
                return arithmetic;
            },
            paramCount: 3,
        },
        'nth:arithmetic-nth': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], step = _b[1], n = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(step, sourceCodeInfo, { finite: true });
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                return start + (n - 1) * step;
            },
            paramCount: 3,
        },
        'nth:arithmetic?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], step = _b[1], n = _b[2];
                assertNumber(n, sourceCodeInfo);
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(step, sourceCodeInfo, { finite: true });
                return isInArithmeticSequence(start, step, n);
            },
            paramCount: 3,
        },
    };

    var bellNumbers = [
        1,
        2,
        5,
        15,
        52,
        203,
        877,
        4140,
        21147,
        115975,
        678570,
        4213597,
        27644437,
        190899322,
        1382958545,
        10480142147,
        82864869804,
        682076806159,
        5832742205057,
        51724158235372,
        474869816156751,
        4506715738447323,
    ];

    function getBernoulliSeq(length) {
        var bernoulli = [1];
        for (var n = 1; n < length; n += 1) {
            var sum = 0;
            for (var k = 0; k < n; k += 1) {
                sum += binomialCoefficient(n + 1, k) * bernoulli[k];
            }
            bernoulli[n] = n > 1 && n % 2 === 1 ? 0 : -sum / (n + 1);
        }
        return bernoulli;
    }
    /**
     * Generates Bernoulli numbers as long as the predicate function returns true
     * @param predicate - Function that takes a Bernoulli number and its index and returns true if generation should continue
     * @returns Array of Bernoulli numbers generated until predicate returns false
     */
    function generateBernoulli(predicate) {
        var batchSize = 100;
        // Start with computing the Bernoulli numbers
        var bernoulli = [1];
        var n = 1;
        // Continue generating as long as the predicate returns true
        while (true) {
            // Generate a batch of numbers at a time for efficiency
            var targetLength = bernoulli.length + batchSize;
            for (; n < targetLength; n++) {
                var sum = 0;
                for (var k = 0; k < n; k++) {
                    sum += binomialCoefficient(n + 1, k) * bernoulli[k];
                }
                var newValue = n > 1 && n % 2 === 1 ? 0 : -sum / (n + 1);
                // Check if we should continue
                if (!predicate(newValue, n)) {
                    // We're done, return the generated sequence (including the last value)
                    return bernoulli;
                }
                bernoulli.push(newValue);
            }
        }
    }
    var bernoulliNormalExpressions = {
        'nth:bernoulli-seq': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), length = _b[0];
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                return getBernoulliSeq(length);
            },
            paramCount: 1,
        },
        'nth:bernoulli-nth': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                var bernoulli = getBernoulliSeq(n);
                return bernoulli[n - 1];
            },
            paramCount: 1,
        },
        'nth:bernoulli-take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 1), fn = _c[0];
                var executeFunction = _b.executeFunction;
                assertFunctionLike(fn, sourceCodeInfo);
                var bernoulli = generateBernoulli(function (value, index) { return !!executeFunction(fn, [value, index], contextStack); });
                return bernoulli;
            },
            paramCount: 1,
        },
    };

    var catalanNumbers = [
        1,
        2,
        5,
        14,
        42,
        132,
        429,
        1430,
        4862,
        16796,
        58786,
        208012,
        742900,
        2674440,
        9694845,
        35357670,
        129644790,
        477638700,
        1767263190,
        6564120420,
        24466267020,
        91482563640,
        343059613650,
        1289904147324,
        4861946401452,
        18367353072152,
        69533550916004,
        263747951750360,
        1002242216651368,
        3814986502092304,
    ];

    var collatzSequence = {
        'nth:collatz-seq': function (start) {
            var x = start;
            var collatz = [x];
            while (x !== 1) {
                if (x % 2 === 0) {
                    x /= 2;
                }
                else {
                    x = 3 * x + 1;
                }
                collatz.push(x);
            }
            return collatz;
        },
        'noNth': true,
    };

    function isPrime(num) {
        if (num <= 1) {
            return false;
        }
        if (num <= 3) {
            return true;
        }
        if (num % 2 === 0 || num % 3 === 0) {
            return false;
        }
        for (var i = 5; i * i <= num; i += 6) {
            if (num % i === 0 || num % (i + 2) === 0) {
                return false;
            }
        }
        return true;
    }
    var primeSequence = {
        'nth:prime-seq': function (length) {
            var primes = [];
            var num = 2;
            while (primes.length < length) {
                if (isPrime(num)) {
                    primes.push(num);
                }
                num += 1;
            }
            return primes;
        },
        'nth:prime?': function (n) { return isPrime(n); },
        'nth:prime-take-while': function (takeWhile) {
            var primes = [];
            for (var i = 2;; i += 1) {
                if (!isPrime(i)) {
                    continue;
                }
                if (!takeWhile(i, primes.length)) {
                    break;
                }
                primes.push(i);
            }
            return primes;
        },
    };

    function isComposite(num) {
        if (num <= 1) {
            return false;
        }
        return !isPrime(num);
    }
    var compositeSequence = {
        'nth:composite-seq': function (length) {
            var composites = [];
            var num = 2;
            while (composites.length < length) {
                if (isComposite(num)) {
                    composites.push(num);
                }
                num += 1;
            }
            return composites;
        },
        'nth:composite?': function (n) { return isComposite(n); },
        'nth:composite-take-while': function (takeWhile) {
            var composites = [];
            for (var i = 4;; i += 1) {
                if (!isComposite(i)) {
                    continue;
                }
                if (!takeWhile(i, composites.length)) {
                    break;
                }
                composites.push(i);
            }
            return composites;
        },
    };

    function isDeficient(num) {
        var properDivisors = getProperDivisors(num);
        var sum = properDivisors.reduce(function (acc, curr) { return acc + curr; }, 0);
        return sum < num;
    }
    var deficientSequence = {
        'nth:deficient-seq': function (length) {
            var deficients = [];
            var num = 1;
            while (deficients.length < length) {
                if (isDeficient(num)) {
                    deficients.push(num);
                }
                num += 1;
            }
            return deficients;
        },
        'nth:deficient?': function (n) { return isDeficient(n); },
        'nth:deficient-take-while': function (takeWhile) {
            var deficients = [];
            for (var i = 1;; i += 1) {
                if (!isDeficient(i)) {
                    continue;
                }
                if (!takeWhile(i, deficients.length)) {
                    break;
                }
                deficients.push(i);
            }
            return deficients;
        },
    };

    var fibonacciNumbers = [
        0,
        1,
        1,
        2,
        3,
        5,
        8,
        13,
        21,
        34,
        55,
        89,
        144,
        233,
        377,
        610,
        987,
        1597,
        2584,
        4181,
        6765,
        10946,
        17711,
        28657,
        46368,
        75025,
        121393,
        196418,
        317811,
        514229,
        832040,
        1346269,
        2178309,
        3524578,
        5702887,
        9227465,
        14930352,
        24157817,
        39088169,
        63245986,
        102334155,
        165580141,
        267914296,
        433494437,
        701408733,
        1134903170,
        1836311903,
        2971215073,
        4807526976,
        7778742049,
        12586269025,
        20365011074,
        32951280099,
        53316291173,
        86267571272,
        139583862445,
        225851433717,
        365435296162,
        591286729879,
        956722026041,
        1548008755920,
        2504730781961,
        4052739537881,
        6557470319842,
        10610209857723,
        17167680177565,
        27777890035288,
        44945570212853,
        72723460248141,
        117669030460994,
        190392490709135,
        308061521170129,
        498454011879264,
        806515533049393,
        1304969544928657,
        2111485077978050,
        3416454622906707,
        5527939700884757,
        8944394323791464,
    ];

    /**
     * Checks if a number is a member of a geometric sequence.
     * @param initialTerm The first term of the sequence (a)
     * @param ratio The common ratio of the sequence (r)
     * @param number The number to check
     * @returns true if the number is in the sequence, false otherwise
     */
    function isInGeometricSequence(initialTerm, ratio, number) {
        // Handle special cases
        if (approxEqual(initialTerm, 0)) {
            return approxEqual(number, 0);
        }
        if (approxEqual(ratio, 1)) {
            return approxEqual(number, initialTerm);
        }
        if (approxEqual(ratio, 0)) {
            return approxEqual(number, 0) || approxEqual(number, initialTerm);
        }
        // Check if the number is exactly the initial term
        if (approxEqual(number, initialTerm)) {
            return true;
        }
        // Special case for ratio = -1 (alternating sequence)
        if (approxEqual(ratio, -1)) {
            // In an alternating sequence with ratio -1, the terms are just initialTerm and -initialTerm
            return approxEqual(number, initialTerm) || approxEqual(number, -initialTerm);
        }
        // For negative ratios, we need special handling
        if (ratio < 0) {
            // Calculate log using absolute values
            var logResult_1 = Math.log(Math.abs(number / initialTerm)) / Math.log(Math.abs(ratio));
            // Check if logResult is very close to an integer
            var roundedLogResult_1 = Math.round(logResult_1);
            if (!approxEqual(roundedLogResult_1, logResult_1) || roundedLogResult_1 < 0) {
                return false;
            }
            // For negative ratios, alternating terms have alternating signs
            // Check if sign matches what we expect based on the power
            var expectedSign = roundedLogResult_1 % 2 === 0
                ? Math.sign(initialTerm)
                : Math.sign(initialTerm) * Math.sign(ratio);
            return Math.sign(number) === expectedSign;
        }
        // For positive ratios
        // Quick check based on sequence direction
        if ((ratio > 1 && number < initialTerm) || (ratio < 1 && number > initialTerm)) {
            return false;
        }
        // Calculate n in: number = initialTerm * (ratio^n)
        var logResult = Math.log(number / initialTerm) / Math.log(ratio);
        // Check if logResult is very close to an integer and non-negative
        var roundedLogResult = Math.round(logResult);
        if (!approxEqual(roundedLogResult, logResult) || roundedLogResult < 0) {
            return false;
        }
        // Verify calculated value matches the number exactly
        var calculatedValue = initialTerm * Math.pow(ratio, roundedLogResult);
        return approxEqual(calculatedValue, number);
    }
    var geometricNormalExpressions = {
        'nth:geometric-seq': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], ratio = _b[1], length = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(ratio, sourceCodeInfo, { finite: true });
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                return Array.from({ length: length }, function (_, i) { return start * Math.pow(ratio, i); });
            },
            paramCount: 3,
        },
        'nth:geometric-take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 3), start = _c[0], ratio = _c[1], fn = _c[2];
                var executeFunction = _b.executeFunction;
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(ratio, sourceCodeInfo, { finite: true });
                assertFunctionLike(fn, sourceCodeInfo);
                var geometric = [];
                for (var i = 0;; i += 1) {
                    var value = start * Math.pow(ratio, i);
                    if (!executeFunction(fn, [value, i], contextStack, sourceCodeInfo)) {
                        break;
                    }
                    geometric[i] = value;
                }
                return geometric;
            },
            paramCount: 3,
        },
        'nth:geometric-nth': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], ratio = _b[1], n = _b[2];
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(ratio, sourceCodeInfo, { finite: true });
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                return start * Math.pow(ratio, (n - 1));
            },
            paramCount: 3,
        },
        'nth:geometric?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), start = _b[0], ratio = _b[1], n = _b[2];
                assertNumber(n, sourceCodeInfo);
                assertNumber(start, sourceCodeInfo, { finite: true });
                assertNumber(ratio, sourceCodeInfo, { finite: true });
                return isInGeometricSequence(start, ratio, n);
            },
            paramCount: 3,
        },
    };

    function getGolombSeq(n) {
        var golomb = [0, 1];
        for (var i = 2; i <= n; i += 1) {
            golomb.push(1 + golomb[i - golomb[golomb[i - 1]]]);
        }
        return golomb.slice(1);
    }
    function generateGolombSeq(pred) {
        if (!pred(1, 0)) {
            return [];
        }
        var golomb = [0, 1];
        for (var i = 2;; i++) {
            var golombNumber = 1 + golomb[i - golomb[golomb[i - 1]]];
            if (!pred(golombNumber, i - 1)) {
                break;
            }
            golomb.push(golombNumber);
        }
        return golomb.slice(1);
    }
    var golombSequence = {
        'nth:golomb-seq': function (length) { return getGolombSeq(length); },
        'nth:golomb?': function () { return true; },
        'nth:golomb-take-while': function (takeWhile) { return generateGolombSeq(takeWhile); },
    };

    function isHappyNumber(n) {
        // A happy number is defined by the following process:
        // 1. Starting with any positive integer, replace the number by the sum of the squares of its digits
        // 2. Repeat until either:
        //    - The number equals 1 (in which case it's a happy number)
        //    - It enters a cycle that doesn't include 1 (in which case it's not a happy number)
        if (n <= 0)
            return false;
        // Use a set to detect cycles
        var seen = new Set();
        // Continue until we either reach 1 or detect a cycle
        while (n !== 1 && !seen.has(n)) {
            seen.add(n);
            n = getSumOfSquaredDigits(n);
        }
        // If we reached 1, it's a happy number
        return n === 1;
    }
    function getSumOfSquaredDigits(n) {
        var sum = 0;
        while (n > 0) {
            var digit = n % 10;
            sum += digit * digit;
            n = Math.floor(n / 10);
        }
        return sum;
    }
    var happySequence = {
        'nth:happy-seq': function (length) {
            var happyNumbers = [];
            for (var i = 1; happyNumbers.length < length; i++) {
                var n = i;
                var seen = new Set();
                while (n !== 1 && !seen.has(n)) {
                    seen.add(n);
                    n = String(n)
                        .split('')
                        .reduce(function (sum, digit) { return sum + Math.pow(Number(digit), 2); }, 0);
                }
                if (n === 1)
                    happyNumbers.push(i);
            }
            return happyNumbers;
        },
        'nth:happy?': function (n) { return isHappyNumber(n); },
        'nth:happy-take-while': function (takeWhile) {
            var happyNumbers = [];
            for (var i = 1;; i++) {
                var n = i;
                var seen = new Set();
                while (n !== 1 && !seen.has(n)) {
                    seen.add(n);
                    n = String(n)
                        .split('')
                        .reduce(function (sum, digit) { return sum + Math.pow(Number(digit), 2); }, 0);
                }
                if (n === 1) {
                    if (!takeWhile(i, happyNumbers.length)) {
                        break;
                    }
                    happyNumbers.push(i);
                }
            }
            return happyNumbers;
        },
    };

    var jugglerSequence = {
        'nth:juggler-seq': function (start) {
            var next = start;
            var juggler = [next];
            while (next > 1) {
                next = next % 2 === 0
                    ? Math.floor(Math.sqrt(next))
                    : Math.floor(Math.pow(next, (3 / 2)));
                juggler.push(next);
            }
            return juggler;
        },
        'noNth': true,
    };

    /**
     * Checks if a number is part of the Look-and-Say sequence.
     *
     * The Look-and-Say sequence starts with "1" and each subsequent term describes
     * the previous term by counting consecutive digits. For example:
     * 1, 11, 21, 1211, 111221, 312211, 13112221, ...
     *
     * @param {string|number} target - The number to check (can be a string or number)
     * @returns {boolean} - Whether the target is in the sequence
     */
    function isLookAndSay(target) {
        // The first term of the sequence
        var current = '1';
        // Check if the first term matches
        if (current === target) {
            return true;
        }
        // Generate terms and check against the target
        while (true) {
            current = getNextLookAndSayTerm(current);
            if (current === target) {
                return true;
            }
            // Optimization: if the current term is longer than the target, and
            // the sequence is strictly increasing in length, the target won't be found
            if (current.length > target.length) {
                return false;
            }
        }
    }
    /**
     * Generates the next term in the Look-and-Say sequence
     *
     * @param {string} term - The current term
     * @returns {string} - The next term in the sequence
     */
    function getNextLookAndSayTerm(term) {
        var result = '';
        var count = 1;
        for (var i = 0; i < term.length; i++) {
            // If the current digit is the same as the next one, increment count
            if (i + 1 < term.length && term[i] === term[i + 1]) {
                count++;
            }
            else {
                // Otherwise, append count and the digit to the result
                result += count.toString() + term[i];
                count = 1;
            }
        }
        return result;
    }
    var lookAndSaySequence = {
        'string': true,
        'nth:look-and-say-seq': function (length) {
            var lookAndSay = ['1'];
            for (var i = 1; i < length; i += 1) {
                var prev = lookAndSay[i - 1];
                var next = prev.replace(/(\d)\1*/g, function (match) { return "".concat(match.length).concat(match[0]); });
                lookAndSay[i] = next;
            }
            return lookAndSay;
        },
        'nth:look-and-say-take-while': function (takeWhile) {
            if (!takeWhile('1', 0)) {
                return [];
            }
            var lookAndSay = ['1'];
            for (var i = 1;; i += 1) {
                var prev = lookAndSay[i - 1];
                var next = prev.replace(/(\d)\1*/g, function (match) { return "".concat(match.length).concat(match[0]); });
                if (!takeWhile(next, i)) {
                    break;
                }
                lookAndSay[i] = next;
            }
            return lookAndSay;
        },
        'nth:look-and-say?': function (n) { return isLookAndSay(n); },
    };

    var lucasNumbers = [
        2,
        1,
        3,
        4,
        7,
        11,
        18,
        29,
        47,
        76,
        123,
        199,
        322,
        521,
        843,
        1364,
        2207,
        3571,
        5778,
        9349,
        15127,
        24476,
        39603,
        64079,
        103682,
        167761,
        271443,
        439204,
        710647,
        1149851,
        1860498,
        3010349,
        4870847,
        7881196,
        12752043,
        20633239,
        33385282,
        54018521,
        87403803,
        141422324,
        228826127,
        370248451,
        599074578,
        969323029,
        1568397607,
        2537720636,
        4106118243,
        6643838879,
        10749957122,
        17393796001,
        28143753123,
        45537549124,
        73681302247,
        119218851371,
        192900153618,
        312119004989,
        505019158607,
        817138163596,
        1322157322203,
        2139295485799,
        3461452808002,
        5600748293801,
        9062201101803,
        14662949395604,
        23725150497407,
        38388099893011,
        62113250390418,
        100501350283429,
        162614600673847,
        263115950957276,
        425730551631123,
        688846502588399,
        1114577054219522,
        1803423556807921,
        2918000611027443,
        4721424167835364,
        7639424778862807,
    ];

    /**
     * Generates lucky numbers while the predicate function returns true.
     *
     * @param predicate - Function that tests if we should continue generating numbers.
     *                    Takes the current lucky number and index as parameters.
     * @returns An array of lucky numbers
     */
    function generateLuckyNumbers(predicate) {
        // Start with counting from 1
        var numbers = [];
        for (var i = 1; i <= 2000; i++) {
            numbers.push(i);
        }
        // First step: remove all even numbers (keep 1)
        var filteredNumbers = [1];
        for (var i = 1; i < numbers.length; i++) {
            if (numbers[i] % 2 !== 0) {
                filteredNumbers.push(numbers[i]);
            }
        }
        var luckyNumbers = [1]; // 1 is always the first lucky number
        var count = 1;
        // Check if we should continue after the first number
        if (!predicate(1, 0)) {
            return [];
        }
        // Continue the sieve process
        var index = 1; // Start with the second element (index 1, which is 3)
        while (index < filteredNumbers.length) {
            // Get the current lucky number
            var luckyNumber = filteredNumbers[index];
            // Check if we should continue
            if (!predicate(luckyNumber, count)) {
                break;
            }
            // Add to result
            luckyNumbers.push(luckyNumber);
            count++;
            // Apply the sieve
            var step = luckyNumber;
            var newFiltered = [];
            for (var i = 0; i < filteredNumbers.length; i++) {
                if ((i + 1) % step !== 0) { // Keep numbers not at positions divisible by step
                    newFiltered.push(filteredNumbers[i]);
                }
            }
            filteredNumbers = newFiltered;
            index++;
            // If we're running low on numbers, extend the sequence
            if (index >= filteredNumbers.length - 5) {
                var lastNum = filteredNumbers[filteredNumbers.length - 1];
                var next = lastNum + 2;
                while (filteredNumbers.length < index + 1000) {
                    filteredNumbers.push(next);
                    next += 2;
                }
            }
        }
        return luckyNumbers;
    }
    /**
     * Generates lucky numbers up to a specified length or count
     *
     * Lucky numbers are a subset of integers defined by a specific sieving process:
     * 1. Start with all positive integers: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...
     * 2. Keep 1, delete every 2nd number: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, ...
     * 3. The second remaining number is 3, so keep it and delete every 3rd number: 1, 3, 7, 9, 13, 15, 19, ...
     * 4. The third remaining number is 7, so keep it and delete every 7th number
     * 5. Continue this process to get all lucky numbers
     *
     * @param count - The number of lucky numbers to generate
     * @returns An array containing the first 'count' lucky numbers
     */
    function getLuckyNumbers(count) {
        // Step 1: Start with all odd numbers (we skip the first elimination step since we know
        // the first sieve removes all even numbers)
        var numbers = [];
        var n = 1;
        // Generate enough odd numbers to ensure we'll have 'count' lucky numbers after sieving
        // The factor depends on how many numbers we expect to be eliminated
        // For larger counts, we need a higher factor to ensure we have enough numbers
        var factor = count < 100 ? 20 : 30;
        var initialSize = count * factor;
        while (numbers.length < initialSize) {
            numbers.push(n);
            n += 2;
        }
        // Step 2 and beyond: Apply the lucky number sieve
        var sieveIndex = 1; // Start at index 1 (the second element which is 3)
        while (sieveIndex < numbers.length && sieveIndex < count) {
            var sieveValue = numbers[sieveIndex];
            // Remove every sieveValue-th number
            // This is an optimization over creating a new array each time
            var j = 0;
            for (var i = 0; i < numbers.length; i++) {
                if ((i + 1) % sieveValue !== 0) {
                    numbers[j++] = numbers[i];
                }
            }
            numbers.length = j; // Truncate the array
            // Only increment sieveIndex if it's still within the new array bounds
            if (sieveIndex < numbers.length) {
                sieveIndex++;
            }
        }
        // Return the requested number of lucky numbers
        return numbers.slice(0, count);
    }
    var luckySequence = {
        'nth:lucky-seq': function (length) { return getLuckyNumbers(length); },
        'nth:lucky?': function (n) { return generateLuckyNumbers(function (l) { return l <= n; }).includes(n); },
        'nth:lucky-take-while': function (takeWhile) { return generateLuckyNumbers(takeWhile); },
    };

    var mersenneNumbers = [3, 7, 31, 127, 2047, 8191, 131071, 524287, 2147483647];

    /**
     * Checks if a number is a Padovan number.
     * Padovan numbers follow the recurrence relation: P(n) = P(n-2) + P(n-3) for n >= 3,
     * with initial values P(0) = P(1) = P(2) = 1.
     *
     * The first few Padovan numbers are:
     * 1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 12, 16, 21, 28, 37, 49, 65, 86, 114, 151, 200, ...
     *
     * @param num - The number to check
     * @returns True if the number is a Padovan number, false otherwise
     */
    function isPadovan(num) {
        // Padovan numbers are always positive integers
        if (!Number.isInteger(num) || num <= 0) {
            return false;
        }
        // Special case: The first three Padovan numbers are all 1
        if (num === 1) {
            return true;
        }
        // Pre-calculated Padovan numbers (for efficient lookup, verified for correctness)
        var padovanNumbers = [
            1,
            1,
            1,
            2,
            2,
            3,
            4,
            5,
            7,
            9,
            12,
            16,
            21,
            28,
            37,
            49,
            65,
            86,
            114,
            151,
            200,
            265,
            351,
            465,
            616,
            816,
            1081,
            1432,
            1897,
            2513,
            3329,
            4410,
            5842,
            7739,
            10252,
            13581,
            17991,
            23833,
            31572,
            41824,
            55405,
            73396,
            97229,
        ];
        // Direct lookup for known values
        if (padovanNumbers.includes(num)) {
            return true;
        }
        // For numbers larger than our pre-calculated list but within JavaScript's safe range
        if (num > padovanNumbers[padovanNumbers.length - 1] && num <= Number.MAX_SAFE_INTEGER) {
            // Start with the last three values from our known sequence
            var a = padovanNumbers[padovanNumbers.length - 3];
            var b = padovanNumbers[padovanNumbers.length - 2];
            var c = padovanNumbers[padovanNumbers.length - 1];
            var next 
            // Generate Padovan numbers until we either find a match or exceed the input
            = void 0;
            // Generate Padovan numbers until we either find a match or exceed the input
            while (c < num) {
                next = a + b;
                a = b;
                b = c;
                c = next;
                if (c === num) {
                    return true;
                }
                // Check for numeric overflow/precision issues
                if (!Number.isSafeInteger(c)) {
                    return false;
                }
            }
        }
        return false;
    }
    var padovanSequence = {
        'nth:padovan-seq': function (length) {
            var padovan = [1, 1, 1];
            for (var i = 3; i < length; i += 1) {
                padovan[i] = padovan[i - 2] + padovan[i - 3];
            }
            return padovan.slice(0, length);
        },
        'nth:padovan?': function (n) { return isPadovan(n); },
        'nth:padovan-take-while': function (takeWhile) {
            var padovan = [];
            if (!takeWhile(1, 0)) {
                return padovan;
            }
            padovan.push(1);
            if (!takeWhile(1, 1)) {
                return padovan;
            }
            padovan.push(1);
            if (!takeWhile(1, 2)) {
                return padovan;
            }
            padovan.push(1);
            var a = 1;
            var b = 1;
            var c = 1;
            for (var i = 4;; i += 1) {
                var temp = a + b;
                a = b;
                b = c;
                c = temp;
                if (!takeWhile(c, i)) {
                    break;
                }
                padovan.push(c);
            }
            return padovan;
        },
    };

    var pellNumbers = [
        1,
        2,
        5,
        12,
        29,
        70,
        169,
        408,
        985,
        2378,
        5741,
        13860,
        33461,
        80782,
        195025,
        470832,
        1136689,
        2744210,
        6625109,
        15994428,
        38613965,
        93222358,
        225058681,
        543339720,
        1311738121,
        3166815962,
        7645370045,
        18457556052,
        44560482149,
        107578520350,
        259717522849,
        627013566048,
        1513744654945,
        3654502875938,
        8822750406821,
        21300003689580,
        51422757785981,
        124145519261542,
        299713796309065,
        723573111879672,
        1746860020068409,
        4217293152016490,
    ];

    var perfectNumbers = [6, 28, 496, 8128, 33550336, 8589869056, 137438691328];

    var perfectCubeSequence = {
        'nth:perfect-cube-seq': function (length) {
            var perfectcubes = [];
            for (var i = 1; i <= length; i++) {
                perfectcubes.push(Math.pow(i, 3));
            }
            return perfectcubes;
        },
        'nth:perfect-cube?': function (n) { return n > 0 && Number.isInteger(Math.cbrt(n)); },
        'nth:perfect-cube-take-while': function (takeWhile) {
            var perfectcubes = [];
            for (var i = 1;; i++) {
                var value = Math.pow(i, 3);
                if (!takeWhile(value, i)) {
                    break;
                }
                perfectcubes.push(value);
            }
            return perfectcubes;
        },
    };

    /**
     * Checks if a number is a perfect power and returns the base and exponent if it is.
     * A perfect power is a number that can be expressed as an integer power of another integer.
     *
     * @param n - The number to check
     * @returns [base, exponent] if n is a perfect power, null otherwise
     */
    function perfectPower(n) {
        // Handle edge cases
        if (n < 2) {
            if (n === 1) {
                // 1 is 1^k for any k, we return [1, 2] as the simplest representation
                return [1, 2];
            }
            return null; // Non positive numbers are not perfect powers
        }
        // For each possible exponent k, try to find base b such that b^k = n
        var maxK = Math.floor(Math.log2(n)) + 1;
        for (var k = 2; k <= maxK; k++) {
            // Calculate the potential base as n^(1/k)
            var b = Math.pow(n, (1 / k));
            var roundedB = Math.round(b);
            if (approxEqual(Math.pow(roundedB, k), n)) {
                return [roundedB, k];
            }
        }
        return null; // Not a perfect power
    }
    var perfectPowerSequence = {
        'nth:perfect-power-seq': function (length) {
            var perfectPowers = [];
            for (var i = 1; perfectPowers.length < length; i++) {
                if (perfectPower(i)) {
                    perfectPowers.push(i);
                }
            }
            return perfectPowers;
        },
        'nth:perfect-power?': function (n) { return perfectPower(n) !== null; },
        'nth:perfect-power-take-while': function (takeWhile) {
            var perfectPowers = [];
            for (var i = 1;; i++) {
                if (perfectPower(i)) {
                    if (!takeWhile(i, perfectPowers.length)) {
                        break;
                    }
                    perfectPowers.push(i);
                }
            }
            return perfectPowers;
        },
    };

    var perfectSquareSequence = {
        'nth:perfect-square-seq': function (length) {
            var perfectSquares = [];
            for (var i = 1; i <= length; i++) {
                perfectSquares.push(Math.pow(i, 2));
            }
            return perfectSquares;
        },
        'nth:perfect-square?': function (n) { return n > 0 && Number.isInteger(Math.sqrt(n)); },
        'nth:perfect-square-take-while': function (takeWhile) {
            var perfectSquares = [];
            for (var i = 1;; i++) {
                var value = Math.pow(i, 2);
                if (!takeWhile(value, i)) {
                    break;
                }
                perfectSquares.push(value);
            }
            return perfectSquares;
        },
    };

    var poligonalNormalExpressions = {
        'nth:polygonal-seq': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), sides = _b[0], n = _b[1];
                assertNumber(sides, sourceCodeInfo, { integer: true, gte: 3 });
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                var polygonal = [];
                for (var i = 1; i <= n; i += 1) {
                    polygonal[i - 1] = (i * i * (sides - 2) - i * (sides - 4)) / 2;
                }
                return polygonal;
            },
            paramCount: 2,
        },
        'nth:polygonal-take-while': {
            evaluate: function (_a, sourceCodeInfo, contextStack, _b) {
                var _c = __read(_a, 2), sides = _c[0], fn = _c[1];
                var executeFunction = _b.executeFunction;
                assertNumber(sides, sourceCodeInfo, { integer: true, gte: 3 });
                assertFunctionLike(fn, sourceCodeInfo);
                var polygonal = [];
                for (var i = 1;; i += 1) {
                    var value = (i * i * (sides - 2) - i * (sides - 4)) / 2;
                    if (!executeFunction(fn, [value, i], contextStack, sourceCodeInfo)) {
                        break;
                    }
                    polygonal[i - 1] = (i * i * (sides - 2) - i * (sides - 4)) / 2;
                }
                return polygonal;
            },
            paramCount: 2,
        },
        'nth:polygonal-nth': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), sides = _b[0], n = _b[1];
                assertNumber(sides, sourceCodeInfo, { integer: true, gte: 3 });
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                return (n * n * (sides - 2) - n * (sides - 4)) / 2;
            },
            paramCount: 2,
        },
        'nth:polygonal?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), sides = _b[0], n = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true });
                assertNumber(sides, sourceCodeInfo, { integer: true, gte: 3 });
                if (n <= 0) {
                    return false;
                }
                var a = sides - 2;
                var b = sides - 4;
                var discriminant = 8 * a * n + b * b;
                var sqrtPart = Math.sqrt(discriminant);
                // Discriminant must yield an integer square root
                if (!Number.isInteger(sqrtPart))
                    return false;
                var numerator = sqrtPart + b;
                // Numerator must be divisible by 2*a
                if (numerator % (2 * a) !== 0)
                    return false;
                var x = numerator / (2 * a);
                // x must be a positive integer
                return Number.isInteger(x) && x > 0;
            },
            paramCount: 2,
        },
    };

    /**
     * Generates the first 'n' terms of the Recamán sequence.
     *
     * @param n - Number of terms to generate
     * @returns Array containing the first n terms of the Recamán sequence
     */
    function generateRecamanSequence(n) {
        if (n === 1)
            return [0];
        var sequence = [0];
        var seen = new Set([0]);
        for (var i = 1; i < n; i++) {
            // Try to go backward
            var next = sequence[i - 1] - i;
            // If that's not positive or already seen, go forward
            if (next <= 0 || seen.has(next)) {
                next = sequence[i - 1] + i;
            }
            sequence.push(next);
            seen.add(next);
        }
        return sequence;
    }
    var recamanSequence = {
        'nth:recaman-seq': function (length) { return generateRecamanSequence(length); },
        'nth:recaman-take-while': function (takeWhile) {
            if (!takeWhile(0, 0))
                return [];
            var sequence = [0];
            var seen = new Set([0]);
            for (var i = 1;; i++) {
                // Try to go backward
                var next = sequence[i - 1] - i;
                // If that's not positive or already seen, go forward
                if (next <= 0 || seen.has(next)) {
                    next = sequence[i - 1] + i;
                }
                if (!takeWhile(next, i))
                    break;
                sequence.push(next);
                seen.add(next);
            }
            return sequence;
        },
        'nth:recaman?': function () { return true; },
    };

    var sylvesterNumbers = [
        2,
        6,
        42,
        1806,
        3263442,
        10650056950806,
    ];

    var thueMorseSequence = {
        'nth:thue-morse-seq': function (length) {
            var thueMorse = [];
            for (var i = 0; i < length; i += 1) {
                thueMorse[i] = countSetBits(i) % 2;
            }
            return thueMorse;
        },
        'nth:thue-morse-take-while': function (takeWhile) {
            var thueMorse = [];
            for (var i = 0;; i += 1) {
                var value = countSetBits(i) % 2;
                if (!takeWhile(value, i)) {
                    break;
                }
                thueMorse[i] = value;
            }
            return thueMorse;
        },
        'nth:thue-morse?': function (n) { return n === 1 || n === 0; },
    };
    function countSetBits(num) {
        var count = 0;
        while (num) {
            count += num & 1;
            num >>= 1;
        }
        return count;
    }

    var tribonacciNumbers = [
        0,
        1,
        1,
        2,
        4,
        7,
        13,
        24,
        44,
        81,
        149,
        274,
        504,
        927,
        1705,
        3136,
        5768,
        10609,
        19513,
        35890,
        66012,
        121415,
        223317,
        410744,
        755476,
        1389537,
        2555757,
        4700770,
        8646064,
        15902591,
        29249425,
        53798080,
        98950096,
        181997601,
        334745777,
        615693474,
        1132436852,
        2082876103,
        3831006429,
        7046319384,
        12960201916,
        23837527729,
        43844049029,
        80641778674,
        148323355432,
        272809183135,
        501774317241,
        922906855808,
        1697490356184,
        3122171529233,
        5742568741225,
        10562230626642,
        19426970897100,
        35731770264967,
        65720971788709,
        120879712950776,
        222332455004452,
        408933139743937,
        752145307699165,
        1383410902447554,
        2544489349890656,
        4680045560037375,
        8607945812375585,
    ];

    var sequenceNormalExpressions = {};
    addSequence(abundantSequence);
    addSequence(collatzSequence);
    addSequence(compositeSequence);
    addSequence(deficientSequence);
    addSequence(golombSequence);
    addSequence(happySequence);
    addSequence(jugglerSequence);
    addSequence(lookAndSaySequence);
    addSequence(luckySequence);
    addSequence(padovanSequence);
    addSequence(perfectSquareSequence);
    addSequence(perfectCubeSequence);
    addSequence(perfectPowerSequence);
    addSequence(primeSequence);
    addSequence(recamanSequence);
    addSequence(thueMorseSequence);
    addNormalExpressions$1(getFiniteNumberSequence('tribonacci', tribonacciNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('catalan', catalanNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('factorial', factorialNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('fibonacci', fibonacciNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('lucas', lucasNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('mersenne', mersenneNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('partition', partitionNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('pell', pellNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('perfect', perfectNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('sylvester', sylvesterNumbers));
    addNormalExpressions$1(getFiniteNumberSequence('bell', bellNumbers));
    addNormalExpressions$1(arithmeticNormalExpressions);
    addNormalExpressions$1(bernoulliNormalExpressions);
    addNormalExpressions$1(geometricNormalExpressions);
    addNormalExpressions$1(poligonalNormalExpressions);
    function addNormalExpressions$1(normalExpressions) {
        var e_1, _a;
        try {
            for (var _b = __values(Object.entries(normalExpressions)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (sequenceNormalExpressions[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                sequenceNormalExpressions[key] = value;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    function getFiniteNumberSequence(name, sequence) {
        var _a;
        return _a = {},
            _a["nth:".concat(name, "-seq")] = createSeqNormalExpression(function (length) { return sequence.slice(0, length); }, sequence.length),
            _a["nth:".concat(name, "-take-while")] = createTakeWhileNormalExpression(function (takeWhile) {
                var i = 0;
                for (i = 0;; i += 1) {
                    if (i >= sequence.length) {
                        break;
                    }
                    if (!takeWhile(sequence[i], i)) {
                        break;
                    }
                }
                return sequence.slice(0, i);
            }, sequence.length),
            _a["nth:".concat(name, "-nth")] = createNthNormalExpression(function () { return sequence; }, sequence.length),
            _a["nth:".concat(name, "?")] = createNumberPredNormalExpression(function (n) { return sequence.includes(n); }),
            _a;
    }
    function addSequence(sequence) {
        var e_2, _a;
        try {
            for (var _b = __values(Object.entries(sequence)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (sequenceNormalExpressions[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                if (key.endsWith('seq')) {
                    sequenceNormalExpressions[key] = createSeqNormalExpression(value, sequence.maxLength);
                    if (!sequence.noNth) {
                        sequenceNormalExpressions[key.replace(/seq$/, 'nth')] = createNthNormalExpression(value, sequence.maxLength);
                    }
                }
                else if (key.endsWith('take-while')) {
                    sequenceNormalExpressions[key] = createTakeWhileNormalExpression(value, sequence.maxLength);
                }
                else if (key.endsWith('?')) {
                    if (sequence.string) {
                        sequenceNormalExpressions[key] = createStringPredNormalExpression(value);
                    }
                    else {
                        sequenceNormalExpressions[key] = createNumberPredNormalExpression(value);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    function createSeqNormalExpression(seqFunction, maxLength) {
        return {
            evaluate: function (params, sourceCodeInfo) {
                var _a;
                var length = (_a = params[0]) !== null && _a !== void 0 ? _a : maxLength;
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true, lte: maxLength });
                var result = seqFunction(length, sourceCodeInfo);
                if (typeof result[0] === 'number') {
                    /* v8 ignore next 3 */
                    if (result.some(function (n) { return n > Number.MAX_SAFE_INTEGER; })) {
                        throw new LitsError('Result exceeds maximum safe integer', sourceCodeInfo);
                    }
                }
                return result;
            },
            paramCount: typeof maxLength === 'number' ? { max: 1 } : 1,
        };
    }
    function createTakeWhileNormalExpression(takeWhileFunction, maxLength) {
        return {
            evaluate: function (params, sourceCodeInfo, contextStack, _a) {
                var executeFunction = _a.executeFunction;
                var fn = params[0];
                assertFunctionLike(fn, sourceCodeInfo);
                var result = takeWhileFunction(function (value, index) { return !!executeFunction(fn, [value, index], contextStack); }, sourceCodeInfo);
                if (typeof result[0] === 'number') {
                    /* v8 ignore next 3 */
                    if (result.some(function (n) { return n > Number.MAX_SAFE_INTEGER; })) {
                        throw new LitsError('Result exceeds maximum safe integer', sourceCodeInfo);
                    }
                }
                return result;
            },
            paramCount: typeof maxLength === 'number' ? { max: 1 } : 1,
        };
    }
    function createNthNormalExpression(seqFunction, maxLength) {
        return {
            evaluate: function (params, sourceCodeInfo) {
                var n = params[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true, lte: maxLength });
                var sequence = seqFunction(n, sourceCodeInfo);
                if (typeof sequence[0] === 'number') {
                    /* v8 ignore next 3 */
                    if (sequence.some(function (val) { return val > Number.MAX_SAFE_INTEGER; })) {
                        throw new LitsError('Result exceeds maximum safe integer', sourceCodeInfo);
                    }
                }
                return sequence[n - 1];
            },
            paramCount: 1,
        };
    }
    function createNumberPredNormalExpression(predFunction) {
        return {
            evaluate: function (params, sourceCodeInfo) {
                var value = params[0];
                assertNumber(value, sourceCodeInfo);
                return predFunction(value, sourceCodeInfo);
            },
            paramCount: 1,
        };
    }
    function createStringPredNormalExpression(predFunction) {
        return {
            evaluate: function (params, sourceCodeInfo) {
                var value = params[0];
                assertString(value, sourceCodeInfo);
                return predFunction(value, sourceCodeInfo);
            },
            paramCount: 1,
        };
    }

    function gcd(a, b) {
        while (b !== 0) {
            var temp = b;
            b = a % b;
            a = temp;
        }
        return Math.abs(a);
    }
    function lcm(a, b) {
        return Math.floor((a * b) / gcd(a, b));
    }
    function mobius(n) {
        if (n === 1)
            return 1;
        var factors = primeFactors(n);
        var uniqueFactors = new Set(factors);
        // If n has a repeated prime factor (not square-free)
        if (uniqueFactors.size !== factors.length)
            return 0;
        // If square-free with even number of prime factors: return 1
        // If square-free with odd number of prime factors: return -1
        return factors.length % 2 === 0 ? 1 : -1;
    }
    /**
     * Efficiently computes (base^exponent) % modulus using the square-and-multiply algorithm
     * Based on the pseudocode algorithm for modular exponentiation
     *
     * @param base - The base number
     * @param exponent - The exponent (must be non-negative)
     * @param modulus - The modulus (must be positive)
     * @returns The result of (base^exponent) % modulus
     */
    function modExp(base, exponent, modulus) {
        // Edge case: modulus is 1
        if (modulus === 1) {
            return 0;
        }
        // Assert: (modulus - 1) * (modulus - 1) does not overflow base
        // This is a limitation of using regular JavaScript numbers instead of BigInt
        // Initialize result
        var result = 1;
        // Apply modulo to base first
        base = base % modulus;
        // Square and multiply algorithm
        while (exponent > 0) {
            // If current bit of exponent is 1, multiply result with current base
            if (exponent % 2 === 1) {
                result = (result * base) % modulus;
            }
            // Shift exponent right (divide by 2)
            exponent = exponent >> 1;
            // Square the base for next iteration
            base = (base * base) % modulus;
        }
        return result;
    }
    /**
     * Extended Euclidean Algorithm
     * Finds gcd(a,b) and coefficients x,y such that ax + by = gcd(a,b)
     */
    function extendedGcd(a, b) {
        if (b === 0) {
            return [a, 1, 0];
        }
        var _a = __read(extendedGcd(b, a % b), 3), g = _a[0], x = _a[1], y = _a[2];
        return [g, y, x - Math.floor(a / b) * y];
    }
    /**
     * Modular Multiplicative Inverse
     * Finds x such that (a * x) % m = 1
     */
    function modInverse(a, m) {
        var _a = __read(extendedGcd(a, m), 2), g = _a[0], x = _a[1];
        if (g !== 1) {
            throw new Error("Modular inverse does not exist (gcd(".concat(a, ", ").concat(m, ") = ").concat(g, ")"));
        }
        return ((x % m) + m) % m; // Ensure positive result
    }
    /**
     * Chinese Remainder Theorem
     * Solve system of congruences: x ≡ remainders[i] (mod moduli[i])
     * Returns the smallest positive integer that satisfies all congruences
     */
    function chineseRemainder(remainders, moduli) {
        // Verify moduli are pairwise coprime
        for (var i = 0; i < moduli.length; i++) {
            for (var j = i + 1; j < moduli.length; j++) {
                var extGcd = extendedGcd(moduli[i], moduli[j])[0];
                if (extGcd !== 1) {
                    throw new Error("Moduli must be pairwise coprime, but gcd(".concat(moduli[i], ", ").concat(moduli[j], ") = ").concat(extGcd));
                }
            }
        }
        // Calculate product of all moduli
        var product = moduli.reduce(function (acc, val) { return acc * val; }, 1);
        var sum = 0;
        for (var i = 0; i < remainders.length; i++) {
            var ai = remainders[i];
            var ni = moduli[i];
            var bi = product / ni;
            // Find modular multiplicative inverse of bi modulo ni
            var inverse = modInverse(bi, ni);
            // Add contribution from this congruence
            sum = (sum + ai * bi * inverse) % product;
        }
        return sum;
    }
    var combinatoricalNormalExpression = {
        'nth:coprime?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo, { integer: true });
                assertNumber(b, sourceCodeInfo, { integer: true });
                return gcd(a, b) === 1;
            },
            paramCount: 2,
        },
        'nth:divisible-by?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), value = _b[0], divisor = _b[1];
                assertNumber(value, sourceCodeInfo, { integer: true });
                assertNumber(divisor, sourceCodeInfo, { integer: true });
                if (divisor === 0)
                    return false;
                return value % divisor === 0;
            },
            paramCount: 2,
        },
        'nth:gcd': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo);
                assertNumber(b, sourceCodeInfo);
                return gcd(a, b);
            },
            paramCount: 2,
        },
        'nth:lcm': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo);
                assertNumber(b, sourceCodeInfo);
                return lcm(a, b);
            },
            paramCount: 2,
        },
        'nth:multinomial': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a), args = _b.slice(0);
                assertVector(args, sourceCodeInfo);
                var sum = args.reduce(function (acc, curr) {
                    assertNumber(curr, sourceCodeInfo, { integer: true, nonNegative: true });
                    return acc + curr;
                }, 0);
                return factorialOf(sum) / args.reduce(function (acc, curr) { return acc * factorialOf(curr); }, 1);
            },
            paramCount: { min: 1 },
        },
        'nth:amicable?': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(b, sourceCodeInfo, { integer: true, positive: true });
                var sumA = getProperDivisors(a).reduce(function (acc, curr) { return acc + curr; }, 0);
                var sumB = getProperDivisors(b).reduce(function (acc, curr) { return acc + curr; }, 0);
                return sumA === b && sumB === a && a !== b;
            },
            paramCount: 2,
        },
        'nth:euler-totient': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                var result = n;
                for (var p = 2; p * p <= n; p += 1) {
                    if (n % p === 0) {
                        while (n % p === 0)
                            n /= p;
                        result -= result / p;
                    }
                }
                if (n > 1)
                    result -= result / n;
                return result;
            },
            paramCount: 1,
        },
        'nth:mobius': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                if (n === 1)
                    return 1;
                var factors = primeFactors(n);
                var uniqueFactors = new Set(factors);
                // If n has a repeated prime factor (not square-free)
                if (uniqueFactors.size !== factors.length)
                    return 0;
                // If square-free with even number of prime factors: return 1
                // If square-free with odd number of prime factors: return -1
                return factors.length % 2 === 0 ? 1 : -1;
            },
            paramCount: 1,
            aliases: ['nth:möbius'],
        },
        'nth:mertens': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                if (n === 1)
                    return 1;
                var result = 0;
                for (var i = 1; i <= n; i++) {
                    var mobiusValue = mobius(i);
                    result += mobiusValue; // * Math.floor(n / i)
                }
                return result;
            },
            paramCount: 1,
            aliases: ['nth:mertens'],
        },
        'nth:sigma': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                return getDivisors(n).reduce(function (acc, curr) { return acc + curr; }, 0);
            },
            paramCount: 1,
        },
        'nth:carmichael-lambda': {
            evaluate: function (_a, sourceCodeInfo) {
                var e_1, _b, e_2, _c;
                var _d = __read(_a, 1), n = _d[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                if (n === 1) {
                    return 1;
                }
                // Count occurrences of each prime factor
                var primes = primeFactors(n);
                var factorMap = new Map();
                try {
                    for (var primes_1 = __values(primes), primes_1_1 = primes_1.next(); !primes_1_1.done; primes_1_1 = primes_1.next()) {
                        var prime = primes_1_1.value;
                        factorMap.set(prime, (factorMap.get(prime) || 0) + 1);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (primes_1_1 && !primes_1_1.done && (_b = primes_1.return)) _b.call(primes_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                var lambdaValues = [];
                try {
                    // Calculate lambda for each prime power
                    for (var _e = __values(factorMap.entries()), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var _g = __read(_f.value, 2), p = _g[0], k = _g[1];
                        if (p === 2) {
                            if (k === 1) {
                                lambdaValues.push(1); // λ(2) = 1
                            }
                            else if (k === 2) {
                                lambdaValues.push(2); // λ(4) = 2
                            }
                            else {
                                lambdaValues.push(Math.pow(2, (k - 2))); // λ(2^k) = 2^(k-2) for k >= 3
                            }
                        }
                        else {
                            // For odd prime powers p^k: λ(p^k) = (p-1)*p^(k-1)
                            lambdaValues.push((p - 1) * Math.pow(p, (k - 1)));
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                // Find LCM of all lambda values
                return lambdaValues.reduce(function (acc, val) { return lcm(acc, val); }, 1);
            },
            paramCount: 1,
        },
        'nth:cartesian-product': {
            evaluate: function (params, sourceCodeInfo) {
                params.forEach(function (set) {
                    assertArray(set, sourceCodeInfo);
                });
                var sets = params;
                return sets.reduce(function (acc, set) {
                    var result = [];
                    acc.forEach(function (arr) {
                        set.forEach(function (value) {
                            result.push(__spreadArray(__spreadArray([], __read(arr), false), [value], false));
                        });
                    });
                    return result;
                }, [[]]);
            },
            paramCount: { min: 1 },
        },
        'nth:perfect-power': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), n = _b[0];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                var result = perfectPower(n);
                return result || null;
            },
            paramCount: 1,
        },
        'nth:mod-exp': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 3), base = _b[0], exponent = _b[1], modulus = _b[2];
                assertNumber(base, sourceCodeInfo, { finite: true });
                assertNumber(exponent, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(modulus, sourceCodeInfo, { integer: true, positive: true });
                return modExp(base, exponent, modulus);
            },
            paramCount: 3,
        },
        'nth:mod-inv': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], m = _b[1];
                assertNumber(a, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(m, sourceCodeInfo, { integer: true, positive: true });
                try {
                    return modInverse(a, m);
                }
                catch (error) {
                    throw new LitsError(error, sourceCodeInfo);
                }
            },
            paramCount: 2,
        },
        'nth:extended-gcd': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), a = _b[0], b = _b[1];
                assertNumber(a, sourceCodeInfo, { integer: true });
                assertNumber(b, sourceCodeInfo, { integer: true });
                return extendedGcd(a, b);
            },
            paramCount: 2,
        },
        'nth:chinese-remainder': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), remainders = _b[0], moduli = _b[1];
                assertVector(remainders, sourceCodeInfo);
                assertVector(moduli, sourceCodeInfo);
                if (remainders.length !== moduli.length) {
                    throw new LitsError('Remainders and moduli must have the same length.', sourceCodeInfo);
                }
                try {
                    return chineseRemainder(remainders, moduli);
                }
                catch (error) {
                    throw new LitsError(error.message, sourceCodeInfo);
                }
            },
            paramCount: 2,
        },
        'nth:stirling-first': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], k = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(k, sourceCodeInfo, { integer: true, positive: true, lte: n });
                // Create a table to store results
                var dp = Array.from({ length: n + 1 }, function () { return Array(k + 1).fill(0); });
                // Base case
                dp[0][0] = 1;
                // Fill the table using the recurrence relation
                for (var i = 1; i <= n; i++) {
                    for (var j = 1; j <= Math.min(i, k); j++) {
                        dp[i][j] = dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j];
                    }
                }
                return dp[n][k];
            },
            paramCount: 2,
        },
        'nth:stirling-second': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], k = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, positive: true });
                assertNumber(k, sourceCodeInfo, { integer: true, positive: true, lte: n });
                if (k === 1)
                    return 1; // Only one way to put n objects into one subset
                if (k === n)
                    return 1; // Only one way to put n objects into n subsets (one object per subset)
                // Create a 2D array for memoization
                var dp = Array.from({ length: n + 1 }, function () { return Array(k + 1).fill(0); });
                // Initialize base cases
                dp[0][0] = 1;
                // Fill the dp table using the recurrence relation:
                // S(n,k) = k * S(n-1,k) + S(n-1,k-1)
                for (var i = 1; i <= n; i++) {
                    for (var j = 1; j <= Math.min(i, k); j++) {
                        dp[i][j] = j * dp[i - 1][j] + dp[i - 1][j - 1];
                    }
                }
                return dp[n][k];
            },
            paramCount: 2,
        },
    };
    addSequences(sequenceNormalExpressions);
    addNormalExpressions(factorialNormalExpressions);
    addNormalExpressions(divisorsNormalExpressions);
    addNormalExpressions(combinationsNormalExpressions);
    addNormalExpressions(permutationsNormalExpressions);
    addNormalExpressions(partitionsNormalExpressions);
    addNormalExpressions(primeFactorsNormalExpressions);
    addNormalExpressions(derangementsNormalExpressions);
    addNormalExpressions(powerSetNormalExpressions);
    function addSequences(sequences) {
        var e_3, _a;
        try {
            for (var _b = __values(Object.entries(sequences)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (combinatoricalNormalExpression[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                combinatoricalNormalExpression[key] = value;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
    function addNormalExpressions(normalExpressions) {
        var e_4, _a;
        try {
            for (var _b = __values(Object.entries(normalExpressions)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                /* v8 ignore next 3 */
                if (combinatoricalNormalExpression[key]) {
                    throw new Error("Duplicate normal expression key found: ".concat(key));
                }
                combinatoricalNormalExpression[key] = value;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }

    var randomNormalExpression = {
        '!:random': {
            evaluate: function () {
                return Math.random();
            },
            paramCount: 0,
        },
        '!:random-int': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), min = _b[0], max = _b[1];
                assertNumber(min, sourceCodeInfo, { integer: true });
                assertNumber(max, sourceCodeInfo, { integer: true, gt: min });
                return Math.floor(Math.random() * (max - min)) + min;
            },
            paramCount: 2,
        },
        '!:random-int-inclusive': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), min = _b[0], max = _b[1];
                assertNumber(min, sourceCodeInfo, { integer: true });
                assertNumber(max, sourceCodeInfo, { integer: true, gte: min });
                return Math.floor(Math.random() * (max - min + 1)) + min;
            },
            paramCount: 2,
        },
        '!:random-float': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), min = _b[0], max = _b[1];
                assertNumber(min, sourceCodeInfo);
                assertNumber(max, sourceCodeInfo, { gt: min });
                return Math.random() * (max - min) + min;
            },
            paramCount: 2,
        },
        '!:random-boolean': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), prob = _b[0];
                var probability = prob !== null && prob !== void 0 ? prob : 0.5;
                assertNumber(probability, sourceCodeInfo, { gte: 0, lte: 1 });
                return Math.random() < probability;
            },
            paramCount: { min: 0, max: 1 },
        },
        '!:random-item': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), array = _b[0];
                assertArray(array, sourceCodeInfo);
                var index = Math.floor(Math.random() * array.length);
                return asAny(array[index]);
            },
            paramCount: 1,
        },
        '!:random-sample': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], n = _b[1];
                assertArray(array, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                if (array.length === 0) {
                    throw new LitsError('Cannot sample from an empty array.', sourceCodeInfo);
                }
                var result = [];
                for (var i = 0; i < n; i++) {
                    // Pick a random index from the array
                    var randomIndex = Math.floor(Math.random() * array.length);
                    // Add the randomly selected item to the result
                    result.push(array[randomIndex]);
                }
                return result;
            },
            paramCount: 2,
        },
        '!:random-sample-unique': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), array = _b[0], n = _b[1];
                assertArray(array, sourceCodeInfo);
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true, lte: array.length });
                if (array.length === 0) {
                    throw new LitsError('Cannot sample from an empty array.', sourceCodeInfo);
                }
                var result = [];
                var copyArray = __spreadArray([], __read(array), false);
                for (var i = 0; i < n; i++) {
                    // Pick a random index from the array
                    var randomIndex = Math.floor(Math.random() * copyArray.length);
                    // Add the randomly selected item to the result
                    result.push(copyArray[randomIndex]);
                    // Remove the used item from the copy array
                    copyArray.splice(randomIndex, 1);
                }
                return result;
            },
            paramCount: 2,
        },
        '!:shuffle': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b;
                var _c = __read(_a, 1), array = _c[0];
                assertArray(array, sourceCodeInfo);
                var shuffledArray = __spreadArray([], __read(array), false);
                for (var i = shuffledArray.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    _b = __read([shuffledArray[j], shuffledArray[i]], 2), shuffledArray[i] = _b[0], shuffledArray[j] = _b[1];
                }
                return shuffledArray;
            },
            paramCount: 1,
        },
        '!:random-normal': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), mean = _b[0], stdDev = _b[1];
                assertNumber(mean, sourceCodeInfo);
                assertNumber(stdDev, sourceCodeInfo, { gt: 0 });
                var u1 = Math.random();
                var u2 = Math.random();
                var z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
                return z0 * stdDev + mean;
            },
            paramCount: 2,
        },
        '!:random-exponential': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), lambda = _b[0];
                assertNumber(lambda, sourceCodeInfo, { gt: 0 });
                var u = Math.random();
                return -Math.log(u) / lambda;
            },
            paramCount: 1,
        },
        '!:random-binomial': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), n = _b[0], p = _b[1];
                assertNumber(n, sourceCodeInfo, { integer: true, nonNegative: true });
                assertNumber(p, sourceCodeInfo, { gte: 0, lte: 1 });
                var k = 0;
                for (var i = 0; i < n; i++) {
                    if (Math.random() < p) {
                        k++;
                    }
                }
                return k;
            },
            paramCount: 2,
        },
        '!:random-poisson': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), lambda = _b[0];
                assertNumber(lambda, sourceCodeInfo, { gt: 0 });
                var L = Math.exp(-lambda);
                var k = 0;
                var p = 1;
                do {
                    k++;
                    p *= Math.random();
                } while (p > L);
                return k - 1;
            },
            paramCount: 1,
        },
        '!:random-gamma': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), shape = _b[0], scale = _b[1];
                assertNumber(shape, sourceCodeInfo, { gt: 0 });
                assertNumber(scale, sourceCodeInfo, { gt: 0 });
                return randomGamma(shape, scale);
            },
            paramCount: 2,
        },
        '!:random-pareto': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), alpha = _b[0];
                assertNumber(alpha, sourceCodeInfo, { gt: 0 });
                var u = Math.random();
                return Math.pow((1 / u), (1 / alpha));
            },
            paramCount: 1,
        },
        '!:uuid': {
            evaluate: function () {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (char) {
                    var random = Math.random() * 16 | 0;
                    var value = char === 'x' ? random : (random & 0x3 | 0x8);
                    return value.toString(16);
                });
            },
            paramCount: 0,
        },
        '!:random-char': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), charSet = _b[0];
                assertString(charSet, sourceCodeInfo);
                if (charSet.length === 0) {
                    throw new LitsError('Character set cannot be empty.', sourceCodeInfo);
                }
                var randomIndex = Math.floor(Math.random() * charSet.length);
                return charSet[randomIndex];
            },
            paramCount: 1,
        },
        '!:random-string': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 2), length = _b[0], charSet = _b[1];
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                assertString(charSet, sourceCodeInfo);
                if (charSet.length === 0) {
                    throw new LitsError('Character set cannot be empty.', sourceCodeInfo);
                }
                var result = '';
                for (var i = 0; i < length; i++) {
                    var randomIndex = Math.floor(Math.random() * charSet.length);
                    result += charSet[randomIndex];
                }
                return result;
            },
            paramCount: 2,
        },
        '!:random-id': {
            evaluate: function (_a, sourceCodeInfo) {
                var _b = __read(_a, 1), length = _b[0];
                assertNumber(length, sourceCodeInfo, { integer: true, positive: true });
                var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                var result = '';
                for (var i = 0; i < length; i++) {
                    var randomIndex = Math.floor(Math.random() * chars.length);
                    result += chars[randomIndex];
                }
                return result;
            },
            paramCount: 1,
        },
        '!:random-color': {
            evaluate: function () {
                var randomColor = Math.floor(Math.random() * 0x1000000).toString(16);
                return "#".concat(randomColor.padStart(6, '0'));
            },
            paramCount: 0,
        },
    };
    /**
     * Generates a random number from a gamma distribution
     * @param shape The shape parameter (alpha) - must be positive
     * @param scale The scale parameter (beta) - must be positive
     * @returns A random number following the gamma distribution
     */
    function randomGamma(shape, scale) {
        if (scale === void 0) { scale = 1; }
        // Special case for shape < 1
        if (shape < 1) {
            var d_1 = shape + 1.0 - 1.0 / 3.0;
            return randomGamma(d_1, scale) * Math.pow(Math.random(), (1.0 / shape));
        }
        // Marsaglia and Tsang method for shape >= 1
        var d = shape - 1.0 / 3.0;
        var c = 1.0 / Math.sqrt(9.0 * d);
        var x, v, u;
        while (true) {
            do {
                x = randn(); // Standard normal random variable
                v = 1.0 + c * x;
            } while (v <= 0);
            v = v * v * v;
            u = Math.random();
            if (u < 1.0 - 0.0331 * x * x * x * x) {
                return scale * d * v;
            }
            if (Math.log(u) < 0.5 * x * x + d * (1.0 - v + Math.log(v))) {
                return scale * d * v;
            }
        }
    }
    /**
     * Helper function to generate standard normal random variables
     * using Box-Muller transform
     */
    function randn() {
        var u = 0;
        var v = 0;
        while (u === 0)
            u = Math.random();
        while (v === 0)
            v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    var expressions = __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, bitwiseNormalExpression), collectionNormalExpression), arrayNormalExpression), sequenceNormalExpression), mathNormalExpression), miscNormalExpression), assertNormalExpression), objectNormalExpression), predicatesNormalExpression), regexpNormalExpression), stringNormalExpression), functionalNormalExpression), vectorNormalExpression), linearAlgebraNormalExpression), gridNormalExpression), matrixNormalExpression), combinatoricalNormalExpression), randomNormalExpression);
    var aliases = {};
    Object.values(expressions).forEach(function (normalExpression) {
        var _a;
        (_a = normalExpression.aliases) === null || _a === void 0 ? void 0 : _a.forEach(function (alias) {
            aliases[alias] = normalExpression;
        });
    });
    var normalExpressions = __assign(__assign({}, expressions), aliases);
    var normalExpressionTypes = {};
    var allNormalExpressions = [];
    Object.entries(normalExpressions).forEach(function (_a, index) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        normalExpressionTypes[key] = index;
        allNormalExpressions.push(value);
    });

    var andSpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var value = true;
            try {
                for (var _c = __values(node[1][1]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var param = _d.value;
                    value = evaluateNode(param, contextStack);
                    if (!value)
                        break;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return value;
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var e_2, _a;
            var value = true;
            try {
                for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                    var param = params_1_1.value;
                    value = asAny(param, sourceCodeInfo);
                    if (!value)
                        break;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return value;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var condSpecialExpression = {
        paramCount: { even: true },
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var params = node[1][1];
            try {
                for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                    var _c = __read(params_1_1.value, 2), test = _c[0], form = _c[1];
                    var value = evaluateNode(test, contextStack);
                    if (!value)
                        continue;
                    return evaluateNode(form, contextStack);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (params_1_1 && !params_1_1.done && (_b = params_1.return)) _b.call(params_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1].flat(), contextStack, builtin, evaluateNode);
        },
    };

    var switchSpecialExpression = {
        paramCount: { odd: true },
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var _c = __read(node[1], 3), switchValueNode = _c[1], cases = _c[2];
            var switchValue = evaluateNode(switchValueNode, contextStack);
            try {
                for (var cases_1 = __values(cases), cases_1_1 = cases_1.next(); !cases_1_1.done; cases_1_1 = cases_1.next()) {
                    var _d = __read(cases_1_1.value, 2), test = _d[0], form = _d[1];
                    var value = evaluateNode(test, contextStack);
                    if (value === switchValue) {
                        return evaluateNode(form, contextStack);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (cases_1_1 && !cases_1_1.done && (_b = cases_1.return)) _b.call(cases_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(__spreadArray([node[1][1]], __read(node[1][2].flat()), false), contextStack, builtin, evaluateNode);
        },
    };

    function isSymbolNode(node) {
        var nodeType = node[0];
        return NodeTypes.UserDefinedSymbol === nodeType
            || NodeTypes.NormalBuiltinSymbol === nodeType
            || NodeTypes.SpecialBuiltinSymbol === nodeType;
    }
    function assertSymbolNode(node, sourceCodeInfo) {
        if (!isSymbolNode(node))
            throw getAssertionError('SymbolNode', node, sourceCodeInfo);
    }
    function isUserDefinedSymbolNode(node) {
        return NodeTypes.UserDefinedSymbol === node[0];
    }
    function asUserDefinedSymbolNode(node, sourceCodeInfo) {
        assertUserDefinedSymbolNode(node, sourceCodeInfo);
        return node;
    }
    function assertUserDefinedSymbolNode(node, sourceCodeInfo) {
        if (!isUserDefinedSymbolNode(node))
            throw getAssertionError('UserDefinedSymbolNode', node, sourceCodeInfo);
    }
    function isNormalBuiltinSymbolNode(node) {
        return NodeTypes.NormalBuiltinSymbol === node[0];
    }
    function isSpecialBuiltinSymbolNode(node) {
        return NodeTypes.SpecialBuiltinSymbol === node[0];
    }
    function isNormalExpressionNode(node) {
        return node[0] === NodeTypes.NormalExpression;
    }
    function isNormalExpressionNodeWithName(node) {
        if (!isNormalExpressionNode(node)) {
            return false;
        }
        return isSymbolNode(node[1][0]);
    }
    function isSpreadNode(node) {
        return node[0] === NodeTypes.Spread;
    }

    var definedSpecialExpression = {
        paramCount: 1,
        evaluate: function (node, contextStack) {
            var symbolNode = node[1][1];
            assertSymbolNode(symbolNode);
            if (!isUserDefinedSymbolNode(symbolNode)) {
                return true; // If the symbol is not a user defined symbol, it is defined. normal or special builtin
            }
            var lookUpResult = contextStack.lookUp(symbolNode);
            return lookUpResult !== null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols([node[1][1]], contextStack, builtin, evaluateNode);
        },
    };

    var bindingTargetTypes = {
        symbol: 11,
        rest: 12,
        object: 13,
        array: 14,
    };

    function walkDefaults(bindingTarget, onDefault) {
        var _a;
        if (bindingTarget[0] === bindingTargetTypes.object) {
            Object.values(bindingTarget[1][0]).forEach(function (element) {
                if (element[1][1]) {
                    onDefault(element[1][1]);
                }
                walkDefaults(element, onDefault);
            });
        }
        else if (bindingTarget[0] === bindingTargetTypes.array) {
            for (var index = 0; index < bindingTarget[1][0].length; index += 1) {
                var element = (_a = bindingTarget[1][0][index]) !== null && _a !== void 0 ? _a : null;
                if (element === null) {
                    continue;
                }
                if (element[1][1]) {
                    onDefault(element[1][1]);
                }
                walkDefaults(element, onDefault);
            }
        }
    }
    function evalueateBindingNodeValues(target, value, evaluate) {
        var sourceCodeInfo = target[2];
        var record = {};
        createRecord(target, value, evaluate, sourceCodeInfo, record);
        return record;
    }
    function createRecord(bindingTarget, value, evaluate, sourceCodeInfo, record) {
        var _a, _b;
        if (bindingTarget[0] === bindingTargetTypes.object) {
            assertUnknownRecord(value, sourceCodeInfo);
            var capturedKeys_1 = new Set();
            var restElement_1;
            Object.entries(bindingTarget[1][0]).forEach(function (_a) {
                var _b;
                var _c = __read(_a, 2), key = _c[0], element = _c[1];
                if (element[0] === bindingTargetTypes.rest) {
                    restElement_1 = element;
                    return;
                }
                capturedKeys_1.add(key);
                var val = (_b = (value[key] !== undefined ? value[key] : element[1][1] && evaluate(element[1][1]))) !== null && _b !== void 0 ? _b : null;
                assertAny(val, sourceCodeInfo);
                createRecord(element, val, evaluate, sourceCodeInfo, record);
            });
            if (restElement_1) {
                var restValues = Object.entries(value)
                    .filter(function (_a) {
                    var _b = __read(_a, 1), key = _b[0];
                    return !capturedKeys_1.has(key);
                })
                    .reduce(function (acc, _a) {
                    var _b = __read(_a, 2), key = _b[0], val = _b[1];
                    acc[key] = asAny(val);
                    return acc;
                }, {});
                record[restElement_1[1][0]] = restValues;
            }
        }
        else if (bindingTarget[0] === bindingTargetTypes.array) {
            var restIndex = null;
            assertArray(value, sourceCodeInfo);
            for (var index = 0; index < bindingTarget[1][0].length; index += 1) {
                var element = (_a = bindingTarget[1][0][index]) !== null && _a !== void 0 ? _a : null;
                if (element === null) {
                    continue;
                }
                if (element[0] === bindingTargetTypes.rest) {
                    restIndex = index;
                    break;
                }
                var val = (_b = (value[index] !== undefined ? value[index] : element[1][1] && evaluate(element[1][1]))) !== null && _b !== void 0 ? _b : null;
                assertAny(val, sourceCodeInfo);
                createRecord(element, val, evaluate, sourceCodeInfo, record);
            }
            if (restIndex !== null) {
                var restValues = value.slice(restIndex);
                var restElement = bindingTarget[1][0][restIndex];
                record[restElement[1][0]] = restValues;
            }
        }
        else if (bindingTarget[0] === bindingTargetTypes.rest) {
            record[bindingTarget[1][0]] = asAny(value);
        }
        else {
            record[bindingTarget[1][0][1]] = asAny(value);
        }
    }
    function getAllBindingTargetNames(bindingTarget) {
        var names = {};
        getNamesFromBindingTarget(bindingTarget, names);
        return names;
    }
    function getNamesFromBindingTarget(target, names) {
        var e_1, _a, e_2, _b;
        if (target === null) {
            return;
        }
        if (target[0] === bindingTargetTypes.array) {
            try {
                for (var _c = __values(target[1][0]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var element = _d.value;
                    getNamesFromBindingTarget(element, names);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else if (target[0] === bindingTargetTypes.object) {
            try {
                for (var _e = __values(Object.values(target[1][0])), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var element = _f.value;
                    getNamesFromBindingTarget(element, names);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        else if (target[0] === bindingTargetTypes.rest) {
            if (names[target[1][0]]) {
                throw new LitsError("Duplicate binding name: ".concat(target[1][0]), target[2]);
            }
            names[target[1][0]] = true;
        }
        else {
            if (names[target[1][0][1]]) {
                throw new LitsError("Duplicate binding name: ".concat(target[1][0]), target[2]);
            }
            names[target[1][0][1]] = true;
        }
    }

    var defSpecialExpression = {
        paramCount: 2,
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var bindingNode = node[1][1];
            var target = bindingNode[1][0];
            var value = bindingNode[1][1];
            var bindingValue = evaluateNode(value, contextStack);
            var values = evalueateBindingNodeValues(target, bindingValue, function (Node) { return evaluateNode(Node, contextStack); });
            contextStack.exportValues(values, target[2]);
            return bindingValue;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var bindingNode = node[1][1];
            var target = bindingNode[1][0];
            var value = bindingNode[1][1];
            var bindingResult = getUndefinedSymbols([value], contextStack, builtin, evaluateNode);
            walkDefaults(target, function (defaultNode) {
                addToSet(bindingResult, getUndefinedSymbols([defaultNode], contextStack, builtin, evaluateNode));
            });
            contextStack.addValues(getAllBindingTargetNames(target), target[2]);
            return bindingResult;
        },
    };

    var doSpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var newContext = {};
            var newContextStack = contextStack.create(newContext);
            var result = null;
            try {
                for (var _c = __values(node[1][1]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var form = _d.value;
                    result = evaluateNode(form, newContextStack);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack.create({}), builtin, evaluateNode);
        },
    };

    var nonNumberReservedSymbolRecord = {
        true: true,
        false: false,
        null: null,
        else: null,
        case: null,
        each: null,
        in: null,
        when: null,
        while: null,
        catch: null,
        function: null,
        export: null,
        as: null,
        _: null,
    };
    var phi = (1 + Math.sqrt(5)) / 2;
    var numberReservedSymbolRecord = {
        'E': Math.E,
        '-E': -Math.E,
        'ε': Math.E,
        '-ε': -Math.E,
        'PI': Math.PI,
        '-PI': -Math.PI,
        'π': Math.PI,
        '-π': -Math.PI,
        'PHI': phi,
        '-PHI': -phi,
        'φ': phi,
        '-φ': -phi,
        'POSITIVE_INFINITY': Number.POSITIVE_INFINITY,
        '∞': Number.POSITIVE_INFINITY,
        'NEGATIVE_INFINITY': Number.NEGATIVE_INFINITY,
        '-∞': Number.NEGATIVE_INFINITY,
        'MAX_SAFE_INTEGER': Number.MAX_SAFE_INTEGER,
        'MIN_SAFE_INTEGER': Number.MIN_SAFE_INTEGER,
        'MAX_VALUE': Number.MAX_VALUE,
        'MIN_VALUE': Number.MIN_VALUE,
        'NaN': Number.NaN,
    };
    var reservedSymbolRecord = __assign(__assign({}, nonNumberReservedSymbolRecord), numberReservedSymbolRecord);
    var validReservedSymbolRecord = __assign(__assign({}, nonNumberReservedSymbolRecord), numberReservedSymbolRecord);
    function isReservedSymbol(symbol) {
        return symbol in validReservedSymbolRecord;
    }
    function isNumberReservedSymbol(symbol) {
        return symbol in numberReservedSymbolRecord;
    }

    var specialExpressionTypes = {
        '??': 0,
        '&&': 1,
        '||': 2,
        'array': 3,
        'cond': 4,
        '0_def': 5,
        'defined?': 6,
        '0_defn': 7,
        'block': 8,
        'doseq': 9,
        '0_fn': 10,
        'for': 11,
        'function': 12,
        'if': 13,
        'let': 14,
        'loop': 15,
        'object': 16,
        'recur': 17,
        'switch': 18,
        'throw': 19,
        'try': 20,
        'unless': 21,
    };

    function assertNameNotDefined(name, contextStack, builtin, sourceCodeInfo) {
        if (typeof name !== 'string')
            return;
        // TODO only subset of special expressions are necessary to check (CommonSpecialExpressionType)
        if (specialExpressionTypes[name])
            throw new LitsError("Cannot define variable ".concat(name, ", it's a special expression."), sourceCodeInfo);
        if (builtin.normalExpressions[name])
            throw new LitsError("Cannot define variable ".concat(name, ", it's a builtin function."), sourceCodeInfo);
        if (isReservedSymbol(name))
            throw new LitsError("Cannot define variable ".concat(name, ", it's a reserved name."), sourceCodeInfo);
        if (contextStack.globalContext[name])
            throw new LitsError("Name already defined \"".concat(name, "\"."), sourceCodeInfo);
    }

    var functionSpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var _b, _c;
            var builtin = _a.builtin, getUndefinedSymbols = _a.getUndefinedSymbols, evaluateNode = _a.evaluateNode;
            var _d = __read(node[1], 3), functionSymbol = _d[1], fn = _d[2];
            assertUserDefinedSymbolNode(functionSymbol, node[2]);
            assertNameNotDefined(functionSymbol[1], contextStack, builtin, node[2]);
            var evaluatedFunction = evaluateFunction(fn, contextStack, builtin, getUndefinedSymbols, evaluateNode);
            var litsFunction = (_b = {},
                _b[FUNCTION_SYMBOL] = true,
                _b.sourceCodeInfo = node[2],
                _b.functionType = 'UserDefined',
                _b.name = functionSymbol[1],
                _b.evaluatedfunction = evaluatedFunction,
                _b);
            contextStack.addValues((_c = {}, _c[functionSymbol[1]] = litsFunction, _c), functionSymbol[2]);
            return litsFunction;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var _b, _c;
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var functionName = node[1][1][1];
            contextStack.addValues((_b = {}, _b[functionName] = true, _b), node[1][1][2]);
            var newContext = (_c = {}, _c[functionName] = { value: true }, _c);
            return getFunctionUnresolvedSymbols(node[1][2], contextStack, getUndefinedSymbols, builtin, evaluateNode, newContext);
        },
    };
    var defnSpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var _b, _c;
            var builtin = _a.builtin, getUndefinedSymbols = _a.getUndefinedSymbols, evaluateNode = _a.evaluateNode;
            var _d = __read(node[1], 3), functionSymbol = _d[1], fn = _d[2];
            assertUserDefinedSymbolNode(functionSymbol, node[2]);
            assertNameNotDefined(functionSymbol[1], contextStack, builtin, node[2]);
            var evaluatedFunctionOverloades = evaluateFunction(fn, contextStack, builtin, getUndefinedSymbols, evaluateNode);
            var litsFunction = (_b = {},
                _b[FUNCTION_SYMBOL] = true,
                _b.sourceCodeInfo = node[2],
                _b.functionType = 'UserDefined',
                _b.name = functionSymbol[1],
                _b.evaluatedfunction = evaluatedFunctionOverloades,
                _b);
            contextStack.exportValues((_c = {}, _c[functionSymbol[1]] = litsFunction, _c), functionSymbol[2]);
            return litsFunction;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var _b, _c;
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var functionName = node[1][1][1];
            var fn = node[1][2];
            contextStack.exportValues((_b = {}, _b[functionName] = true, _b), node[1][1][2]);
            var newContext = (_c = {}, _c[functionName] = { value: true }, _c);
            return getFunctionUnresolvedSymbols(fn, contextStack, getUndefinedSymbols, builtin, evaluateNode, newContext);
        },
    };
    var fnSpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var _b;
            var builtin = _a.builtin, getUndefinedSymbols = _a.getUndefinedSymbols, evaluateNode = _a.evaluateNode;
            var fn = node[1][1];
            var evaluatedFunction = evaluateFunction(fn, contextStack, builtin, getUndefinedSymbols, evaluateNode);
            var litsFunction = (_b = {},
                _b[FUNCTION_SYMBOL] = true,
                _b.sourceCodeInfo = node[2],
                _b.functionType = 'UserDefined',
                _b.name = undefined,
                _b.evaluatedfunction = evaluatedFunction,
                _b);
            return litsFunction;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var fn = node[1][1];
            return getFunctionUnresolvedSymbols(fn, contextStack, getUndefinedSymbols, builtin, evaluateNode);
        },
    };
    function evaluateFunction(fn, contextStack, builtin, getUndefinedSymbols, evaluateNode) {
        var functionContext = {};
        var context = fn[0].reduce(function (ctx, arg) {
            Object.keys(getAllBindingTargetNames(arg)).forEach(function (name) {
                ctx[name] = { value: null };
            });
            return ctx;
        }, {});
        var undefinedSymbols = getUndefinedSymbols(fn[1], contextStack.new(context), builtin, evaluateNode);
        undefinedSymbols.forEach(function (name) {
            var value = contextStack.getValue(name);
            if (isAny(value)) {
                functionContext[name] = { value: value };
            }
        });
        var evaluatedFunction = [
            fn[0],
            fn[1],
            functionContext,
        ];
        return evaluatedFunction;
    }
    function getFunctionUnresolvedSymbols(fn, contextStack, getUndefinedSymbols, builtin, evaluateNode, functionNameContext) {
        var result = new Set();
        var contextStackWithFunctionName = functionNameContext ? contextStack.create(functionNameContext) : contextStack;
        var newContext = {};
        fn[0].forEach(function (arg) {
            Object.assign(newContext, getAllBindingTargetNames(arg));
            walkDefaults(arg, function (defaultNode) {
                addToSet(result, getUndefinedSymbols([defaultNode], contextStack, builtin, evaluateNode));
            });
        });
        var newContextStack = contextStackWithFunctionName.create(newContext);
        var overloadResult = getUndefinedSymbols(fn[1], newContextStack, builtin, evaluateNode);
        addToSet(result, overloadResult);
        return result;
    }

    var ifSpecialExpression = {
        paramCount: { min: 2, max: 3 },
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var _b = __read(node[1][1], 3), conditionNode = _b[0], trueNode = _b[1], falseNode = _b[2];
            if (evaluateNode(conditionNode, contextStack)) {
                return evaluateNode(trueNode, contextStack);
            }
            else if (falseNode) {
                return evaluateNode(falseNode, contextStack);
            }
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1].filter(function (n) { return !!n; }), contextStack, builtin, evaluateNode);
        },
    };

    var unlessSpecialExpression = {
        paramCount: { min: 2, max: 3 },
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var _b = __read(node[1][1], 3), conditionNode = _b[0], trueNode = _b[1], falseNode = _b[2];
            if (!evaluateNode(conditionNode, contextStack)) {
                return evaluateNode(trueNode, contextStack);
            }
            else if (falseNode) {
                return evaluateNode(falseNode, contextStack);
            }
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1].filter(function (n) { return !!n; }), contextStack, builtin, evaluateNode);
        },
    };

    var letSpecialExpression = {
        paramCount: 0,
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var bindingNode = node[1][1];
            var target = bindingNode[1][0];
            var value = bindingNode[1][1];
            var bindingValue = evaluateNode(value, contextStack);
            var values = evalueateBindingNodeValues(target, bindingValue, function (Node) { return evaluateNode(Node, contextStack); });
            contextStack.addValues(values, target[2]);
            return bindingValue;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var bindingNode = node[1][1];
            var target = bindingNode[1][0];
            var value = bindingNode[1][1];
            var bindingResult = getUndefinedSymbols([value], contextStack, builtin, evaluateNode);
            walkDefaults(target, function (defaultNode) {
                addToSet(bindingResult, getUndefinedSymbols([defaultNode], contextStack, builtin, evaluateNode));
            });
            contextStack.addValues(getAllBindingTargetNames(target), target[2]);
            return bindingResult;
        },
    };

    var loopSpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var bindingNodes = node[1][1];
            var bindingContext = bindingNodes.reduce(function (result, bindingNode) {
                var val = evaluateNode(bindingNode[1][1], contextStack.create(result));
                var valueRecord = evalueateBindingNodeValues(bindingNode[1][0], val, function (Node) { return evaluateNode(Node, contextStack); });
                Object.entries(valueRecord).forEach(function (_a) {
                    var _b = __read(_a, 2), name = _b[0], value = _b[1];
                    result[name] = { value: value };
                });
                return result;
            }, {});
            var newContextStack = contextStack.create(bindingContext);
            var body = node[1][2];
            var _loop_1 = function () {
                var e_1, _b;
                var result = null;
                try {
                    try {
                        for (var body_1 = (e_1 = void 0, __values(body)), body_1_1 = body_1.next(); !body_1_1.done; body_1_1 = body_1.next()) {
                            var form = body_1_1.value;
                            result = evaluateNode(form, newContextStack);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (body_1_1 && !body_1_1.done && (_b = body_1.return)) _b.call(body_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                catch (error) {
                    if (error instanceof RecurSignal) {
                        var params_1 = error.params;
                        if (params_1.length !== bindingNodes.length) {
                            throw new LitsError("recur expected ".concat(bindingNodes.length, " parameters, got ").concat(valueToString(params_1.length)), node[2]);
                        }
                        bindingNodes.forEach(function (bindingNode, index) {
                            var e_2, _a;
                            var valueRecord = evalueateBindingNodeValues(bindingNode[1][0], asAny(params_1[index]), function (Node) { return evaluateNode(Node, contextStack); });
                            try {
                                for (var _b = (e_2 = void 0, __values(Object.entries(valueRecord))), _c = _b.next(); !_c.done; _c = _b.next()) {
                                    var _d = __read(_c.value, 2), name_1 = _d[0], value = _d[1];
                                    bindingContext[name_1].value = value;
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        });
                        return "continue";
                    }
                    throw error;
                }
                return { value: result };
            };
            for (;;) {
                var state_1 = _loop_1();
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var bindingNodes = node[1][1];
            var newContext = bindingNodes
                .reduce(function (context, bindingNode) {
                var names = getAllBindingTargetNames(bindingNode[1][0]);
                Object.keys(names).forEach(function (name) {
                    context[name] = { value: true };
                });
                return context;
            }, {});
            var bindingValueNodes = bindingNodes.map(function (bindingNode) { return bindingNode[1][1]; });
            var bindingsResult = getUndefinedSymbols(bindingValueNodes, contextStack, builtin, evaluateNode);
            var paramsResult = getUndefinedSymbols(node[1][2], contextStack.create(newContext), builtin, evaluateNode);
            return joinSets(bindingsResult, paramsResult);
        },
    };

    function addToContext(bindings, context, contextStack, evaluateNode) {
        var e_1, _a;
        try {
            for (var bindings_1 = __values(bindings), bindings_1_1 = bindings_1.next(); !bindings_1_1.done; bindings_1_1 = bindings_1.next()) {
                var bindingNode = bindings_1_1.value;
                var _b = __read(bindingNode[1], 2), target = _b[0], bindingValue = _b[1];
                var val = evaluateNode(bindingValue, contextStack);
                var valueRecord = evalueateBindingNodeValues(target, val, function (Node) { return evaluateNode(Node, contextStack); });
                Object.entries(valueRecord).forEach(function (_a) {
                    var _b = __read(_a, 2), name = _b[0], value = _b[1];
                    context[name] = { value: value };
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (bindings_1_1 && !bindings_1_1.done && (_a = bindings_1.return)) _a.call(bindings_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    function evaluateLoop(returnResult, loopNode, contextStack, evaluateNode) {
        var sourceCodeInfo = loopNode[2];
        var _a = __read(loopNode[1], 3), loopBindings = _a[1], body = _a[2];
        var result = [];
        var bindingIndices = loopBindings.map(function () { return 0; });
        var abort = false;
        var _loop_1 = function () {
            var context = {};
            var newContextStack = contextStack.create(context);
            var skip = false;
            bindingsLoop: for (var bindingIndex = 0; bindingIndex < loopBindings.length; bindingIndex += 1) {
                var _b = __read(loopBindings[bindingIndex], 4), bindingNode = _b[0], letBindings = _b[1], whenNode = _b[2], whileNode = _b[3];
                var _c = __read(bindingNode[1], 2), targetNode = _c[0], valueNode = _c[1];
                var coll = asColl(evaluateNode(valueNode, newContextStack), sourceCodeInfo);
                var seq = isSeq(coll) ? coll : Object.entries(coll);
                if (seq.length === 0) {
                    skip = true;
                    abort = true;
                    break;
                }
                var index = asNonUndefined(bindingIndices[bindingIndex], sourceCodeInfo);
                if (index >= seq.length) {
                    skip = true;
                    if (bindingIndex === 0) {
                        abort = true;
                        break;
                    }
                    bindingIndices[bindingIndex] = 0;
                    bindingIndices[bindingIndex - 1] = asNonUndefined(bindingIndices[bindingIndex - 1], sourceCodeInfo) + 1;
                    break;
                }
                var val = asAny(seq[index], sourceCodeInfo);
                var valueRecord = evalueateBindingNodeValues(targetNode, val, function (Node) { return evaluateNode(Node, newContextStack); });
                Object.entries(valueRecord).forEach(function (_a) {
                    var _b = __read(_a, 2), name = _b[0], value = _b[1];
                    context[name] = { value: value };
                });
                if (letBindings) {
                    addToContext(letBindings, context, newContextStack, evaluateNode);
                }
                if (whenNode && !evaluateNode(whenNode, newContextStack)) {
                    bindingIndices[bindingIndex] = asNonUndefined(bindingIndices[bindingIndex], sourceCodeInfo) + 1;
                    skip = true;
                    break bindingsLoop;
                }
                if (whileNode && !evaluateNode(whileNode, newContextStack)) {
                    bindingIndices[bindingIndex] = Number.POSITIVE_INFINITY;
                    skip = true;
                    break bindingsLoop;
                }
            }
            if (!skip) {
                var value = evaluateNode(body, newContextStack);
                if (returnResult)
                    result.push(value);
                if (bindingIndices.length > 0)
                    bindingIndices[bindingIndices.length - 1] += 1;
            }
        };
        while (!abort) {
            _loop_1();
        }
        return returnResult ? result : null;
    }
    function analyze$1(loopNode, contextStack, getUndefinedSymbols, builtin, evaluateNode) {
        var result = new Set();
        var newContext = {};
        var _a = __read(loopNode[1], 3), loopBindings = _a[1], body = _a[2];
        loopBindings.forEach(function (loopBindingNode) {
            var _a = __read(loopBindingNode, 4), bindingNode = _a[0], letBindings = _a[1], whenNode = _a[2], whileNode = _a[3];
            var _b = __read(bindingNode[1], 2), target = _b[0], value = _b[1];
            getUndefinedSymbols([value], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
                return result.add(symbol);
            });
            Object.assign(newContext, getAllBindingTargetNames(target));
            if (letBindings) {
                letBindings.forEach(function (letBindingNode) {
                    var _a = __read(letBindingNode[1], 2), letTarget = _a[0], letValue = _a[1];
                    getUndefinedSymbols([letValue], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
                        return result.add(symbol);
                    });
                    Object.assign(newContext, getAllBindingTargetNames(letTarget));
                });
            }
            if (whenNode) {
                getUndefinedSymbols([whenNode], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
                    return result.add(symbol);
                });
            }
            if (whileNode) {
                getUndefinedSymbols([whileNode], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
                    return result.add(symbol);
                });
            }
        });
        getUndefinedSymbols([body], contextStack.create(newContext), builtin, evaluateNode).forEach(function (symbol) {
            return result.add(symbol);
        });
        return result;
    }
    var forSpecialExpression = {
        paramCount: 1,
        evaluate: function (node, contextStack, helpers) { return evaluateLoop(true, node, contextStack, helpers.evaluateNode); },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return analyze$1(node, contextStack, getUndefinedSymbols, builtin, evaluateNode);
        },
    };
    var doseqSpecialExpression = {
        paramCount: 1,
        evaluate: function (node, contextStack, helpers) {
            evaluateLoop(false, node, contextStack, helpers.evaluateNode);
            return null;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return analyze$1(node, contextStack, getUndefinedSymbols, builtin, evaluateNode);
        },
    };

    var orSpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var value = false;
            try {
                for (var _c = __values(node[1][1]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var param = _d.value;
                    value = evaluateNode(param, contextStack);
                    if (value)
                        break;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return value;
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var e_2, _a;
            var value = false;
            try {
                for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                    var param = params_1_1.value;
                    value = asAny(param, sourceCodeInfo);
                    if (value)
                        break;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return value;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var qqSpecialExpression = {
        paramCount: { min: 1, max: 2 },
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var _b = __read(node[1][1], 2), firstNode = _b[0], secondNode = _b[1];
            if (isUserDefinedSymbolNode(firstNode) && contextStack.lookUp(firstNode) === null) {
                return secondNode ? evaluateNode(secondNode, contextStack) : null;
            }
            assertAny(firstNode, node[2]);
            var firstResult = evaluateNode(firstNode, contextStack);
            return firstResult !== null && firstResult !== void 0 ? firstResult : (secondNode ? evaluateNode(secondNode, contextStack) : null);
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var firstParam = asAny(params[0], sourceCodeInfo);
            var secondParam = params[1] !== undefined ? asAny(params[1], sourceCodeInfo) : null;
            return firstParam !== null && firstParam !== void 0 ? firstParam : secondParam;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1].filter(function (n) { return !!n; }), contextStack, builtin, evaluateNode);
        },
    };

    var recurSpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var params = node[1][1];
            var evaluatedParams = params.map(function (paramNode) { return evaluateNode(paramNode, contextStack); });
            throw new RecurSignal(evaluatedParams);
        },
        evaluateAsNormalExpression: function (params) {
            throw new RecurSignal(params);
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var throwSpecialExpression = {
        paramCount: 1,
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var message = asString(evaluateNode(node[1][1], contextStack), node[2], {
                nonEmpty: true,
            });
            throw new UserDefinedError(message, node[2]);
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var message = asString(params[0], sourceCodeInfo, {
                nonEmpty: true,
            });
            throw new UserDefinedError(message, undefined);
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols([node[1][1]], contextStack, builtin, evaluateNode);
        },
    };

    var trySpecialExpression = {
        paramCount: 1,
        evaluate: function (node, contextStack, _a) {
            var _b;
            var evaluateNode = _a.evaluateNode;
            var _c = __read(node[1], 4), tryExpression = _c[1], errorSymbol = _c[2], catchExpression = _c[3];
            try {
                return evaluateNode(tryExpression, contextStack);
            }
            catch (error) {
                var newContext = errorSymbol
                    ? (_b = {},
                        _b[errorSymbol[1]] = { value: error },
                        _b) : {};
                return evaluateNode(catchExpression, contextStack.create(newContext));
            }
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var _b;
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            var _c = __read(node[1], 4), tryExpression = _c[1], errorSymbol = _c[2], catchExpression = _c[3];
            var tryResult = getUndefinedSymbols([tryExpression], contextStack, builtin, evaluateNode);
            var newContext = errorSymbol
                ? (_b = {},
                    _b[errorSymbol[1]] = { value: true },
                    _b) : {};
            var catchResult = getUndefinedSymbols([catchExpression], contextStack.create(newContext), builtin, evaluateNode);
            return joinSets(tryResult, catchResult);
        },
    };

    var arraySpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var e_1, _b;
            var evaluateNode = _a.evaluateNode;
            var result = [];
            try {
                for (var _c = __values(node[1][1]), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var param = _d.value;
                    if (isSpreadNode(param)) {
                        var spreadValue = evaluateNode(param[1], contextStack);
                        if (!Array.isArray(spreadValue)) {
                            throw new LitsError('Spread value is not an array', param[2]);
                        }
                        result.push.apply(result, __spreadArray([], __read(spreadValue), false));
                    }
                    else {
                        result.push(evaluateNode(param, contextStack));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var e_2, _a;
            var result = [];
            try {
                for (var params_1 = __values(params), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                    var param = params_1_1.value;
                    result.push(asAny(param, sourceCodeInfo));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (params_1_1 && !params_1_1.done && (_a = params_1.return)) _a.call(params_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var objectSpecialExpression = {
        paramCount: {},
        evaluate: function (node, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var result = {};
            var params = node[1][1];
            for (var i = 0; i < params.length; i += 2) {
                var keyNode = params[i];
                if (isSpreadNode(keyNode)) {
                    var spreadObject = evaluateNode(keyNode[1], contextStack);
                    if (!isUnknownRecord(spreadObject)) {
                        throw new LitsError('Spread value is not an object', keyNode[2]);
                    }
                    Object.assign(result, spreadObject);
                    i -= 1;
                }
                else {
                    var key = evaluateNode(keyNode, contextStack);
                    var valueNode = params[i + 1];
                    if (valueNode === undefined) {
                        throw new LitsError('Missing value for key', keyNode[2]);
                    }
                    var value = evaluateNode(valueNode, contextStack);
                    assertString(key, keyNode[2]);
                    result[key] = value;
                }
            }
            return result;
        },
        evaluateAsNormalExpression: function (params, sourceCodeInfo) {
            var result = {};
            for (var i = 0; i < params.length; i += 2) {
                var key = params[i];
                var value = params[i + 1];
                assertString(key, sourceCodeInfo);
                result[key] = value !== null && value !== void 0 ? value : null;
            }
            return result;
        },
        getUndefinedSymbols: function (node, contextStack, _a) {
            var getUndefinedSymbols = _a.getUndefinedSymbols, builtin = _a.builtin, evaluateNode = _a.evaluateNode;
            return getUndefinedSymbols(node[1][1], contextStack, builtin, evaluateNode);
        },
    };

    var specialExpressions = [
        qqSpecialExpression,
        andSpecialExpression,
        orSpecialExpression,
        arraySpecialExpression,
        condSpecialExpression,
        defSpecialExpression,
        definedSpecialExpression,
        defnSpecialExpression,
        doSpecialExpression,
        doseqSpecialExpression,
        fnSpecialExpression,
        forSpecialExpression,
        functionSpecialExpression,
        ifSpecialExpression,
        letSpecialExpression,
        loopSpecialExpression,
        objectSpecialExpression,
        recurSpecialExpression,
        switchSpecialExpression,
        throwSpecialExpression,
        trySpecialExpression,
        unlessSpecialExpression,
    ];
    var builtin = {
        normalExpressions: normalExpressions,
        specialExpressions: specialExpressions,
        allNormalExpressions: allNormalExpressions,
    };
    var normalExpressionKeys = Object.keys(normalExpressions);
    var specialExpressionKeys = Object.keys(specialExpressionTypes);
    new Set(specialExpressionKeys);
    // TODO, remove
    // console.log('builtin', [...specialExpressionKeys, ...normalExpressionKeys].length)

    var binaryOperators = [
        '^', // exponentiation
        '*', // multiplication
        '/', // division
        '%', // remainder
        '+', // addition
        '-', // subtraction
        '<<', // left shift
        '>>', // signed right shift
        '>>>', // unsigned right shift
        '++', // string concatenation
        '<', // less than
        '<=', // less than or equal
        '≤', // less than or equal
        '>', // greater than
        '>=', // greater than or equal
        '≥', // greater than or equal
        '==', // equal
        '!=', // not equal
        '≠', // not equal
        '&', // bitwise AND
        'xor', // bitwise XOR
        '|', // bitwise OR
        '&&', // logical AND
        '||', // logical OR
        '??', // nullish coalescing
        '|>', // pipe
    ];
    var otherOperators = [
        '?', // conditional operator
        ':', // conditional operator
        '->', // lambda
        '...', // rest
        '.', // property accessor
        ',', // item separator
        '=', // assignment
        ':', // property assignment
        ';', // statement terminator
    ];
    var symbolicOperators = __spreadArray(__spreadArray([], __read(binaryOperators), false), __read(otherOperators), false);
    var nonFunctionOperators = [
        'comment',
        'cond',
        'def',
        'defined?',
        'block',
        'doseq',
        'if',
        'let',
        'loop',
        'recur',
        'throw',
        'try',
        'unless',
        'while',
    ];
    var nonFunctionOperatorSet = new Set(nonFunctionOperators);
    function isFunctionOperator(operator) {
        return !nonFunctionOperatorSet.has(operator);
    }
    var binaryOperatorSet = new Set(binaryOperators);
    function isBinaryOperator(operator) {
        return binaryOperatorSet.has(operator);
    }
    var symbolicOperatorSet = new Set(symbolicOperators);
    function isSymbolicOperator(operator) {
        return symbolicOperatorSet.has(operator);
    }

    function getNumberTheorySequenceNames(name) {
        return ["nth:".concat(name, "-seq"), "nth:".concat(name, "-nth"), "nth:".concat(name, "-take-while"), "nth:".concat(name, "?")];
    }
    function getVectorReductionNames(name) {
        return ["vec:".concat(name), "vec:moving-".concat(name), "vec:centered-moving-".concat(name), "vec:running-".concat(name)];
    }
    var api = {
        collection: [
            'filter',
            'filteri',
            'map',
            'mapi',
            'reduce',
            'reducei',
            'reduce-right',
            'reducei-right',
            'reductions',
            'reductionsi',
            'count',
            'get',
            'get-in',
            'contains?',
            'assoc',
            'assoc-in',
            '++',
            'not-empty',
            'every?',
            'not-every?',
            'any?',
            'not-any?',
            'update',
            'update-in',
        ],
        array: [
            'range',
            'repeat',
            'flatten',
            'mapcat',
            'moving-fn',
            'running-fn',
        ],
        sequence: [
            'nth',
            'push',
            'pop',
            'unshift',
            'shift',
            'slice',
            'splice',
            'position',
            'index-of',
            'last-index-of',
            'some',
            'reverse',
            'first',
            'second',
            'last',
            'rest',
            'next',
            'take',
            'take-last',
            'take-while',
            'drop',
            'drop-last',
            'drop-while',
            'sort',
            'sort-by',
            'distinct',
            'remove',
            'remove-at',
            'split-at',
            'split-with',
            'frequencies',
            'group-by',
            'partition',
            'partition-all',
            'partition-by',
            'starts-with?',
            'ends-with?',
            'interleave',
            'interpose',
        ],
        math: [
            '+',
            '-',
            '*',
            '/',
            'mod',
            'rem',
            'quot',
            'inc',
            'dec',
            'sqrt',
            'cbrt',
            '^',
            'round',
            'trunc',
            'floor',
            'ceil',
            'min',
            'max',
            'abs',
            'sign',
            'ln',
            'log2',
            'log10',
            'sin',
            'cos',
            'tan',
            'asin',
            'acos',
            'atan',
            'sinh',
            'cosh',
            'tanh',
            'asinh',
            'acosh',
            'atanh',
            'to-rad',
            'to-deg',
        ],
        functional: [
            '|>',
            'apply',
            'identity',
            'comp',
            'constantly',
            'juxt',
            'complement',
            'every-pred',
            'some-pred',
            'fnull',
        ],
        misc: [
            '!=', // TODO
            '==',
            '<',
            '>',
            '≤',
            '≥',
            '!',
            'write!',
            'iso-date->epoch',
            'epoch->iso-date',
            'boolean',
            'compare',
            'identical?',
            'json-parse',
            'json-stringify',
        ],
        object: [
            'dissoc',
            'keys',
            'vals',
            'entries',
            'find',
            'merge',
            'merge-with',
            'zipmap',
            'select-keys',
        ],
        predicate: [
            'boolean?',
            'null?',
            'number?',
            'string?',
            'function?',
            'integer?',
            'array?',
            'object?',
            'coll?',
            'seq?',
            'regexp?',
            'zero?',
            'pos?',
            'neg?',
            'even?',
            'odd?',
            'finite?',
            'negative-infinity?',
            'positive-infinity?',
            'false?',
            'true?',
            'empty?',
            'not-empty?',
            'vector?',
            'grid?',
            'matrix?',
        ],
        regularExpression: [
            'regexp',
            'match',
            'replace',
            'replace-all',
        ],
        string: [
            'string-repeat',
            'str',
            'number',
            'lower-case',
            'upper-case',
            'trim',
            'trim-left',
            'trim-right',
            'pad-left',
            'pad-right',
            'split',
            'split-lines',
            'template',
            'to-char-code',
            'from-char-code',
            'encode-base64',
            'decode-base64',
            'encode-uri-component',
            'decode-uri-component',
            'join',
            'capitalize',
            'blank?',
        ],
        bitwise: [
            '<<',
            '>>',
            '>>>',
            'bit-not',
            '&',
            'bit-and-not',
            '|',
            'xor',
            'bit-flip',
            'bit-clear',
            'bit-set',
            'bit-test',
        ],
        // TODO, remove some, add some. E.g. type guards, assert-number, assert-string, etc.
        assert: [
            'assert',
            'assert=',
            'assert!=',
            'assert-gt',
            'assert-lt',
            'assert-gte',
            'assert-lte',
            'assert-true',
            'assert-false',
            'assert-truthy',
            'assert-falsy',
            'assert-null',
            'assert-throws',
            'assert-throws-error',
            'assert-not-throws',
        ],
        grid: [
            'grid:every?',
            'grid:some?',
            'grid:every-row?',
            'grid:some-row?',
            'grid:every-col?',
            'grid:some-col?',
            'grid:row',
            'grid:col',
            'grid:shape',
            'grid:fill',
            'grid:generate',
            'grid:reshape',
            'grid:transpose',
            'grid:flip-h',
            'grid:flip-v',
            'grid:rotate',
            'grid:reverse-rows',
            'grid:reverse-cols',
            'grid:slice',
            'grid:slice-rows',
            'grid:slice-cols',
            'grid:splice-rows',
            'grid:splice-cols',
            'grid:concat-rows',
            'grid:concat-cols',
            'grid:map',
            'grid:mapi',
            'grid:reduce',
            'grid:reducei',
            'grid:push-rows',
            'grid:unshift-rows',
            'grid:pop-row',
            'grid:shift-row',
            'grid:push-cols',
            'grid:unshift-cols',
            'grid:pop-col',
            'grid:shift-col',
            'grid:from-array',
        ],
        matrix: [
            'mat:mul',
            'mat:det',
            'mat:inv',
            'mat:adj',
            'mat:cofactor',
            'mat:minor',
            'mat:trace',
            'mat:symmetric?',
            'mat:triangular?',
            'mat:upper-triangular?',
            'mat:lower-triangular?',
            'mat:diagonal?',
            'mat:square?',
            'mat:orthogonal?',
            'mat:identity?',
            'mat:invertible?',
            'mat:hilbert',
            'mat:vandermonde',
            'mat:band',
            'mat:banded?',
            'mat:rank',
            'mat:frobenius-norm',
            'mat:1-norm',
            'mat:inf-norm',
            'mat:max-norm',
        ],
        vector: __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([
            'vec:monotonic?',
            'vec:strictly-monotonic?',
            'vec:increasing?',
            'vec:decreasing?',
            'vec:strictly-increasing?',
            'vec:strictly-decreasing?',
            'vec:median',
            'vec:mode',
            'vec:min-index',
            'vec:max-index',
            'vec:sort-indices',
            'vec:count-values',
            'vec:linspace',
            'vec:ones',
            'vec:zeros',
            'vec:fill',
            'vec:generate',
            'vec:cumsum',
            'vec:cumprod',
            'vec:quartiles',
            'vec:percentile',
            'vec:quantile',
            'vec:histogram',
            'vec:ecdf',
            'vec:outliers?',
            'vec:outliers',
            'vec:bincount',
            'vec:winsorize',
            'vec:mse',
            'vec:mae',
            'vec:rmse',
            'vec:smape'
        ], __read(getVectorReductionNames('mean')), false), __read(getVectorReductionNames('median')), false), __read(getVectorReductionNames('variance')), false), __read(getVectorReductionNames('sample-variance')), false), __read(getVectorReductionNames('sum')), false), __read(getVectorReductionNames('prod')), false), __read(getVectorReductionNames('min')), false), __read(getVectorReductionNames('max')), false), __read(getVectorReductionNames('stdev')), false), __read(getVectorReductionNames('sample-stdev')), false), __read(getVectorReductionNames('iqr')), false), __read(getVectorReductionNames('span')), false), __read(getVectorReductionNames('geometric-mean')), false), __read(getVectorReductionNames('harmonic-mean')), false), __read(getVectorReductionNames('skewness')), false), __read(getVectorReductionNames('sample-skewness')), false), __read(getVectorReductionNames('kurtosis')), false), __read(getVectorReductionNames('sample-kurtosis')), false), __read(getVectorReductionNames('excess-kurtosis')), false), __read(getVectorReductionNames('sample-excess-kurtosis')), false), __read(getVectorReductionNames('rms')), false), __read(getVectorReductionNames('mad')), false), __read(getVectorReductionNames('medad')), false), __read(getVectorReductionNames('gini-coefficient')), false), __read(getVectorReductionNames('entropy')), false), __read(getVectorReductionNames('skewness')), false),
        linAlg: [
            'lin:reflect',
            'lin:refract',
            'lin:lerp',
            'lin:rotate2d',
            'lin:rotate3d',
            'lin:dot',
            'lin:cross',
            'lin:normalize-minmax',
            'lin:normalize-zscore',
            'lin:normalize-robust',
            'lin:normalize-l1',
            'lin:normalize-l2',
            'lin:normalize-log',
            'lin:angle',
            'lin:projection',
            'lin:orthogonal?',
            'lin:parallel?',
            'lin:collinear?',
            'lin:cosine-similarity',
            'lin:euclidean-distance',
            'lin:euclidean-norm',
            'lin:manhattan-distance',
            'lin:manhattan-norm',
            'lin:hamming-distance',
            'lin:hamming-norm',
            'lin:chebyshev-distance',
            'lin:chebyshev-norm',
            'lin:minkowski-distance',
            'lin:minkowski-norm',
            'lin:cov',
            'lin:corr',
            'lin:spearman-corr',
            'lin:pearson-corr',
            'lin:kendall-tau',
            'lin:autocorrelation',
            'lin:cross-correlation',
            'lin:rref',
            'lin:solve',
            'lin:to-polar',
            'lin:from-polar',
        ],
        numberTheory: __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(getNumberTheorySequenceNames('abundant')), false), __read(getNumberTheorySequenceNames('bell')), false), __read(getNumberTheorySequenceNames('catalan')), false), __read(getNumberTheorySequenceNames('composite')), false), __read(getNumberTheorySequenceNames('factorial')), false), __read(getNumberTheorySequenceNames('fibonacci')), false), __read(getNumberTheorySequenceNames('geometric')), false), __read(getNumberTheorySequenceNames('golomb')), false), __read(getNumberTheorySequenceNames('happy')), false), __read(getNumberTheorySequenceNames('look-and-say')), false), __read(getNumberTheorySequenceNames('lucas')), false), __read(getNumberTheorySequenceNames('lucky')), false), __read(getNumberTheorySequenceNames('mersenne')), false), __read(getNumberTheorySequenceNames('padovan')), false), __read(getNumberTheorySequenceNames('partition')), false), __read(getNumberTheorySequenceNames('pell')), false), __read(getNumberTheorySequenceNames('perfect')), false), __read(getNumberTheorySequenceNames('perfect-cube')), false), __read(getNumberTheorySequenceNames('perfect-power')), false), __read(getNumberTheorySequenceNames('perfect-square')), false), __read(getNumberTheorySequenceNames('polygonal')), false), __read(getNumberTheorySequenceNames('prime')), false), __read(getNumberTheorySequenceNames('recaman')), false), __read(getNumberTheorySequenceNames('sylvester')), false), __read(getNumberTheorySequenceNames('thue-morse')), false), __read(getNumberTheorySequenceNames('tribonacci')), false), [
            'nth:collatz-seq',
            'nth:juggler-seq',
            'nth:bernoulli-seq',
            'nth:bernoulli-take-while',
            'nth:bernoulli-nth',
            'nth:combinations',
            'nth:count-combinations',
            'nth:derangements',
            'nth:count-derangements',
            'nth:divisors',
            'nth:count-divisors',
            'nth:proper-divisors',
            'nth:count-proper-divisors',
            'nth:prime-factors',
            'nth:count-prime-factors',
            'nth:distinct-prime-factors',
            'nth:count-distinct-prime-factors',
            'nth:factorial',
            'nth:partitions',
            'nth:count-partitions',
            'nth:permutations',
            'nth:count-permutations',
            'nth:power-set',
            'nth:count-power-set',
            'nth:coprime?',
            'nth:divisible-by?',
            'nth:gcd',
            'nth:lcm',
            'nth:multinomial',
            'nth:amicable?',
            'nth:euler-totient',
            'nth:mobius',
            'nth:mertens',
            'nth:sigma',
            'nth:carmichael-lambda',
            'nth:cartesian-product',
            'nth:perfect-power',
            'nth:mod-exp',
            'nth:mod-inv',
            'nth:extended-gcd',
            'nth:chinese-remainder',
            'nth:stirling-first',
            'nth:stirling-second',
        ], false),
        random: [
            '!:random',
            '!:random-int',
            '!:random-int-inclusive',
            '!:random-float',
            '!:random-boolean',
            '!:random-item',
            '!:random-sample',
            '!:random-sample-unique',
            '!:shuffle',
            '!:random-normal',
            '!:random-exponential',
            '!:random-binomial',
            '!:random-poisson',
            '!:random-gamma',
            '!:random-pareto',
            '!:uuid',
            '!:random-char',
            '!:random-string',
            '!:random-id',
            '!:random-color',
        ],
        shorthand: [
            '-short-regexp',
            '-short-fn',
        ],
        datatype: [
            '-type-number',
            '-type-string',
            '-type-object',
            '-type-array',
            '-type-vector',
            '-type-matrix',
            '-type-grid',
            '-type-boolean',
            '-type-function',
            '-type-integer',
            '-type-any',
            '-type-null',
            '-type-collection',
            '-type-sequence',
            '-type-regexp',
            '-type-never',
        ],
    };
    var apiFunctionNames = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(api.collection), false), __read(api.array), false), __read(api.sequence), false), __read(api.math), false), __read(api.functional), false), __read(api.misc), false), __read(api.object), false), __read(api.predicate), false), __read(api.regularExpression), false), __read(api.string), false), __read(api.bitwise), false), __read(api.assert), false), __read(api.matrix), false), __read(api.vector), false), __read(api.linAlg), false), __read(api.grid), false), __read(api.numberTheory), false), __read(api.random), false);
    __spreadArray(__spreadArray(__spreadArray([], __read(apiFunctionNames), false), __read(api.shorthand), false), __read(api.datatype), false);
    function getOperatorArgs(a, b) {
        return { a: { type: a }, b: { type: b } };
    }

    var arrayReference = {
        'range': {
            title: 'range',
            category: 'Array',
            returns: {
                type: 'number',
                array: true,
            },
            args: __assign(__assign({}, getOperatorArgs('number', 'number')), { step: {
                    type: 'number',
                } }),
            variants: [
                { argumentNames: ['b'] },
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'step'] },
            ],
            description: "$range creates an array with a range of numbers from $a to $b (exclusive), by $step.\n\n$a defaults to 0.  \n$step defaults to 1.",
            examples: [
                'range(4)',
                'range(1, 4)',
                '1 range 10',
                'range(0.4, 4.9)',
                "\nrange(\n  0.25, // start value\n  1,    // end value (exclusive)\n  0.25, // step value\n)",
            ],
        },
        'repeat': {
            title: 'repeat',
            category: 'Array',
            returns: {
                type: 'any',
                array: true,
            },
            args: __assign({}, getOperatorArgs('any', 'integer')),
            variants: [{
                    argumentNames: ['a', 'b'],
                }],
            description: 'Returns an array with $a repeated $b times.',
            examples: [
                'repeat(10, 3)',
                'repeat(10, 0)',
                '"Albert" repeat 5',
            ],
        },
        'flatten': {
            title: 'flatten',
            category: 'Array',
            returns: {
                type: 'any',
                array: true,
            },
            args: {
                x: {
                    type: ['array', 'any'],
                    description: 'If $x is not an array, `[ ]` is returned.',
                },
            },
            variants: [{
                    argumentNames: ['x'],
                }],
            description: 'Takes a nested array $x and flattens it.',
            examples: [
                'flatten([1, 2, [3, 4], 5])',
                "\nlet foo = \"bar\";\nflatten([\n  1,\n  \" 2 A \",\n  [foo, [4, [\"ABC\"]]],\n  6,\n])",
            ],
            noOperatorDocumentation: true,
        },
        'mapcat': {
            title: 'mapcat',
            category: 'Array',
            returns: {
                type: 'collection',
            },
            args: __assign(__assign({}, getOperatorArgs('collection', 'function')), { colls: {
                    type: 'collection',
                    array: true,
                }, fun: {
                    type: 'function',
                } }),
            variants: [{
                    argumentNames: ['colls', 'fun'],
                }],
            description: 'Returns the result of applying concat to the result of applying map to $fun and $colls.',
            examples: [
                '[[3, 2, 1, 0], [6, 5, 4], [9, 8, 7]] mapcat reverse',
                'mapcat([[3, 2, 1, 0], [6, 5, 4], [9, 8, 7]], reverse)',
                '[[3, 2, 1, 0,], [6, 5, 4,], [9, 8, 7]] mapcat reverse',
                "\nfunction foo(n) {\n  [n - 1, n, n + 1]\n};\n[1, 2, 3] mapcat foo",
                "\nmapcat(\n  [[1, 2], [2, 2], [2, 3]],\n  -> $ remove even?\n)",
            ],
        },
        'moving-fn': {
            title: 'moving-fn',
            category: 'Array',
            returns: {
                type: 'array',
            },
            args: {
                arr: {
                    type: 'array',
                },
                windowSize: {
                    type: 'number',
                    description: 'The size of the moving window.',
                },
                fn: {
                    type: 'function',
                },
            },
            variants: [{
                    argumentNames: ['arr', 'windowSize', 'fn'],
                }],
            description: 'Returns the result of applying $fn to each moving window of size $windowSize in $arr.',
            examples: [
                'moving-fn([1, 2, 3], 2, vec:sum)',
                'moving-fn([1, 2, 3], 1, vec:sum)',
                'moving-fn([1, 2, 3], 3, vec:sum)',
            ],
        },
        'running-fn': {
            title: 'running-fn',
            category: 'Array',
            returns: {
                type: 'array',
            },
            args: {
                a: {
                    type: 'array',
                },
                b: {
                    type: 'function',
                },
            },
            variants: [{
                    argumentNames: ['a', 'b'],
                }],
            description: 'Returns the result of applying $b to each element of $a.',
            examples: [
                'running-fn([1, 2, 3], vec:sum)',
                'running-fn([1, 2, 3], vec:max)',
                'running-fn([1, 2, 3], vec:min)',
            ],
        },
    };

    var assertReference = {
        'assert': {
            title: 'assert',
            category: 'Assert',
            returns: {
                type: 'any',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['value'] },
                { argumentNames: ['value', 'message'] },
            ],
            description: 'If $value is falsy it throws `AssertionError` with $message. If no $message is provided, message is set to $value.',
            examples: ['try { assert(0, "Expected a positive value") } catch (e) { e.message }'],
            noOperatorDocumentation: true,
        },
        'assert!=': {
            title: 'assert!=',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { message: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'message'] },
            ],
            description: 'If $a is the same as $b it throws `AssertionError`.',
            examples: [
                'try { assert!=(0, 0, "Expected different values") } catch (e) { e.message }',
                'try { assert!=(0, 0) } catch (e) { e.message }',
                'try { 0 assert!= 0 } catch (e) { e.message }',
                'try { assert!=(0, 1) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert=': {
            title: 'assert=',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { message: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'message'] },
            ],
            description: 'If $a is not structural equal to $b it throws `AssertionError`.',
            examples: [
                'try { assert=({ "a": 1 }, { "a": 2 }, "Expected equal values") } catch (e) { e.message }',
                'try { assert=({ "a": 1 }, { "a": 2 }) } catch (e) { e.message }',
                'try { assert=({ "a": 1 }, { "a": 1 }) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-gt': {
            title: 'assert-gt',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { message: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'message'] },
            ],
            description: 'If $a is not greater than $b it throws `AssertionError`.',
            examples: [
                'try { assert-gt(0, 1, "Expected greater value") } catch (e) { e.message }',
                'try { assert-gt(0, 0) } catch (e) { e.message }',
                'try { assert-gt(1, 0) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-lt': {
            title: 'assert-lt',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { message: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'message'] },
            ],
            description: 'If $a is not less than $b it throws `AssertionError`.',
            examples: [
                'try { assert-lte(1, 0, "Expected smaller value value") } catch (e) { e.message }',
                'try { assert-lte(1, 1) } catch (e) { e.message }',
                'try { assert-lte(0, 1) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-gte': {
            title: 'assert-gte',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { message: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'message'] },
            ],
            description: 'If $a is less than $b it throws `AssertionError`.',
            examples: [
                'try { assert-gte(0, 1, "Expected greater value") } catch (e) { e.message }',
                'try { assert-gte(0, 1) } catch (e) { e.message }',
                'try { assert-gte(1, 1) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-lte': {
            title: 'assert-lte',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { message: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'message'] },
            ],
            description: 'If $a is grater than $b it throws `AssertionError`.',
            examples: [
                'try { assert-lte(1, 0, "Expected smaller value value") } catch (e) { e.message }',
                'try { assert-lte(1, 0) } catch (e) { e.message }',
                'try { assert-lte(1, 1) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-true': {
            title: 'assert-true',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['value'] },
                { argumentNames: ['value', 'message'] },
            ],
            description: 'If $value is not `true` it throws `AssertionError`.',
            examples: [
                'try { assert-true(false, "Expected true") } catch (e) { e.message }',
                'try { assert-true(false) } catch (e) { e.message }',
                'try { assert-true(true) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-false': {
            title: 'assert-false',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['value'] },
                { argumentNames: ['value', 'message'] },
            ],
            description: 'If $value is not `false` it throws `AssertionError`.',
            examples: [
                'try { assert-false(true, "Expected false") } catch (e) { e.message }',
                'try { assert-false(true) } catch (e) { e.message }',
                'try { assert-false(false) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-truthy': {
            title: 'assert-truthy',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['value'] },
                { argumentNames: ['value', 'message'] },
            ],
            description: 'If $value is not `truthy` it throws `AssertionError`.',
            examples: [
                'try { assert-truthy(false, "Expected truthy") } catch (e) { e.message }',
                'try { assert-truthy(false) } catch (e) { e.message }',
                'try { assert-truthy(0) } catch (e) { e.message }',
                'try { assert-truthy(null) } catch (e) { e.message }',
                'try { assert-truthy("") } catch (e) { e.message }',
                'try { assert-truthy(true) } catch (e) { e.message }',
                'try { assert-truthy(1) } catch (e) { e.message }',
                'try { assert-truthy("x") } catch (e) { e.message }',
                'try { assert-truthy([]) } catch (e) { e.message }',
                'try { assert-truthy({}) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-falsy': {
            title: 'assert-falsy',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['value'] },
                { argumentNames: ['value', 'message'] },
            ],
            description: 'If $value is not `falsy` it throws `AssertionError`.',
            examples: [
                'try { assert-falsy(true, "Expected falsy") } catch (e) { e.message }',
                'try { assert-falsy("x") } catch (e) { e.message }',
                'try { assert-falsy([]) } catch (e) { e.message }',
                'try { assert-falsy({}) } catch (e) { e.message }',
                'try { assert-falsy(1) } catch (e) { e.message }',
                'try { assert-falsy(false) } catch (e) { e.message }',
                'try { assert-falsy(0) } catch (e) { e.message }',
                'try { assert-falsy(null) } catch (e) { e.message }',
                'try { assert-falsy("") } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-null': {
            title: 'assert-null',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: {
                value: {
                    type: 'any',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['value'] },
                { argumentNames: ['value', 'message'] },
            ],
            description: 'If $value is not `null` it throws `AssertionError`.',
            examples: [
                'try { assert-null(null) } catch (e) { e.message }',
                'try { assert-null(true, "Expected null") } catch (e) { e.message }',
                'try { assert-null("x") } catch (e) { e.message }',
                'try { assert-null([]) } catch (e) { e.message }',
                'try { assert-null({}) } catch (e) { e.message }',
                'try { assert-null(1) } catch (e) { e.message }',
                'try { assert-null(false) } catch (e) { e.message }',
                'try { assert-null(0) } catch (e) { e.message }',
                'try { assert-null("") } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-throws': {
            title: 'assert-throws',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: {
                fun: {
                    type: 'function',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['fun'] },
                { argumentNames: ['fun', 'message'] },
            ],
            description: 'If $fun does not throw, it throws `AssertionError`.',
            examples: [
                'assert-throws(-> throw("Error"))',
                'try { assert-throws(-> identity("Error")) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-throws-error': {
            title: 'assert-throws-error',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: {
                'fun': {
                    type: 'function',
                },
                'error-message': {
                    type: 'string',
                },
                'message': {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['value', 'error-message'] },
                { argumentNames: ['value', 'error-message', 'message'] },
            ],
            description: 'If $fun does not throw $error-message, it throws `AssertionError`.',
            examples: [
                'try { assert-throws-error(-> throw("Error"), "Error") } catch (e) { e.message }',
                'try { assert-throws-error(-> identity("Error"), "Error") } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
        'assert-not-throws': {
            title: 'assert-not-throws',
            category: 'Assert',
            returns: {
                type: 'null',
            },
            args: {
                fun: {
                    type: 'function',
                },
                message: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['fun'] },
                { argumentNames: ['fun', 'message'] },
            ],
            description: 'If $fun throws, it throws `AssertionError`.',
            examples: [
                'try { assert-not-throws(-> identity("Error")) } catch (e) { e.message }',
                'try { assert-not-throws(-> throw("Error")) } catch (e) { e.message }',
            ],
            noOperatorDocumentation: true,
        },
    };

    var bitwiseReference = {
        '<<': {
            title: '<<',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Shifts $a arithmetically left by $b bit positions.',
            examples: [
                '1 << 10',
                '<<(1, 10)',
                '<<(-4, 2)',
            ],
        },
        '>>': {
            title: '>>',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Shifts $a arithmetically right by $b bit positions.',
            examples: [
                '2048 >> 10',
                '>>(2048, 10)',
                '>>>(-16, 2)',
                '>>(4, 10)',
            ],
        },
        '>>>': {
            title: '>>>',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Shifts $a arithmetically right by $b bit positions without sign extension.',
            examples: [
                '-16 >>> 2',
                '>>>(2048, 10)',
                '>>>(-16, 2)',
                '>>>(4, 10)',
                '>>>(-1, 10)',
            ],
        },
        'bit-not': {
            title: 'bit-not',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                },
            },
            variants: [
                { argumentNames: ['a'] },
            ],
            description: 'Returns bitwise `not` of $a.',
            examples: [
                'bit-not(0)',
                'bit-not(255)',
            ],
        },
        '&': {
            title: '&',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign(__assign({}, getOperatorArgs('integer', 'integer')), { c: {
                    type: 'integer',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'c'] },
            ],
            description: 'Returns bitwise `and` of all arguments.',
            examples: [
                '0b0011 & 0b0110',
                '&(0b0011, 0b0110)',
                '&(0b0011, 0b0110, 0b1001)',
            ],
        },
        'bit-and-not': {
            title: 'bit-and-not',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign(__assign({}, getOperatorArgs('integer', 'integer')), { c: {
                    type: 'integer',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'c'] },
            ],
            description: 'Returns bitwise `and` with complement.',
            examples: [
                '0b0011 bit-and-not 0b0110',
                'bit-and-not(0b0011, 0b0110)',
                'bit-and-not(0b0011, 0b0110, 0b1001)',
            ],
        },
        '|': {
            title: '|',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign(__assign({}, getOperatorArgs('integer', 'integer')), { c: {
                    type: 'integer',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'c'] },
            ],
            description: 'Returns bitwise `or` of all arguments.',
            examples: [
                '0b0011 | 0b0110',
                '|(0b0011, 0b0110)',
                '|(0b1000, 0b0100, 0b0010)',
            ],
        },
        'xor': {
            title: 'xor',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign(__assign({}, getOperatorArgs('integer', 'integer')), { c: {
                    type: 'integer',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'c'] },
            ],
            description: 'Returns bitwise `xor` of all arguments.',
            examples: [
                '0b0011 xor 0b0110',
                'xor(0b0011, 0b0110)',
                'xor(0b11110000, 0b00111100, 0b10101010)',
            ],
        },
        'bit-flip': {
            title: 'bit-flip',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Flips bit number $b.',
            examples: [
                '0b0011 bit-flip 1',
                'bit-flip(0b0011, 1)',
                'bit-flip(0b1100, 1)',
            ],
        },
        'bit-clear': {
            title: 'bit-clear',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Clears bit number $b.',
            examples: [
                '0b0011 bit-clear 1',
                'bit-clear(0b0011, 1)',
                'bit-clear(0b1100, 1)',
            ],
        },
        'bit-set': {
            title: 'bit-set',
            category: 'Bitwise',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Sets bit number $b.',
            examples: [
                '0b0010 bit-set 1',
                'bit-set(0b0011, 1)',
                'bit-set(0b1100, 1)',
            ],
        },
        'bit-test': {
            title: 'bit-test',
            category: 'Bitwise',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Checks if bit number $b is set.',
            examples: [
                '0b0011 bit-test 1',
                'bit-test(0b0011, 1)',
                'bit-test(0b1100, 1)',
            ],
        },
    };

    var collectionReference = {
        'filter': {
            title: 'filter',
            category: 'Collection',
            returns: {
                type: 'collection',
            },
            args: __assign(__assign({}, getOperatorArgs('collection', 'function')), { coll: {
                    type: 'collection',
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['coll', 'fun'] },
            ],
            description: 'Creates a new collection with all elements that pass the test implemented by $fun.',
            examples: [
                "\nfilter(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                "\nfilter(\n  [5, 10, 15, 20],\n  -> $ > 10\n)",
                "\nfilter(\n  { a: 1, b: 2 },\n  odd?\n)",
            ],
        },
        'filteri': {
            title: 'filteri',
            category: 'Collection',
            returns: {
                type: 'collection',
            },
            args: {
                a: {
                    type: 'collection',
                },
                b: {
                    type: 'function',
                    description: 'The function to call for each element in the collection. The function should take two arguments: the element itself and the index.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Creates a new collection with all elements that pass the test implemented by $b. The function is called for each element in the collection, and it should take two arguments: the element itself and the index.',
            examples: [
                'filteri([1, 2, 3], (x, i) -> i % 2 == 0)',
                'filteri([1, 2, 3], (x, i) -> x % 2 == 0)',
                'filteri([1, 2, 3], (x, i) -> x + i > 3)',
            ],
        },
        'map': {
            title: 'map',
            category: 'Collection',
            returns: {
                type: 'collection',
            },
            args: __assign(__assign({}, getOperatorArgs('collection', 'function')), { colls: {
                    type: 'collection',
                    rest: true,
                    description: 'At least one.',
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['colls', 'fun'] },
            ],
            description: 'Creates a new collection populated with the results of calling $fun on every element in $colls.',
            examples: [
                '[1, 2, 3] map -',
                '[1, 2, 3] map -> -($)',
                'map(["Albert", "Mojir", 42], str)',
                'map([1, 2, 3], inc)',
                'map([1, 2, 3], [1, 10, 100], *)',
                'map({ a: 1, b: 2 }, inc)',
                'map({ a: 1, b: 2 }, { a: 10, b: 20 }, +)',
            ],
        },
        'mapi': {
            title: 'mapi',
            category: 'Collection',
            returns: {
                type: 'collection',
            },
            args: {
                a: {
                    type: 'collection',
                },
                b: {
                    type: 'function',
                    description: 'The function to call for each element in the collection. The function should take two arguments: the element itself and the index.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Creates a new collection populated with the results of calling $b on every element in $a. The function is called for each element in the collection, and it should take two arguments: the element itself and the index.',
            examples: [
                'mapi([1, 2, 3], (x, i) -> x + i)',
                'mapi([1, 2, 3], (x, i) -> x * i)',
                'mapi([1, 2, 3], (x, i) -> x - i)',
                'mapi([1, 2, 3], (x, i) -> x / i)',
                'mapi([1, 2, 3], (x, i) -> x % inc(i))',
            ],
        },
        'reduce': {
            title: 'reduce',
            category: 'Collection',
            returns: {
                type: 'any',
            },
            args: {
                fun: {
                    type: 'function',
                },
                coll: {
                    type: 'collection',
                },
                initial: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['coll', 'fun', 'initial'] },
            ],
            description: 'Runs $fun function on each element of the $coll, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value.',
            examples: [
                'reduce([1, 2, 3], +, 0)',
                'reduce([], +, 0)',
                'reduce({ a: 1, b: 2 }, +, 0)',
                "\nreduce(\n  [1, 2, 3, 4, 5, 6, 7, 8, 9],\n  (result, value) -> result + (even?(value) ? value : 0),\n  0)",
            ],
        },
        'reduce-right': {
            title: 'reduce-right',
            category: 'Collection',
            returns: {
                type: 'any',
            },
            args: {
                fun: {
                    type: 'function',
                },
                coll: {
                    type: 'collection',
                },
                initial: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['coll', 'fun', 'initial'] },
            ],
            description: 'Runs $fun function on each element of the $coll (starting from the last item), passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value.',
            examples: [
                'reduce-right(["A", "B", "C"], str, "")',
                'reduce-right({ a: 1, b: 2 }, +, 0)',
            ],
        },
        'reducei-right': {
            title: 'reducei-right',
            category: 'Collection',
            returns: {
                type: 'any',
            },
            args: {
                coll: {
                    type: 'collection',
                },
                fun: {
                    type: 'function',
                    description: 'The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index.',
                },
                initial: {
                    type: 'any',
                    description: 'The initial value to use as the accumulator.',
                },
            },
            variants: [
                { argumentNames: ['coll', 'fun', 'initial'] },
            ],
            description: 'Runs $fun function on each element of the $coll (starting from the last item), passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.',
            examples: [
                'reducei-right([1, 2, 3], (acc, x, i) -> acc + x + i, 0)',
                'reducei-right("Albert", (acc, x, i) -> acc ++ x ++ i, "")',
                'reducei-right({ a: 1, b: 2 }, -> $1 ++ $3, "")',
            ],
        },
        'reducei': {
            title: 'reducei',
            category: 'Collection',
            returns: {
                type: 'any',
            },
            args: {
                coll: {
                    type: 'collection',
                },
                fun: {
                    type: 'function',
                    description: 'The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index.',
                },
                initial: {
                    type: 'any',
                    description: 'The initial value to use as the accumulator.',
                },
            },
            variants: [
                { argumentNames: ['coll', 'fun', 'initial'] },
            ],
            description: 'Runs $fun function on each element of the $coll, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.',
            examples: [
                'reducei([1, 2, 3], (acc, x, i) -> acc + x + i, 0)',
                'reducei("Albert", (acc, x, i) -> acc ++ x ++ i, "")',
                'reducei({ a: 1, b: 2 }, -> $1 ++ $3, "")',
            ],
        },
        'reductions': {
            title: 'reductions',
            category: 'Collection',
            returns: {
                type: 'any',
                array: true,
            },
            args: {
                fun: {
                    type: 'function',
                },
                coll: {
                    type: 'collection',
                },
                initial: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['coll', 'fun', 'initial'] },
            ],
            description: 'Returns an array of the intermediate values of the reduction (see `reduce`) of $coll by $fun.',
            examples: [
                'reductions([1, 2, 3], +, 0)',
                'reductions([1, 2, 3], +, 10)',
                'reductions([], +, 0)',
                'reductions({ a: 1, b: 2 }, +, 0)',
                "\nreductions(\n  [1, 2, 3, 4, 5, 6, 7, 8, 9],\n  (result, value) -> result + (even?(value) ? value : 0),\n  0\n)",
            ],
        },
        'reductionsi': {
            title: 'reductionsi',
            category: 'Collection',
            returns: {
                type: 'any',
                array: true,
            },
            args: {
                coll: {
                    type: 'collection',
                },
                fun: {
                    type: 'function',
                    description: 'The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index.',
                },
                initial: {
                    type: 'any',
                    description: 'The initial value to use as the accumulator.',
                },
            },
            variants: [
                { argumentNames: ['coll', 'fun', 'initial'] },
            ],
            description: 'Returns an array of the intermediate values of the reduction (see `reduce`) of $coll by $fun. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.',
            examples: [
                'reductionsi([1, 2, 3], (acc, x, i) -> acc + x + i, 0)',
                'reductionsi("Albert", (acc, x, i) -> acc ++ x ++ i, "")',
                'reductionsi({ a: 1, b: 2 }, -> $1 ++ $3, "")',
            ],
        },
        'count': {
            title: 'count',
            category: 'Collection',
            returns: {
                type: 'number',
            },
            args: {
                coll: {
                    type: ['collection', 'null'],
                },
            },
            variants: [
                { argumentNames: ['coll'] },
            ],
            description: 'Returns number of elements in $coll.',
            examples: [
                'count([1, 2, 3])',
                'count([])',
                'count({ a: 1 })',
                'count("")',
                'count("Albert")',
                'count(null)',
            ],
        },
        'get': {
            title: 'get',
            category: 'Collection',
            returns: {
                type: 'any',
            },
            args: __assign(__assign({}, getOperatorArgs('collection', ['string', 'integer'])), { 'not-found': {
                    type: 'any',
                    description: 'Default value to return if $b is not found.',
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'not-found'] },
            ],
            description: 'Returns value in $a mapped at $b.',
            examples: [
                '[1, 2, 3] get 1',
                '{ a: 1 } get "a"',
                '"Albert" get "3"',
                "\nget(\n  [1, 2, 3],\n  1, // Optional comma after last argument\n)",
                "\nget(\n  [],\n  1\n)",
                "\nget(\n  [],\n  1,\n  \"default\"\n)",
                "\nget(\n  { a: 1 },\n  \"a\"\n)",
                "\nget(\n  { a: 1 },\n  \"b\"\n)",
                "\nget(\n  { a: 1 },\n  \"b\",\n  \"default\"\n)",
                "\nget(\n  null,\n  \"a\"\n)",
                "\nget(\n  null,\n  \"b\",\n  \"default\"\n)",
            ],
        },
        'get-in': {
            title: 'get-in',
            category: 'Collection',
            returns: {
                type: 'any',
            },
            args: __assign(__assign({}, getOperatorArgs('collection', 'array')), { 'not-found': {
                    type: 'any',
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'not-found'] },
            ],
            description: 'Returns the value in a nested collection, where $b is an array of keys. Returns $not-found if the key is not present. If $not-found is not set, `null` is returned.',
            examples: [
                "\nget-in(\n  [[1, 2, 3], [4, { a: \"Kalle\" }, 6]],\n  [1, 1, \"a\", 0]\n)",
                "\nget-in(\n  [[1, 2, 3], [4, { a: \"Kalle\" }, 6]],\n  [1, 1, \"b\", 0]\n)",
                "\nget-in(\n  [[1, 2, 3], [4, { a: \"Kalle\" }, 6]],\n  [1, 1, \"b\", 0],\n  \"Lisa\"\n)",
            ],
        },
        'contains?': {
            title: 'contains?',
            category: 'Collection',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs(['collection', 'null'], ['string', 'integer'])),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns `true` if $a contains $b, otherwise returns `false`. For strings, it checks if substring is included.',
            examples: [
                '[1, 2, 3] contains? 1',
                'null contains? 1',
                '{ a: 1, b: 2 } contains? "a"',
                "\ncontains?(\n  [],\n  1\n)",
                "\ncontains?(\n  [1],\n  1\n)",
                "\ncontains?(\n  [1, 2, 3],\n  1\n)",
                "\ncontains?(\n  {},\n  \"a\"\n)",
                "\ncontains?(\n  { a: 1, b: 2 },\n  \"a\"\n)",
            ],
        },
        'assoc': {
            title: 'assoc',
            category: 'Collection',
            returns: {
                type: 'collection',
            },
            args: {
                coll: {
                    type: 'collection',
                },
                key: {
                    type: ['string', 'number'],
                },
                value: {
                    type: 'any',
                },
                kvs: {
                    type: 'any',
                    description: 'Key-value pairs to associate.',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['coll', 'key', 'value'] },
                { argumentNames: ['coll', 'key', 'value', 'kvs'] },
            ],
            description: "\nAdd or replace the value of element $key to $value in $coll. Repeated for all key-value pairs in $kvs.  \nIf $coll is an 'array', $key must be `number` satisfying `0 <=` $key `<= length`.",
            examples: [
                "\nassoc(\n  [1, 2, 3],\n  1,\n  \"Two\"\n)",
                "\nassoc(\n  [1, 2, 3],\n  3,\n  \"Four\"\n)",
                "\nassoc(\n  { a: 1, b: 2 },\n  \"a\",\n  \"One\")",
                "\nassoc(\n  { a: 1, b: 2 },\n  \"c\",\n  \"Three\")",
                "\nassoc(\n  \"Albert\",\n  6,\n  \"a\")",
            ],
        },
        'assoc-in': {
            title: 'assoc-in',
            category: 'Collection',
            returns: {
                type: 'collection',
            },
            args: {
                coll: {
                    type: 'collection',
                },
                ks: {
                    type: ['number', 'string'],
                    array: true,
                },
                value: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['coll', 'ks', 'value'] },
            ],
            description: "\nAssociates a value in the nested collection $coll, where $ks is an array of keys and $value is the new value.\n\nIf any levels do not exist, objects will be created - and the corresponding keys must be of type string.",
            examples: [
                "\nassoc-in(\n  {},\n  [\"a\", \"b\", \"c\"],\n  \"Albert\"\n)",
                "\nassoc-in(\n  [1, 2, [1, 2, 3]],\n  [2, 1],\n  \"Albert\"\n)",
                "\nassoc-in(\n  [1, 2, { name: \"albert\" }],\n  [2, \"name\", 0],\n  \"A\"\n)",
            ],
        },
        '++': {
            title: '++',
            category: 'Collection',
            returns: {
                type: 'collection',
            },
            args: __assign(__assign({}, getOperatorArgs('collection', 'collection')), { colls: {
                    type: 'collection',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['a'] },
                { argumentNames: ['a', 'colls'] },
            ],
            description: 'Concatenates collections into one collection.',
            examples: [
                '"Albert" ++ " " ++ "Mojir"',
                '"Albert" ++ "Mojir"',
                '"Hi " concat "Albert"',
                '[1, 2] concat [3, 4]',
                '++("Albert", "-", "Mojir")',
                '++("Albert")',
                'concat("A", "l", "b", "e", "r", "t")',
                'concat([1, 2], [3, 4])',
                'concat([], [3, 4])',
                'concat([1, 2], [])',
                'concat([1, 2], [3, 4], [5, 6])',
                'concat([])',
                'concat({ a: 1, b: 2 }, { b: 1, c: 2 })',
                'concat({}, { a: 1 })',
            ],
            aliases: ['concat'],
        },
        'not-empty': {
            title: 'not-empty',
            category: 'Collection',
            returns: {
                type: 'boolean',
            },
            args: {
                coll: {
                    type: ['collection', 'null'],
                },
            },
            variants: [
                { argumentNames: ['coll'] },
            ],
            description: 'Returns `null` if $coll is empty or `null`, otherwise $coll.',
            examples: [
                'not-empty([])',
                'not-empty([1, 2, 3])',
                'not-empty({})',
                'not-empty({ a: 2 })',
                'not-empty("")',
                'not-empty("Albert")',
                'not-empty(null)',
            ],
        },
        'every?': {
            title: 'every?',
            category: 'Collection',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('collection', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns `true` if all entries in $a pass the test implemented by $b, otherwise returns `false`.',
            examples: [
                '[1, 2, 3] every? number?',
                '[1, 2, 3] every? even?',
                "\nevery?(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?,\n)",
                "\nevery?(\n  [50, 100, 150, 200],\n  -> $ > 10,\n)",
                "\nevery?(\n  [],\n  number?\n)",
                "\nevery?(\n  \"\",\n  number?\n)",
                "\nevery?(\n  {},\n  number?\n)",
                "\nevery?(\n  { a: 2, b: 4},\n  -> even?(second($))\n)",
                "\nevery?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)",
            ],
        },
        'not-every?': {
            title: 'not-every?',
            category: 'Collection',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('collection', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns `true` if at least one element in $a does not pass the test implemented by $b, otherwise returns `false`.',
            examples: [
                "\nnot-every?(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                "\nnot-every?(\n  [50, 100, 150, 200],\n  x -> x > 10\n)",
                "\nnot-every?(\n  [],\n  number?\n)",
                "\nnot-every?(\n  \"\",\n  number?\n)",
                "\nnot-every?(\n  {},\n  number?\n)",
                "\nnot-every?(\n  { a: 2, b: 4 },\n  -> even?(second($))\n)",
                "\nnot-every?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)",
            ],
        },
        'any?': {
            title: 'any?',
            category: 'Collection',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('collection', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns `true` if any element in $a pass the test implemented by $b, otherwise returns `false`.',
            examples: [
                "\nany?(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                "\nany?(\n  [50, 100, 150, 200],\n  x -> x > 10\n)",
                "\nany?(\n  [],\n  number?\n)",
                "\nany?(\n  \"\",\n  number?\n)",
                "\nany?(\n  {},\n  number?\n)",
                "\nany?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)",
                "\nany?(\n  { a: 1, b: 3 },\n  -> even?(second($))\n)",
            ],
        },
        'not-any?': {
            title: 'not-any?',
            category: 'Collection',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('collection', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns `false` if any element in $a pass the test implemented by $b, otherwise returns `true`.',
            examples: [
                "\nnot-any?(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                "\nnot-any?(\n  [50, 100, 150, 200],\n  x -> x > 10\n)",
                "\nnot-any?(\n  [],\n  number?\n)",
                "\nnot-any?(\n  \"\",\n  number?\n)",
                "\nnot-any?(\n  {},\n  number?\n)",
                "\nnot-any?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)",
                "\nnot-any?(\n  { a: 1, b: 3 },\n  -> even?(second($))\n)",
            ],
        },
        'update': {
            title: 'update',
            category: 'Collection',
            returns: {
                type: 'collection',
            },
            args: {
                'coll': {
                    type: 'collection',
                },
                'key': {
                    type: ['string', 'number'],
                },
                'fun': {
                    type: 'function',
                },
                'fun-args': {
                    type: 'any',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['coll', 'value', 'fun'] },
                { argumentNames: ['coll', 'value', 'fun', 'fun-args'] },
            ],
            description: "\nUpdates a value in the $coll collection, where $key is a key. $fun is a function\nthat will take the old value and any supplied $fun-args and\nreturn the new value.\nIf the key does not exist, `null` is passed as the old value.",
            examples: [
                "\nlet x = { a: 1, b: 2 };\nupdate(x, \"a\", inc)",
                "\nlet x = { a: 1, b: 2 };\nupdate(\n  x,\n  \"c\",\n  val -> null?(val) ? 0 : inc(val)\n)",
            ],
        },
        'update-in': {
            title: 'update-in',
            category: 'Collection',
            returns: {
                type: 'collection',
            },
            args: {
                'coll': {
                    type: 'collection',
                },
                'ks': {
                    type: 'array',
                },
                'fun': {
                    type: 'function',
                },
                'fun-args': {
                    type: 'any',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['coll', 'ks', 'fun'] },
                { argumentNames: ['coll', 'ks', 'fun', 'fun-args'] },
            ],
            description: "Updates a value in the $coll collection, where $ks is an array of\nkeys and $fun is a function that will take the old value and\nany supplied $fun-args and return the new value. If any levels do not exist,\nobjects will be created - and the corresponding keys must be of type string.",
            examples: [
                "\nupdate-in(\n  { a: [1, 2, 3] },\n  [\"a\", 1],\n  -> null?($) ? 0 : inc($)\n)",
                "\nupdate-in(\n  { a: { foo: \"bar\"} },\n  [\"a\", \"foo\"],\n  -> null?($) ? \"?\" : \"!\"\n)",
                "\nupdate-in(\n  { a: { foo: \"bar\"} },\n  [\"a\", \"baz\"],\n  -> null?($) ? \"?\" : \"!\"\n)",
                "\nupdate-in(\n  { a: [1, 2, 3] },\n  [\"a\", 1],\n  *,\n  10,\n  10,\n  10,\n)",
            ],
        },
    };

    var functionalReference = {
        '|>': {
            title: '|>',
            category: 'Functional',
            returns: {
                type: 'any',
            },
            args: __assign({}, getOperatorArgs('any', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Takes a value $a and a function $b, and returns the result of applying $b to $a.',
            examples: [
                "\n1 |> inc |> inc",
                "range(10)\n  |> map(_, -> $ ^ 2) // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n  |> filter(_, odd?)  // [1, 9, 25, 49, 81]\n  |> reduce(_, +, 0)  // 165\n  |> sqrt             // 12.84523257866513\n  |> round(_, 2)",
            ],
        },
        'apply': {
            title: 'apply',
            category: 'Functional',
            returns: {
                type: 'any',
            },
            args: __assign(__assign({}, getOperatorArgs('function', 'array')), { fun: {
                    type: 'function',
                }, args: {
                    type: 'array',
                } }),
            variants: [
                { argumentNames: ['fun', 'args'] },
            ],
            description: 'Call supplied function $fun with specified arguments $args.',
            examples: [
                "\napply(+, [1, 2, 3])",
                "\napply(\n  (x, y) -> sqrt(x ^ 2 + y ^ 2),\n  [3, 4]\n)",
                "\n(x, y) -> sqrt(x ^ 2 + y ^ 2) apply [3, 4]",
            ],
        },
        'identity': {
            title: 'identity',
            category: 'Functional',
            returns: {
                type: 'any',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns $x.',
            examples: ['identity(1)', 'identity("Albert")', 'identity({ a: 1 })', 'identity(null)'],
        },
        'comp': {
            title: 'comp',
            category: 'Functional',
            returns: {
                type: 'function',
            },
            args: __assign(__assign({}, getOperatorArgs('function', 'function')), { fns: {
                    type: 'function',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['fns'] },
            ],
            description: "Takes a variable number of functions and returns a function that is the composition of those.\n\n  The returned function takes a variable number of arguments,\n  applies the rightmost function to the args,\n  the next function (right-to-left) to the result, etc.",
            examples: [
                "\nlet negative-quotient = comp(-, /);\nnegative-quotient(9, 3)",
                "\nlet x = { bar: { foo: 42 } };\ncomp(\"foo\", \"bar\")(x)",
            ],
        },
        'constantly': {
            title: 'constantly',
            category: 'Functional',
            returns: {
                type: 'function',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns a function that takes any number of arguments and always returns $x.',
            examples: [
                "\nlet always-true = constantly(true);\nalways-true(9, 3)",
            ],
        },
        'juxt': {
            title: 'juxt',
            category: 'Functional',
            returns: {
                type: 'function',
            },
            args: __assign(__assign({}, getOperatorArgs('function', 'function')), { fun: {
                    type: 'function',
                }, fns: {
                    type: 'function',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['fun'] },
                { argumentNames: ['fun', 'fns'] },
            ],
            description: "Takes one or many function and returns a function that is the juxtaposition of those functions.  \nThe returned function takes a variable number of args,\nand returns a vector containing the result of applying each function to the args (left-to-right).",
            examples: [
                "\njuxt(+, *, min, max)(\n  3,\n  4,\n  6,\n)",
                "\njuxt(\"a\", \"b\")(\n  {\n    a: 1,\n    b: 2,\n    c: 3,\n    d: 4\n  }\n)",
                "\njuxt(+, *, min, max) apply range(1, 11)",
            ],
        },
        'complement': {
            title: 'complement',
            category: 'Functional',
            returns: {
                type: 'function',
            },
            args: {
                fun: {
                    type: 'function',
                },
            },
            variants: [
                { argumentNames: ['fun'] },
            ],
            description: 'Takes a function $fun and returns a new function that takes the same arguments as f, has the same effects, if any, and returns the opposite truth value.',
            examples: [
                'complement(>)(1, 3)',
                'complement(<)(1, 3)',
                'complement(+)(1, 3)',
                'complement(+)(0, 0)',
            ],
        },
        'every-pred': {
            title: 'every-pred',
            category: 'Functional',
            returns: {
                type: 'function',
            },
            args: {
                fun: {
                    type: 'function',
                },
                fns: {
                    type: 'function',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['fun'] },
                { argumentNames: ['fun', 'fns'] },
            ],
            description: "\nTakes a number of predicates and returns a function that returns `true` if all predicates\nreturn a truthy value against all of its arguments, else it returns `false`.",
            examples: [
                "\nevery-pred(string?, -> count($) > 3)(\n  \"Albert\",\n  \"Mojir\"\n)",
                "\n(string? every-pred -> count($) > 3)(\n  \"Albert\",\n  \"M\"\n)",
            ],
            noOperatorDocumentation: true,
        },
        'some-pred': {
            title: 'some-pred',
            category: 'Functional',
            returns: {
                type: 'function',
            },
            args: {
                fun: {
                    type: 'function',
                },
                fns: {
                    type: 'function',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['fun'] },
                { argumentNames: ['fun', 'fns'] },
            ],
            description: 'Takes a number of `predicates` and returns a function that returns \`true\` if at least one of the `predicates` return a truthy \`true\` value against at least one of its arguments, else it returns `false`.',
            examples: [
                'some-pred(string?, -> count($) > 3)("Albert", "Mojir")',
                'some-pred(string?, -> count($) > 3)("a", "M")',
                'some-pred(string?, -> count($) > 3)("a", [1, 2, 3])',
                'some-pred(string?, -> count($) > 3)([1, 2, 3], [2])',
            ],
            noOperatorDocumentation: true,
        },
        'fnull': {
            title: 'fnull',
            category: 'Functional',
            returns: {
                type: 'function',
            },
            args: __assign(__assign({}, getOperatorArgs('function', 'any')), { fun: {
                    type: 'function',
                }, arg: {
                    type: 'any',
                }, args: {
                    type: 'any',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['fun', 'arg'] },
                { argumentNames: ['fun', 'arg', 'args'] },
            ],
            description: 'Takes a function $fun, and returns a function that calls $fun, replacing a null argument to the corresponding argument.',
            examples: [
                'fnull(inc, 0)(1)',
                'fnull(inc, 0)(null)',
                '(inc fnull 0)(null)',
                'fnull(+, 1, 2)(null, 0)',
                'fnull(+, 1, 2)(0, null)',
                'fnull(+, 1, 2)(null, null)',
                'fnull(+, 1, 2)(null, null, 3, 4)',
            ],
        },
    };

    var mixedArgs = {
        type: ['number', 'vector', 'matrix'],
        rest: true,
    };
    var mixedOperatorArgs = getOperatorArgs(['number', 'vector', 'matrix'], ['number', 'vector', 'matrix']);
    var mathReference = {
        '+': {
            title: '+',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: __assign({ xs: mixedArgs }, mixedOperatorArgs),
            variants: [
                { argumentNames: ['xs'] },
            ],
            description: 'The `+` function performs addition of numbers and element-wise addition of `vectors` and `matrices` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it adds the scalar to each element of the collection.',
            examples: [
                '1 + 2',
                '1 + 20 + 30',
                '+(1, 2, 3, 4)',
                '+()',
                '+(1)',
                '[1, 2, 3] + 2',
                '[1, 2, 3] + [4, 5, 6]',
                '[[1, 2, 3], [4, 5, 6]] + [[7, 8, 9], [10, 11, 12]]',
                '[[1, 2, 3], [4, 5, 6]] + 2',
            ],
        },
        '-': {
            title: '-',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: __assign({ xs: mixedArgs }, mixedOperatorArgs),
            variants: [
                { argumentNames: ['xs'] },
            ],
            description: 'Computes difference between first value and sum of the rest. When called with only one argument, it does negation.',
            examples: [
                '50 - 8',
                '1 - 1 - 1',
                '-()',
                '-(4, 2)',
                '-(4, 3, 2, 1,)',
                '[1, 2, 3] - 2',
                '[1, 2, 3] - [4, 5, 6]',
                '[[1, 2, 3], [4, 5, 6]] - [[7, 8, 9], [10, 11, 12]]',
                '[[1, 2, 3], [4, 5, 6]] - 2',
            ],
        },
        '*': {
            title: '*',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: __assign({ xs: mixedArgs }, mixedOperatorArgs),
            variants: [
                { argumentNames: ['xs'] },
            ],
            description: 'The `*` function performs multiplication of `numbers` and element-wise multiplication of `vectors` and `matrices` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it multiplies each element of the collection by the scalar.',
            examples: [
                '6 * 7',
                '-1 * 4',
                '*(4, 7)',
                '*(1, 2, 3, 4, 5)',
                '*()',
                '*(8)',
                '[1, 2, 3] * 2',
                '[1, 2, 3] * [4, 5, 6]',
                '[[1, 2, 3], [4, 5, 6]] * [[7, 8, 9], [10, 11, 12]]',
                '[[1, 2, 3], [4, 5, 6]] * 2',
            ],
            aliases: ['·'],
        },
        '/': {
            title: '/',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: __assign({ xs: mixedArgs }, mixedOperatorArgs),
            variants: [
                { argumentNames: ['xs'] },
            ],
            description: 'The `/` function performs division of `numbers` and element-wise division of `vectors` and `matrices` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it divides each element of the collection by the scalar.',
            examples: [
                '12 / 100',
                '-1 / 4',
                '/(7, 4)',
                '/(1, 2, 4, 8)',
                '/()',
                '/(8)',
                '[1, 2, 3] / 2',
                '[1, 2, 3] / [4, 5, 6]',
                '[[1, 2, 3], [4, 5, 6]] / [[7, 8, 9], [10, 11, 12]]',
                '[[1, 2, 3], [4, 5, 6]] / 2',
            ],
        },
        'mod': {
            title: 'mod',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: __assign({}, mixedOperatorArgs),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'The `mod` function computes the modulo of division with the same sign as the divisor, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies the modulo operation between each element of the collection and the scalar.',
            examples: [
                'mod(5, 3)',
                'mod(5.2, 3.1)',
                'mod(-5, 3)',
                '5 mod -3',
                '-5 mod -3',
                '[1, 2, 3] mod 2',
                '2 mod [1, 2, 3]',
                'mod([1, 2, 3], [4, 5, 6])',
                '[[1, 2, 3], [4, 5, 6]] mod [[7, 8, 9], [10, 11, 12]]',
                'mod([[1, 2, 3], [4, 5, 6]], 2)',
            ],
        },
        'rem': {
            title: 'rem',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: __assign({}, mixedOperatorArgs),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'The `rem` function computes the remainder of division with the same sign as the dividend, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies the remainder operation between each element of the collection and the scalar.',
            examples: [
                '5 % 3',
                '5.2 % 3.1',
                '-5 % 3',
                '%(5, -3)',
                '%(-5, -3)',
                '5 rem -3',
                '-5 rem -3',
                '[1, 2, 3] % 2',
                '2 % [1, 2, 3]',
                '%([1, 2, 3], [4, 5, 6])',
                '[[1, 2, 3], [4, 5, 6]] % [[7, 8, 9], [10, 11, 12]]',
                '%([[1, 2, 3], [4, 5, 6]], 2)',
                '[[1, 2, 3], [4, 5, 6]] rem [[7, 8, 9], [10, 11, 12]]',
            ],
            aliases: ['%'],
        },
        'quot': {
            title: 'quot',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: __assign({}, mixedOperatorArgs),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'The `quot` function performs integer division truncated toward zero, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies integer division between each element of the collection and the scalar.',
            examples: [
                'quot(5, 3)',
                'quot(5.2, 3.1)',
                'quot(-5, 3)',
                '5 quot -3',
                '-5 quot -3',
                'quot(5, 0)',
                'quot(0, 5)',
                '[1, 2, 3] quot 2',
                '2 quot [1, 2, 3]',
                'quot([1, 2, 3], [4, 5, 6])',
                '[[1, 2, 3], [4, 5, 6]] quot [[7, 8, 9], [10, 11, 12]]',
                'quot([[1, 2, 3], [4, 5, 6]], 2)',
                '[[1, 2, 3], [4, 5, 6]] quot [[7, 8, 9], [10, 11, 12]]',
            ],
        },
        'inc': {
            title: 'inc',
            category: 'Math',
            returns: {
                type: 'number',
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `inc` function increments its argument by 1, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it increases each element by 1 while preserving the original structure.',
            examples: [
                'inc(0)',
                'inc(1)',
                'inc(100.1)',
                'inc([1, 2, 3])',
                'inc([[1, 2], [3, 4]])',
            ],
        },
        'dec': {
            title: 'dec',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `dec` function decrements its argument by 1, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it decreases each element by 1 while preserving the original structure.',
            examples: [
                'dec(0)',
                'dec(1)',
                'dec(100.1)',
                'dec([1, 2, 3])',
                'dec([[1, 2], [3, 4]])',
            ],
        },
        'sqrt': {
            title: 'sqrt',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `sqrt` function calculates the square root of `numbers` and computes element-wise square roots of `vectors` and `matrices`. When applied to collections, it returns the square root of each element while preserving the original structure.',
            examples: [
                '√(0)',
                '√(9)',
                '√(2)',
                'sqrt(0)',
                'sqrt(9)',
                'sqrt(2)',
                'sqrt([1, 4, 9])',
                'sqrt([[1, 4], [9, 16]])',
            ],
            aliases: ['√'],
        },
        'cbrt': {
            title: 'cbrt',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `cbrt` function calculates the cube root of `numbers` and computes element-wise cube roots of `vectors` and `matrices`. When applied to collections, it returns the cube root of each element while preserving the original structure.',
            examples: [
                '∛(0)',
                '∛(27)',
                '∛(2)',
                '∛(1)',
                'cbrt(0)',
                'cbrt(27)',
                'cbrt(2)',
                'cbrt(1)',
                'cbrt([1, 8, 27])',
                'cbrt([[1, 8], [27, 64]])',
            ],
            aliases: ['∛'],
        },
        '^': {
            title: '^',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: __assign({}, mixedOperatorArgs),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'The ^ function computes exponentiation, raising the first argument to the power of the second, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies the power operation between each element of the collection and the scalar.',
            examples: [
                '2 ^ 3',
                '2 ^ 0',
                '2 ^ -3',
                '^(-2, 3)',
                '^(-2, -3)',
                '[1, 2, 3] ^ 2',
                '2 ^ [1, 2, 3]',
                '^([1, 2, 3], [4, 5, 6])',
                '[[1, 2, 3], [4, 5, 6]] ^ [[7, 8, 9], [10, 11, 12]]',
                '^([[1, 2, 3], [4, 5, 6]], 2)',
            ],
        },
        'round': {
            title: 'round',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: __assign({}, getOperatorArgs(['number', 'vector', 'matrix'], 'integer')),
            variants: [
                { argumentNames: ['a'] },
                { argumentNames: ['a', 'b'] },
            ],
            description: 'The `round` function rounds a `number` to the nearest `integer` or to a specified number of `decimal` places, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it rounds each element while preserving the original structure.',
            examples: [
                'round(2)',
                'round(2.49)',
                'round(2.5)',
                'round(-2.49)',
                'round(-2.5)',
                'round(-2.501)',
                'round(1.23456789, 4)',
                '1.123456789 round 2',
                'round([1.23456789, 2.3456789], 1)',
                '[1.23456789, 2.3456789] round 4',
                '[[1.23456789, 2.3456789], [3.456789, 4.56789]] round 4',
                'round([[1.23456789, 2.3456789], [3.456789, 4.56789]], 2)',
            ],
        },
        'trunc': {
            title: 'trunc',
            category: 'Math',
            returns: {
                type: ['integer', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `trunc` function truncates `numbers` toward zero (removing decimal portions without rounding), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it truncates each element while preserving the original structure.',
            examples: [
                'trunc(2)',
                'trunc(2.49)',
                'trunc(2.5)',
                'trunc(-2.49)',
                'trunc(-2.5)',
                'trunc(-2.501)',
                'trunc([1.23456789, 2.3456789])',
                'trunc([[1.23456789, 2.3456789], [3.456789, 4.56789]])',
            ],
        },
        'floor': {
            title: 'floor',
            category: 'Math',
            returns: {
                type: ['integer', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `floor` function returns the largest `integer` less than or equal to a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the floor of each element while preserving the original structure.',
            examples: [
                'floor(2)',
                'floor(2.49)',
                'floor(2.5)',
                'floor(-2.49)',
                'floor(-2.5)',
                'floor(-2.501)',
                'floor([1.23456789, 2.3456789])',
                'floor([[1.23456789, 2.3456789], [3.456789, 4.56789]])',
            ],
        },
        'ceil': {
            title: 'ceil',
            category: 'Math',
            returns: {
                type: ['integer', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `ceil` function returns the smallest `integer` greater than or equal to a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the ceiling of each element while preserving the original structure.',
            examples: [
                'ceil(2)',
                'ceil(2.49)',
                'ceil(2.5)',
                'ceil(-2.49)',
                'ceil(-2.5)',
                'ceil(-2.501)',
                'ceil([1.23456789, 2.3456789])',
                'ceil([[1.23456789, 2.3456789], [3.456789, 4.56789]])',
            ],
        },
        'min': {
            title: 'min',
            category: 'Math',
            returns: {
                type: 'number',
            },
            args: __assign(__assign({}, getOperatorArgs('number', 'number')), { xs: {
                    type: 'number',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['xs'] },
            ],
            description: 'Returns the smallest number of the arguments.',
            examples: [
                '2 min 3',
                'min(2, 0, 1)',
                'min(2, -1, 1)',
                'min(2.5)',
                '12 min 14',
            ],
        },
        'max': {
            title: 'max',
            category: 'Math',
            returns: {
                type: 'number',
            },
            args: __assign(__assign({}, getOperatorArgs('number', 'number')), { xs: {
                    type: 'number',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['xs'] },
            ],
            description: 'Returns the largest number of the arguments.',
            examples: [
                ' 2 max 3',
                'max(2, 0, 1)',
                'max(2, -1, 1)',
                'max(2, 0.5)',
                '4 max 2',
            ],
        },
        'abs': {
            title: 'abs',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The abs function returns the absolute value (magnitude) of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the absolute value of each element while preserving the original structure.',
            examples: [
                'abs(-2.3)',
                'abs(0)',
                'abs(2.5)',
                'abs([1, -2, 3])',
                'abs([[1, -2], [3, -4]])',
            ],
        },
        'sign': {
            title: 'sign',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `sign` function returns the `sign** of a **number` (-1 for negative, 0 for zero, 1 for positive), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the sign of each element while preserving the original structure.',
            examples: [
                'sign(-2.3)',
                'sign(-0)',
                'sign(0)',
                'sign(12312)',
                'sign([1, -2, 3])',
                'sign([[1, -2], [3, -4]])',
            ],
        },
        'ln': {
            title: 'ln',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `ln` function computes the natural logarithm (base `e`) of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the natural logarithm of each element while preserving the original structure.',
            examples: [
                'ln(0.01)',
                'ln(2.5)',
                'ln(E)',
                'ln([1, 2, 3])',
                'ln([[1, 2], [3, 4]])',
            ],
        },
        'log2': {
            title: 'log2',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `log2` function computes the base `2` logarithm of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the base-2 logarithm of each element while preserving the original structure.',
            examples: [
                'log2(0.01)',
                'log2(2 ^ 12)',
                'log2(2.5)',
                'log2([1, 2, 3])',
                'log2([[1, 2], [3, 4]])',
            ],
            aliases: ['log₂'],
        },
        'log10': {
            title: 'log10',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            aliases: ['log₁₀'],
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `log10` function computes the base `10` logarithm of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the base-10 logarithm of each element while preserving the original structure.',
            examples: [
                'log10(0.01)',
                'log10(10 ^ 12)',
                'log10(2.5)',
                'log10([1, 2, 3])',
                'log10([[1, 2], [3, 4]])',
            ],
        },
        'sin': {
            title: 'sin',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `sin` function computes the sine of an angle (in radians), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the sine of each element while preserving the original structure.',
            examples: [
                'sin(0)',
                'sin(1)',
                'sin(PI)',
                'sin(-0.5)',
                'sin([1, 2, 3])',
                'sin([[1, 2], [3, 4]])',
            ],
        },
        'cos': {
            title: 'cos',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `cos` function computes the cosine of an angle (in radians), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the cosine of each element while preserving the original structure.',
            examples: [
                'cos(0)',
                'cos(1)',
                'cos(PI)',
                'cos(-0.5)',
                'cos([1, 2, 3])',
                'cos([[1, 2], [3, 4]])',
            ],
        },
        'tan': {
            title: 'tan',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `tan` function computes the tangent of an angle (in radians), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the tangent of each element while preserving the original structure.',
            examples: [
                'tan(0)',
                'tan(1)',
                'tan(PI)',
                'tan(-0.5)',
                'tan([1, 2, 3])',
                'tan([[1, 2], [3, 4]])',
            ],
        },
        'asin': {
            title: 'asin',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `asin` function computes the arcsine (inverse sine) of a `number` in radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the arcsine of each element while preserving the original structure.',
            examples: [
                'asin(0)',
                'asin(1)',
                'asin(-0.5)',
                'asin([1, 2, 3])',
                'asin([[1, 2], [3, 4]])',
            ],
        },
        'acos': {
            title: 'acos',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `acos` function computes the arccosine (inverse cosine) of a `number` in radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the arccosine of each element while preserving the original structure.',
            examples: [
                'acos(0)',
                'acos(1)',
                'acos(-0.5)',
                'acos([0.1, 0.2, 0.3])',
                'acos([[0.1, 0.2], [0.3, 0.4]])',
            ],
        },
        'atan': {
            title: 'atan',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `atan` function computes the arctangent (inverse tangent) of a `number` in radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the arctangent of each element while preserving the original structure.',
            examples: [
                'atan(0)',
                'atan(1)',
                'atan(-0.5)',
                'atan([0.1, 0.2, 0.3])',
                'atan([[0.1, 0.2], [0.3, 0.4]])',
            ],
        },
        'sinh': {
            title: 'sinh',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `sinh` function computes the hyperbolic sine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the hyperbolic sine of each element while preserving the original structure.',
            examples: [
                'sinh(0)',
                'sinh(1)',
                'sinh(-0.5)',
                'sinh([0.1, 0.2, 0.3])',
                'sinh([[0.1, 0.2], [0.3, 0.4]])',
            ],
        },
        'cosh': {
            title: 'cosh',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `cosh` function computes the hyperbolic cosine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the hyperbolic cosine of each element while preserving the original structure.',
            examples: [
                'cosh(0)',
                'cosh(1)',
                'cosh(-0.5)',
                'cosh([0.1, 0.2, 0.3])',
                'cosh([[0.1, 0.2], [0.3, 0.4]])',
            ],
        },
        'tanh': {
            title: 'tanh',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `tanh` function computes the hyperbolic tangent of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the hyperbolic tangent of each element while preserving the original structure.',
            examples: ['tanh(0)', 'tanh(1)', 'tanh(-0.5)', 'tanh(50)'],
        },
        'asinh': {
            title: 'asinh',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `asinh` function computes the inverse hyperbolic sine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the inverse hyperbolic sine of each element while preserving the original structure.',
            examples: [
                'asinh(10)',
                'asinh(90)',
                'asinh (50)',
                'asinh([10, 20, 30])',
                'asinh([[10, 20], [30, 40]])',
            ],
        },
        'acosh': {
            title: 'acosh',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `acosh` function computes the inverse hyperbolic cosine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the inverse hyperbolic cosine of each element while preserving the original structure.',
            examples: [
                'acosh(1)',
                'acosh(2)',
                'acosh(100)',
                'acosh(50)',
                'acosh([1, 2, 3])',
                'acosh([[1, 2], [3, 4]])',
            ],
        },
        'atanh': {
            title: 'atanh',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `atanh` function computes the inverse hyperbolic tangent of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the inverse hyperbolic tangent of each element while preserving the original structure.',
            examples: [
                'atanh(0)',
                'atanh(0.9)',
                'atanh(-0.5)',
                'atanh([0.1, 0.2, 0.3])',
                'atanh([[0.1, 0.2], [0.3, 0.4]])',
            ],
        },
        'to-rad': {
            title: 'to-rad',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `to-rad` function converts an angle from degrees to radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it converts each element while preserving the original structure.',
            examples: [
                'to-rad(0)',
                'to-rad(90)',
                'to-rad(180)',
                'to-rad(360)',
                'to-rad([0, 90, 180])',
                'to-rad([[0, 90], [180, 360]])',
            ],
        },
        'to-deg': {
            title: 'to-deg',
            category: 'Math',
            returns: {
                type: ['number', 'vector', 'matrix'],
            },
            args: {
                x: {
                    type: ['number', 'vector', 'matrix'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'The `to-deg` function converts an angle from radians to degrees, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it converts each element while preserving the original structure.',
            examples: [
                'to-deg(0)',
                'to-deg(PI)',
                'to-deg(PI / 2)',
                'to-deg(3 * PI / 2)',
                'to-deg([0, PI, PI / 2])',
                'to-deg([[0, PI], [PI / 2, 3 * PI / 2]])',
            ],
        },
    };

    var miscReference = {
        '!=': {
            title: '!=',
            category: 'Misc',
            returns: {
                type: 'boolean',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { x: {
                    type: 'any',
                }, ys: {
                    type: 'any',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['x'] },
                { argumentNames: ['x', 'ys'] },
            ],
            description: 'Returns `true` if all `values` are not equal to each other, otherwise result is `false`. `(!= a b c)` is same as `(! (== a b c))`.',
            examples: [
                '1 ≠ 2',
                '3 != 3',
                '≠(3)',
                '!=(3, 3, 2)',
                '≠("3", "2", "1", "0",)',
                '!=(0, -0)',
            ],
            aliases: ['≠'],
        },
        '==': {
            title: '==',
            category: 'Misc',
            returns: {
                type: 'boolean',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { x: {
                    type: 'any',
                }, ys: {
                    type: 'any',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['x'] },
                { argumentNames: ['x', 'ys'] },
            ],
            description: 'Returns `true` if all `values` are structaul equal to each other, otherwise result is `false`.',
            examples: [
                '1 == 1',
                '[1, 2] == [1, 2]',
                "\n{\n a: 1,\n b: 2,\n} == {\n b: 2,\n a: 1,\n}",
                '==(1, 1)',
                '==(1.01, 1)',
                '==("1", 1)',
                '==("2", "2", "2", "2")',
                '==(2, 2, 1, 2)',
                '==([1, 2], [1, 2])',
                '==({ a: 1, b: 2 }, { b: 2, a: 1 })',
            ],
        },
        '<': {
            title: '<',
            category: 'Misc',
            returns: {
                type: 'boolean',
            },
            args: __assign(__assign({}, getOperatorArgs(['number', 'string'], ['number', 'string'])), { x: {
                    type: ['number', 'string'],
                }, ys: {
                    type: ['number', 'string'],
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['x'] },
                { argumentNames: ['x', 'ys'] },
            ],
            description: 'Returns `true` if $x and $ys are in increasing order, `false` otherwise.',
            examples: [
                '<(0, 1)',
                '<(1, 1.01)',
                '<(1, 1)',
                '<(1, 2, 2, 3)',
                '<("a", "b")',
            ],
        },
        '>': {
            title: '>',
            category: 'Misc',
            returns: {
                type: 'boolean',
            },
            args: __assign(__assign({}, getOperatorArgs(['number', 'string'], ['number', 'string'])), { x: {
                    type: ['number', 'string'],
                }, ys: {
                    type: ['number', 'string'],
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['x'] },
                { argumentNames: ['x', 'ys'] },
            ],
            description: 'Returns `true` if $x and $ys are in decreasing order, `false` otherwise.',
            examples: [
                '>(1, 0)',
                '>(1.01, 1)',
                '>(1, 1)',
                '>(4, 3, 2, 1)',
                '>(3, 2, 2, 1)',
            ],
        },
        '≤': {
            title: '≤',
            category: 'Misc',
            returns: {
                type: 'boolean',
            },
            args: __assign(__assign({}, getOperatorArgs(['number', 'string'], ['number', 'string'])), { x: {
                    type: ['number', 'string'],
                }, ys: {
                    type: ['number', 'string'],
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['x'] },
                { argumentNames: ['x', 'ys'] },
            ],
            description: 'Returns `true` if $x and $ys are in non decreasing order, `false` otherwise.',
            examples: [
                '1 ≤ 1',
                '<=(0, 1)',
                '≤(1, 1.01)',
                '<=(1, 1)',
                '≤(1, 2, 3, 4)',
                '<=(1, 2, 2, 3)',
            ],
            aliases: ['<='],
        },
        '≥': {
            title: '≥',
            category: 'Misc',
            returns: {
                type: 'boolean',
            },
            args: __assign(__assign({}, getOperatorArgs(['number', 'string'], ['number', 'string'])), { x: {
                    type: ['number', 'string'],
                }, ys: {
                    type: ['number', 'string'],
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['x'] },
                { argumentNames: ['x', 'ys'] },
            ],
            description: 'Returns `true` if $x and $ys are in non increasing order, `false` otherwise.',
            examples: [
                '1 ≥ 1',
                '0 ≥ 1',
                '>=(1, 0)',
                '≥(1.01, 1)',
                '>=(1, 1)',
                '≥(4, 3, 2, 1)',
                '>=(3, 2, 2, 1)',
            ],
            aliases: ['>='],
        },
        '!': {
            title: '!',
            category: 'Misc',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Computes logical negation. Note that any other $x than `false`, `0`, `null` and `\'\'` is truthy.',
            examples: [
                '!(3)',
                '!(true)',
                '!("A string")',
                '!(0)',
                '!(false)',
                '!(null)',
                '!("")',
            ],
        },
        'write!': {
            title: 'write!',
            category: 'Misc',
            returns: {
                type: 'any',
            },
            args: {
                values: {
                    type: 'any',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['values'] },
            ],
            description: 'It logs the $values and then returns the last argument. If called with no arguments `null` is returned.',
            examples: [
                'write!("A string")',
                'write!(100, "items")',
                'write!(object("a", 10))',
                'write!(["a", "b", "c"])',
                'write!(#"^start")',
                'write!(null, true, false)',
            ],
            noOperatorDocumentation: true,
        },
        'iso-date->epoch': {
            title: 'iso-date->epoch',
            category: 'Misc',
            returns: {
                type: 'number',
            },
            args: {
                iso: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['iso'] },
            ],
            description: 'Returns milliseconds elapsed since the UNIX epoch to `iso`.',
            examples: [
                'iso-date->epoch("2022-04-12T09:37:10.899Z")',
                'iso-date->epoch("1980-01-01")',
            ],
        },
        'epoch->iso-date': {
            title: 'epoch->iso-date',
            category: 'Misc',
            returns: {
                type: 'string',
            },
            args: {
                ms: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['ms'] },
            ],
            description: 'Returns IOS date time string from `ms` (milliseconds elapsed since the UNIX epoch).',
            examples: [
                'epoch->iso-date(1649756230899)',
                'epoch->iso-date(0)',
            ],
        },
        'boolean': {
            title: 'boolean',
            category: 'Misc',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Coerces $x to boolean.',
            examples: [
                'boolean(0)',
                'boolean(1)',
                'boolean(null)',
                'boolean("Albert")',
            ],
        },
        'compare': {
            title: 'compare',
            category: 'Misc',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs(['number', 'string'], ['number', 'string'])),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Compares two values. Returns `-1` if $a < $b, `1` if $a > $b and `0` if $a and $b have the same sort order.',
            examples: [
                'compare(0, 1)',
                'compare(0, 0)',
                'compare(1, 0)',
                'compare("Albert", "Mojir")',
            ],
        },
        'identical?': {
            title: 'identical?',
            category: 'Misc',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('any', 'any')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns true if $a and $b are referential equal.',
            examples: [
                'identical?({ a: 10, b: 20 }, { b: 20, a: 10 })',
                'identical?([1, true, null], [1, true, null])',
                'identical?(0.3, 0.1 + 0.2)',
            ],
        },
        'json-parse': {
            title: 'json-parse',
            category: 'Misc',
            returns: {
                type: 'any',
            },
            args: {
                x: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `JSON.parse(`$x`)`.',
            examples: [
                'json-parse("[1, 2, 3]")',
            ],
        },
        'json-stringify': {
            title: 'json-stringify',
            category: 'Misc',
            returns: {
                type: 'string',
            },
            args: {
                x: {
                    type: 'any',
                },
                indent: {
                    type: 'integer',
                    description: 'Number of spaces to use for indentation.',
                },
            },
            variants: [
                { argumentNames: ['x'] },
                { argumentNames: ['x', 'indent'] },
            ],
            description: 'Returns `JSON.stringify(`$x`)`. If second argument is provided, returns `JSON.stringify(`$x`, null, `$indent`)`.',
            examples: [
                'json-stringify([1, 2, 3])',
                'json-stringify({ a: { b: 10 }}, 2)',
            ],
            noOperatorDocumentation: true,
        },
    };

    var objectReference = {
        'dissoc': {
            title: 'dissoc',
            category: 'Object',
            returns: {
                type: 'object',
            },
            args: __assign(__assign({}, getOperatorArgs('object', 'string')), { obj: {
                    type: 'object',
                }, key: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['obj', 'key'] },
            ],
            description: 'Return shallow copy of $obj with $key deleted.',
            examples: [
                '{ x: 10, y: 20 } dissoc "y"',
                'dissoc({ x: 10, y: 20 }, "x")',
                'dissoc({ x: 10 }, "y")',
                "\nlet o = { a: 5 };\ndissoc(o, \"a\");\no",
            ],
        },
        'keys': {
            title: 'keys',
            category: 'Object',
            returns: {
                type: 'any',
                array: true,
            },
            args: {
                obj: {
                    type: 'object',
                },
            },
            variants: [
                { argumentNames: ['obj'] },
            ],
            description: 'Returns array of all keys in $obj.',
            examples: [
                'keys({})',
                'keys({ x: 10, y: true, z: "A string" })',
                'keys(object("x", 10, "y", true, "z", "A string"))',
            ],
        },
        'vals': {
            title: 'vals',
            category: 'Object',
            returns: {
                type: 'any',
                array: true,
            },
            args: {
                obj: {
                    type: 'object',
                },
            },
            variants: [
                { argumentNames: ['obj'] },
            ],
            description: 'Returns array of all values in $obj.',
            examples: [
                'vals({})',
                'vals({ x: 10, y: true, z: "A string" })',
                'vals(object("x", 10, "y", true, "z", "A string"))',
            ],
        },
        'entries': {
            title: 'entries',
            category: 'Object',
            returns: {
                type: 'array',
            },
            args: {
                obj: {
                    type: 'object',
                },
            },
            variants: [
                { argumentNames: ['obj'] },
            ],
            description: 'Returns nested array of all key - value pairs in $obj.',
            examples: [
                'entries({})',
                'entries({ x: 10, y: true, z: "A string" })',
                'entries(object("x", 10, "y", true, "z", "A string"))',
            ],
        },
        'find': {
            title: 'find',
            category: 'Object',
            returns: {
                type: ['array', 'null'],
            },
            args: __assign(__assign({}, getOperatorArgs('object', 'string')), { obj: {
                    type: 'object',
                }, key: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['obj', 'key'] },
            ],
            description: 'Returns entry (key-value pair) for $key, or `null` if $key not present in $obj.',
            examples: [
                '{ a: 1, "b": 2 } find "a"',
                'find(object("a", 1, "b", 2), "b")',
                'find(object("a", 1, "b", 2), "c")',
            ],
        },
        'merge': {
            title: 'merge',
            category: 'Object',
            returns: {
                type: 'object',
            },
            args: __assign(__assign({}, getOperatorArgs('object', 'object')), { objs: {
                    type: 'object',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['objs'] },
            ],
            description: "Returns a new object created by merging together all arguments.\n\nIf two keys appears in more than one object the value from the last object is used.  \nIf no arguments are provided `null` is returned.",
            examples: [
                '{ x: 10 } merge { y: 20 }',
                'merge(object("x", 10), object("y", 20))',
                'merge(object("x", 10), object("x", 15, "y", 20))',
            ],
        },
        'merge-with': {
            title: 'merge-with',
            category: 'Object',
            returns: {
                type: 'object',
            },
            args: {
                objs: {
                    type: 'object',
                    rest: true,
                },
                fun: {
                    type: 'function',
                },
            },
            variants: [
                { argumentNames: ['objs', 'fun'] },
            ],
            description: "\nReturns a new object created by merging together all arguments.\nIf two keys appears in more than one object $fun is used to calculate the new value.\n\nIf no arguments are provided `null` is returned.",
            examples: [
                'merge-with(object("x", 10), object("y", 20), +)',
                'merge-with(object("x", 10), object("x", 15, "y", 20), +)',
                'merge-with({ x: 10 }, { x: 20 }, { x: 30 }, { x: 40 }, -)',
            ],
            noOperatorDocumentation: true,
        },
        'zipmap': {
            title: 'zipmap',
            category: 'Object',
            returns: {
                type: 'object',
            },
            args: __assign({}, getOperatorArgs('array', 'array')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns a new object created by mapping $a to $b.',
            examples: [
                '["a", "b", "c"] zipmap [1, 2, 3]',
                'zipmap(["a", "b", "c"], [10, null, [1, 2, 3]])',
                'zipmap(["a", "b", "c"], [1])',
                'zipmap([], [10, null, [1, 2, 3]])',
            ],
        },
        'select-keys': {
            title: 'select-keys',
            category: 'Object',
            returns: {
                type: 'object',
            },
            args: __assign({}, getOperatorArgs('object', 'array')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns an object containing only those entries in $a whose key is in $b.',
            examples: [
                '{ a: 1, b: 2, c: 3 } select-keys ["a", "b"]',
                'select-keys({ a: 1, b: 2, c: 3 }, ["a", "b"])',
                'select-keys({ a: 1 }, ["a", "b"])',
            ],
        },
    };

    var matrixReference = {
        'mat:mul': {
            title: 'mat:mul',
            category: 'Matrix',
            returns: {
                type: 'matrix',
            },
            args: __assign({}, getOperatorArgs('matrix', 'matrix')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Multiplies two `matrices` using standard `matrix` multiplication based on **dot products** of rows and columns.',
            examples: [
                'mat:mul([[1, 2], [3, 4]], [[5, 6], [7, 8]])',
                'mat:mul([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]])',
            ],
        },
        'mat:det': {
            title: 'mat:det',
            category: 'Matrix',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the determinant of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **determinant** of a square matrix.',
            examples: [
                'mat:det([[1, 2], [3, 4]])',
                'mat:det([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
        'mat:inv': {
            title: 'mat:inv',
            category: 'Matrix',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the inverse of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **inverse** of a square matrix.',
            examples: [
                'mat:inv([[1, 2], [3, 4]])',
                'mat:inv([[1, 2, 3], [4, 5, 7], [7, 8, 10]])',
            ],
        },
        'mat:adj': {
            title: 'mat:adj',
            category: 'Matrix',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the adjugate of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **adjugate** of a square matrix.',
            examples: [
                'mat:adj([[1, 2], [3, 4]])',
                'mat:adj([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'mat:adj([[1, 2, 3], [7, 8, 9], [4, 5, 6]])',
            ],
        },
        'mat:cofactor': {
            title: 'mat:cofactor',
            category: 'Matrix',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the cofactor of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **cofactor** of a square matrix.',
            examples: [
                'mat:cofactor([[1, 2], [3, 4]])',
                'mat:cofactor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'mat:cofactor([[1, 2, 3], [7, 8, 9], [4, 5, 6]])',
            ],
        },
        'mat:minor': {
            title: 'mat:minor',
            category: 'Matrix',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the minor of.',
                },
                row: {
                    type: 'integer',
                    description: 'The row index of the element to calculate the minor for.',
                },
                col: {
                    type: 'integer',
                    description: 'The column index of the element to calculate the minor for.',
                },
            },
            variants: [
                { argumentNames: ['m', 'row', 'col'] },
            ],
            description: 'Calculates the **minor** of a square matrix.',
            examples: [
                'mat:minor([[1, 2], [3, 4]], 0, 1)',
                'mat:minor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1, 1)',
            ],
        },
        'mat:trace': {
            title: 'mat:trace',
            category: 'Matrix',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the trace of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **trace** of a square matrix.',
            examples: [
                'mat:trace([[1, 2], [3, 4]])',
                'mat:trace([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
        'mat:symmetric?': {
            title: 'mat:symmetric?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for symmetry.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Checks if a `matrix` is **symmetric**.',
            examples: [
                'mat:symmetric?([[1, 2], [2, 1]])',
                'mat:symmetric?([[1, 2, 3], [2, 1, 4], [3, 4, 1]])',
            ],
        },
        'mat:triangular?': {
            title: 'mat:triangular?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for triangularity.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Checks if a `matrix` is **triangular**.',
            examples: [
                'mat:triangular?([[2, 0], [0, 1]])',
                'mat:triangular?([[1, 2, 3], [0, 4, 5], [0, 0, 6]])',
            ],
        },
        'mat:upper-triangular?': {
            title: 'mat:upper-triangular?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for upper triangularity.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Checks if a `matrix` is **upper triangular**.',
            examples: [
                'mat:upper-triangular?([[1, 2], [0, 3]])',
                'mat:upper-triangular?([[1, 2, 3], [0, 4, 5], [0, 0, 6]])',
            ],
        },
        'mat:lower-triangular?': {
            title: 'mat:lower-triangular?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for lower triangularity.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Checks if a `matrix` is **lower triangular**.',
            examples: [
                'mat:lower-triangular?([[1, 0], [2, 3]])',
                'mat:lower-triangular?([[1, 0, 0], [2, 3, 0], [4, 5, 6]])',
            ],
        },
        'mat:diagonal?': {
            title: 'mat:diagonal?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for diagonal property.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Checks if a `matrix` is **diagonal**.',
            examples: [
                'mat:diagonal?([[1, 0], [0, 2]])',
                'mat:diagonal?([[1, 0, 0], [0, 2, 0], [0, 0, 3]])',
                'mat:diagonal?([[1, 0, 0], [2, 2, 2], [0, 0, 3]])',
            ],
        },
        'mat:square?': {
            title: 'mat:square?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for square property.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Checks if a `matrix` is **square**.',
            examples: [
                'mat:square?([[1, 2], [3, 4]])',
                'mat:square?([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'mat:square?([[1, 2, 3], [4, 5, 6]])',
            ],
        },
        'mat:orthogonal?': {
            title: 'mat:orthogonal?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for **orthogonality**.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Checks if a `matrix` is **orthogonal**.',
            examples: [
                'mat:orthogonal?([[1, 0], [0, 1]])',
                'mat:orthogonal?([[1, 0], [0, -1]])',
                'mat:orthogonal?([[1, 2], [3, 4]])',
            ],
        },
        'mat:identity?': {
            title: 'mat:identity?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for identity property.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Checks if a `matrix` is an **identity matrix**.',
            examples: [
                'mat:identity?([[1, 0], [0, 1]])',
                'mat:identity?([[1, 0, 0], [0, 1, 0], [0, 0, 1]])',
                'mat:identity?([[1, 0, 0], [0, 1, 0], [0, 0, 0]])',
            ],
        },
        'mat:invertible?': {
            title: 'mat:invertible?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for invertibility.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Checks if a `matrix` is **invertible**.',
            examples: [
                'mat:invertible?([[1, 2], [3, 4]])',
                'mat:invertible?([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'mat:invertible?([[1, 2], [2, 4]])',
            ],
        },
        'mat:hilbert': {
            title: 'mat:hilbert',
            category: 'Matrix',
            returns: {
                type: 'matrix',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The size of the Hilbert matrix.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            description: 'Generates a **Hilbert matrix** of size `n`.',
            examples: [
                'mat:hilbert(3)',
                'mat:hilbert(4)',
            ],
        },
        'mat:vandermonde': {
            title: 'mat:vandermonde',
            category: 'Matrix',
            returns: {
                type: 'matrix',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'The vector to generate the Vandermonde matrix from.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            description: 'Generates a **Vandermonde matrix** from a vector.',
            examples: [
                'mat:vandermonde([1, 2, 3])',
                'mat:vandermonde([1, 0, 1])',
            ],
        },
        'mat:band': {
            title: 'mat:band',
            category: 'Matrix',
            returns: {
                type: 'matrix',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The size of the banded matrix.',
                },
                lband: {
                    type: 'integer',
                    description: 'The lower band index.',
                },
                uband: {
                    type: 'integer',
                    description: 'The upper band index.',
                },
            },
            variants: [
                { argumentNames: ['n', 'lband', 'uband'] },
            ],
            description: 'Generates a **banded matrix** of size `n` with lower band index `lband` and upper band index `uband`.',
            examples: [
                'mat:band(3, 1, 1)',
                'mat:band(4, 1, 2)',
            ],
        },
        'mat:banded?': {
            title: 'mat:banded?',
            category: 'Matrix',
            returns: {
                type: 'boolean',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to check for **banded** property.',
                },
                lband: {
                    type: 'integer',
                    description: 'The lower band index.',
                },
                uband: {
                    type: 'integer',
                    description: 'The upper band index.',
                },
            },
            variants: [
                { argumentNames: ['m', 'lband', 'uband'] },
            ],
            description: 'Checks if a `matrix` is **banded** with lower band index `lband` and upper band index `uband`.',
            examples: [
                "mat:banded?([\n  [1, 1, 1, 0],\n  [1, 1, 1, 1],\n  [1, 1, 1, 1],\n  [0, 1, 1, 1],\n], 2, 2)",
                "mat:banded?([\n  [1, 1, 1, 0],\n  [1, 1, 1, 1],\n  [1, 1, 1, 1],\n  [0, 1, 1, 1],\n], 1, 1)",
            ],
        },
        'mat:rank': {
            title: 'mat:rank',
            category: 'Matrix',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the rank of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **rank** of a matrix using **Gaussian elimination**.',
            examples: [
                'mat:rank([[1, 0, 0], [0, 1, 0], [0, 0, 1]])',
                'mat:rank([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'mat:rank([[2, 4, 6], [3, 6, 9], [4, 8, 12]])',
            ],
        },
        'mat:frobenius-norm': {
            title: 'mat:frobenius-norm',
            category: 'Matrix',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the Frobenius norm of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **Frobenius norm** of a matrix.',
            examples: [
                'mat:frobenius-norm([[1, 2], [3, 4]])',
                'mat:frobenius-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
        'mat:1-norm': {
            title: 'mat:1-norm',
            category: 'Matrix',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the 1-norm of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **1-norm** of a matrix.',
            examples: [
                'mat:1-norm([[1, 2], [3, 4]])',
                'mat:1-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
        'mat:inf-norm': {
            title: 'mat:inf-norm',
            category: 'Matrix',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the infinity norm of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **infinity norm** of a matrix.',
            examples: [
                'mat:inf-norm([[1, 2], [3, 4]])',
                'mat:inf-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
            aliases: ['mat:row-norm'],
        },
        'mat:max-norm': {
            title: 'mat:max-norm',
            category: 'Matrix',
            returns: {
                type: 'number',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'The `matrix` to calculate the max norm of.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            description: 'Calculates the **max norm** of a matrix.',
            examples: [
                'mat:max-norm([[1, 2], [3, 4]])',
                'mat:max-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
            ],
        },
    };

    var exampleGrid1 = "[\n  [\"Albert\", \"father\", 10],\n  [\"Nina\", \"mother\", 20],\n  [\"Kian\", \"son\", 30],\n]";
    var exampleGrid2 = "[\n  [\"Albert\", \"father\"],\n  [\"Nina\", \"mother\"],\n  [\"Kian\", \"son\"],\n]";
    var exampleGrid3 = "[\n  [1, 2],\n  [3, 4],\n]";
    var gridReference = {
        'grid:every?': {
            title: 'grid:every?',
            category: 'Grid',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('grid', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Checks if all elements in a grid satisfy a predicate. Returns true only if the predicate returns true for every element in the grid.',
            examples: [
                "grid:every?(".concat(exampleGrid1, ", string?)"),
                "grid:every?(".concat(exampleGrid2, ", string?)"),
                "grid:every?(".concat(exampleGrid3, ", string?)"),
            ],
        },
        'grid:some?': {
            title: 'grid:some?',
            category: 'Grid',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('grid', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Checks if any element in a grid satisfies a predicate. Returns true if the predicate returns true for at least one element in the grid.',
            examples: [
                "grid:some?(".concat(exampleGrid1, ", string?)"),
                "grid:some?(".concat(exampleGrid2, ", string?)"),
                "grid:some?(".concat(exampleGrid3, ", string?)"),
            ],
        },
        'grid:every-row?': {
            title: 'grid:every-row?',
            category: 'Grid',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('grid', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Checks if all rows in a grid satisfy a predicate. Returns true only if the predicate returns true for every row in the grid.',
            examples: [
                "grid:every-row?(".concat(exampleGrid1, ", -> string?($[0]))"),
                "grid:every-row?(".concat(exampleGrid2, ", -> string?($[0]))"),
                "grid:every-row?(".concat(exampleGrid3, ", -> string?($[0]))"),
            ],
        },
        'grid:some-row?': {
            title: 'grid:some-row?',
            category: 'Grid',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('grid', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Checks if any row in a grid satisfies a predicate. Returns true if the predicate returns true for at least one row in the grid.',
            examples: [
                "grid:some-row?(".concat(exampleGrid1, ", -> $ contains? \"Albert\")"),
                "grid:some-row?(".concat(exampleGrid2, ", -> $ contains? \"Albert\")"),
                "grid:some-row?(".concat(exampleGrid3, ", -> $ contains? \"Albert\")"),
            ],
        },
        'grid:every-col?': {
            title: 'grid:every-col?',
            category: 'Grid',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('grid', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Checks if all columns in a grid satisfy a predicate. Returns true only if the predicate returns true for every column in the grid.',
            examples: [
                "grid:every-col?(".concat(exampleGrid1, ", -> string?($[0]))"),
                "grid:every-col?(".concat(exampleGrid2, ", -> string?($[0]))"),
                "grid:every-col?(".concat(exampleGrid3, ", -> string?($[0]))"),
            ],
        },
        'grid:some-col?': {
            title: 'grid:some-col?',
            category: 'Grid',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('grid', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Checks if any column in a grid satisfies a predicate. Returns true if the predicate returns true for at least one column in the grid.',
            examples: [
                "grid:some-col?(".concat(exampleGrid1, ", -> $ contains? \"Albert\")"),
                "grid:some-col?(".concat(exampleGrid2, ", -> $ contains? \"Albert\")"),
                "grid:some-col?(".concat(exampleGrid3, ", -> $ contains? \"Albert\")"),
            ],
        },
        'grid:row': {
            title: 'grid:row',
            category: 'Grid',
            returns: {
                type: 'any',
            },
            args: __assign({}, getOperatorArgs('grid', 'number')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns the row at index $a in the grid $b.',
            examples: [
                "grid:row(".concat(exampleGrid1, ", 0)"),
                "grid:row(".concat(exampleGrid1, ", 1)"),
                "grid:row(".concat(exampleGrid1, ", 2)"),
            ],
        },
        'grid:col': {
            title: 'grid:col',
            category: 'Grid',
            returns: {
                type: 'any',
            },
            args: __assign({}, getOperatorArgs('grid', 'number')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns the column at index $a in the grid $b.',
            examples: [
                "grid:col(".concat(exampleGrid1, ", 0)"),
                "grid:col(".concat(exampleGrid1, ", 1)"),
                "grid:col(".concat(exampleGrid1, ", 2)"),
            ],
        },
        'grid:shape': {
            title: 'grid:shape',
            category: 'Grid',
            returns: {
                type: 'vector',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to get the shape of.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Returns the shape of the grid `g` as a `vector` of two numbers, where the first number is the number of rows and the second number is the number of columns.',
            examples: [
                "grid:shape(".concat(exampleGrid1, ")"),
                "grid:shape(".concat(exampleGrid2, ")"),
                "grid:shape(".concat(exampleGrid3, ")"),
            ],
        },
        'grid:fill': {
            title: 'grid:fill',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                rows: {
                    type: 'integer',
                    description: 'The number of rows in the grid.',
                },
                cols: {
                    type: 'integer',
                    description: 'The number of columns in the grid.',
                },
                value: {
                    type: 'any',
                    description: 'The value to fill the grid with.',
                },
            },
            variants: [
                { argumentNames: ['rows', 'cols', 'value'] },
            ],
            description: 'Creates a grid of the specified size, filled with the specified value.',
            examples: [
                'grid:fill(2, 3, 0)',
                'grid:fill(2, 3, "x")',
            ],
        },
        'grid:generate': {
            title: 'grid:generate',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                rows: {
                    type: 'number',
                    description: 'The number of rows in the grid.',
                },
                cols: {
                    type: 'number',
                    description: 'The number of columns in the grid.',
                },
                fn: {
                    type: 'function',
                    description: 'The function to generate the grid. It takes two arguments: the row index and the column index.',
                },
            },
            variants: [
                { argumentNames: ['rows', 'cols', 'fn'] },
            ],
            description: 'Generates a grid of the specified size, where each element is generated by the provided function.',
            examples: [
                'grid:generate(3, 3, (i, j) -> i + j)',
            ],
        },
        'grid:reshape': {
            title: 'grid:reshape',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: __assign({}, getOperatorArgs('grid', 'number')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Reshapes the grid `a` into a new grid with the specified number of rows `b`. The number of columns is automatically calculated based on the total number of elements in the grid.',
            examples: [
                "grid:reshape(".concat(exampleGrid2, ", 2)"),
            ],
        },
        'grid:transpose': {
            title: 'grid:transpose',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to transpose.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Transposes the grid `g`, swapping its rows and columns.',
            examples: [
                "grid:transpose(".concat(exampleGrid1, ")"),
                "grid:transpose(".concat(exampleGrid2, ")"),
                "grid:transpose(".concat(exampleGrid3, ")"),
            ],
            aliases: ['grid:tr'],
        },
        'grid:flip-h': {
            title: 'grid:flip-h',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to flip horizontally.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Flips the grid `g` horizontally.',
            examples: [
                "grid:flip-h(".concat(exampleGrid1, ")"),
                "grid:flip-h(".concat(exampleGrid2, ")"),
                "grid:flip-h(".concat(exampleGrid3, ")"),
            ],
        },
        'grid:flip-v': {
            title: 'grid:flip-v',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to flip vertically.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Flips the grid `g` vertically.',
            examples: [
                "grid:flip-v(".concat(exampleGrid1, ")"),
                "grid:flip-v(".concat(exampleGrid2, ")"),
                "grid:flip-v(".concat(exampleGrid3, ")"),
            ],
        },
        'grid:rotate': {
            title: 'grid:rotate',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: __assign({}, getOperatorArgs('grid', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Rotates the grid `g` by the specified angle. The angle is given in terms of 90-degree rotations. Positive values rotate the grid clockwise, while negative values rotate it counterclockwise.',
            examples: [
                "grid:rotate(".concat(exampleGrid3, ", 1)"),
                "grid:rotate(".concat(exampleGrid3, ", 2)"),
                "grid:rotate(".concat(exampleGrid3, ", 3)"),
                "grid:rotate(".concat(exampleGrid3, ", 4)"),
                "grid:rotate(".concat(exampleGrid3, ", -1)"),
                "grid:rotate(".concat(exampleGrid3, ", -2)"),
                "grid:rotate(".concat(exampleGrid3, ", -3)"),
            ],
        },
        'grid:reverse-rows': {
            title: 'grid:reverse-rows',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to reverse rows.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Reverses the order of rows in the grid `g`.',
            examples: [
                "grid:reverse-rows(".concat(exampleGrid1, ")"),
                "grid:reverse-rows(".concat(exampleGrid2, ")"),
                "grid:reverse-rows(".concat(exampleGrid3, ")"),
            ],
        },
        'grid:reverse-cols': {
            title: 'grid:reverse-cols',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to reverse columns.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Reverses the order of columns in the grid `g`.',
            examples: [
                "grid:reverse-cols(".concat(exampleGrid1, ")"),
                "grid:reverse-cols(".concat(exampleGrid2, ")"),
                "grid:reverse-cols(".concat(exampleGrid3, ")"),
            ],
        },
        'grid:slice': {
            title: 'grid:slice',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to slice.',
                },
                begin: {
                    type: 'vector',
                    description: 'The starting index of the slice as a vector of two numbers: `[row, col]`.',
                },
                stop: {
                    type: 'vector',
                    description: 'Optional ending index of the slice as a vector of two numbers: `[row, col]`.',
                },
            },
            variants: [
                { argumentNames: ['g', 'begin'] },
                { argumentNames: ['g', 'begin', 'stop'] },
            ],
            description: 'Slices the grid `g` from the starting index `begin` to the optional ending index `stop`. The slice is inclusive of the starting index and exclusive of the ending index.',
            examples: [
                "grid:slice(".concat(exampleGrid1, ", [1, 1], [2, 2])"),
                "grid:slice(".concat(exampleGrid1, ", [1, 1])"),
            ],
            noOperatorDocumentation: true,
        },
        'grid:slice-rows': {
            title: 'grid:slice-rows',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to slice.',
                },
                begin: {
                    type: 'number',
                    description: 'The starting index of the slice.',
                },
                stop: {
                    type: 'number',
                    description: 'Optional ending index of the slice.',
                },
            },
            variants: [
                { argumentNames: ['g', 'begin'] },
                { argumentNames: ['g', 'begin', 'stop'] },
            ],
            description: 'Slices rows of the grid `g` from the starting index `begin` to the optional ending index `stop`. The slice is inclusive of the starting index and exclusive of the ending index.',
            examples: [
                "grid:slice-rows(".concat(exampleGrid1, ", 1, 2)"),
                "grid:slice-rows(".concat(exampleGrid1, ", 1)"),
            ],
            noOperatorDocumentation: true,
        },
        'grid:slice-cols': {
            title: 'grid:slice-cols',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to slice.',
                },
                begin: {
                    type: 'number',
                    description: 'The starting index of the slice.',
                },
                stop: {
                    type: 'number',
                    description: 'Optional ending index of the slice.',
                },
            },
            variants: [
                { argumentNames: ['g', 'begin'] },
                { argumentNames: ['g', 'begin', 'stop'] },
            ],
            description: 'Slices columns of the grid `g` from the starting index `begin` to the optional ending index `stop`. The slice is inclusive of the starting index and exclusive of the ending index.',
            examples: [
                "grid:slice-cols(".concat(exampleGrid1, ", 1, 2)"),
                "grid:slice-cols(".concat(exampleGrid1, ", 1)"),
            ],
            noOperatorDocumentation: true,
        },
        'grid:splice-rows': {
            title: 'grid:splice-rows',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to splice.',
                },
                begin: {
                    type: 'number',
                    description: 'The starting index of the splice.',
                },
                deleteCount: {
                    type: 'number',
                    description: 'The number of rows to delete.',
                },
                items: {
                    type: 'array',
                    rest: true,
                    description: 'The rows to insert.',
                },
            },
            variants: [
                { argumentNames: ['g', 'begin', 'deleteCount'] },
                { argumentNames: ['g', 'begin', 'deleteCount', 'items'] },
            ],
            description: 'Splices rows of the grid `g` starting from the index `begin`. Deletes `deleteCount` rows and inserts the specified `items` at that position.',
            examples: [
                "grid:splice-rows(".concat(exampleGrid1, ", 1, 2)"),
                "grid:splice-rows(".concat(exampleGrid1, ", 1, 1, [\"Nazanin\", \"mother\", 40])"),
            ],
            noOperatorDocumentation: true,
        },
        'grid:splice-cols': {
            title: 'grid:splice-cols',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to splice.',
                },
                begin: {
                    type: 'number',
                    description: 'The starting index of the splice.',
                },
                deleteCount: {
                    type: 'number',
                    description: 'The number of columns to delete.',
                },
                items: {
                    type: 'array',
                    rest: true,
                    description: 'The columns to insert.',
                },
            },
            variants: [
                { argumentNames: ['g', 'begin', 'deleteCount'] },
                { argumentNames: ['g', 'begin', 'deleteCount', 'items'] },
            ],
            description: 'Splices columns of the grid `g` starting from the index `begin`. Deletes `deleteCount` columns and inserts the specified `items` at that position.',
            examples: [
                "grid:splice-cols(".concat(exampleGrid1, ", 1, 2)"),
                "grid:splice-cols(".concat(exampleGrid1, ", 1, 1, [\"f\", \"m\", \"s\"])"),
            ],
            noOperatorDocumentation: true,
        },
        'grid:concat-rows': {
            title: 'grid:concat-rows',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: __assign({}, getOperatorArgs('grid', 'grid')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Concatenates two grids `a` and `b` by rows. The number of columns in both grids must be the same.',
            examples: [
                "grid:concat-rows(".concat(exampleGrid2, ", ").concat(exampleGrid3, ")"),
            ],
        },
        'grid:concat-cols': {
            title: 'grid:concat-cols',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: __assign({}, getOperatorArgs('grid', 'grid')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Concatenates two grids `a` and `b` by columns. The number of rows in both grids must be the same.',
            examples: [
                "grid:concat-cols(".concat(exampleGrid1, ", ").concat(exampleGrid2, ")"),
            ],
        },
        'grid:map': {
            title: 'grid:map',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: __assign({}, getOperatorArgs('grid', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Maps a function `a` over each element of the grid `b`, returning a new grid with the results.',
            examples: [
                "grid:map(".concat(exampleGrid1, ", str)"),
            ],
        },
        'grid:mapi': {
            title: 'grid:mapi',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: __assign({}, getOperatorArgs('grid', 'function')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Maps a function `a` over each element of the grid `b`, passing the row and column index as additional arguments to the function.',
            examples: [
                "grid:mapi(".concat(exampleGrid1, ", -> $1 ++ \"(\" ++ $2 ++ \", \" ++ $3 ++ \")\")"),
            ],
        },
        'grid:reduce': {
            title: 'grid:reduce',
            category: 'Grid',
            returns: {
                type: 'any',
            },
            args: {
                'g': {
                    type: 'grid',
                    description: 'The grid to reduce.',
                },
                'fn': {
                    type: 'function',
                    description: 'The function to reduce the grid. It takes two arguments: the accumulator and the current element.',
                },
                'initial-value': {
                    type: 'any',
                    description: 'The initial value for the accumulator.',
                },
            },
            variants: [
                { argumentNames: ['g', 'fn', 'initial-value'] },
            ],
            description: 'Reduces the grid `a` using the function `b`, returning a single value.',
            examples: [
                "grid:reduce(".concat(exampleGrid1, ", ++, \"\")"),
            ],
        },
        'grid:reducei': {
            title: 'grid:reducei',
            category: 'Grid',
            returns: {
                type: 'any',
            },
            args: {
                'g': {
                    type: 'grid',
                    description: 'The grid to reduce.',
                },
                'fn': {
                    type: 'function',
                    description: 'The function to reduce the grid. It takes four arguments: the accumulator, the current element, the row index, and the column index.',
                },
                'initial-value': {
                    type: 'any',
                    description: 'The initial value for the accumulator.',
                },
            },
            variants: [
                { argumentNames: ['g', 'fn', 'initial-value'] },
            ],
            description: 'Reduces the grid `a` using the function `b`, passing the row and column indices as additional arguments to the function.',
            examples: [
                "grid:reducei(".concat(exampleGrid1, ", ++, \"\")"),
            ],
        },
        'grid:push-rows': {
            title: 'grid:push-rows',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to push rows into.',
                },
                rows: {
                    type: 'array',
                    rest: true,
                    description: 'The rows to push into the grid.',
                },
            },
            variants: [
                { argumentNames: ['g', 'rows'] },
            ],
            description: 'Pushes the specified rows into the grid `g` and returns the new grid.',
            examples: [
                "grid:push-rows(".concat(exampleGrid1, ", [\"Nazanin\", \"mother\", 40])"),
            ],
            noOperatorDocumentation: true,
        },
        'grid:unshift-rows': {
            title: 'grid:unshift-rows',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to unshift rows into.',
                },
                rows: {
                    type: 'array',
                    rest: true,
                    description: 'The rows to unshift into the grid.',
                },
            },
            variants: [
                { argumentNames: ['g', 'rows'] },
            ],
            description: 'Unshifts the specified rows into the grid `g` and returns the new grid.',
            examples: [
                "grid:unshift-rows(".concat(exampleGrid1, ", [\"Nazanin\", \"mother\", 40])"),
            ],
            noOperatorDocumentation: true,
        },
        'grid:pop-row': {
            title: 'grid:pop-row',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to pop a row from.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Pops the last row from the grid `g` and returns the new grid.',
            examples: [
                "grid:pop-row(".concat(exampleGrid1, ")"),
            ],
        },
        'grid:shift-row': {
            title: 'grid:shift-row',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to shift a row from.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Shifts the first row from the grid `g` and returns the new grid.',
            examples: [
                "grid:shift-row(".concat(exampleGrid1, ")"),
            ],
        },
        'grid:push-cols': {
            title: 'grid:push-cols',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to push columns into.',
                },
                cols: {
                    type: 'array',
                    rest: true,
                    description: 'The columns to push into the grid.',
                },
            },
            variants: [
                { argumentNames: ['g', 'cols'] },
            ],
            description: 'Pushes the specified columns into the grid `g` and returns the new grid.',
            examples: [
                "grid:push-cols(".concat(exampleGrid1, ", [\"f\", \"m\", \"s\"])"),
            ],
            noOperatorDocumentation: true,
        },
        'grid:unshift-cols': {
            title: 'grid:unshift-cols',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to unshift columns into.',
                },
                cols: {
                    type: 'array',
                    rest: true,
                    description: 'The columns to unshift into the grid.',
                },
            },
            variants: [
                { argumentNames: ['g', 'cols'] },
            ],
            description: 'Unshifts the specified columns into the grid `g` and returns the new grid.',
            examples: [
                "grid:unshift-cols(".concat(exampleGrid1, ", [\"f\", \"m\", \"s\"])"),
            ],
            noOperatorDocumentation: true,
        },
        'grid:pop-col': {
            title: 'grid:pop-col',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to pop a column from.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Pops the last column from the grid `g` and returns the new grid.',
            examples: [
                "grid:pop-col(".concat(exampleGrid1, ")"),
            ],
        },
        'grid:shift-col': {
            title: 'grid:shift-col',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: {
                g: {
                    type: 'grid',
                    description: 'The grid to shift a column from.',
                },
            },
            variants: [
                { argumentNames: ['g'] },
            ],
            description: 'Shifts the first column from the grid `g` and returns the new grid.',
            examples: [
                "grid:shift-col(".concat(exampleGrid1, ")"),
            ],
        },
        'grid:from-array': {
            title: 'grid:from-array',
            category: 'Grid',
            returns: {
                type: 'grid',
            },
            args: __assign({}, getOperatorArgs('array', 'number')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Creates a grid from a flat array with specified dimensions. The array is reshaped into the specified number of rows, and the number of columns is automatically calculated based on the total number of elements in the array.',
            examples: [
                'grid:from-array([1, 2, 3, 4], 2)',
                'grid:from-array([1, 2, 3, 4], 4)',
            ],
        },
    };

    var meanReference = {
        'vec:mean': {
            title: 'vec:mean',
            category: 'Vector',
            description: 'Returns the `mean` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `mean` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:mean([1, 2, 3])',
                'vec:mean([1, 2, -3])',
            ],
        },
        'vec:moving-mean': {
            title: 'vec:moving-mean',
            category: 'Vector',
            description: 'Returns the **moving mean` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving mean** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-mean([1, 2, 3, 4, 5], 3)',
                'vec:moving-mean([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-mean': {
            title: 'vec:centered-moving-mean',
            category: 'Vector',
            description: 'Returns the **centered moving mean` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving mean** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-mean([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-mean([1, 2, 3, 4, 5], 3, 0, 10)',
                'vec:centered-moving-mean([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'vec:running-mean': {
            title: 'vec:running-mean',
            category: 'Vector',
            description: 'Returns the **running mean` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running mean** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-mean([1, 2, 3, 4, 5])',
            ],
        },
    };
    var geometricMeanReference = {
        'vec:geometric-mean': {
            title: 'vec:geometric-mean',
            category: 'Vector',
            description: 'Returns the `geometric mean` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `geometric mean` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:geometric-mean([1, 2, 3])',
                'vec:geometric-mean([1, 2, 9])',
            ],
        },
        'vec:moving-geometric-mean': {
            title: 'vec:moving-geometric-mean',
            category: 'Vector',
            description: 'Returns the **moving geometric mean` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving geometric mean** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-geometric-mean([1, 2, 3, 4, 5], 3)',
                'vec:moving-geometric-mean([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-geometric-mean': {
            title: 'vec:centered-moving-geometric-mean',
            category: 'Vector',
            description: 'Returns the **centered moving geometric mean` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving geometric mean** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-geometric-mean([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-geometric-mean([1, 2, 3, 4, 5], 3, 0, 10)',
                'vec:centered-moving-geometric-mean([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'vec:running-geometric-mean': {
            title: 'vec:running-geometric-mean',
            category: 'Vector',
            description: 'Returns the **running geometric mean` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running geometric mean** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-geometric-mean([1, 2, 3, 4, 5])',
            ],
        },
    };
    var harmonicMeanReference = {
        'vec:harmonic-mean': {
            title: 'vec:harmonic-mean',
            category: 'Vector',
            description: 'Returns the `harmonic mean` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `harmonic mean` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:harmonic-mean([1, 2, 3])',
                'vec:harmonic-mean([1, 2, 9])',
            ],
        },
        'vec:moving-harmonic-mean': {
            title: 'vec:moving-harmonic-mean',
            category: 'Vector',
            description: 'Returns the **moving harmonic mean` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving harmonic mean** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-harmonic-mean([1, 2, 3, 4, 5], 3)',
                'vec:moving-harmonic-mean([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-harmonic-mean': {
            title: 'vec:centered-moving-harmonic-mean',
            category: 'Vector',
            description: 'Returns the **centered moving harmonic mean` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving harmonic mean** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-harmonic-mean([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-harmonic-mean([1, 2, 3, 4, 5], 3, 0, 10)',
                'vec:centered-moving-harmonic-mean([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'vec:running-harmonic-mean': {
            title: 'vec:running-harmonic-mean',
            category: 'Vector',
            description: 'Returns the **running harmonic mean` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running harmonic mean** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-harmonic-mean([1, 2, 3, 4, 5])',
            ],
        },
    };

    var medianReference = {
        'vec:median': {
            title: 'vec:median',
            category: 'Vector',
            description: 'Returns the `median` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the `median` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:median([1, 2, 3])',
                'vec:median([1, 2, -3])',
            ],
        },
        'vec:moving-median': {
            title: 'vec:moving-median',
            category: 'Vector',
            description: 'Returns the **moving median` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving median** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-median([1, 2, 3, 4, 5], 3)',
                'vec:moving-median([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-median': {
            title: 'vec:centered-moving-median',
            category: 'Vector',
            description: 'Returns the **centered moving median` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving median** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-median([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-median([1, 2, 3, 4, 5], 3, 0, 10)',
                'vec:centered-moving-median([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'vec:running-median': {
            title: 'vec:running-median',
            category: 'Vector',
            description: 'Returns the **running median` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running median** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-median([1, 2, 3, 4, 5])',
            ],
        },
    };

    var varianceReference = {
        'vec:variance': {
            title: 'vec:variance',
            category: 'Vector',
            description: 'Returns the `variance` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `variance` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:variance([1, 2, 3])',
                'vec:variance([1, 2, -3])',
            ],
        },
        'vec:moving-variance': {
            title: 'vec:moving-variance',
            category: 'Vector',
            description: 'Returns the **moving variance` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving variance** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-variance([1, 2, 3, 4, 5], 3)',
                'vec:moving-variance([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-variance': {
            title: 'vec:centered-moving-variance',
            category: 'Vector',
            description: 'Returns the **centered moving variance` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving variance** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                '[1, 2, 3, 4, 5] vec:centered-moving-variance 3',
                'vec:centered-moving-variance([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-variance([1, 2, 3, 4, 5], 3, 1)',
                'vec:centered-moving-variance([1, 2, 3, 4, 5], 3, 1, 5)',
                'vec:centered-moving-variance([1, 2, 3, 4, 5], 3, 0, 6)',
            ],
        },
        'vec:running-variance': {
            title: 'vec:running-variance',
            category: 'Vector',
            description: 'Returns the **running variance` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running variance** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-variance([1, 2, 3, 4, 5])',
            ],
        },
    };
    var sampleVarianceReference = {
        'vec:sample-variance': {
            title: 'vec:sample-variance',
            category: 'Vector',
            description: 'Returns the `variance` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the variance of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:sample-variance([1, 2, 3])',
                'vec:sample-variance([1, 2, -3])',
            ],
        },
        'vec:moving-sample-variance': {
            title: 'vec:moving-sample-variance',
            category: 'Vector',
            description: 'Returns the **moving sample variance` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample variance** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-sample-variance([1, 2, 3, 4, 5], 3)',
                'vec:moving-sample-variance([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-sample-variance': {
            title: 'vec:centered-moving-sample-variance',
            category: 'Vector',
            description: 'Returns the **centered moving sample variance` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample variance** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                '[1, 2, 3, 4, 5] vec:centered-moving-sample-variance 3',
                'vec:centered-moving-sample-variance([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-sample-variance([1, 2, 3, 4, 5], 3, 1)',
                'vec:centered-moving-sample-variance([1, 2, 3, 4, 5], 3, 1, 5)',
                'vec:centered-moving-sample-variance([1, 2, 3, 4, 5], 3, 0, 6)',
            ],
        },
        'vec:running-sample-variance': {
            title: 'vec:running-sample-variance',
            category: 'Vector',
            description: 'Returns the **running sample variance` of the `vector**.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample variance` of. First element in result is `null` since `sample variance** is not defined for a single element.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-sample-variance([1, 2, 3, 4, 5])',
            ],
        },
    };

    var standardDeviationReference = {
        'vec:stdev': {
            title: 'vec:stdev',
            category: 'Vector',
            description: 'Returns the **standard deviation` of the `vector**.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **standard deviation** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:variance([1, 2, 3])',
                'vec:variance([1, 2, -3])',
            ],
        },
        'vec:moving-stdev': {
            title: 'vec:moving-stdev',
            category: 'Vector',
            description: 'Returns the **moving standard deviation` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving standard deviation** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-stdev([1, 2, 3, 4, 5], 3)',
                'vec:moving-stdev([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-stdev': {
            title: 'vec:centered-moving-stdev',
            category: 'Vector',
            description: 'Returns the **centered moving standard deviation` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving standard deviation** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                '[1, 2, 3, 4, 5] vec:centered-moving-stdev 3',
                'vec:centered-moving-stdev([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-stdev([1, 2, 3, 4, 5], 3, 1)',
                'vec:centered-moving-stdev([1, 2, 3, 4, 5], 3, 1, 5)',
                'vec:centered-moving-stdev([1, 2, 3, 4, 5], 3, 0, 6)',
            ],
        },
        'vec:running-stdev': {
            title: 'vec:running-stdev',
            category: 'Vector',
            description: 'Returns the **running standard deviation` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running standard deviation** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-stdev([1, 2, 3, 4, 5])',
            ],
        },
    };
    var sampleStandardDeviationReference = {
        'vec:sample-stdev': {
            title: 'vec:sample-stdev',
            category: 'Vector',
            description: 'Returns the **sample standard deviation` of the `vector**.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **sample standard deviation** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:variance([1, 2, 3])',
                'vec:variance([1, 2, -3])',
            ],
        },
        'vec:moving-sample-stdev': {
            title: 'vec:moving-sample-stdev',
            category: 'Vector',
            description: 'Returns the **moving sample standard deviation` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample standard deviation** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-sample-stdev([1, 2, 3, 4, 5], 3)',
                'vec:moving-sample-stdev([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-sample-stdev': {
            title: 'vec:centered-moving-sample-stdev',
            category: 'Vector',
            description: 'Returns the **centered moving sample standard deviation` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample standard deviation** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                '[1, 2, 3, 4, 5] vec:centered-moving-sample-stdev 3',
                'vec:centered-moving-sample-stdev([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 1)',
                'vec:centered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 1, 5)',
                'vec:centered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 0, 6)',
            ],
        },
        'vec:running-sample-stdev': {
            title: 'vec:running-sample-stdev',
            category: 'Vector',
            description: 'Returns the **running sample standard deviation` of the `vector**.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample standard deviation` of. First element in result is `null` since `sample standard deviation** is not defined for a single element.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-sample-stdev([1, 2, 3, 4, 5])',
            ],
        },
    };

    var skewnessReference = {
        'vec:skewness': {
            title: 'vec:skewness',
            category: 'Vector',
            description: 'Calculates the **skewness** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **skewness** of. Minimum length is 3.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:skewness([1, 2, 3, 6, 20])',
                'vec:skewness([1, 2, 2, 3])',
            ],
        },
        'vec:moving-skewness': {
            title: 'vec:moving-skewness',
            category: 'Vector',
            description: 'Calculates the **moving skewness** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving skewness** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-skewness([1, 2, 4, 7, 11, 16], 4)',
                'vec:moving-skewness([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'vec:centered-moving-skewness': {
            title: 'vec:centered-moving-skewness',
            category: 'Vector',
            description: 'Calculates the **centered moving skewness** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving skewness** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-skewness([1, 2, 4, 7, 11, 16], 4)',
                'vec:centered-moving-skewness([1, 2, 4, 7, 11, 16], 4, 0, 0)',
            ],
        },
        'vec:running-skewness': {
            title: 'vec:running-skewness',
            category: 'Vector',
            description: 'Calculates the **running skewness** of a `vector` with a given window size. First two element in result is `null` since **running skewness** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running skewness** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-skewness([1, 2, 4, 7, 11])',
            ],
        },
    };
    var sampleSkewnessReference = {
        'vec:sample-skewness': {
            title: 'vec:sample-skewness',
            category: 'Vector',
            description: 'Calculates the **sample skewness** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **sample skewness** of. Minimum length is 3.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:sample-skewness([1, 2, 3, 6, 20])',
                'vec:sample-skewness([1, 2, 2, 3])',
            ],
        },
        'vec:moving-sample-skewness': {
            title: 'vec:moving-sample-skewness',
            category: 'Vector',
            description: 'Calculates the **moving sample skewness** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample skewness** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-sample-skewness([1, 2, 4, 7, 11, 16], 4)',
                'vec:moving-sample-skewness([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'vec:centered-moving-sample-skewness': {
            title: 'vec:centered-moving-sample-skewness',
            category: 'Vector',
            description: 'Calculates the **centered moving sample skewness** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample skewness** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-sample-skewness([1, 2, 4, 7, 11, 16], 4)',
                'vec:centered-moving-sample-skewness([1, 2, 4, 7, 11, 16], 3, 0, 100)',
            ],
        },
        'vec:running-sample-skewness': {
            title: 'vec:running-sample-skewness',
            category: 'Vector',
            description: 'Calculates the **running sample skewness** of a `vector` with a given window size. First two element in result is `null` since **running sample skewness** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample skewness** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-sample-skewness([1, 2, 4, 7, 11])',
            ],
        },
    };

    var interquartileRangeReference = {
        'vec:iqr': {
            title: 'vec:iqr',
            category: 'Vector',
            description: 'Calculates the **interquartile range** of a `vector`. Returns the difference between the third and first quartiles.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **interquartile range** of. Minimum length is 4.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:iqr([1, 2, 3, 4])',
                'vec:iqr([5, 4, 3, 2, 1, 2, 3, 4, 5])',
                'vec:iqr(range(1, 1000))',
                'vec:iqr(vec:generate(1000, -> 1e6 / ($ + 1) ^ 2))',
                'vec:iqr(vec:generate(1000, -> ln($ + 1)))',
            ],
        },
        'vec:moving-iqr': {
            title: 'vec:moving-iqr',
            category: 'Vector',
            description: 'Calculates the **moving interquartile range** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving interquartile range** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-iqr([1, 2, 4, 7, 11, 16], 4)',
                'vec:moving-iqr([1, 2, 4, 7, 11, 16], 5)',
                'vec:moving-iqr([1, 2, 4, 7, 11, 16], 6)',
            ],
        },
        'vec:centered-moving-iqr': {
            title: 'vec:centered-moving-iqr',
            category: 'Vector',
            description: 'Calculates the **centered moving interquartile range** of a `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving interquartile range** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-iqr([1, 2, 4, 7, 11, 16], 4)',
                'vec:centered-moving-iqr([1, 2, 4, 7, 11, 16], 4, 0, 0)',
            ],
        },
        'vec:running-iqr': {
            title: 'vec:running-iqr',
            category: 'Vector',
            description: 'Calculates the **running interquartile range** of a `vector`. First three element in result is `null` since **running interquartile range** is not defined for less than four elements.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running interquartile range** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-iqr([1, 2, 3, 4, 5, 6])',
                'vec:running-iqr([-1, -2, -3, 1, 2, 3])',
            ],
        },
    };

    var sumReference = {
        'vec:sum': {
            title: 'vec:sum',
            category: 'Vector',
            description: 'Returns the `sum` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `sum` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:sum([1, 2, 3])',
                'vec:sum([1, 2, -3])',
            ],
        },
        'vec:moving-sum': {
            title: 'vec:moving-sum',
            category: 'Vector',
            description: 'Returns the **moving sum` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sum** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-sum([1, 2, 3, 4, 5], 3)',
                'vec:moving-sum([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-sum': {
            title: 'vec:centered-moving-sum',
            category: 'Vector',
            description: 'Returns the **centered moving sum` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sum** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the centered moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-sum([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-sum([1, 2, 3, 4, 5], 3, 0, 0)',
                'vec:centered-moving-sum([1, 2, 3, 4, 5], 3, 10)',
            ],
        },
        'vec:running-sum': {
            title: 'vec:running-sum',
            category: 'Vector',
            description: 'Returns the **running sum` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sum** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-sum([1, 2, 3])',
                'vec:running-sum([1, -2, -3])',
            ],
        },
    };

    var prodReference = {
        'vec:prod': {
            title: 'vec:prod',
            category: 'Vector',
            description: 'Returns the `product` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `product` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:prod([1, 2, 3])',
                'vec:prod([1, 2, -3])',
            ],
        },
        'vec:moving-prod': {
            title: 'vec:moving-prod',
            category: 'Vector',
            description: 'Returns the **moving product` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving product** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-prod([1, 2, 3, 4, 5], 3)',
                'vec:moving-prod([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-prod': {
            title: 'vec:centered-moving-prod',
            category: 'Vector',
            description: 'Returns the **centered moving product` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving product** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-prod([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-prod([1, 2, 3, 4, 5], 3, 0, 0)',
            ],
        },
        'vec:running-prod': {
            title: 'vec:running-prod',
            category: 'Vector',
            description: 'Returns the **running product` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running product** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-prod([1, 2, 3, 4, 5])',
                'vec:running-prod([1, -2, -3])',
            ],
        },
    };

    var minReference = {
        'vec:min': {
            title: 'vec:min',
            category: 'Vector',
            description: 'Returns the `minimum` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `minimum` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:min([1, 2, 3])',
                'vec:min([1, 2, -3])',
            ],
        },
        'vec:moving-min': {
            title: 'vec:moving-min',
            category: 'Vector',
            description: 'Returns the **moving minimum` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving minimum** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-min([1, 2, 3, 4, 5], 3)',
                'vec:moving-min([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-min': {
            title: 'vec:centered-moving-min',
            category: 'Vector',
            description: 'Returns the **centered moving minimum` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving minimum** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-min([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-min([1, 2, 3, 4, 5], 3, 0, 100)',
                'vec:centered-moving-min([1, 2, 3, 4, 5], 3, 0)',
            ],
        },
        'vec:running-min': {
            title: 'vec:running-min',
            category: 'Vector',
            description: 'Returns the **running minimum` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running minimum** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-min([1, 2, 3])',
                'vec:running-min([1, -2, -3])',
            ],
        },
    };

    var maxReference = {
        'vec:max': {
            title: 'vec:max',
            category: 'Vector',
            description: 'Returns the `maximum` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `maximum` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:max([1, 2, 3])',
                'vec:max([1, 2, -3])',
            ],
        },
        'vec:moving-max': {
            title: 'vec:moving-max',
            category: 'Vector',
            description: 'Returns the **moving maximum` of the `vector** with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving maximum** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-max([1, 2, 3, 4, 5], 3)',
                'vec:moving-max([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-max': {
            title: 'vec:centered-moving-max',
            category: 'Vector',
            description: 'Returns the **centered moving maximum` of the `vector** with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving maximum** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-max([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-max([1, 2, 3, 4, 5], 3, 0, 100)',
                'vec:centered-moving-max([1, 2, 3, 4, 5], 3, 0)',
            ],
        },
        'vec:running-max': {
            title: 'vec:running-max',
            category: 'Vector',
            description: 'Returns the **running maximum` of the `vector**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running maximum** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-max([1, 2, 3])',
                'vec:running-max([1, -2, -3])',
            ],
        },
    };

    var spanReference = {
        'vec:span': {
            title: 'vec:span',
            category: 'Vector',
            description: 'Calculates the **span** of a `vector`. Returns the difference between the maximum and minimum values.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **span** of. Minimum length is 0.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:span([1, 2, 3, 4])',
                'vec:span([1, 2, 3, 4, 5])',
                'vec:span([1])',
                'vec:span([])',
            ],
        },
        'vec:moving-span': {
            title: 'vec:moving-span',
            category: 'Vector',
            description: 'Calculates the **moving span** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving span** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-span([1, 2, 4, 7, 11, 16], 4)',
                'vec:moving-span([1, 2, 4, 7, 11, 16], 5)',
                'vec:moving-span([1, 2, 4, 7, 11, 16], 6)',
            ],
        },
        'vec:centered-moving-span': {
            title: 'vec:centered-moving-span',
            category: 'Vector',
            description: 'Calculates the **centered moving span** of a `vector` with a given window size. The result is padded with `leftPadding` on the left and right.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving span** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'The value to pad the result with on the left.',
                }, rightPadding: {
                    type: 'number',
                    description: 'The value to pad the result with on the right.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-span([1, 2, 4, 7, 11, 16], 4)',
                'vec:centered-moving-span([1, 2, 4, 7, 11, 16], 3, 0, 100)',
            ],
        },
        'vec:running-span': {
            title: 'vec:running-span',
            category: 'Vector',
            description: 'Calculates the **running span** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running span** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-span([1, 2, 4])',
            ],
        },
    };

    var kurtosisReference = {
        'vec:kurtosis': {
            title: 'vec:kurtosis',
            category: 'Vector',
            description: 'Calculates the **kurtosis** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **kurtosis** of. Minimum length is 3.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:kurtosis([1, 2, 3, 6, 20])',
                'vec:kurtosis([1, 2, 2, 3])',
            ],
        },
        'vec:moving-kurtosis': {
            title: 'vec:moving-kurtosis',
            category: 'Vector',
            description: 'Calculates the **moving kurtosis** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving kurtosis** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'vec:moving-kurtosis([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'vec:centered-moving-kurtosis': {
            title: 'vec:centered-moving-kurtosis',
            category: 'Vector',
            description: 'Calculates the **centered moving kurtosis** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving kurtosis** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'vec:centered-moving-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 0)',
            ],
        },
        'vec:running-kurtosis': {
            title: 'vec:running-kurtosis',
            category: 'Vector',
            description: 'Calculates the **running kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running kurtosis** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running kurtosis** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-kurtosis([1, 2, 4, 7, 11])',
            ],
        },
    };
    var sampleKurtosisReference = {
        'vec:sample-kurtosis': {
            title: 'vec:sample-kurtosis',
            category: 'Vector',
            description: 'Calculates the **sample kurtosis** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **sample kurtosis** of. Minimum length is 3.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:sample-kurtosis([1, 2, 3, 6, 20])',
                'vec:sample-kurtosis([1, 2, 2, 3])',
            ],
        },
        'vec:moving-sample-kurtosis': {
            title: 'vec:moving-sample-kurtosis',
            category: 'Vector',
            description: 'Calculates the **moving sample kurtosis** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample kurtosis** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'vec:moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'vec:centered-moving-sample-kurtosis': {
            title: 'vec:centered-moving-sample-kurtosis',
            category: 'Vector',
            description: 'Calculates the **centered moving sample kurtosis** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample kurtosis** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'vec:centered-moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 100)',
            ],
        },
        'vec:running-sample-kurtosis': {
            title: 'vec:running-sample-kurtosis',
            category: 'Vector',
            description: 'Calculates the **running sample kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running sample kurtosis** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample kurtosis** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-sample-kurtosis([1, 2, 4, 7, 11])',
            ],
        },
    };
    var excessKurtoisReference = {
        'vec:excess-kurtosis': {
            title: 'vec:excess-kurtosis',
            category: 'Vector',
            description: 'Calculates the **excess kurtosis** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **excess kurtosis** of. Minimum length is 3.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:excess-kurtosis([1, 2, 3, 6, 20])',
                'vec:excess-kurtosis([1, 2, 2, 3])',
            ],
        },
        'vec:moving-excess-kurtosis': {
            title: 'vec:moving-excess-kurtosis',
            category: 'Vector',
            description: 'Calculates the **moving excess kurtosis** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving excess kurtosis** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'vec:moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'vec:centered-moving-excess-kurtosis': {
            title: 'vec:centered-moving-excess-kurtosis',
            category: 'Vector',
            description: 'Calculates the **centered moving excess kurtosis** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving excess kurtosis** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'vec:centered-moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 0)',
            ],
        },
        'vec:running-excess-kurtosis': {
            title: 'vec:running-excess-kurtosis',
            category: 'Vector',
            description: 'Calculates the **running excess kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running excess kurtosis** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running excess kurtosis** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-excess-kurtosis([1, 2, 4, 7, 11])',
            ],
        },
    };
    var sampleExcessKurtosisReference = {
        'vec:sample-excess-kurtosis': {
            title: 'vec:sample-excess-kurtosis',
            category: 'Vector',
            description: 'Calculates the **sample excess kurtosis** of a `vector`. Returns the third standardized moment.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **sample excess kurtosis** of. Minimum length is 3.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:sample-excess-kurtosis([1, 2, 3, 6, 20])',
                'vec:sample-excess-kurtosis([1, 2, 2, 3])',
            ],
        },
        'vec:moving-sample-excess-kurtosis': {
            title: 'vec:moving-sample-excess-kurtosis',
            category: 'Vector',
            description: 'Calculates the **moving sample excess kurtosis** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving sample excess kurtosis** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'vec:moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 5)',
            ],
        },
        'vec:centered-moving-sample-excess-kurtosis': {
            title: 'vec:centered-moving-sample-excess-kurtosis',
            category: 'Vector',
            description: 'Calculates the **centered moving sample excess kurtosis** of a `vector` with a given window size and padding.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving sample excess kurtosis** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)',
                'vec:centered-moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 100)',
            ],
        },
        'vec:running-sample-excess-kurtosis': {
            title: 'vec:running-sample-excess-kurtosis',
            category: 'Vector',
            description: 'Calculates the **running sample excess kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running sample excess kurtosis** is not defined for less than three elements.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running sample excess kurtosis** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-sample-excess-kurtosis([1, 2, 4, 7, 11])',
            ],
        },
    };

    var rootMeanSquareReference = {
        'vec:rms': {
            title: 'vec:rms',
            category: 'Vector',
            description: 'Calculates the **root mean square** of a `vector`. Returns the square root of the average of the squares of the elements.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **root mean square** of. Minimum length is 1.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:rms([1, 2, 3, 4])',
                'vec:rms([5, 4, 3, 2, 1])',
                'vec:rms(range(1, 1000))',
                'vec:rms(vec:generate(1000, -> 1e6 / ($ + 1) ^ 2))',
                'vec:rms(vec:generate(1000, -> ln($ + 1)))',
            ],
        },
        'vec:moving-rms': {
            title: 'vec:moving-rms',
            category: 'Vector',
            description: 'Calculates the **moving root mean square** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving root mean square** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-rms([1, 2, 4, 7, 11, 16], 4)',
                'vec:moving-rms([1, 2, 4, 7, 11, 16], 5)',
                'vec:moving-rms([1, 2, 4, 7, 11, 16], 6)',
            ],
        },
        'vec:centered-moving-rms': {
            title: 'vec:centered-moving-rms',
            category: 'Vector',
            description: 'Calculates the **centered moving root mean square** of a `vector` with a given window size and padding value.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving root mean square** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-rms([1, 2, 4, 7, 11, 16], 4)',
                'vec:centered-moving-rms([1, 2, 4, 7, 11, 16], 5, 0)',
                'vec:centered-moving-rms([1, 2, 4, 7, 11, 16], 6, 0, 0)',
            ],
        },
        'vec:running-rms': {
            title: 'vec:running-rms',
            category: 'Vector',
            description: 'Calculates the **running root mean square** of a `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running root mean square** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-rms([1, 2, 3, 4, 5, 6])',
                'vec:running-rms([1, -3, 2])',
                'vec:running-rms([-1, -2, -3])',
                'vec:running-rms([0])',
            ],
        },
    };

    var meanAbsoluteDeviationReference = {
        'vec:mad': {
            title: 'vec:mad',
            category: 'Vector',
            description: 'Returns the `mean absolute deviation` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `mean absolute deviation` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:mad([1, 2, 3])',
                'vec:mad([1, 2, -3])',
            ],
        },
        'vec:moving-mad': {
            title: 'vec:moving-mad',
            category: 'Vector',
            description: 'Returns the `moving mean absolute deviation` of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `moving mean absolute deviation` of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-mad([1, 2, 3, 4, 5], 3)',
                'vec:moving-mad([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-mad': {
            title: 'vec:centered-moving-mad',
            category: 'Vector',
            description: 'Returns the `centered moving mean absolute deviation` of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `centered moving mean absolute deviation` of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-mad([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-mad([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:running-mad': {
            title: 'vec:running-mad',
            category: 'Vector',
            description: 'Returns the `running mean absolute deviation` of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `running mean absolute deviation` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-mad([1, 2, 3])',
                'vec:running-mad([1, 2, -3])',
            ],
        },
    };

    var medianAbsoluteDeviationReference = {
        'vec:medad': {
            title: 'vec:medad',
            category: 'Vector',
            description: 'Returns the `median absolute deviation` of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `median absolute deviation` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:medad([1, 2, 3])',
                'vec:medad([1, 2, -3])',
            ],
        },
        'vec:moving-medad': {
            title: 'vec:moving-medad',
            category: 'Vector',
            description: 'Returns the `moving median absolute deviation` of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `moving median absolute deviation` of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-medad([1, 2, 3, 4, 5], 3)',
                'vec:moving-medad([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:centered-moving-medad': {
            title: 'vec:centered-moving-medad',
            category: 'Vector',
            description: 'Returns the `centered moving median absolute deviation` of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `centered moving median absolute deviation` of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-medad([1, 2, 3, 4, 5], 3)',
                'vec:centered-moving-medad([1, 2, 3, 4, 5], 5)',
            ],
        },
        'vec:running-medad': {
            title: 'vec:running-medad',
            category: 'Vector',
            description: 'Returns the `running median absolute deviation` of the `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the `running median absolute deviation` of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-medad([1, 2, 3])',
                'vec:running-medad([1, 2, -3])',
            ],
        },
    };

    var giniCoefficientReference = {
        'vec:gini-coefficient': {
            title: 'vec:gini-coefficient',
            category: 'Vector',
            description: 'Returns the **gini coefficient** of all elements in the `vector`.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **gini coefficient** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:gini-coefficient([1, 2, 3])',
                'vec:gini-coefficient([1, 1, 3])',
            ],
        },
        'vec:moving-gini-coefficient': {
            title: 'vec:moving-gini-coefficient',
            category: 'Vector',
            description: 'Returns the **moving gini coefficient** of the `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving gini coefficient** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-gini-coefficient([1, 2, 3], 2)',
                'vec:moving-gini-coefficient([1, 1, 3], 2)',
            ],
        },
        'vec:centered-moving-gini-coefficient': {
            title: 'vec:centered-moving-gini-coefficient',
            category: 'Vector',
            description: 'Returns the **centered moving gini coefficient** of the `vector` with a given window size.',
            returns: {
                type: 'array',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving gini coefficient** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-gini-coefficient([1, 2, 3], 2)',
                'vec:centered-moving-gini-coefficient([1, 1, 3], 2)',
            ],
        },
        'vec:running-gini-coefficient': {
            title: 'vec:running-gini-coefficient',
            category: 'Vector',
            description: 'Returns the **running gini coefficient** of the `vector`.',
            returns: {
                type: 'array',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running gini coefficient** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-gini-coefficient([1, 2, 3])',
                'vec:running-gini-coefficient([1, 1, 3])',
            ],
        },
    };

    var entropyReference = {
        'vec:entropy': {
            title: 'vec:entropy',
            category: 'Vector',
            description: 'Calculates the **entropy** of a `vector`. The entropy is a measure of the uncertainty associated with a random variable.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **entropy** of. Minimum length is 1.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:entropy([1, 1, 2, 3, 3, 3])',
                'vec:entropy([1, 2, 3])',
                'vec:entropy([1, 2, 2, 3])',
                'vec:entropy([0])',
                'vec:entropy([1])',
                'vec:entropy([1, 2])',
            ],
        },
        'vec:moving-entropy': {
            title: 'vec:moving-entropy',
            category: 'Vector',
            description: 'Calculates the **moving entropy** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **moving entropy** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
            ],
            examples: [
                'vec:moving-entropy([1, 1, 2, 3, 3, 3], 4)',
                'vec:moving-entropy([1, 1, 2, 3, 3, 3], 3)',
                'vec:moving-entropy([1, 2], 2)',
            ],
        },
        'vec:centered-moving-entropy': {
            title: 'vec:centered-moving-entropy',
            category: 'Vector',
            description: 'Calculates the **centered moving entropy** of a `vector` with a given window size.',
            returns: {
                type: 'vector',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **centered moving entropy** of.',
                }, windowSize: {
                    type: 'integer',
                    description: 'The size of the moving window.',
                }, leftPadding: {
                    type: 'number',
                    description: 'Optional value to use for padding. Default is `null`.',
                }, rightPadding: {
                    type: 'number',
                    description: 'Optional value to use for right padding. Default is `null`.',
                } }, getOperatorArgs('vector', 'integer')),
            variants: [
                { argumentNames: ['vector', 'windowSize'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding'] },
                { argumentNames: ['vector', 'windowSize', 'leftPadding', 'rightPadding'] },
            ],
            examples: [
                'vec:centered-moving-entropy([1, 1, 2, 3, 3, 3], 4)',
                'vec:centered-moving-entropy([1, 1, 2, 3, 3, 3], 3)',
                'vec:centered-moving-entropy([1, 2], 2)',
            ],
        },
        'vec:running-entropy': {
            title: 'vec:running-entropy',
            category: 'Vector',
            description: 'Calculates the **running entropy** of a `vector`.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to calculate the **running entropy** of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:running-entropy([1, 1, 2, 3, 3, 3])',
                'vec:running-entropy([1, 2])',
            ],
        },
    };

    var vectorReference = __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, meanReference), geometricMeanReference), harmonicMeanReference), medianReference), varianceReference), sampleVarianceReference), standardDeviationReference), sampleStandardDeviationReference), interquartileRangeReference), sumReference), prodReference), minReference), maxReference), spanReference), skewnessReference), sampleSkewnessReference), excessKurtoisReference), kurtosisReference), sampleExcessKurtosisReference), sampleKurtosisReference), rootMeanSquareReference), meanAbsoluteDeviationReference), medianAbsoluteDeviationReference), giniCoefficientReference), entropyReference), { 'vec:monotonic?': {
            title: 'vec:monotonic?',
            category: 'Vector',
            description: 'Checks if a vector is monotonic.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:monotonic?([1, 2, 3])',
                'vec:monotonic?([1, 2, 2, 3])',
                'vec:monotonic?([3, 2, 1])',
                'vec:monotonic?([3, 2, 1, 1])',
                'vec:monotonic?([3, 2, 1, 2])',
                'vec:monotonic?([1])',
                'vec:monotonic?([])',
            ],
        }, 'vec:strictly-monotonic?': {
            title: 'vec:strictly-monotonic?',
            category: 'Vector',
            description: 'Checks if a vector is strictly monotonic.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:strictly-monotonic?([1, 2, 3])',
                'vec:strictly-monotonic?([1, 2, 2, 3])',
                'vec:strictly-monotonic?([3, 2, 1])',
                'vec:strictly-monotonic?([3, 2, 1, 1])',
                'vec:strictly-monotonic?([3, 2, 1, 2])',
                'vec:strictly-monotonic?([1])',
                'vec:strictly-monotonic?([])',
            ],
        }, 'vec:increasing?': {
            title: 'vec:increasing?',
            category: 'Vector',
            description: 'Checks if a vector is increasing.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:increasing?([1, 2, 3])',
                'vec:increasing?([1, 2, 2, 3])',
                'vec:increasing?([3, 2, 1])',
                'vec:increasing?([3, 2, 1, 1])',
                'vec:increasing?([3, 2, 1, 2])',
                'vec:increasing?([1])',
                'vec:increasing?([])',
            ],
        }, 'vec:decreasing?': {
            title: 'vec:decreasing?',
            category: 'Vector',
            description: 'Checks if a vector is decreasing.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:decreasing?([1, 2, 3])',
                'vec:decreasing?([1, 2, 2, 3])',
                'vec:decreasing?([3, 2, 1])',
                'vec:decreasing?([3, 2, 1, 1])',
                'vec:decreasing?([3, 2, 1, 2])',
                'vec:decreasing?([1])',
                'vec:decreasing?([])',
            ],
        }, 'vec:strictly-increasing?': {
            title: 'vec:strictly-increasing?',
            category: 'Vector',
            description: 'Checks if a vector is strictly increasing.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:strictly-increasing?([1, 2, 3])',
                'vec:strictly-increasing?([1, 2, 2, 3])',
                'vec:strictly-increasing?([3, 2, 1])',
                'vec:strictly-increasing?([3, 2, 1, 1])',
                'vec:strictly-increasing?([3, 2, 1, 2])',
                'vec:strictly-increasing?([1])',
                'vec:strictly-increasing?([])',
            ],
        }, 'vec:strictly-decreasing?': {
            title: 'vec:strictly-decreasing?',
            category: 'Vector',
            description: 'Checks if a vector is strictly decreasing.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to check.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:strictly-decreasing?([1, 2, 3])',
                'vec:strictly-decreasing?([1, 2, 2, 3])',
                'vec:strictly-decreasing?([3, 2, 1])',
                'vec:strictly-decreasing?([3, 2, 1, 1])',
                'vec:strictly-decreasing?([3, 2, 1, 2])',
                'vec:strictly-decreasing?([1])',
                'vec:strictly-decreasing?([])',
            ],
        }, 'vec:sum': {
            title: 'vec:sum',
            category: 'Vector',
            description: 'Returns the sum of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to sum.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:sum([1, 2, 3])',
                'vec:sum([1, 2, -3])',
            ],
        }, 'vec:median': {
            title: 'vec:median',
            category: 'Vector',
            description: 'Returns the median of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the median of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:median([1, 2, 3])',
                'vec:median([1, 2, -3])',
                'vec:median([1, 2, 3, 4])',
                'vec:median([1, 2, -3, 4])',
            ],
        }, 'vec:mode': {
            title: 'vec:mode',
            category: 'Vector',
            description: 'Returns the mode of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the mode of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:mode([1, 2, 3])',
                'vec:mode([1, 2, -3, 1])',
                'vec:mode([2, 2, 3, 3, 4])',
                'vec:mode([2, 2, 3, 3])',
                'vec:mode([1, 2, 3, 2, 1, 2])',
            ],
        }, 'vec:sample-variance': {
            title: 'vec:sample-variance',
            category: 'Vector',
            description: 'Returns the sample variance of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the sample variance of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:sample-variance([1, 2, 3])',
                'vec:sample-variance([1, 2, -3])',
                'vec:sample-variance([1, 2, 3, 4])',
                'vec:sample-variance([1, 2, -3, 4])',
                'vec:sample-variance([1, 2, 3, 40, 50])',
            ],
        }, 'vec:stdev': {
            title: 'vec:stdev',
            category: 'Vector',
            description: 'Returns the standard deviation of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the standard deviation of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:stdev([1, 2, 3])',
                'vec:stdev([1, 2, -3])',
                'vec:stdev([1, 2, 3, 4])',
                'vec:stdev([1, 2, -3, 4])',
                'vec:stdev([1, 2, 3, 40, 50])',
            ],
        }, 'vec:sample-stdev': {
            title: 'vec:sample-stdev',
            category: 'Vector',
            description: 'Returns the sample standard deviation of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the sample standard deviation of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:sample-stdev([1, 2, 3])',
                'vec:sample-stdev([1, 2, -3])',
                'vec:sample-stdev([1, 2, 3, 4])',
                'vec:sample-stdev([1, 2, -3, 4])',
                'vec:sample-stdev([1, 2, 3, 40, 50])',
            ],
        }, 'vec:min': {
            title: 'vec:min',
            category: 'Vector',
            description: 'Returns the minimum value of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the minimum of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:min([1, 2, 3])',
                'vec:min([1, 1, 2, 3, 3])',
                'vec:min([1, 2, -3])',
                'vec:min([1, 2, 3, 4])',
                'vec:min([1, 2, -3, 4])',
            ],
        }, 'vec:max': {
            title: 'vec:max',
            category: 'Vector',
            description: 'Returns the maximum value of all elements in the vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the maximum of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:max([1, 2, 3])',
                'vec:max([1, 1, 2, 3, 3])',
                'vec:max([1, 2, -3])',
                'vec:max([1, 2, 3, 4])',
                'vec:max([1, 2, -3, 4])',
            ],
        }, 'vec:min-index': {
            title: 'vec:min-index',
            category: 'Vector',
            description: 'Returns the index of the minimum value of all elements in the vector.',
            returns: {
                type: 'integer',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the minimum index of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:min-index([1, 2, 3])',
                'vec:min-index([1, 1, 2, 3, 3])',
                'vec:min-index([1, 2, -3])',
                'vec:min-index([1, 2, 3, 4])',
                'vec:min-index([1, 2, -3, 4])',
            ],
        }, 'vec:max-index': {
            title: 'vec:max-index',
            category: 'Vector',
            description: 'Returns the index of the maximum value of all elements in the vector.',
            returns: {
                type: 'integer',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the maximum index of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:max-index([1, 2, 3])',
                'vec:max-index([1, 1, 2, 3, 3])',
                'vec:max-index([1, 2, -3])',
                'vec:max-index([1, 2, 3, 4])',
                'vec:max-index([1, 2, -3, 4])',
            ],
        }, 'vec:sort-indices': {
            title: 'vec:sort-indices',
            category: 'Vector',
            description: 'Returns the indices of the elements in the vector sorted in ascending order.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Non emtpy vector to calculate the sorted indices of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:sort-indices([1, 2, 3])',
                'vec:sort-indices([1, 1, 2, 3, 3])',
                'vec:sort-indices([1, 2, -3])',
                'vec:sort-indices([1, 2, 3, 4])',
                'vec:sort-indices([1, 2, -3, 4])',
            ],
        }, 'vec:count-values': {
            title: 'vec:count-values',
            category: 'Vector',
            description: 'Counts the number of occurrences of each value in the vector.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Vector to count the values of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:count-values([1, 2, 3])',
                'vec:count-values([1, 1, 2, 3, 3])',
                'vec:count-values([1, 2, -3])',
                'vec:count-values([1, 2, 2, 1, 3, 2, 4, 2, 1, 2, 2, 1, 3, 2, 4])',
            ],
        }, 'vec:linspace': {
            title: 'vec:linspace',
            category: 'Vector',
            description: 'Generates a vector of evenly spaced numbers between two values.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting value.',
                },
                stop: {
                    type: 'number',
                    description: 'The ending value.',
                },
                n: {
                    type: 'integer',
                    description: 'The number of values to generate.',
                },
            },
            variants: [
                { argumentNames: ['start', 'stop', 'n'] },
            ],
            examples: [
                'vec:linspace(0, 10, 6)',
                'vec:linspace(10, 20, 25)',
            ],
        }, 'vec:ones': {
            title: 'vec:ones',
            category: 'Vector',
            description: 'Generates a vector of ones.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the vector.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'vec:ones(5)',
                'vec:ones(10)',
                'vec:ones(0)',
            ],
        }, 'vec:zeros': {
            title: 'vec:zeros',
            category: 'Vector',
            description: 'Generates a vector of zeros.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the vector.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'vec:zeros(5)',
                'vec:zeros(10)',
                'vec:zeros(0)',
            ],
        }, 'vec:fill': {
            title: 'vec:fill',
            category: 'Vector',
            description: 'Generates a vector filled with a number.',
            returns: {
                type: 'number',
                array: true,
            },
            args: __assign({ length: {
                    type: 'integer',
                    description: 'The length of the vector.',
                }, value: {
                    type: 'number',
                    description: 'The value to fill the vector with.',
                } }, getOperatorArgs('number', 'integer')),
            variants: [
                { argumentNames: ['length', 'value'] },
            ],
            examples: [
                'vec:fill(5, PI)',
                'vec:fill(10, -1)',
            ],
        }, 'vec:generate': {
            title: 'vec:generate',
            category: 'Vector',
            description: 'Generates a vector of numbers based on a function.',
            returns: {
                type: 'number',
                array: true,
            },
            args: __assign({ length: {
                    type: 'integer',
                    description: 'The length of the vector.',
                }, func: {
                    type: 'function',
                    description: 'A function that takes an index and returns a number.',
                } }, getOperatorArgs('number', 'integer')),
            variants: [
                { argumentNames: ['length', 'func'] },
            ],
            examples: [
                'vec:generate(5, -> $ * 2)',
                'vec:generate(10, -> $ + 1)',
                'vec:generate(0, -> $ + 1)',
            ],
        }, 'vec:cumsum': {
            title: 'vec:cumsum',
            category: 'Vector',
            description: 'Calculates the cumulative sum of a vector.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the cumulative sum of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:cumsum([1, 2, 3])',
                'vec:cumsum([1, 2, -3])',
                'vec:cumsum([])',
            ],
        }, 'vec:cumprod': {
            title: 'vec:cumprod',
            category: 'Vector',
            description: 'Calculates the cumulative product of a vector.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the cumulative product of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:cumprod([1, 2, 3])',
                'vec:cumprod([1, 2, -3, 0, 10])',
                'vec:cumprod([])',
            ],
        }, 'vec:quartiles': {
            title: 'vec:quartiles',
            category: 'Vector',
            description: 'Calculates the quartiles of a vector. Returns an array containing the first, second (median), and third quartiles.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the quartiles of. Minimum length is 4.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:quartiles([1, 2, 3, 4])',
                'vec:quartiles([5, 4, 3, 2, 1, 2, 3, 4, 5])',
                'vec:quartiles(range(1, 1000))',
                'vec:quartiles(vec:generate(1000, -> 1e6 / ($ + 1) ^ 2))',
                'vec:quartiles(vec:generate(1000, -> ln($ + 1)))',
            ],
        }, 'vec:percentile': {
            title: 'vec:percentile',
            category: 'Vector',
            description: 'Calculates the percentile of a vector. Returns the value at the specified percentile.',
            returns: {
                type: 'number',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The non empty vector to calculate the percentile of.',
                }, percentile: {
                    type: 'number',
                    description: 'The percentile to calculate. Must be between 0 and 1.',
                } }, getOperatorArgs('number', 'integer')),
            variants: [
                { argumentNames: ['vector', 'percentile'] },
            ],
            examples: [
                'vec:percentile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 35)',
                'vec:percentile(range(100) ^ 0.5, 0)',
                'vec:percentile(range(100) ^ 0.5, 10)',
                'vec:percentile(range(100) ^ 0.5, 20)',
                'vec:percentile(range(100) ^ 0.5, 30)',
                'vec:percentile(range(100) ^ 0.5, 40)',
                'vec:percentile(range(100) ^ 0.5, 50)',
                'vec:percentile(range(100) ^ 0.5, 60)',
                'vec:percentile(range(100) ^ 0.5, 70)',
                'vec:percentile(range(100) ^ 0.5, 80)',
                'vec:percentile(range(100) ^ 0.5, 90)',
                'vec:percentile(range(100) ^ 0.5, 100)',
            ],
        }, 'vec:quantile': {
            title: 'vec:quantile',
            category: 'Vector',
            description: 'Calculates the quantile of a vector. Returns the value at the specified quantile.',
            returns: {
                type: 'number',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The non empty vector to calculate the quantile of.',
                }, quantile: {
                    type: 'number',
                    description: 'The quantile to calculate. Must be between 0 and 1.',
                } }, getOperatorArgs('number', 'integer')),
            variants: [
                { argumentNames: ['vector', 'quantile'] },
            ],
            examples: [
                'vec:quantile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0.35)',
                'vec:quantile(range(100) ^ 0.5, 0)',
                'vec:quantile(range(100) ^ 0.5, 0.1)',
                'vec:quantile(range(100) ^ 0.5, 0.2)',
                'vec:quantile(range(100) ^ 0.5, 0.3)',
                'vec:quantile(range(100) ^ 0.5, 0.4)',
                'vec:quantile(range(100) ^ 0.5, 0.5)',
                'vec:quantile(range(100) ^ 0.5, 0.6)',
                'vec:quantile(range(100) ^ 0.5, 0.7)',
                'vec:quantile(range(100) ^ 0.5, 0.8)',
                'vec:quantile(range(100) ^ 0.5, 0.9)',
                'vec:quantile(range(100) ^ 0.5, 1)',
            ],
        }, 'vec:span': {
            title: 'vec:span',
            category: 'Vector',
            description: 'Returns the difference between the maximum and minimum values in a vector.',
            returns: {
                type: 'number',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to calculate the span of.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:span([1, 2, 3])',
                'vec:span([1, 1, 2, 3, 3])',
                'vec:span([1, 2, -3])',
            ],
        }, 'vec:histogram': {
            title: 'vec:histogram',
            category: 'Vector',
            description: 'Creates a histogram from a numeric `array` by dividing the data range into the specified number of bins. Returns an `array` of `[binStart, binEnd, count]` tuples representing each bin\'s range and the number of values within it. Handles empty arrays, identical values, and properly places maximum values in the last bin.',
            returns: {
                type: 'array',
                array: true,
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The numeric array to create a histogram from.',
                }, bins: {
                    type: 'integer',
                    description: 'The number of bins to divide the data range into.',
                } }, getOperatorArgs('number', 'integer')),
            variants: [
                { argumentNames: ['vector', 'bins'] },
            ],
            examples: [
                'vec:histogram([1, 2, 2, 3, 2, 6, 4, 3, 2, 4, 1, 3, 2, 9], 3)',
                'vec:histogram([1, 2, 3, 4, 5], 5)',
                'vec:histogram([1, 2, 3, 4, 5], 10)',
                'vec:histogram([1, 2, 3, 4, 5], 1)',
            ],
        }, 'vec:ecdf': {
            title: 'vec:ecdf',
            category: 'Vector',
            description: 'Calculates the empirical cumulative distribution function value for a given threshold in a non empty dataset. Returns the proportion of values in the `array` that are less than or equal to the specified threshold.',
            returns: {
                type: 'number',
            },
            args: __assign({ vector: {
                    type: 'vector',
                    description: 'The numeric array to calculate the ECDF from.',
                }, threshold: {
                    type: 'number',
                    description: 'The threshold value to calculate the ECDF for.',
                } }, getOperatorArgs('number', 'integer')),
            variants: [
                { argumentNames: ['vector', 'threshold'] },
            ],
            examples: [
                'vec:ecdf([1, 2, 2, 3, 2, 6, 4, 3, 2, 4, 1, 3, 2, 9, 10, 12], 5)',
                'vec:ecdf([1, 2, 3, 4, 5], 3)',
                'vec:ecdf([1, 2, 3, 4, 5], 0)',
                'vec:ecdf([1, 2, 3, 4, 5], 10)',
                'vec:ecdf([1, 2, 3, 4, 5], 2)',
            ],
        }, 'vec:outliers?': {
            title: 'vec:outliers?',
            category: 'Vector',
            description: 'Checks if the `vector` contains outliers based on the interquartile range (IQR) method. Returns `true` if outliers are present, `false` otherwise.',
            returns: {
                type: 'boolean',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to check for outliers.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:outliers?([1, 2, 3])',
                'vec:outliers?([1, 2, -3])',
                'vec:outliers?([1, 2, 3, 2, 4, 120])',
            ],
        }, 'vec:outliers': {
            title: 'vec:outliers',
            category: 'Vector',
            description: 'Identifies outliers in the `vector` based on the interquartile range (IQR) method. Returns an array of outlier values.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The `vector` to check for outliers.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'vec:outliers([1, 2, 3])',
                'vec:outliers([1, 2, -3])',
                'vec:outliers([1, 2, 3, 2, 4, 120])',
            ],
        }, 'vec:bincount': {
            title: 'vec:bincount',
            category: 'Vector',
            description: 'counts occurrences of each `integer` in a vector, returning an array where index `i` contains the count of value `i`, with optional **minimum size** and **weights parameters**.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'The vector to count occurrences in.',
                },
                minSize: {
                    type: 'integer',
                    description: 'Optional minimum size of the output array.',
                },
                weights: {
                    type: 'number',
                    array: true,
                    description: 'Optional weights for each element in the vector.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
                { argumentNames: ['vector', 'minSize'] },
                { argumentNames: ['vector', 'minSize', 'weights'] },
            ],
            examples: [
                'vec:bincount([1, 2, 3])',
                'vec:bincount([1, 2, 2, 3, 3])',
            ],
            noOperatorDocumentation: true,
        }, 'vec:winsorize': {
            title: 'vec:winsorize',
            category: 'Vector',
            description: 'Limits extreme values in a `vector` by replacing values below the **lower quantile** and above the **upper quantile** with the values at those quantiles. The function takes a `vector` of values and **quantile thresholds** (between 0 and 1), with the upper quantile. Winsorization reduces the influence of outliers while preserving the overall distribution shape, making statistical analyses more robust.',
            returns: {
                type: 'vector',
            },
            args: {
                'vector': {
                    type: 'vector',
                    description: 'The vector to winsorize.',
                },
                'lower-quantile': {
                    type: 'number',
                    description: 'The lower quantile threshold (between 0 and 1).',
                },
                'upper-quantile': {
                    type: 'number',
                    description: 'Optional Upper quantile threshold (between 0 and 1). Defaults to `(1 - lower-quantile)` if `lower-quantile <= 0.5` otherwise `1`.',
                },
            },
            variants: [
                { argumentNames: ['vector', 'lower-quantile'] },
                { argumentNames: ['vector', 'lower-quantile', 'upper-quantile'] },
            ],
            examples: [
                'vec:winsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25)',
                'vec:winsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25, 0.75)',
                'vec:winsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25, 0.5)',
            ],
            noOperatorDocumentation: true,
        }, 'vec:mse': {
            title: 'vec:mse',
            category: 'Vector',
            description: 'Calculates the **Mean Squared Error (MSE)** between two vectors. Returns the average of the squared differences between corresponding elements.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'The first vector.',
                },
                b: {
                    type: 'vector',
                    description: 'The second vector.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'vec:mse([1, 2, 3], [1, 2, 3])',
                'vec:mse([1, 2, 3], [4, 5, 6])',
                'vec:mse([1, 2, 3], [2, 2, 2])',
                'vec:mse([1, 2], [3, 3])',
                'vec:mse([1], [3])',
            ],
        }, 'vec:rmse': {
            title: 'vec:rmse',
            category: 'Vector',
            description: 'Calculates the **Root Mean Squared Error (RMSE)** between two vectors. Returns the square root of the average of the squared differences between corresponding elements.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'The first vector.',
                },
                b: {
                    type: 'vector',
                    description: 'The second vector.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'vec:rmse([1, 2, 3], [1, 2, 3])',
                'vec:rmse([1, 2, 3], [4, 5, 6])',
                'vec:rmse([1, 2, 3], [2, 2, 2])',
                'vec:rmse([1, 2], [3, 3])',
                'vec:rmse([1], [3])',
            ],
        }, 'vec:mae': {
            title: 'vec:mae',
            category: 'Vector',
            description: 'Calculates the **Mean Absolute Error (MAE)** between two vectors. Returns the average of the absolute differences between corresponding elements.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'The first vector.',
                },
                b: {
                    type: 'vector',
                    description: 'The second vector.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'vec:mae([1, 2, 3], [1, 2, 3])',
                'vec:mae([1, 2, 3], [4, 5, 6])',
                'vec:mae([1, 2, 3], [2, 2, 2])',
                'vec:mae([1, 2], [3, 3])',
                'vec:mae([1], [3])',
            ],
        }, 'vec:smape': {
            title: 'vec:smape',
            category: 'Vector',
            description: 'Calculates the **Symmetric Mean Absolute Percentage Error (SMAPE)** between two vectors. Returns the average of the absolute percentage differences between corresponding elements.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'The first vector.',
                },
                b: {
                    type: 'vector',
                    description: 'The second vector.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'vec:smape([1, 2, 3], [1, 2, 3])',
                'vec:smape([1, 2, 3], [4, 5, 6])',
                'vec:smape([1, 2, 3], [2, 2, 2])',
                'vec:smape([1, 2], [3, 3])',
                'vec:smape([1], [3])',
            ],
        } });

    var linAlgReference = {
        'lin:reflect': {
            title: 'lin:reflect',
            category: 'Linear Algebra',
            description: 'Reflects a vector across a given axis.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Vector to reflect.',
                },
                b: {
                    type: 'vector',
                    description: 'Axis of reflection.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:reflect([1, 2], [0, 1])',
                'lin:reflect([1, 2, 3], [0, 0, 1])',
            ],
        },
        'lin:refract': {
            title: 'lin:refract',
            category: 'Linear Algebra',
            description: 'Refracts a vector across a given axis.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: 'Vector to refract.',
                },
                axis: {
                    type: 'vector',
                    description: 'Axis of refraction.',
                },
                eta: {
                    type: 'number',
                    description: 'Refraction index.',
                },
            },
            variants: [
                { argumentNames: ['vector', 'axis', 'eta'] },
            ],
            examples: [
                'lin:refract([1, 2], [0, 1], 1.5)',
                'lin:refract([1, 2, 3], [0, 0, 1], 1.5)',
            ],
        },
        'lin:lerp': {
            title: 'lin:lerp',
            category: 'Linear Algebra',
            description: 'Performs linear interpolation between two vectors.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Start vector.',
                },
                b: {
                    type: 'vector',
                    description: 'End vector.',
                },
                t: {
                    type: 'number',
                    description: 'Interpolation factor (0 to 1).',
                },
            },
            variants: [
                { argumentNames: ['a', 'b', 't'] },
            ],
            examples: [
                'lin:lerp([1, 2], [3, 4], 0.5)',
                'lin:lerp([1, 2], [3, 4], 2)',
                'lin:lerp([1, 2], [3, 4], -1)',
                'lin:lerp([1, 2, 3], [4, 5, 6], 0.25)',
            ],
        },
        'lin:rotate2d': {
            title: 'lin:rotate2d',
            category: 'Linear Algebra',
            description: 'Rotates a 2D vector by a given angle in radians.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Vector to rotate.',
                },
                b: {
                    type: 'number',
                    description: 'Angle in b.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:rotate2d([1, 0], PI / 2)',
                'lin:rotate2d([0, 1], PI)',
            ],
        },
        'lin:rotate3d': {
            title: 'lin:rotate3d',
            category: 'Linear Algebra',
            description: 'Rotates a 3D vector around a given axis by a given angle in radians.',
            returns: {
                type: 'vector',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to rotate.',
                },
                axis: {
                    type: 'vector',
                    description: 'Axis of rotation.',
                },
                radians: {
                    type: 'number',
                    description: 'Angle in radians.',
                },
            },
            variants: [
                { argumentNames: ['v', 'axis', 'radians'] },
            ],
            examples: [
                'lin:rotate3d([1, 0, 0], [0, 1, 0], PI / 2)',
                'lin:rotate3d([0, 1, 0], [1, 0, 0], PI)',
            ],
        },
        'lin:dot': {
            title: 'lin:dot',
            category: 'Linear Algebra',
            description: 'Calculates the dot product of two vectors. The result is a scalar.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'First vector.',
                },
                b: {
                    type: 'vector',
                    description: 'Second vector.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:dot([1, 2], [3, 4])',
                'lin:dot([1, 2, 3], [4, 5, 6])',
            ],
        },
        'lin:cross': {
            title: 'lin:cross',
            category: 'Linear Algebra',
            description: 'Calculates the cross product of two 3D vectors. The result is a vector perpendicular to both input vectors.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'First vector (3D).',
                },
                b: {
                    type: 'vector',
                    description: 'Second vector (3D).',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:cross([1, 2, 3], [4, 5, 6])',
                'lin:cross([1, 0, 0], [0, 1, 0])',
                'lin:cross([0, 0, 1], [1, 0, 0])',
                'lin:cross([1, 2, 3], [0, 0, 0])',
                'lin:cross([0, 0, 0], [1, 2, 3])',
            ],
        },
        'lin:normalize-minmax': {
            title: 'lin:normalize-minmax',
            category: 'Linear Algebra',
            description: 'Normalizes the vector using min-max normalization. The result is a vector with values between 0 and 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:normalize-minmax([1, 2, 3])',
                'lin:normalize-minmax([1, 2, -3])',
                'lin:normalize-minmax([1, 2, 3, 4])',
                'lin:normalize-minmax([1, 2, -3, 4])',
                'lin:normalize-minmax([1, 2, 3, 40, 50])',
            ],
        },
        'lin:normalize-zscore': {
            title: 'lin:normalize-zscore',
            category: 'Linear Algebra',
            description: 'Normalizes the vector using z-score normalization. The result is a vector with mean 0 and standard deviation 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:normalize-zscore([1, 2, 3])',
                'lin:normalize-zscore([1, 2, -3])',
                'lin:normalize-zscore([1, 2, 3, 4])',
                'lin:normalize-zscore([1, 2, -3, 4])',
                'lin:normalize-zscore([1, 2, 3, 40, 50])',
            ],
        },
        'lin:normalize-robust': {
            title: 'lin:normalize-robust',
            category: 'Linear Algebra',
            description: 'Normalizes the vector using robust normalization. The result is a vector with median 0 and median absolute deviation 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:normalize-robust([1, 2, 3])',
                'lin:normalize-robust([1, 2, -3])',
                'lin:normalize-robust([1, 2, 3, 4])',
                'lin:normalize-robust([1, 2, -3, 4])',
                'lin:normalize-robust([1, 2, 3, 40, 50])',
            ],
        },
        'lin:normalize-l1': {
            title: 'lin:normalize-l1',
            category: 'Linear Algebra',
            description: 'Normalizes the vector using L1 normalization. The result is a vector with L1 norm equal to 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:normalize-l1([1, 2, 3])',
                'lin:normalize-l1([1, 2, -3])',
                'lin:normalize-l1([1, 2, 3, 4])',
                'lin:normalize-l1([1, 2, -3, 4])',
                'lin:normalize-l1([1, 2, 3, 40, 50])',
            ],
        },
        'lin:normalize-l2': {
            title: 'lin:normalize-l2',
            category: 'Linear Algebra',
            description: 'Normalizes the vector using L2 normalization. The result is a vector with L2 norm equal to 1.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:normalize-l2([1, 2, 3])',
                'lin:unit([1, 2, 3])',
                'lin:normalize-l2([1, 2, -3])',
                'lin:normalize-l2([1, 2, 3, 4])',
                'lin:normalize-l2([1, 2, -3, 4])',
                'lin:normalize-l2([1, 2, 3, 40, 50])',
            ],
            aliases: [
                'lin:unit',
                'lin:normalize',
            ],
        },
        'lin:normalize-log': {
            title: 'lin:normalize-log',
            category: 'Linear Algebra',
            description: 'Normalizes the vector using natural log normalization. The result is a vector with log-transformed values.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to normalize.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:normalize-log([1, 2, 3])',
                'lin:normalize-log([1, 2, 3, 4])',
                'lin:normalize-log([1, 2, 3, 40, 50])',
            ],
        },
        'lin:angle': {
            title: 'lin:angle',
            category: 'Linear Algebra',
            description: 'Calculates the `angle` between two vectors in radians.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:angle([1, 0], [0, 1])',
                'lin:angle([1, 0, 1], [0, 1, 0])',
            ],
        },
        'lin:projection': {
            title: 'lin:projection',
            category: 'Linear Algebra',
            description: 'Calculates the **projection** of vector `a` onto vector `b`.',
            returns: {
                type: 'vector',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:projection([1, 2], [3, 4])',
                'lin:projection([1, 2, 3], [4, 5, 6])',
            ],
        },
        'lin:collinear?': {
            title: 'lin:collinear?',
            category: 'Linear Algebra',
            description: 'Checks if two vectors are **collinear**.',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:collinear?([1, 2], [2, 4])',
                'lin:collinear?([1, 2], [-2, -4])',
                'lin:collinear?([1, 2, 3], [2, 4, 6])',
            ],
        },
        'lin:parallel?': {
            title: 'lin:parallel?',
            category: 'Linear Algebra',
            description: 'Checks if two vectors are **parallel**.',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:parallel?([1, 2], [2, 4])',
                'lin:parallel?([1, 2], [-2, -4])',
                'lin:parallel?([1, 2, 3], [2, 4, 6])',
                'lin:parallel?([1, 2], [3, 4])',
            ],
        },
        'lin:orthogonal?': {
            title: 'lin:orthogonal?',
            category: 'Linear Algebra',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Checks if two vectors are **orthogonal**.',
            examples: [
                'lin:orthogonal?([1, 0], [0, 1])',
                'lin:orthogonal?([1, 0, 1], [0, 1, 0])',
                'lin:orthogonal?([1, 2], [2, -1])',
            ],
        },
        'lin:cosine-similarity': {
            title: 'lin:cosine-similarity',
            category: 'Linear Algebra',
            description: 'Calculates the **cosine similarity** between two vectors. The result is a value between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:cosine-similarity([1, 2], [3, 4])',
                'lin:cosine-similarity([1, 2, 3], [4, 5, 6])',
                'lin:cosine-similarity([1, 0], [0, 1])',
            ],
        },
        'lin:euclidean-distance': {
            title: 'lin:euclidean-distance',
            category: 'Linear Algebra',
            description: 'Calculates the **Euclidean distance** between two vectors. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:euclidean-distance([1, 2], [3, 4])',
                'lin:euclidean-distance([1, 2, 3], [4, 5, 6])',
                'lin:euclidean-distance([1, 0], [0, 1])',
            ],
            aliases: [
                'lin:distance',
                'lin:l2-distance',
            ],
        },
        'lin:euclidean-norm': {
            title: 'lin:euclidean-norm',
            category: 'Linear Algebra',
            description: 'Calculates the **Euclidean norm** (L2 norm) of a vector. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:euclidean-norm([1, 2])',
                'lin:euclidean-norm([3, 4])',
                'lin:euclidean-norm([1, 2, 3])',
            ],
            aliases: [
                'lin:l2-norm',
                'lin:length',
            ],
        },
        'lin:manhattan-distance': {
            title: 'lin:manhattan-distance',
            category: 'Linear Algebra',
            description: 'Calculates the **Manhattan distance** between two vectors. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:manhattan-distance([1, 2], [3, 4])',
                'lin:manhattan-distance([1, 2, 3], [4, 5, 6])',
                'lin:manhattan-distance([1, 0], [0, 1])',
            ],
            aliases: [
                'lin:l1-distance',
                'lin:cityblock-distance',
            ],
        },
        'lin:manhattan-norm': {
            title: 'lin:manhattan-norm',
            category: 'Linear Algebra',
            description: 'Calculates the **Manhattan norm** (L1 norm) of a vector. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:manhattan-norm([1, 2])',
                'lin:manhattan-norm([3, 4])',
                'lin:manhattan-norm([1, 2, 3])',
            ],
            aliases: [
                'lin:l1-norm',
                'lin:cityblock-norm',
            ],
        },
        'lin:hamming-distance': {
            title: 'lin:hamming-distance',
            category: 'Linear Algebra',
            description: 'Calculates the **Hamming distance** between two vectors. The result is a non-negative integer.',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:hamming-distance([1, 2], [3, 4])',
                'lin:hamming-distance([1, 2, 3], [4, 5, 6])',
                'lin:hamming-distance([1, 0], [0, 1])',
            ],
        },
        'lin:hamming-norm': {
            title: 'lin:hamming-norm',
            category: 'Linear Algebra',
            description: 'Calculates the **Hamming norm** of a vector. The result is a non-negative integer.',
            returns: {
                type: 'integer',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:hamming-norm([1, 2])',
                'lin:hamming-norm([3, 4])',
                'lin:hamming-norm([1, 2, 3])',
            ],
        },
        'lin:chebyshev-distance': {
            title: 'lin:chebyshev-distance',
            category: 'Linear Algebra',
            description: 'Calculates the **Chebyshev distance** between two vectors. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:chebyshev-distance([1, 2], [3, 4])',
                'lin:chebyshev-distance([1, 2, 3], [4, 5, 6])',
                'lin:chebyshev-distance([1, 0], [0, 1])',
            ],
        },
        'lin:chebyshev-norm': {
            title: 'lin:chebyshev-norm',
            category: 'Linear Algebra',
            description: 'Calculates the **Chebyshev norm** of a vector. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                v: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
            },
            variants: [
                { argumentNames: ['v'] },
            ],
            examples: [
                'lin:chebyshev-norm([1, 2])',
                'lin:chebyshev-norm([3, 4])',
                'lin:chebyshev-norm([1, 2, 3])',
            ],
        },
        'lin:minkowski-distance': {
            title: 'lin:minkowski-distance',
            category: 'Linear Algebra',
            description: 'Calculates the **Minkowski distance** between two vectors. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: __assign(__assign({}, getOperatorArgs('vector', 'vector')), { p: {
                    type: 'number',
                    description: 'Order of the norm (p).',
                } }),
            variants: [
                { argumentNames: ['a', 'b', 'p'] },
            ],
            examples: [
                'lin:minkowski-distance([1, 2], [3, 4], 2)',
                'lin:minkowski-distance([1, 2, 3], [4, 5, 6], 3)',
                'lin:minkowski-distance([1, 0], [0, 1], 1)',
            ],
        },
        'lin:minkowski-norm': {
            title: 'lin:minkowski-norm',
            category: 'Linear Algebra',
            description: 'Calculates the **Minkowski norm** of a vector. The result is a non-negative number.',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Vector to calculate the norm for.',
                },
                b: {
                    type: 'number',
                    description: 'Order of the norm (p).',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:minkowski-norm([1, 2], 2)',
                'lin:minkowski-norm([3, 4], 3)',
                'lin:minkowski-norm([1, 2, 3], 4)',
            ],
        },
        'lin:cov': {
            title: 'lin:cov',
            category: 'Linear Algebra',
            description: 'Calculates the **covariance** between two vectors. The result is a number.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:cov([1, 2], [3, 4])',
                'lin:cov([1, 2, 3], [4, 5, 6])',
                'lin:cov([1, 0], [0, 1])',
            ],
        },
        'lin:corr': {
            title: 'lin:corr',
            category: 'Linear Algebra',
            description: 'Calculates the **correlation** between two vectors. The result is a number between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:corr([1, 2], [3, 4])',
                'lin:corr([1, 2, 3], [4, 5, 6])',
                'lin:corr([1, 0], [0, 1])',
            ],
        },
        'lin:spearman-corr': {
            title: 'lin:spearman-corr',
            category: 'Linear Algebra',
            description: 'Calculates the **Spearman rank correlation** between two vectors. The result is a number between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:spearman-corr([1, 2], [3, 4])',
                'lin:spearman-corr([1, 2, 3], [4, 5, 6])',
                'lin:spearman-corr([1, 0], [0, 1])',
            ],
            aliases: ['lin:spearman-rho'],
        },
        'lin:pearson-corr': {
            title: 'lin:pearson-corr',
            category: 'Linear Algebra',
            description: 'Calculates the **Pearson correlation** between two vectors. The result is a number between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:pearson-corr([1, 2], [3, 4])',
                'lin:pearson-corr([1, 2, 3], [4, 5, 6])',
                'lin:pearson-corr([1, 0], [0, 1])',
            ],
        },
        'lin:kendall-tau': {
            title: 'lin:kendall-tau',
            category: 'Linear Algebra',
            description: 'Calculates the **Kendall Tau** rank correlation coefficient between two vectors. The result is a number between -1 and 1.',
            returns: {
                type: 'number',
            },
            args: __assign({}, getOperatorArgs('vector', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:kendall-tau([1, 2], [3, 4])',
                'lin:kendall-tau([1, 2, 3], [4, 5, 6])',
                'lin:kendall-tau([1, 0], [0, 1])',
            ],
        },
        'lin:autocorrelation': {
            title: 'lin:autocorrelation',
            category: 'Linear Algebra',
            description: 'Calculates the **autocorrelation** of a vector. The result is a vector of autocorrelation coefficients.',
            returns: {
                type: 'vector',
            },
            args: {
                a: {
                    type: 'vector',
                    description: 'Vector to calculate the autocorrelation for.',
                },
                b: {
                    type: 'integer',
                    description: 'Lag value for the autocorrelation.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'lin:autocorrelation([1, 2, 3], -2)',
                'lin:autocorrelation([1, 2, 3], -1)',
                'lin:autocorrelation([1, 2, 3], 0)',
                'lin:autocorrelation([1, 2, 3], 1)',
                'lin:autocorrelation([1, 2, 3], 2)',
            ],
            aliases: ['lin:acf'],
        },
        'lin:cross-correlation': {
            title: 'lin:cross-correlation',
            category: 'Linear Algebra',
            description: 'Calculates the **cross-correlation** between two vectors. The result is a vector of cross-correlation coefficients.',
            returns: {
                type: 'vector',
            },
            args: __assign(__assign({}, getOperatorArgs('vector', 'vector')), { lag: {
                    type: 'integer',
                    description: 'Lag value for the cross-correlation.',
                } }),
            variants: [
                { argumentNames: ['a', 'b', 'lag'] },
            ],
            examples: [
                'lin:cross-correlation([1, 2, 3], [4, 5, 6], -2)',
                'lin:cross-correlation([1, 2, 3], [4, 5, 6], -1)',
                'lin:cross-correlation([1, 2, 3], [4, 5, 6], 0)',
                'lin:cross-correlation([1, 2, 3], [4, 5, 6], 1)',
                'lin:cross-correlation([1, 2, 3], [4, 5, 6], 2)',
            ],
            aliases: ['lin:ccf'],
        },
        'lin:rref': {
            title: 'lin:rref',
            category: 'Linear Algebra',
            description: 'Calculates the **Reduced Row Echelon Form** (RREF) of a matrix.',
            returns: {
                type: 'matrix',
            },
            args: {
                m: {
                    type: 'matrix',
                    description: 'Matrix to calculate the RREF for.',
                },
            },
            variants: [
                { argumentNames: ['m'] },
            ],
            examples: [
                'lin:rref([[1, 2], [3, 4]])',
                'lin:rref([[1, 2, 3], [4, 5, 6], [7, 8, 9]])',
                'lin:rref([[1, 2, 3], [7, 8, 9], [4, 5, 7]])',
            ],
        },
        'lin:solve': {
            title: 'lin:solve',
            category: 'Linear Algebra',
            description: 'Solves a system of linear equations represented by a matrix and a vector.',
            returns: {
                type: 'vector',
            },
            args: __assign({}, getOperatorArgs('matrix', 'vector')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                "lin:solve([\n  [2, 1, -1, 1], \n  [4, 5, -3, 2], \n  [6, -2, 5, -3], \n  [8, 3, 2, 4]\n], [5, 10, 2, 17])",
                'lin:solve([[2, 0, 0], [3, 1, 0], [4, 5, 6]], [4, 5, 38])',
                'lin:solve([[2, 3], [1, -1]], [8, 2])',
            ],
        },
        'lin:to-polar': {
            title: 'lin:to-polar',
            category: 'Linear Algebra',
            description: 'Converts a 2D vector to polar coordinates.',
            returns: {
                type: 'vector',
            },
            args: {
                vector: {
                    type: 'vector',
                    description: '2D Vector to convert.',
                },
            },
            variants: [
                { argumentNames: ['vector'] },
            ],
            examples: [
                'lin:to-polar([1, 2])',
                'lin:to-polar([3, 4])',
            ],
        },
        'lin:from-polar': {
            title: 'lin:from-polar',
            category: 'Linear Algebra',
            description: 'Converts polar coordinates to a 2D vector.',
            returns: {
                type: 'vector',
            },
            args: {
                polar: {
                    type: 'vector',
                    description: 'Polar coordinates to convert.',
                },
            },
            variants: [
                { argumentNames: ['polar'] },
            ],
            examples: [
                'lin:from-polar([1, PI / 4])',
                'lin:from-polar([1, 0])',
                'lin:from-polar([1, -PI / 2])',
            ],
        },
    };

    var predicateReference = {
        'boolean?': {
            title: 'boolean?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is a `boolean`, otherwise `false`.',
            examples: [
                'boolean?(true)',
                'boolean?(false)',
                'boolean?([1, 2, 3])',
                'boolean?(0)',
                'boolean?("A string")',
            ],
        },
        'null?': {
            title: 'null?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is `null`, otherwise `false`.',
            examples: [
                'null?(null)',
                'null?(false)',
                'null?([1, 2, 3])',
                'null?(0)',
                'null?("A string")',
            ],
        },
        'number?': {
            title: 'number?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is a number, otherwise `false`.',
            examples: [
                'number?(0)',
                'number?(2)',
                'number?(-0.12)',
                'number?(false)',
                'number?([1, 2, 3])',
                'number?("A string")',
            ],
        },
        'string?': {
            title: 'string?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is a string, otherwise `false`.',
            examples: [
                'string?("")',
                'string?("A string")',
                'string?(true ? "A string" : false)',
                'string?(false)',
                'string?([1, 2, 3])',
                'string?(100)',
            ],
        },
        'function?': {
            title: 'function?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is a function, otherwise `false`.',
            examples: [
                'function?(+)',
                'function?(/)',
                'function?((x, y) -> x + y)',
                'function?(false)',
                'function?("false")',
                'function?([1, 2, 3])',
            ],
        },
        'integer?': {
            title: 'integer?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is an integer, otherwise `false`.',
            examples: [
                'integer?(0)',
                'integer?(-12)',
                'integer?(42)',
                'integer?(10.1)',
                'integer?((x, y) -> x + y)',
                'integer?(false)',
                'integer?("false")',
                'integer?([1, 2, 3])',
            ],
        },
        'array?': {
            title: 'array?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is an array, otherwise `false`.',
            examples: [
                'array?([])',
                'array?([1, 2, 3])',
                'array?(object("a", 10))',
                'array?(42)',
                'array?(10.1)',
                'array?((x, y) -> x + y)',
            ],
        },
        'object?': {
            title: 'object?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is an object, otherwise `false`.',
            examples: [
                'object?(object("a", 10))',
                'object?(42)',
                'object?(10.1)',
                'object?((x, y) -> x + y)',
                'object?(#"^start")',
                'object?("false")',
                'object?([1, 2, 3])',
            ],
        },
        'coll?': {
            title: 'coll?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is a Coll i.e. an array, an object or a string, otherwise `false`.',
            examples: [
                'coll?([])',
                'coll?([1, 2, 3])',
                'coll?(object("a", 10))',
                'coll?("Albert")',
                'coll?(42)',
                'coll?(10.1)',
                'coll?((x, y) -> x + y)',
            ],
        },
        'seq?': {
            title: 'seq?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is a Seq i.e. an array or a string, otherwise `false`.',
            examples: [
                'seq?([])',
                'seq?([1, 2, 3])',
                'seq?(object("a", 10))',
                'seq?("Albert")',
                'seq?(42)',
                'seq?(10.1)',
                'seq?((x, y) -> x + y)',
            ],
        },
        'regexp?': {
            title: 'regexp?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is a regexp, otherwise `false`.',
            examples: [
                'regexp?(regexp("^start"))',
                'regexp?(#"^start")',
                'regexp?(-12)',
                'regexp?({})',
                'regexp?(10.1)',
                'regexp?((x, y) -> x + y)',
                'regexp?(false)',
                'regexp?("false")',
                'regexp?([1, 2, 3])',
            ],
        },
        'zero?': {
            title: 'zero?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is `0`, otherwise `false`.',
            examples: [
                'zero?(0)',
                'zero?(-0.0)',
                'zero?(1)',
                'zero?(0.1)',
            ],
        },
        'pos?': {
            title: 'pos?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is greater than `0`, otherwise `false`.',
            examples: [
                'pos?(0)',
                'pos?(-0.0)',
                'pos?(1)',
                'pos?(-0.1)',
            ],
        },
        'neg?': {
            title: 'neg?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is less than `0`, otherwise `false`.',
            examples: [
                'neg?(0)',
                'neg?(-0.0)',
                'neg?(1)',
                'neg?(-0.1)',
            ],
        },
        'even?': {
            title: 'even?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is even, otherwise `false`.',
            examples: [
                'even?(0)',
                'even?(-0.0)',
                'even?(-1)',
                'even?(2.1)',
            ],
        },
        'odd?': {
            title: 'odd?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is odd, otherwise `false`.',
            examples: [
                'odd?(1.0)',
                'odd?(1.001)',
                'odd?(-1)',
                'odd?(2.1)',
            ],
        },
        'finite?': {
            title: 'finite?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is finite, otherwise `false`.',
            examples: [
                'finite?(1.0)',
                'finite?(1 / 0)',
                'finite?(-1 / 0)',
            ],
        },
        'negative-infinity?': {
            title: 'negative-infinity?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x equals negative infinity, otherwise `false`.',
            examples: [
                'negative-infinity?(1.0)',
                'negative-infinity?(1 / 0)',
                'negative-infinity?(-1 / 0)',
            ],
        },
        'positive-infinity?': {
            title: 'positive-infinity?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x equals positive infinity, otherwise `false`.',
            examples: [
                'positive-infinity?(1.0)',
                'positive-infinity?(1 / 0)',
                'positive-infinity?(-1 / 0)',
            ],
        },
        'false?': {
            title: 'false?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is `true`, otherwise `false`.',
            examples: [
                'false?(false)',
                'false?(true)',
                'false?(1)',
                'false?(0)',
            ],
        },
        'true?': {
            title: 'true?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is `true`, otherwise `false`.',
            examples: [
                'true?(false)',
                'true?(true)',
                'true?(1)',
                'true?(0)',
            ],
        },
        'empty?': {
            title: 'empty?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: ['collection', 'string', 'null'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `true` if $x is empty or `null`, otherwise `false`.',
            examples: [
                'empty?([])',
                'empty?([1, 2, 3])',
                'empty?({})',
                'empty?({ a: 2 })',
                'empty?("")',
                'empty?("Albert")',
                'empty?(null)',
            ],
        },
        'not-empty?': {
            title: 'not-empty?',
            category: 'Predicate',
            returns: {
                type: 'boolean',
            },
            args: {
                x: {
                    type: ['collection', 'string', 'null'],
                },
            },
            variants: [
                { argumentNames: ['x'] },
            ],
            description: 'Returns `false` if $x is empty or `null`, otherwise `true`.',
            examples: [
                'not-empty?([])',
                'not-empty?([1, 2, 3])',
                'not-empty?({})',
                'not-empty?({ a: 2 })',
                'not-empty?("")',
                'not-empty?("Albert")',
                'not-empty?(null)',
            ],
        },
        'vector?': {
            title: 'vector?',
            category: 'Predicate',
            description: 'Checks if a value is a `vector`. A `vector` is an array of `numbers`.',
            returns: {
                type: 'boolean',
            },
            args: {
                value: {
                    type: 'any',
                    description: 'The value to check.',
                },
            },
            variants: [
                { argumentNames: ['value'] },
            ],
            examples: [
                'vector?(1)',
                'vector?([1, 2, 3])',
                'vector?([1, 2, "3"])',
            ],
        },
        'matrix?': {
            title: 'matrix?',
            category: 'Predicate',
            description: 'Checks if a value is a `matrix`. A `matrix` is an array of arrays of `numbers`.',
            returns: {
                type: 'boolean',
            },
            args: {
                value: {
                    type: 'any',
                    description: 'The value to check.',
                },
            },
            variants: [
                { argumentNames: ['value'] },
            ],
            examples: [
                'matrix?(1)',
                'matrix?([1, 2, 3])',
                'matrix?([[1, 2], [3, 4]])',
                'matrix?([[1, 2], [3, "4"]])',
                'matrix?([[1, 2], [3]])',
            ],
        },
        'grid?': {
            title: 'grid?',
            category: 'Predicate',
            description: 'Checks if a `value` is a `grid`. A `grid` is an `array` of `arrays` where all inner `arrays` have the same length.',
            returns: {
                type: 'boolean',
            },
            args: {
                value: {
                    type: 'any',
                    description: 'The value to check.',
                },
            },
            variants: [
                { argumentNames: ['value'] },
            ],
            examples: [
                'grid?("1")',
                'grid?(["1", 2, 3])',
                'grid?([["1", 2], [3, 4]])',
                'grid?([["1", 2], [3, "4"]])',
                'grid?([["1", 2], [3]])',
            ],
        },
    };

    var regularExpressionReference = {
        'regexp': {
            title: 'regexp',
            category: 'Regular expression',
            returns: {
                type: 'regexp',
            },
            args: {
                pattern: {
                    type: 'string',
                },
                flags: {
                    type: 'string',
                    description: 'Optional flags for the regular expression. Possible values are the same as Javascript RegExp takes.',
                },
            },
            variants: [
                { argumentNames: ['pattern'] },
                { argumentNames: ['pattern', 'flags'] },
            ],
            description: 'Creates a RegExp from $pattern and $flags.',
            examples: [
                'regexp("^\\s*(.*)$")',
                '#"^\\s*(.*)$"',
                'regexp("albert", "ig")',
                '#"albert"ig',
            ],
            noOperatorDocumentation: true,
        },
        'match': {
            title: 'match',
            category: 'Regular expression',
            returns: {
                type: 'any',
                array: true,
            },
            args: __assign({}, getOperatorArgs('regexp', 'string')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: "Matches $b against regular expression $a.\nIf $b is a string and matches the regular expression, a `match`-array is returned, otherwise `null` is returned.",
            examples: [
                'match("  A string", regexp("^\\\\s*(.*)$"))',
                'match("  A string", #"^\\s*(.*)$")',
                'match("My name is Albert", #"albert"i)',
                'match("My name is Ben", #"albert"i)',
                'match(null, #"albert"i)',
                'match(1, #"albert"i)',
                'match({}, #"albert"i)',
            ],
        },
        'replace': {
            title: 'replace',
            category: 'Regular expression',
            returns: {
                type: 'any',
                array: true,
            },
            args: __assign(__assign({}, getOperatorArgs('string', ['regexp', 'string'])), { x: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['a', 'b', 'x'] },
            ],
            description: 'Returns a new string with first match of regular expression $b replaced by $x.',
            examples: [
                'replace("Duck duck", "u", "i")',
                'replace("Duck duck", #"u", "i")',
                'replace("abcABC", regexp("a", "i"), "-")',
                'replace("abcABC", regexp("a", "gi"), "-")',
                'replace("abcABC", #"a"i, "-")',
                'replace("abcABC", #"a"gi, "-")',
            ],
        },
        'replace-all': {
            title: 'replace-all',
            category: 'Regular expression',
            returns: {
                type: 'any',
                array: true,
            },
            args: __assign(__assign({}, getOperatorArgs('string', ['regexp', 'string'])), { x: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['a', 'b', 'x'] },
            ],
            description: 'Returns a new string with all matches of regular expression $b replaced by $x.',
            examples: [
                'replace-all("Duck duck", "u", "i")',
                'replace-all("Duck duck", regexp("u"), "i")',
                'replace-all("abcABC", regexp("a", "i"), "-")',
                'replace-all("abcABC", regexp("a", "gi"), "-")',
                'replace-all("abcABC", #"a"i, "-")',
                'replace-all("abcABC", #"a"gi, "-")',
            ],
        },
    };

    var sequenceReference = {
        'nth': {
            title: 'nth',
            category: 'Sequence',
            returns: {
                type: 'any',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'integer')), { 'seq': {
                    type: ['sequence', 'null'],
                }, 'n': {
                    type: 'integer',
                }, 'not-found': {
                    type: 'any',
                } }),
            variants: [
                { argumentNames: ['seq', 'n'] },
                { argumentNames: ['seq', 'n', 'not-found'] },
            ],
            description: 'Accesses element $n of $seq. Accessing out-of-bounds indices returns $not-found, if present, else `null`.',
            examples: [
                '[1, 2, 3] nth 1',
                '"A string" nth 3',
                'nth([1, 2, 3], 1)',
                'nth([1, 2, 3], 3)',
                'nth([1, 2, 3], -1)',
                'nth([1, 2, 3], 3, 99)',
                'nth("A string", 1)',
                'nth("A string", 3)',
                'nth("A string", -3)',
                'nth("A string", 30, "X")',
                'nth(null, 1)',
                'nth(null, 1, "Default value")',
            ],
        },
        'push': {
            title: 'push',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'any')), { seq: {
                    type: 'sequence',
                }, values: {
                    type: 'any',
                    rest: true,
                    description: 'At least one.',
                } }),
            variants: [
                { argumentNames: ['seq', 'values'] },
            ],
            description: 'Returns copy of $seq with $values added to the end of it.',
            examples: [
                '[1, 2, 3] push 4',
                '"Albert" push "!"',
                'push([1, 2, 3], 4)',
                'push([1, 2, 3], 4, 5, 6)',
                "\nlet l = [1, 2, 3];\npush(l, 4);\nl",
            ],
        },
        'pop': {
            title: 'pop',
            category: 'Sequence',
            returns: {
                type: ['sequence', 'null'],
                rest: true,
            },
            args: {
                seq: {
                    type: 'sequence',
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: 'Returns a copy of $seq with last element removed. If $seq is empty `null` is returned.',
            examples: [
                'pop([1, 2, 3])',
                'pop([])',
            ],
        },
        'unshift': {
            title: 'unshift',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'any')), { seq: {
                    type: 'sequence',
                }, values: {
                    type: 'any',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['seq', 'values'] },
            ],
            description: 'Returns copy of $seq with $values added to the beginning.',
            examples: [
                '[1, 2, 3] unshift 4',
                'unshift([1, 2, 3], 4)',
                'unshift([1, 2, 3], 4, 5, 6)',
                "\nlet l = [1, 2, 3];\nunshift(l, 4);\nl",
            ],
        },
        'shift': {
            title: 'shift',
            category: 'Sequence',
            returns: {
                type: ['sequence', 'null'],
            },
            args: {
                seq: {
                    type: 'sequence',
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: 'Returns a copy of $seq with first element removed. If $seq is empty `null` is returned.',
            examples: [
                'shift([1, 2, 3])',
                'shift([])',
            ],
        },
        'slice': {
            title: 'slice',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'integer')), { seq: {
                    type: 'sequence',
                    rest: true,
                }, start: {
                    type: 'integer',
                    description: 'Defaults to `0`.',
                }, stop: {
                    type: 'integer',
                    description: 'Defaults lenght of sequence + 1.',
                } }),
            variants: [
                { argumentNames: ['seq'] },
                { argumentNames: ['seq', 'start'] },
                { argumentNames: ['seq', 'start', 'stop'] },
            ],
            description: 'Returns a copy of a portion of $seq from index $start (inclusive) to $stop (exclusive).',
            examples: [
                '[1, 2, 3, 4, 5] slice 2',
                'slice([1, 2, 3, 4, 5], 2, 4)',
                'slice([1, 2, 3, 4, 5], 2)',
            ],
        },
        'splice': {
            title: 'splice',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: {
                seq: {
                    type: 'sequence',
                    rest: true,
                },
                start: {
                    type: 'integer',
                },
                deleteCount: {
                    type: 'integer',
                },
                items: {
                    type: 'any',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['seq', 'start', 'deleteCount'] },
                { argumentNames: ['seq', 'start', 'deleteCount', 'items'] },
            ],
            description: 'Returns a a spliced array. Removes $deleteCount elements from $seq starting at $start and replaces them with $items. If $start is negative, it is counting from the end of the array.',
            examples: [
                'splice([1, 2, 3, 4, 5], 2, 2, "x")',
                'splice([1, 2, 3, 4, 5], -2, 1, "x")',
                'splice("Albert", 2, 2, "fo")',
            ],
        },
        'position': {
            title: 'position',
            category: 'Sequence',
            returns: {
                type: ['number', 'null'],
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: ['sequence', 'null'],
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq', 'fun'] },
            ],
            description: 'Returns the index of the first elements that passes the test implemented by $fun. If no element was found, `null` is returned.',
            examples: [
                "\nposition(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                "\nposition(\n  [5, 10, 15, 20],\n  -> $ > 10\n)",
                "\nposition(\n  [5, 10, 15, 20],\n  -> $ > 100\n)",
                "\nposition(\n  null,\n  -> $ > 100\n)",
            ],
        },
        'index-of': {
            title: 'index-of',
            category: 'Sequence',
            returns: {
                type: ['number', 'null'],
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'any')), { seq: {
                    type: ['sequence', 'null'],
                }, x: {
                    type: 'any',
                } }),
            variants: [
                { argumentNames: ['seq', 'x'] },
            ],
            description: 'Returns the index of $x in $seq. If element is not present in $seq `null` is returned.',
            examples: [
                '[[1], [2], [1], [2]] index-of [1]',
                'index-of(["Albert", "Mojir", 160, [1, 2]], "Mojir")',
                'index-of([5, 10, 15, 20], 15)',
                'index-of([5, 10, 15, 20], 1)',
                'index-of(null, 1)',
            ],
        },
        'last-index-of': {
            title: 'last-index-of',
            category: 'Sequence',
            returns: {
                type: ['number', 'null'],
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'any')), { seq: {
                    type: ['sequence', 'null'],
                }, x: {
                    type: 'any',
                } }),
            variants: [
                { argumentNames: ['seq', 'x'] },
            ],
            description: 'Returns the last index of $x in $seq. If element is not present in $seq `null` is returned.',
            examples: [
                '[[1], [2], [1], [2]] last-index-of [1]',
                'last-index-of(["Albert", "Mojir", 160, [1, 2]], "Mojir")',
                'last-index-of([5, 10, 15, 20, 15], 15)',
                'last-index-of([5, 10, 15, 20], 1)',
                'last-index-of(null, 1)',
            ],
        },
        'some': {
            title: 'some',
            category: 'Sequence',
            returns: {
                type: 'any',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: ['sequence', 'null'],
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq', 'fun'] },
            ],
            description: 'Returns the first element that passes the test implemented by $fun. I no element was found, `null` is returned.',
            examples: [
                "\nsome(\n  [\"Albert\", \"Mojir\", 160, [1, 2]],\n  string?\n)",
                "\nsome(\n  [5, 10, 15, 20],\n  -> $ > 10\n)",
                "\nsome(\n  [1, 2, 3, 4],\n  -> $ > 10\n)",
                "\nsome(\n  [],\n  -> $ > 10\n)",
                "\nsome(\n  null,\n  -> $ > 10\n)",
            ],
        },
        'reverse': {
            title: 'reverse',
            category: 'Sequence',
            returns: {
                type: ['sequence', 'null'],
            },
            args: {
                seq: {
                    type: ['sequence', 'null'],
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: 'If $seq is an array, creates a new array with the elements from $seq in reversed order. If $seq is a string, returns new reversed string.',
            examples: [
                'reverse(["Albert", "Mojir", 160, [1, 2]])',
                'reverse([])',
                'reverse("Albert")',
                'reverse(null)',
            ],
        },
        'first': {
            title: 'first',
            category: 'Sequence',
            returns: {
                type: 'any',
            },
            args: {
                seq: {
                    type: ['sequence', 'null'],
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: 'Returns the first element of $seq. If $seq is empty or `null`, `null` is returned.',
            examples: [
                'first(["Albert", "Mojir", 160, [1, 2]])',
                'first([])',
                'first(null)',
            ],
        },
        'second': {
            title: 'second',
            category: 'Sequence',
            returns: {
                type: 'any',
            },
            args: {
                seq: {
                    type: ['sequence', 'null'],
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: 'Returns the second element of $seq. If $seq has less than two elements or is `null`, `null` is returned.',
            examples: [
                'second(["Albert", "Mojir", 160, [1, 2]])',
                'second([1])',
                'second([])',
                'second(null)',
            ],
        },
        'last': {
            title: 'last',
            category: 'Sequence',
            returns: {
                type: 'any',
            },
            args: {
                seq: {
                    type: ['sequence', 'null'],
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: 'Returns the last element of $seq. If $seq is empty, `null` is returned.',
            examples: [
                'last(["Albert", "Mojir", 160, [1, 2]])',
                'last([1, 2])',
                'last([1])',
                'last([])',
                'last(null)',
            ],
        },
        'rest': {
            title: 'rest',
            category: 'Sequence',
            returns: {
                type: ['sequence', 'null'],
            },
            args: {
                seq: {
                    type: 'sequence',
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: "If $seq is an array, returns a new array with all but the first element from $seq.\nIf $seq has less than two elements, an empty array is returned.\nFor string $seq returns all but the first characters in $seq.",
            examples: [
                'rest(["Albert", "Mojir", 160, [1, 2]])',
                'rest(["Albert"])',
                'rest([])',
                'rest("Albert")',
                'rest("A",)',
                'rest("")',
            ],
        },
        'next': {
            title: 'next',
            category: 'Sequence',
            returns: {
                type: ['sequence', 'null'],
            },
            args: {
                seq: {
                    type: 'sequence',
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: 'If $seq is an array, returns a new array with all but the first element from $seq. If $seq has less than two elements, `null` is returned. For string $seq returns all but the first characters in $seq. If length of string $seq is less than two, `null` is returned.',
            examples: [
                'next(["Albert", "Mojir", 160, [1, 2]])',
                'next(["Albert"])',
                'next([])',
                'next("Albert")',
                'next("A",)',
                'next("")',
            ],
        },
        'take': {
            title: 'take',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'integer')), { n: {
                    type: 'integer',
                }, seq: {
                    type: 'sequence',
                } }),
            variants: [
                { argumentNames: ['seq', 'n'] },
            ],
            description: 'Constructs a new array/string with the $n first elements from $seq.',
            examples: [
                '[1, 2, 3, 4, 5] take 3',
                'take([1, 2, 3, 4, 5], 3)',
                'take([1, 2, 3, 4, 5], 0)',
                'take("Albert", 2)',
                'take("Albert", 50)',
            ],
        },
        'take-last': {
            title: 'take-last',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'integer')), { n: {
                    type: 'integer',
                }, seq: {
                    type: 'sequence',
                } }),
            variants: [
                { argumentNames: ['n', 'seq'] },
            ],
            description: 'Constructs a new array with the $n last elements from $seq.',
            examples: [
                '[1, 2, 3, 4, 5] take-last 3',
                'take-last([1, 2, 3, 4, 5], 3)',
                'take-last([1, 2, 3, 4, 5], 0)',
            ],
        },
        'take-while': {
            title: 'take-while',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: 'sequence',
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq', 'fun'] },
            ],
            description: 'Returns the members of $seq in order, stopping before the first one for which `predicate` returns a falsy value.',
            examples: [
                "\ntake-while(\n  [1, 2, 3, 2, 1],\n  -> $ < 3\n)",
                "\ntake-while(\n  [1, 2, 3, 2, 1],\n  -> $ > 3\n)",
            ],
        },
        'drop': {
            title: 'drop',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'integer')), { seq: {
                    type: 'sequence',
                }, n: {
                    type: 'integer',
                } }),
            variants: [
                { argumentNames: ['seq', 'n'] },
            ],
            description: 'Constructs a new array/string with the $n first elements dropped from $seq.',
            examples: [
                'drop([1, 2, 3, 4, 5], 3)',
                'drop([1, 2, 3, 4, 5], 0)',
                'drop("Albert", 2)',
                'drop("Albert", 50)',
            ],
        },
        'drop-last': {
            title: 'drop-last',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'integer')), { seq: {
                    type: 'sequence',
                }, n: {
                    type: 'integer',
                } }),
            variants: [
                { argumentNames: ['seq', 'n'] },
            ],
            description: 'Constructs a new array with the $n last elements dropped from $seq.',
            examples: [
                '[1, 2, 3, 4, 5] drop-last 3',
                'drop-last([1, 2, 3, 4, 5], 3)',
                'drop-last([1, 2, 3, 4, 5], 0)',
            ],
        },
        'drop-while': {
            title: 'drop-while',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: 'sequence',
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq', 'fun'] },
            ],
            description: 'Returns the members of $seq in order, skipping the fist elements for witch the `predicate` returns a truethy value.',
            examples: [
                "\ndrop-while(\n  [1, 2, 3, 2, 1],\n  -> $ < 3\n)",
                "\ndrop-while(\n  [1, 2, 3, 2, 1],\n  -> $ > 3\n)",
            ],
        },
        'sort': {
            title: 'sort',
            category: 'Sequence',
            returns: {
                type: 'any',
                rest: true,
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: 'sequence',
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq'] },
                { argumentNames: ['seq', 'fun'] },
            ],
            description: 'Returns a new sequence with the elements from $seq sorted according to $fun. If no $fun is supplied, builtin `compare` will be used.',
            examples: [
                '[3, 1, 2] sort (a, b) -> b - a',
                'sort([3, 1, 2])',
                "\nsort(\n  [3, 1, 2],\n  (a, b) -> cond { case a < b: -1 case a > b: 1 case true: -1 }\n)",
                "\nsort(\n  [3, 1, 2],\n  (a, b) -> cond { case a > b: -1 case a < b: 1 case true: -1 }\n)",
            ],
        },
        'sort-by': {
            title: 'sort-by',
            category: 'Sequence',
            returns: {
                type: 'any',
                rest: true,
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: 'sequence',
                }, keyfn: {
                    type: 'function',
                }, comparer: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq', 'keyfn'] },
                { argumentNames: ['seq', 'keyfn', 'comparer'] },
            ],
            description: 'Returns a sorted sequence of the items in $seq, where the sort order is determined by comparing `(keyfn item)`. If no $comparer is supplied, uses builtin `compare`.',
            examples: [
                '["Albert", "Mojir", "Nina"] sort-by count',
                'sort-by(["Albert", "Mojir", "Nina"], count)',
                'sort-by("Albert", lower-case, -> $2 compare $1)',
            ],
        },
        'distinct': {
            title: 'distinct',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: {
                seq: {
                    type: 'sequence',
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: 'Returns a copy of $seq with no duplicates.',
            examples: [
                'distinct([[1], [2], [3], [1], [3], [5]])',
                'distinct([1, 2, 3, 1, 3, 5])',
                'distinct("Albert Mojir")',
                'distinct([])',
                'distinct("")',
            ],
        },
        'remove': {
            title: 'remove',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: 'sequence',
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq', 'fun'] },
            ],
            description: 'Returns a new sequence of items in $seq for witch `pred(item)` returns a falsy value.',
            examples: [
                '[1, 2, 3, 1, 3, 5] remove odd?',
                'remove([1, 2, 3, 1, 3, 5], even?)',
                'remove("Albert Mojir", -> "aoueiyAOUEIY" contains? $)',
            ],
        },
        'remove-at': {
            title: 'remove-at',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'integer')), { seq: {
                    type: 'sequence',
                }, n: {
                    type: 'number',
                } }),
            variants: [
                { argumentNames: ['seq', 'n'] },
            ],
            description: 'Returns a new sequence of all items in $seq except item at position $n. If $n is negative, it is counting from the end of the sequence.',
            examples: [
                '[1, 2, 3, 1, 3, 5] remove-at 2',
                '"Albert" remove-at -2',
                'remove-at([1, 2, 3, 1, 3, 5], 0)',
                'remove-at([1, 2, 3, 1, 3, 5], -1)',
                'remove-at("Albert Mojir", 6)',
            ],
        },
        'split-at': {
            title: 'split-at',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'integer')), { seq: {
                    type: 'sequence',
                }, n: {
                    type: 'number',
                } }),
            variants: [
                { argumentNames: ['seq', 'n'] },
            ],
            description: 'Returns a pair of sequence `[take(pos input), drop(pos input)]`.',
            examples: [
                '[1, 2, 3, 4, 5] split-at 2',
                '"Albert" split-at -2',
                'split-at([1, 2, 3, 4, 5], -2)',
                'split-at("Albert", 2)',
            ],
        },
        'split-with': {
            title: 'split-with',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: 'sequence',
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq', 'fun'] },
            ],
            description: 'Returns a pair of sequences `[take-while(input, fun), drop-while(input, fun)]`.',
            examples: [
                '[1, 2, 3, 4, 5] split-with odd?',
                'split-with([1, 2, 3, 4, 5], -> $ > 3)',
                'split-with("Albert", -> $ <= "o")',
            ],
        },
        'frequencies': {
            title: 'frequencies',
            category: 'Sequence',
            returns: {
                type: 'object',
            },
            args: {
                seq: {
                    type: 'sequence',
                },
            },
            variants: [
                { argumentNames: ['seq'] },
            ],
            description: 'Returns an object from distinct items in $seq to the number of times they appear. Note that all items in $seq must be valid object keys i.e. strings.',
            examples: [
                'frequencies(["Albert", "Mojir", "Nina", "Mojir"])',
                'frequencies("Pneumonoultramicroscopicsilicovolcanoconiosis")',
            ],
        },
        'group-by': {
            title: 'group-by',
            category: 'Sequence',
            returns: {
                type: 'object',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: 'sequence',
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq', 'fun'] },
            ],
            description: 'Returns an object of the elements of $seq keyed by the result of $fun on each element. The value at each key will be an array of the corresponding elements.',
            examples: [
                '[{ name: "Albert" }, { name: "Albert" }, { name: "Mojir" }] group-by "name"',
                'group-by([{name: "Albert"}, {name: "Albert"}, {name: "Mojir"}], "name")',
                'group-by("Albert Mojir", -> "aoueiAOUEI" contains? $ ? "vowel" : "other")',
            ],
        },
        'partition': {
            title: 'partition',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'number')), { seq: {
                    type: 'sequence',
                }, n: {
                    type: 'number',
                }, step: {
                    type: 'number',
                }, pad: {
                    type: 'array',
                } }),
            variants: [
                { argumentNames: ['seq', 'n'] },
                { argumentNames: ['seq', 'n', 'step'] },
                { argumentNames: ['seq', 'n', 'step', 'pad'] },
            ],
            description: 'Returns an array of sequences of $n items each, at offsets $step apart. If $step is not supplied, defaults to $n. If a $pad array is supplied, use its elements as necessary to complete last partition upto $n items. In case there are not enough padding elements, return a partition with less than $n items.',
            examples: [
                'range(20) partition 4',
                'partition(range(20), 4)',
                'partition(range(22), 4)',
                'partition(range(20), 4, 6)',
                'partition(range(20), 4, 3)',
                'partition(range(20), 3, 6, ["a"])',
                'partition(range(20), 4, 6, ["a"])',
                'partition(range(20), 4, 6, ["a", "b", "c", "d"])',
                'partition(["a", "b", "c", "d", "e", "f"], 3, 1)',
                'partition([1, 2, 3, 4], 10)',
                'partition([1, 2, 3, 4], 10, 10)',
                'partition([1, 2, 3, 4], 10, 10, [])',
                'partition([1, 2, 3, 4], 10, 10, null)',
                'partition("superfragilistic", 5)',
                'partition("superfragilistic", 5, 5, null)',
                'let foo = [5, 6, 7, 8]; partition(foo, 2, 1, foo)',
            ],
        },
        'partition-all': {
            title: 'partition-all',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'number')), { seq: {
                    type: 'sequence',
                }, n: {
                    type: 'number',
                }, step: {
                    type: 'number',
                } }),
            variants: [
                { argumentNames: ['seq', 'n'] },
                { argumentNames: ['seq', 'n', 'step'] },
            ],
            description: 'Returns an array of sequences like partition, but may include partitions with fewer than n items at the end.',
            examples: [
                '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] partition-all 4',
                'partition-all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4)',
                'partition([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4)',
                'partition-all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 2, 4)',
            ],
        },
        'partition-by': {
            title: 'partition-by',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'function')), { seq: {
                    type: 'sequence',
                }, fun: {
                    type: 'function',
                } }),
            variants: [
                { argumentNames: ['seq', 'fun'] },
            ],
            description: 'Applies $fun to each value in $seq, splitting it each time $fun returns a new value. Returns an array of sequences.',
            examples: [
                '[1, 2, 3, 4, 5] partition-by odd?',
                'partition-by([1, 2, 3, 4, 5], -> $ == 3)',
                'partition-by([1, 1, 1, 2, 2, 3, 3], odd?)',
                'partition-by("Leeeeeerrroyyy", identity)',
            ],
        },
        'starts-with?': {
            title: 'starts-with?',
            category: 'Sequence',
            returns: {
                type: 'boolean',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'sequence')), { seq: {
                    type: 'sequence',
                }, prefix: {
                    type: 'sequence',
                } }),
            variants: [
                { argumentNames: ['seq', 'prefix'] },
            ],
            description: 'Returns `true` if $seq starts with $prefix, otherwise `false`.',
            examples: [
                '[[1], [2], [3], [4], [5]] starts-with? [1]',
                'starts-with?([1, 2, 3, 4, 5], 1)',
                'starts-with?([1, 2, 3, 4, 5], [1])',
                'starts-with?("Albert", "Al")',
                'starts-with?("Albert", "al")',
            ],
        },
        'ends-with?': {
            title: 'ends-with?',
            category: 'Sequence',
            returns: {
                type: 'boolean',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'sequence')), { seq: {
                    type: 'sequence',
                }, suffix: {
                    type: 'sequence',
                } }),
            variants: [
                { argumentNames: ['seq', 'suffix'] },
            ],
            description: 'Returns `true` if $seq ends with $suffix, otherwise `false`.',
            examples: [
                '[[1], [2], [3], [4], [5]] starts-with? [5]',
                '[[1], [2], [3], [4], [5]] starts-with? 5',
                'ends-with?([1, 2, 3, 4, 5], 5)',
                'ends-with?([1, 2, 3, 4, 5], [5])',
                'ends-with?("Albert", "rt")',
                'ends-with?("Albert", "RT")',
            ],
        },
        'interleave': {
            title: 'interleave',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'sequence')), { seqs: {
                    type: 'sequence',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['seqs'] },
            ],
            description: 'Returns a sequence of the first item from each of the $seqs, then the second item from each of the $seqs, until all items from the shortest seq are exhausted.',
            examples: [
                '[1, 2, 3] interleave [4, 5, 6]',
                '"Albert" interleave ".,.,.,"',
                'interleave([1, 2, 3], [4, 5, 6])',
                'interleave([1, 2, 3], [4, 5, 6], [7, 8, 9])',
                'interleave([1, 2, 3], [4, 5, 6], [7, 8])',
                'interleave([1, 2, 3], [4, 5, 6], [7])',
                'interleave([1, 2, 3], [4, 5, 6], [])',
                'interleave([1, 2, 3], [])',
                'interleave([])',
            ],
        },
        'interpose': {
            title: 'interpose',
            category: 'Sequence',
            returns: {
                type: 'sequence',
            },
            args: __assign(__assign({}, getOperatorArgs('sequence', 'any')), { seq: {
                    type: 'sequence',
                }, separator: {
                    type: 'any',
                } }),
            variants: [
                { argumentNames: ['seq', 'separator'] },
            ],
            description: 'Returns a sequence of the elements of $seq separated by $separator. If $seq is a string, the separator must be a string.',
            examples: [
                '"Albert" interpose "-"',
                'interpose([1, 2, 3, 4, 5], "a")',
                'interpose(["Albert", "Mojir", "Nina"], ", ")',
                'interpose("Albert", ".")',
            ],
        },
    };

    var specialExpressionsReference = {
        'array': {
            title: 'array',
            category: 'Special expression',
            returns: {
                type: 'any',
                array: true,
            },
            args: {
                values: {
                    type: 'any',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['values'] },
            ],
            description: 'Makes new array from $values.',
            examples: [
                'array(1, 2, 3)',
                'array(array(null, false, true))',
                '[]',
                '[1, 2, 3]',
                '[1, 2, ...[3, 4, 5], 6]',
                '[[null, false, true]]',
                '[1, 2, 3][1]',
            ],
            noOperatorDocumentation: true,
        },
        'object': {
            title: 'object',
            category: 'Special expression',
            returns: {
                type: 'object',
            },
            args: {
                kvps: {
                    type: 'any',
                    rest: true,
                    description: 'key - value pairs, where key is a string',
                },
            },
            variants: [
                { argumentNames: ['kvps'] },
            ],
            description: 'Constructs a new object. Object members are created from the $kvps key-value pairs. Requires an even number of arguments.',
            examples: [
                'object()',
                "\nlet default = {\n  type: \"Person\",\n  name: \"John Doe\",\n  age: 42\n};\n\n{\n  ...default,\n  name: \"Lisa\"\n}",
                'object("x", 10, "y", true, "z", "A string")',
                '{}',
                '{ a: 1, b: 2 }',
            ],
            noOperatorDocumentation: true,
        },
        '&&': {
            title: '&&',
            category: 'Special expression',
            returns: {
                type: 'any',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { c: {
                    type: 'any',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'c'] },
            ],
            description: "\nComputes logical `and`. Evaluation of expressions starts from left.\nAs soon as an `expression` evaluates to a falsy value, the result is returned.\n\nIf all expressions evaluate to truthy values, the value of the last expression is returned.",
            examples: [
                'true && 1',
                '&&(1, 1)',
                '&&(3 > 2, "string")',
                '&&(3 < 2, "string")',
                '&&(true, true, true, true)',
                '&&(true, true, 0, true)',
            ],
        },
        '||': {
            title: '||',
            category: 'Special expression',
            returns: {
                type: 'boolean',
            },
            args: __assign(__assign({}, getOperatorArgs('any', 'any')), { c: {
                    type: 'any',
                    rest: true,
                } }),
            variants: [
                { argumentNames: ['a', 'b'] },
                { argumentNames: ['a', 'b', 'c'] },
            ],
            description: "\n  Computes logical `or`. Evaluation of expressions evaluation starts from left.\n  As soon as a `expression` evaluates to a truthy value, the result is returned.\n\n  If all expressions evaluate to falsy values, the value of the last expression is returned.",
            examples: [
                'false || 1',
                '||(1, 1)',
                '||(3 > 2, "string")',
                '||(3 < 2, "string")',
                '||(false, false, false, true)',
                '||(1, 2, 3, 4)',
            ],
        },
        'let': {
            title: 'let',
            category: 'Special expression',
            customVariants: ['let s = value;'],
            details: [
                ['s', 'symbol', 'The name of the variable to bind.'],
                ['value', 'any', 'The value to bind to the variable.'],
            ],
            description: "\n  Binds local variables s to `value`. `value` can be any expression. The scope of the variables is the body of the let expression.",
            examples: ["\nlet a = 1 + 2 + 3 + 4;\nlet b = -> $ * ( $ + 1 );\nwrite!(\"a\", a, \"b\", b)"],
        },
        'function': {
            title: 'function',
            category: 'Special expression',
            customVariants: ['function name(...arg) { body }'],
            details: [
                ['name', 'symbol', 'The name of the function.'],
                ['arg', '[...]arg-name [= value]', 'Arguments of the function.'],
                ['...', 'rest-symbol', 'Optional. The rest argument of the function.'],
                ['arg-name', 'symbol', 'The name of the argument.'],
                ['value', 'any', 'Optional. The default value of the argument.'],
                ['let-binding', 'symbol', 'Optional. The let bindings of the function.'],
                ['body', 'one or more expressions', 'The body of the function.'],
            ],
            description: 'Creates a named function. When called, evaluation of the last expression in the body is returned.',
            examples: [
                "\nfunction hyp (a, b) {\n  sqrt(a * a + b * b)\n};\n\nhyp(3, 4)",
                "\nfunction sumOfSquares(...s) {\n  apply(\n    +,\n    map(s, -> $ ^ 2)\n  )\n};\n\nsumOfSquares(1, 2, 3, 4, 5)",
                "\nfunction withOptional(a, b = 42) {\n  a + b\n};\n\nwrite!(withOptional(1), withOptional(1, 2))",
            ],
        },
        'try': {
            title: 'try',
            category: 'Special expression',
            customVariants: ['try { try-body } catch { catch-body }', 'try { try-body } catch(error) { catch-body }'],
            details: [
                ['try-body', 'expressions', 'The expressions to try.'],
                ['error', 'symbol', 'The error variable to bind.'],
                ['catch-body', 'expression', 'The expressions to evaluate if the try-body throws an error.'],
            ],
            description: 'Executes `try-body`. If that throws, the `catch-body` gets executed. See examples for details.',
            examples: [
                "\ntry {\n  2 / 4\n} catch {\n  \"Oops!\"\n}",
                "\ntry {\n  foo()\n} catch(error) {\n  \"Error: \" ++ error.message\n}",
                "\ntry {\n  foo()\n} catch {\n  42\n}",
            ],
        },
        'throw': {
            title: 'throw',
            category: 'Special expression',
            returns: {
                type: 'never',
            },
            args: {
                expr: {
                    type: 'any',
                },
            },
            variants: [
                { argumentNames: ['expr'] },
            ],
            description: 'Throws `UserDefinedError` with message set to $expr evaluated. $expr must evaluate to a string.',
            examples: [
                'try { throw("You shall not pass!") } catch(error) { "Error: " ++ error.message }',
                'try { throw(slice("You shall not pass!", 0, 3)) } catch(error) { "Error: " ++ error.message }',
            ],
        },
        'if': {
            title: 'if',
            category: 'Special expression',
            customVariants: ['if (test) true-expr else false-expr', 'if (test) true-expr'],
            details: [
                ['test', 'expression', 'The condition to test.'],
                ['true-expr', 'expression', 'The expression to evaluate if the test is truthy.'],
                ['false-expr', 'expression', 'The expression to evaluate if the test is falsy.'],
            ],
            description: 'Either `true-expr` or `false-expr` branch is taken. `true-expr` is selected when $test is truthy. If $test is falsy `false-expr` is executed, if no `false-expr` exists, `null` is returned.',
            examples: [
                "\nif (true) {\n  write!(\"TRUE\")\n} else {\n  write!(\"FALSE\")\n}",
                'if (false) write!("TRUE") else write!("FALSE")',
                'if (true) write!("TRUE")',
                'if (false) write!("TRUE")',
            ],
        },
        'unless': {
            title: 'unless',
            category: 'Special expression',
            customVariants: ['unless (test) true-expr else false-expr end', 'unless test true-expr end'],
            details: [
                ['test', 'expression', 'The condition to test.'],
                ['true-expr', 'expression', 'The expressions to evaluate if the test is falsy.'],
                ['false-expr', 'expression', 'The expressions to evaluate if the test is truthy.'],
            ],
            description: 'Either `true-expr` or `false-expr` branch is taken. `true-expr` is selected when $test is falsy. If $test is truthy `false-expr` is executed, if no `false-expr` exists, `null` is returned.',
            examples: [
                "\nunless (true) {\n  write!(\"TRUE\")\n} else {\n  write!(\"FALSE\")\n}",
                'unless (false) write!("TRUE") else write!("FALSE")',
                'unless (true) write!("TRUE")',
                'unless (false) write!("TRUE")',
            ],
        },
        'cond': {
            title: 'cond',
            category: 'Special expression',
            customVariants: ['cond { cond-branch cond-branch ... }'],
            details: [
                ['cond-branch', 'case test then body', 'A branch of the cond expression.'],
                ['test', 'expression', 'The condition to test.'],
                ['body', 'expressions', 'The expressions to evaluate if the test is truthy.'],
            ],
            description: 'Used for branching. `cond-branches` are tested sequentially from the top. If no branch is tested truthy, `null` is returned.',
            examples: [
                "\ncond {\n  case false: write!(\"FALSE\")\n  case true: write!(\"TRUE\")\n}",
                "\ncond {\n  case false: write!(\"FALSE\")\n  case null: write!(\"null\")\n} ?? write!(\"TRUE\")",
                "\ncond {\n  case false: write!(\"FALSE\")\n  case null: write!(\"null\")\n} ?? write!(\"TRUE\")",
            ],
        },
        'switch': {
            title: 'switch',
            category: 'Special expression',
            customVariants: ['switch (value) { switch-branch switch-branch ... }'],
            details: [
                ['value', 'any', 'The value to test.'],
                ['switch-branch', 'case test then body', 'A branch of the switch expression.'],
                ['test', 'expression', 'The condition to test.'],
                ['body', 'expressions', 'The expressions to evaluate if the test is truthy.'],
            ],
            description: 'Used for branching. `switch-branches` are tested sequentially from the top against `value`. If no branch is tested truthy, `null` is returned.',
            examples: [
                "\nswitch (1) {\n  case 1: write!(\"One\")\n  case 2: write!(\"Two\")\n}",
                "\nswitch (2) {\n  case 1: write!(\"One\")\n  case 2: write!(\"Two\")\n}",
                "\nswitch (3) {\n  case 1: write!(\"One\")\n  case 2: write!(\"Two\")\n}",
            ],
        },
        'block': {
            title: 'block',
            category: 'Special expression',
            customVariants: ['{ body }'],
            details: [
                ['body', 'expressions', 'The expressions to evaluate.'],
            ],
            description: 'Evaluates `body`. Resulting value is the value of the last expression.',
            examples: [
                "\n{\n  let a = 1 + 2 + 3 + 4;\n  let b = -> $ * ( $ + 1 );\n  b(a)\n}",
            ],
        },
        'recur': {
            title: 'recur',
            category: 'Special expression',
            customVariants: ['recur(...recur-args)'],
            description: 'Recursevly calls enclosing function or loop with its evaluated `recur-args`.',
            examples: [
                "\nfunction foo(n) {\n  write!(n);\n  if (!(zero?(n))) {\n    recur(n - 1)\n  }\n};\nfoo(3)",
                "\n(n -> {\n  write!(n);\n  if (!(zero?(n))) {\n    recur(n - 1)\n  }\n})(3)",
                "\nloop (n = 3) {\n  write!(n);\n  if (!(zero?(n))) {\n    recur(n - 1)\n  }\n}",
            ],
        },
    };

    var stringReference = {
        'string-repeat': {
            title: 'string-repeat',
            category: 'String',
            returns: {
                type: 'number',
            },
            args: __assign(__assign({}, getOperatorArgs('string', 'integer')), { s: {
                    type: 'string',
                }, n: {
                    type: 'integer',
                } }),
            variants: [
                { argumentNames: ['s', 'n'] },
            ],
            description: 'Repeates $s $n times.',
            examples: [
                '"*" string-repeat 10',
                'string-repeat("*", 10)',
                'string-repeat("***", 0)',
            ],
        },
        'str': {
            title: 'str',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                values: {
                    type: 'any',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['values'] },
            ],
            description: 'Concatenats $values into one string. If `value` equals `null` empty string is returned.',
            examples: [
                'str("A string", ", and another string", " ...and more")',
                'str("Just one string")',
                'str()',
                'str(0, false, true, null, #"^kalle", [1, 2, 3], {a: "a"})',
            ],
            noOperatorDocumentation: true,
        },
        'number': {
            title: 'number',
            category: 'String',
            returns: {
                type: 'number',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Parses $s to a number.',
            examples: [
                'number("10")',
                'number("010")',
                'number("-1.01")',
            ],
        },
        'lower-case': {
            title: 'lower-case',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns $s converted to lower case.',
            examples: [
                'lower-case("Albert")',
                'lower-case("")',
            ],
        },
        'upper-case': {
            title: 'upper-case',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns $s converted to upper case.',
            examples: [
                'upper-case("Albert")',
                'upper-case("")',
            ],
        },
        'trim': {
            title: 'trim',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns a new string with leading and trailing whitespaces removed.',
            examples: [
                'trim("  Albert  ")',
                'trim("   ")',
                'trim("")',
            ],
        },
        'trim-left': {
            title: 'trim-left',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns a new string with leading whitespaces removed.',
            examples: [
                'trim-left("  Albert  ")',
                'trim-left("   ")',
                'trim-left("")',
            ],
        },
        'trim-right': {
            title: 'trim-right',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns a new string with trailing whitespaces removed.',
            examples: [
                'trim-right("  Albert  ")',
                'trim-right("   ")',
                'trim-right("")',
            ],
        },
        'pad-left': {
            title: 'pad-left',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: __assign(__assign({}, getOperatorArgs('string', 'integer')), { s: {
                    type: 'string',
                }, length: {
                    type: 'integer',
                }, padString: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['s', 'length'] },
                { argumentNames: ['s', 'length', 'padString'] },
            ],
            description: 'Pads from the start of $s with `padString` (multiple times, if needed) until the resulting string reaches the given $length.',
            examples: [
                '"Albert" pad-left 20',
                'pad-left("Albert", 20)',
                'pad-left("Albert", 20, "-*-")',
                'pad-left("Albert", 5)',
                'pad-left("Albert", -1)',
            ],
        },
        'pad-right': {
            title: 'pad-right',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: __assign(__assign({}, getOperatorArgs('string', 'integer')), { s: {
                    type: 'string',
                }, length: {
                    type: 'integer',
                }, padString: {
                    type: 'string',
                } }),
            variants: [
                { argumentNames: ['s', 'length'] },
                { argumentNames: ['s', 'length', 'padString'] },
            ],
            description: 'Pads from the start of $s with `padString` (multiple times, if needed) until the resulting string reaches the given `length`.',
            examples: [
                '"Albert" pad-right 20',
                'pad-right("Albert", 20)',
                'pad-right("Albert", 20, "-*-")',
                'pad-right("Albert", 5)',
                'pad-right("Albert", -1)',
            ],
        },
        'split': {
            title: 'split',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: __assign(__assign({}, getOperatorArgs('string', 'string')), { s: {
                    type: 'string',
                }, delimiter: {
                    type: 'string',
                }, limit: {
                    type: 'integer',
                } }),
            variants: [
                { argumentNames: ['s', 'delimiter'] },
                { argumentNames: ['s', 'delimiter', 'limit'] },
            ],
            description: 'Divides $s into an array of substrings. The division is done by searching for `delimiter`. If `limit` as provided, at most `limit` number of substrings are returned.',
            examples: [
                '"Albert Mojir" split " "',
                'split("Albert Mojir", " ")',
                'split("abcdefghijklmnopqrstuvw", #"[aoueiy]")',
                'split("0123456789", "")',
                'split("0123456789", "", 5) map number',
            ],
        },
        'split-lines': {
            title: 'split-lines',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Divides $s into an array of substrings, each representing a line.',
            examples: [
                'split-lines("Albert\nMojir\n")',
                'split-lines("Albert\n\nMojir")',
                'split-lines("Albert\nMojir\n\n")',
                'split-lines("")',
            ],
        },
        'template': {
            title: 'template',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
                params: {
                    type: 'any',
                    rest: true,
                },
            },
            variants: [
                { argumentNames: ['s', 'params'] },
            ],
            description: 'Applies placeholders to a string. Support for basic pluralization - see examples. If pluralization is used, first placeholder must be a number.',
            examples: [
                'template("Hi, $1 and $2", "Carl", "Larry")',
                'template("Hi $1, $2, $3, $4, $5, $6, $7, $8 and $9", "A", "B", "C", "D", "E", "F", "G", "H", "I")',
                'template("$1 book||||$1 books", 0)',
                'template("$1 book||||$1 books", 1)',
                'template("$1 book||||$1 books", 2)',
                'template("No book||||$1 book||||$1 books", 0)',
                'template("No book||||$1 book||||$1 books", 1)',
                'template("No book||||$1 book||||$1 books", 10)',
                'template("No book||||One book||||Two books||||Three books||||$1 books", 0)',
                'template("No book||||One book||||Two books||||Three books||||$1 books", 1)',
                'template("No book||||One book||||Two books||||Three books||||$1 books", 2)',
                'template("No book||||One book||||Two books||||Three books||||$1 books", 3)',
                'template("No book||||One book||||Two books||||Three books||||$1 books", 4)',
            ],
            noOperatorDocumentation: true,
        },
        'to-char-code': {
            title: 'to-char-code',
            category: 'String',
            returns: {
                type: 'number',
            },
            args: {
                c: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['c'] },
            ],
            description: 'Return code point for first character in $c.',
            examples: [
                'to-char-code("A")',
                'to-char-code("Albert")',
            ],
        },
        'from-char-code': {
            title: 'from-char-code',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                code: {
                    type: 'number',
                },
            },
            variants: [
                { argumentNames: ['code'] },
            ],
            description: 'Return character for code point $code.',
            examples: [
                'from-char-code(65)',
                'from-char-code(0)',
            ],
        },
        'encode-base64': {
            title: 'encode-base64',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns a Base64 encoded string from $s.',
            examples: [
                'encode-base64("Albert")',
            ],
        },
        'decode-base64': {
            title: 'decode-base64',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                base64string: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['base64string'] },
            ],
            description: 'Returns a Base64 decoded string from $base64string.',
            examples: [
                'decode-base64("QWxiZXJ0IPCfkLs=")',
            ],
        },
        'encode-uri-component': {
            title: 'encode-uri-component',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns an escaped `URI` string.',
            examples: [
                'encode-uri-component("Hi everyone!?")',
            ],
        },
        'decode-uri-component': {
            title: 'decode-uri-component',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns an un-escaped `URI` string.',
            examples: [
                'decode-uri-component("Hi%20everyone!%3F%20%F0%9F%91%8D")',
            ],
        },
        'join': {
            title: 'join',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: __assign(__assign({}, getOperatorArgs('array', 'string')), { arr: {
                    type: 'array',
                }, delimiter: {
                    type: 'string',
                } }),
            variants: [{
                    argumentNames: ['arr', 'delimiter'],
                }],
            description: 'Returns a new string by concatenating all of the elements in $arr, separated by $delimiter.',
            examples: [
                'map([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], str) join ", "',
                '([0, 1, 2, 3, 4, 5, 6, 7, 8, 9] map str) join ", "',
                'join(["Albert", 10], ", ")',
                'join(["Albert", "Mojir"], " ")',
                'join(map([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], str), ", ")',
            ],
        },
        'capitalize': {
            title: 'capitalize',
            category: 'String',
            returns: {
                type: 'string',
            },
            args: {
                s: {
                    type: 'string',
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns $s with the first character converted to uppercase and the rest to lowercase.',
            examples: [
                'capitalize("albert")',
                'capitalize("ALBERT")',
                'capitalize("aLBERT")',
                'capitalize("")',
            ],
        },
        'blank?': {
            title: 'blank?',
            category: 'String',
            returns: {
                type: 'boolean',
            },
            args: {
                s: {
                    type: ['string', 'null'],
                },
            },
            variants: [
                { argumentNames: ['s'] },
            ],
            description: 'Returns true if $s is null or only contains whitespace characters.',
            examples: [
                'blank?("")',
                'blank?(null)',
                'blank?("\n")',
                'blank?(" ")',
                'blank?(".")',
            ],
        },
    };

    var datatype = {
        '-type-number': {
            datatype: true,
            title: 'number',
            category: 'Datatype',
            description: 'A `number`',
            examples: [
                '42',
                '3.14',
            ],
        },
        '-type-string': {
            datatype: true,
            title: 'string',
            category: 'Datatype',
            description: 'A `string`',
            examples: [
                '"hello"',
                '""',
            ],
        },
        '-type-object': {
            datatype: true,
            title: 'object',
            category: 'Datatype',
            description: 'An `object`, a collection of key-value pairs where keys are `strings`',
            examples: [
                '{}',
                '{ a: 1, b: 2}',
            ],
        },
        '-type-array': {
            datatype: true,
            title: 'array',
            category: 'Datatype',
            description: 'An `array`',
            examples: [
                '[]',
                '[1, 2, 3]',
                '["a", null, true]',
            ],
        },
        '-type-vector': {
            datatype: true,
            title: 'vector',
            category: 'Datatype',
            description: 'An `array` of `numbers`',
            examples: [
                '[]',
                '[1, 2, 3]',
            ],
        },
        '-type-matrix': {
            datatype: true,
            title: 'matrix',
            category: 'Datatype',
            description: 'A `matrix`, a two-dimensional `array` with `numbers` where each row has the same number of columns. A `matrix` is also a `grid`.',
            examples: [
                '[[]]',
                '[[1, 2], [3, 4]]',
                '[[1, 2], [3, 4], [5, 6]]',
            ],
        },
        '-type-grid': {
            datatype: true,
            title: 'grid',
            category: 'Datatype',
            description: 'A `grid`, a two-dimensional `array` where each row has the same number of columns',
            examples: [
                '[[]]',
                '[[1, 2], [3, 4]]',
                '[["a", "b"], [3, 4], [5, 6]]',
            ],
        },
        '-type-boolean': {
            datatype: true,
            title: 'boolean',
            category: 'Datatype',
            description: 'A `boolean`',
            examples: [
                'true',
                'false',
            ],
        },
        '-type-function': {
            datatype: true,
            title: 'function',
            category: 'Datatype',
            description: 'A `function`',
            examples: [
                'x -> x + 1',
                '(a, b, c) -> (a + b) * c',
                '() -> 42',
                '-> $1 + $2',
            ],
        },
        '-type-integer': {
            datatype: true,
            title: 'integer',
            category: 'Datatype',
            description: 'An `integer`',
            examples: [
                '42',
                '-42',
            ],
        },
        '-type-any': {
            datatype: true,
            title: 'any',
            category: 'Datatype',
            description: '`Any` value',
            examples: [
                '42',
                '"hello"',
                'true',
                'null',
            ],
        },
        '-type-null': {
            datatype: true,
            title: 'null',
            category: 'Datatype',
            description: 'The value `null`',
            examples: [
                'null',
            ],
        },
        '-type-collection': {
            datatype: true,
            title: 'collection',
            category: 'Datatype',
            description: 'A collection, an `object`, an `array` or a `string`',
            examples: [
                '{ foo: 42 }',
                '[1, 2, 3]',
                '"hello"',
            ],
        },
        '-type-sequence': {
            datatype: true,
            title: 'sequence',
            category: 'Datatype',
            description: 'A sequence, an `array` or a `string`',
            examples: [
                '[1, 2, 3]',
                '"hello"',
            ],
        },
        '-type-regexp': {
            datatype: true,
            title: 'regexp',
            category: 'Datatype',
            description: 'A regular expression',
            examples: [
                'regexp("^\\\\s*(.*)$")',
                '#"albert"ig',
            ],
        },
        '-type-never': {
            datatype: true,
            title: 'never',
            category: 'Datatype',
            description: 'A value that can never be created',
            examples: ["\n// throw(\"error\") will never return a value\ntry { throw(\"error\") } catch { \"never\" }",
            ],
        },
    };

    var shorthand = {
        '-short-regexp': {
            shorthand: true,
            title: '#"pattern"',
            category: 'Shorthand',
            description: 'Shorthand for `regexp(pattern)`. Only difference is that escaping is not needed.',
            examples: [
                '#"^\\s*(.*)$"',
                '#"albert"ig',
            ],
            seeAlso: ['regexp'],
        },
        '-short-fn': {
            shorthand: true,
            title: '-> expression',
            category: 'Shorthand',
            description: "\nShorthand for `(args, ...) -> expression`.\n`$1, $2, $3, ...` are shorthand for the first, second, third, ... argument.\n\nYou can reference the first argument using either `$1` or `$`.\nHowever, please note that `$1` and `$` are mutually exclusive and cannot be used simultaneously.\nE.g. `#(* $ $1)` is not valid.",
            examples: [
                '-> $1 + $2',
                '(-> $ * $)(9)',
            ],
        },
    };

    var abundantReference = {
        'nth:abundant-seq': {
            title: 'nth:abundant-seq',
            category: 'Number Theory',
            description: 'Generates the abundant numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:abundant-seq(1)',
                'nth:abundant-seq(5)',
            ],
        },
        'nth:abundant-take-while': {
            title: 'nth:abundant-take-while',
            category: 'Number Theory',
            description: 'Generates the abundant numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:abundant-take-while(-> $ < 100)',
            ],
        },
        'nth:abundant-nth': {
            title: 'nth:abundant-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the abundant numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the number in the sequence.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:abundant-nth(1)',
                'nth:abundant-nth(5)',
            ],
        },
        'nth:abundant?': {
            title: 'nth:abundant?',
            category: 'Number Theory',
            description: 'Checks if a number is abundant.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:abundant?(12)',
                'nth:abundant?(15)',
            ],
        },
    };

    var arithmeticReference = {
        'nth:arithmetic-seq': {
            title: 'nth:arithmetic-seq',
            category: 'Number Theory',
            description: 'Generates the arithmetic sequence for a given $start, $step, and $length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                step: {
                    type: 'number',
                    description: 'The common difference of the sequence.',
                },
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['start', 'step', 'length'] },
            ],
            examples: [
                'nth:arithmetic-seq(3, 2, 2)',
                'nth:arithmetic-seq(2, 3, 2)',
                'nth:arithmetic-seq(1, 2, 2)',
                'nth:arithmetic-seq(1, 1.5, 12)',
            ],
        },
        'nth:arithmetic-take-while': {
            title: 'nth:arithmetic-take-while',
            category: 'Number Theory',
            description: 'Generates the arithmetic sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                step: {
                    type: 'number',
                    description: 'The common difference of the sequence.',
                },
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes a number and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['start', 'step', 'takeWhile'] },
            ],
            examples: [
                'nth:arithmetic-take-while(1, 0.25, -> $ < 3)',
            ],
        },
        'nth:arithmetic-nth': {
            title: 'nth:arithmetic-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the arithmetic sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                step: {
                    type: 'number',
                    description: 'The common difference of the sequence.',
                },
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['start', 'step', 'n'] },
            ],
            examples: [
                'nth:arithmetic-nth(3, 2, 2)',
                'nth:arithmetic-nth(2, 3, 2)',
                'nth:arithmetic-nth(1, 2, 2)',
                'nth:arithmetic-nth(1, 1.5, 12)',
            ],
        },
        'nth:arithmetic?': {
            title: 'nth:arithmetic?',
            category: 'Number Theory',
            description: 'Checks if a number is part of the arithmetic sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                step: {
                    type: 'number',
                    description: 'The common difference of the sequence.',
                },
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['start', 'step', 'n'] },
            ],
            examples: [
                'nth:arithmetic?(3, 2, 2)',
                'nth:arithmetic?(2, 3, 2)',
                'nth:arithmetic?(1, 2, 2)',
                'nth:arithmetic?(1, 1.5, 12)',
            ],
        },
    };

    var bellReference = {
        'nth:bell-seq': {
            title: 'nth:bell-seq',
            category: 'Number Theory',
            description: 'Generates the Bell sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 22 (the maximum length of the pre-calculated bell numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:bell-seq(5)',
                'nth:bell-seq(10)',
                'nth:bell-seq()',
            ],
        },
        'nth:bell-take-while': {
            title: 'nth:bell-take-while',
            category: 'Number Theory',
            description: 'Generates the Bell sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:bell-take-while(-> $ < 1000)',
            ],
        },
        'nth:bell-nth': {
            title: 'nth:bell-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Bell sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:bell-nth(5)',
                'nth:bell-nth(10)',
            ],
        },
        'nth:bell?': {
            title: 'nth:bell?',
            category: 'Number Theory',
            description: 'Checks if a number is in the Bell sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:bell?(1)',
                'nth:bell?(27644437)',
                'nth:bell?(27644436)',
            ],
        },
    };

    var bernoulliReference = {
        'nth:bernoulli-seq': {
            title: 'nth:bernoulli-seq',
            category: 'Number Theory',
            description: 'Generates the Bernoulli sequence up to a specified length.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:bernoulli-seq(5)',
                'nth:bernoulli-seq(10)',
            ],
        },
        'nth:bernoulli-take-while': {
            title: 'nth:bernoulli-take-while',
            category: 'Number Theory',
            description: 'Generates the Bernoulli sequence while a condition is met.',
            returns: {
                type: 'number',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:bernoulli-take-while(-> abs($) < 100)',
            ],
        },
        'nth:bernoulli-nth': {
            title: 'nth:bernoulli-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Bernoulli sequence.',
            returns: {
                type: 'number',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:bernoulli-nth(5)',
                'nth:bernoulli-nth(10)',
                'nth:bernoulli-nth(23)',
            ],
        },
    };

    var catalanReference = {
        'nth:catalan-seq': {
            title: 'nth:catalan-seq',
            category: 'Number Theory',
            description: 'Generates the Catalan sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 30 (the maximum length of the pre-calculated catalan numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:catalan-seq(5)',
                'nth:catalan-seq(10)',
                'nth:catalan-seq()',
            ],
        },
        'nth:catalan-take-while': {
            title: 'nth:catalan-take-while',
            category: 'Number Theory',
            description: 'Generates the Catalan sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:catalan-take-while(-> $ < 1000)',
            ],
        },
        'nth:catalan-nth': {
            title: 'nth:catalan-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Catalan sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:catalan-nth(5)',
                'nth:catalan-nth(10)',
            ],
        },
        'nth:catalan?': {
            title: 'nth:catalan?',
            category: 'Number Theory',
            description: 'Determines if a number is in the Catalan sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:catalan?(5)',
                'nth:catalan?(10)',
            ],
        },
    };

    var collatzReference = {
        'nth:collatz-seq': {
            title: 'nth:collatz-seq',
            category: 'Number Theory',
            description: 'Generates the collatz sequence starting from a given integer.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'integer',
                    description: 'The starting integer for the collatz sequence.',
                },
            },
            variants: [
                { argumentNames: ['start'] },
            ],
            examples: [
                'nth:collatz-seq(3)',
                'nth:collatz-seq(11)',
            ],
        },
    };

    var compositeReference = {
        'nth:composite-seq': {
            title: 'nth:composite-seq',
            category: 'Number Theory',
            description: 'Generates the composite sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:composite-seq(1)',
                'nth:composite-seq(2)',
                'nth:composite-seq(10)',
            ],
        },
        'nth:composite-take-while': {
            title: 'nth:composite-take-while',
            category: 'Number Theory',
            description: 'Generates the composite sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:composite-take-while(-> $ < 50)',
            ],
        },
        'nth:composite-nth': {
            title: 'nth:composite-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the composite sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the composite number to retrieve.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:composite-nth(1)',
                'nth:composite-nth(2)',
                'nth:composite-nth(10)',
            ],
        },
        'nth:composite?': {
            title: 'nth:composite?',
            category: 'Number Theory',
            description: 'Determines if a number is composite.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:composite?(4)',
                'nth:composite?(5)',
                'nth:composite?(11)',
            ],
        },
    };

    var factorialReference = {
        'nth:factorial-seq': {
            title: 'nth:factorial-seq',
            category: 'Number Theory',
            description: 'Generates the factorial sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 19 (the maximum length of the pre-calculated factorial numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:factorial-seq(1)',
                'nth:factorial-seq(2)',
                'nth:factorial-seq(3)',
                'nth:factorial-seq(4)',
                'nth:factorial-seq(5)',
                'nth:factorial-seq(10)',
            ],
        },
        'nth:factorial-take-while': {
            title: 'nth:factorial-take-while',
            category: 'Number Theory',
            description: 'Generates the factorial sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:factorial-take-while(-> $ < 1000)',
            ],
        },
        'nth:factorial-nth': {
            title: 'nth:factorial-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the factorial sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:factorial-nth(1)',
                'nth:factorial-nth(2)',
                'nth:factorial-nth(3)',
                'nth:factorial-nth(4)',
                'nth:factorial-nth(5)',
                'nth:factorial-nth(10)',
            ],
        },
        'nth:factorial?': {
            title: 'nth:factorial?',
            category: 'Number Theory',
            description: 'Checks if a number is in the factorial sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:factorial?(1)',
                'nth:factorial?(2)',
                'nth:factorial?(3)',
                'nth:factorial?(4)',
                'nth:factorial?(5)',
                'nth:factorial?(6)',
                'nth:factorial?(7)',
                'nth:factorial?(8)',
                'nth:factorial?(9)',
                'nth:factorial?(3628800)',
            ],
        },
    };

    var fibonacciReference = {
        'nth:fibonacci-seq': {
            title: 'nth:fibonacci-seq',
            category: 'Number Theory',
            description: 'Generates the fibonacci sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 79 (the maximum length of the pre-calculated Fibonacci numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:fibonacci-seq(1)',
                'nth:fibonacci-seq(2)',
                'nth:fibonacci-seq()',
            ],
        },
        'nth:fibonacci-take-while': {
            title: 'nth:fibonacci-take-while',
            category: 'Number Theory',
            description: 'Generates the fibonacci sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:fibonacci-take-while(-> $ < 100)',
            ],
        },
        'nth:fibonacci-nth': {
            title: 'nth:fibonacci-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the fibonacci sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:fibonacci-nth(5)',
                'nth:fibonacci-nth(50)',
            ],
        },
        'nth:fibonacci?': {
            title: 'nth:fibonacci?',
            category: 'Number Theory',
            description: 'Determines if a number is in the fibonacci sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:fibonacci?(0)',
                'nth:fibonacci?(1)',
                'nth:fibonacci?(2)',
                'nth:fibonacci?(3)',
                'nth:fibonacci?(4)',
                'nth:fibonacci?(5)',
                'nth:fibonacci?(6)',
                'nth:fibonacci?(7)',
                'nth:fibonacci?(8)',
                'nth:fibonacci?(9)',
            ],
        },
    };

    var geometricReference = {
        'nth:geometric-seq': {
            title: 'nth:geometric-seq',
            category: 'Number Theory',
            description: 'Generates the geometric sequence for a given $start, $ratio, and $length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                ratio: {
                    type: 'number',
                    description: 'The common ratio of the sequence.',
                },
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['start', 'ratio', 'length'] },
            ],
            examples: [
                'nth:geometric-seq(3, 2, 2)',
                'nth:geometric-seq(2, 3, 2)',
                'nth:geometric-seq(1, 2, 2)',
                'nth:geometric-seq(1, 1.5, 12)',
            ],
        },
        'nth:geometric-take-while': {
            title: 'nth:geometric-take-while',
            category: 'Number Theory',
            description: 'Generates the geometric sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                ratio: {
                    type: 'number',
                    description: 'The common ratio of the sequence.',
                },
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes a number and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['start', 'ratio', 'takeWhile'] },
            ],
            examples: [
                'nth:geometric-take-while(1, 1.5, -> $ < 10)',
            ],
        },
        'nth:geometric-nth': {
            title: 'nth:geometric-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the geometric sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                ratio: {
                    type: 'number',
                    description: 'The common ratio of the sequence.',
                },
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['start', 'ratio', 'n'] },
            ],
            examples: [
                'nth:geometric-nth(3, 2, 2)',
                'nth:geometric-nth(2, 3, 2)',
                'nth:geometric-nth(1, 2, 2)',
                'nth:geometric-nth(1, 1.5, 4)',
            ],
        },
        'nth:geometric?': {
            title: 'nth:geometric?',
            category: 'Number Theory',
            description: 'Checks if a number is in the geometric sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                start: {
                    type: 'number',
                    description: 'The starting term of the sequence.',
                },
                ratio: {
                    type: 'number',
                    description: 'The common ratio of the sequence.',
                },
                n: {
                    type: 'number',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['start', 'ratio', 'n'] },
            ],
            examples: [
                'nth:geometric?(1, 2, 1)',
                'nth:geometric?(2, 3, 2)',
                'nth:geometric?(3, 2, 2)',
                'nth:geometric?(1, 1.5, 2.25)',
                'nth:geometric?(1, 1.5, -4)',
            ],
        },
    };

    var golombReference = {
        'nth:golomb-seq': {
            title: 'nth:golomb-seq',
            category: 'Number Theory',
            description: 'Generates the Golomb sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:golomb-seq(5)',
                'nth:golomb-seq(20)',
            ],
        },
        'nth:golomb-take-while': {
            title: 'nth:golomb-take-while',
            category: 'Number Theory',
            description: 'Generates the Golomb sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:golomb-take-while(-> $ <= 10)',
            ],
        },
        'nth:golomb-nth': {
            title: 'nth:golomb-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Golomb sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:golomb-nth(5)',
                'nth:golomb-nth(1000)',
            ],
        },
        'nth:golomb?': {
            title: 'nth:golomb?',
            category: 'Number Theory',
            description: 'Checks if a number is in the Golomb sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:golomb?(1)',
                'nth:golomb?(2)',
                'nth:golomb?(3345)',
                'nth:golomb?(67867864)',
            ],
        },
    };

    var happyReference = {
        'nth:happy-seq': {
            title: 'nth:happy-seq',
            category: 'Number Theory',
            description: 'Generates the happy sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 20 (the maximum length of the pre-calculated happy numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:happy-seq(1)',
                'nth:happy-seq(2)',
                'nth:happy-seq(20)',
            ],
        },
        'nth:happy-take-while': {
            title: 'nth:happy-take-while',
            category: 'Number Theory',
            description: 'Generates the happy sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:happy-take-while(-> $ < 100)',
            ],
        },
        'nth:happy-nth': {
            title: 'nth:happy-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the happy sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the happy number to return.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:happy-nth(1)',
                'nth:happy-nth(2)',
                'nth:happy-nth(20)',
            ],
        },
        'nth:happy?': {
            title: 'nth:happy?',
            category: 'Number Theory',
            description: 'Determines if a number is a happy number.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:happy?(1)',
                'nth:happy?(2)',
                'nth:happy?(100)',
            ],
        },
    };

    var jugglerReference = {
        'nth:juggler-seq': {
            title: 'nth:juggler-seq',
            category: 'Number Theory',
            description: 'Generates the Juggler sequence starting from a given integer.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                start: {
                    type: 'integer',
                    description: 'The starting integer for the Juggler sequence.',
                },
            },
            variants: [
                { argumentNames: ['start'] },
            ],
            examples: [
                'nth:juggler-seq(3)',
                'nth:juggler-seq(5)',
            ],
        },
    };

    var lookAndSayReference = {
        'nth:look-and-say-seq': {
            title: 'nth:look-and-say-seq',
            category: 'Number Theory',
            description: 'Generates the Look-and-Say sequence up to a specified length.',
            returns: {
                type: 'string',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:look-and-say-seq(5)',
            ],
        },
        'nth:look-and-say-take-while': {
            title: 'nth:look-and-say-take-while',
            category: 'Number Theory',
            description: 'Generates the Look-and-Say sequence while a condition is met.',
            returns: {
                type: 'string',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes a string and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:look-and-say-take-while((term, index) -> count(term) < 10)',
                'nth:look-and-say-take-while(-> $2 <= 10)',
            ],
        },
        'nth:look-and-say-nth': {
            title: 'nth:look-and-say-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Look-and-Say sequence.',
            returns: {
                type: 'string',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term in the sequence.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:look-and-say-nth(5)',
            ],
        },
        'nth:look-and-say?': {
            title: 'nth:look-and-say?',
            category: 'Number Theory',
            description: 'Checks if a string is a valid Look-and-Say term.',
            returns: {
                type: 'boolean',
            },
            args: {
                term: {
                    type: 'string',
                    description: 'The term to check.',
                },
            },
            variants: [
                { argumentNames: ['term'] },
            ],
            examples: [
                'nth:look-and-say?("111221")',
                'nth:look-and-say?("123")',
            ],
        },
    };

    var lucasReference = {
        'nth:lucas-seq': {
            title: 'nth:lucas-seq',
            category: 'Number Theory',
            description: 'Generates the lucas sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 77 (the maximum length of the pre-calculated Lucas numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:lucas-seq(1)',
                'nth:lucas-seq(2)',
                'nth:lucas-seq()',
            ],
        },
        'nth:lucas-take-while': {
            title: 'nth:lucas-take-while',
            category: 'Number Theory',
            description: 'Generates the lucas sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:lucas-take-while(-> $ < 100)',
            ],
        },
        'nth:lucas-nth': {
            title: 'nth:lucas-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the lucas sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:lucas-nth(1)',
                'nth:lucas-nth(2)',
                'nth:lucas-nth(10)',
            ],
        },
        'nth:lucas?': {
            title: 'nth:lucas?',
            category: 'Number Theory',
            description: 'Determines if a number is in the lucas sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:lucas?(1)',
                'nth:lucas?(2)',
                'nth:lucas?(10)',
            ],
        },
    };

    var luckyReference = {
        'nth:lucky-seq': {
            title: 'nth:lucky-seq',
            category: 'Number Theory',
            description: 'Generates the lucky sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:lucky-seq(1)',
                'nth:lucky-seq(2)',
                'nth:lucky-seq(20)',
            ],
        },
        'nth:lucky-take-while': {
            title: 'nth:lucky-take-while',
            category: 'Number Theory',
            description: 'Generates the lucky sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:lucky-take-while(-> $ < 100)',
            ],
        },
        'nth:lucky-nth': {
            title: 'nth:lucky-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the lucky sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The position in the sequence.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:lucky-nth(1)',
                'nth:lucky-nth(2)',
                'nth:lucky-nth(20)',
            ],
        },
        'nth:lucky?': {
            title: 'nth:lucky?',
            category: 'Number Theory',
            description: 'Checks if a number is a lucky number.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:lucky?(4)',
                'nth:lucky?(7)',
                'nth:lucky?(33)',
            ],
        },
    };

    var mersenneReference = {
        'nth:mersenne-seq': {
            title: 'nth:mersenne-seq',
            category: 'Number Theory',
            description: 'Generates the Mersenne sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 9 (the maximum length of the pre-calculated mersenne numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:mersenne-seq(1)',
                'nth:mersenne-seq(5)',
                'nth:mersenne-seq()',
            ],
        },
        'nth:mersenne-take-while': {
            title: 'nth:mersenne-take-while',
            category: 'Number Theory',
            description: 'Generates the Mersenne sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:mersenne-take-while(-> $ < 1000)',
            ],
        },
        'nth:mersenne-nth': {
            title: 'nth:mersenne-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Mersenne sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:mersenne-nth(1)',
                'nth:mersenne-nth(5)',
            ],
        },
        'nth:mersenne?': {
            title: 'nth:mersenne?',
            category: 'Number Theory',
            description: 'Checks if a number is in the Mersenne sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:mersenne?(3)',
                'nth:mersenne?(4)',
                'nth:mersenne?(7)',
            ],
        },
    };

    var padovanReference = {
        'nth:padovan-seq': {
            title: 'nth:padovan-seq',
            category: 'Number Theory',
            description: 'Generates the Padovan sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:padovan-seq(5)',
                'nth:padovan-seq(10)',
                'nth:padovan-seq(20)',
            ],
        },
        'nth:padovan-take-while': {
            title: 'nth:padovan-take-while',
            category: 'Number Theory',
            description: 'Generates the Padovan sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:padovan-take-while(-> $ < 1000)',
            ],
        },
        'nth:padovan-nth': {
            title: 'nth:padovan-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Padovan sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:padovan-nth(5)',
                'nth:padovan-nth(10)',
                'nth:padovan-nth(20)',
            ],
        },
        'nth:padovan?': {
            title: 'nth:padovan?',
            category: 'Number Theory',
            description: 'Checks if a number is in the Padovan sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:padovan?(1)',
                'nth:padovan?(265)',
                'nth:padovan?(6)',
            ],
        },
    };

    var partitionReference = {
        'nth:partition-seq': {
            title: 'nth:partition-seq',
            category: 'Number Theory',
            description: 'Generates the partition numbers up to a specified length. If no length is provided, it defaults to 299 (the maximum length of the pre-calculated partition numbers).',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:partition-seq(1)',
                'nth:partition-seq(10)',
                'nth:partition-seq()',
            ],
        },
        'nth:partition-take-while': {
            title: 'nth:partition-take-while',
            category: 'Number Theory',
            description: 'Generates the partition numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:partition-take-while(-> $ < 1000)',
            ],
        },
        'nth:partition-nth': {
            title: 'nth:partition-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the partition numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the partition number to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:partition-nth(1)',
                'nth:partition-nth(5)',
            ],
        },
        'nth:partition?': {
            title: 'nth:partition?',
            category: 'Number Theory',
            description: 'Checks if a number is in the partition numbers.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:partition?(0)',
                'nth:partition?(1)',
                'nth:partition?(2)',
                'nth:partition?(3)',
                'nth:partition?(4)',
                'nth:partition?(5)',
            ],
        },
    };

    var pellReference = {
        'nth:pell-seq': {
            title: 'nth:pell-seq',
            category: 'Number Theory',
            description: 'Generates the Pell sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 42 (the maximum length of the pre-calculated Pell numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:pell-seq(5)',
                'nth:pell-seq(10)',
                'nth:pell-seq()',
            ],
        },
        'nth:pell-take-while': {
            title: 'nth:pell-take-while',
            category: 'Number Theory',
            description: 'Generates the Pell sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:pell-take-while(-> $ < 1000)',
            ],
        },
        'nth:pell-nth': {
            title: 'nth:pell-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Pell sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:pell-nth(5)',
                'nth:pell-nth(10)',
                'nth:pell-nth(20)',
            ],
        },
        'nth:pell?': {
            title: 'nth:pell?',
            category: 'Number Theory',
            description: 'Checks if a number is a Pell number.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:pell?(1)',
                'nth:pell?(470832)',
                'nth:pell?(10)',
            ],
        },
    };

    var perfectReference = {
        'nth:perfect-seq': {
            title: 'nth:perfect-seq',
            category: 'Number Theory',
            description: 'Generates the perfect numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If no length is provided, it defaults to 7 (the maximum length of the pre-calculated perfect numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:perfect-seq(1)',
                'nth:perfect-seq(5)',
                'nth:perfect-seq()',
            ],
        },
        'nth:perfect-take-while': {
            title: 'nth:perfect-take-while',
            category: 'Number Theory',
            description: 'Generates the perfect numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:perfect-take-while(-> $ < 1000)',
            ],
        },
        'nth:perfect-nth': {
            title: 'nth:perfect-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the perfect numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the perfect number to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:perfect-nth(1)',
                'nth:perfect-nth(5)',
            ],
        },
        'nth:perfect?': {
            title: 'nth:perfect?',
            category: 'Number Theory',
            description: 'Checks if a number is in the perfect numbers.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:perfect?(0)',
                'nth:perfect?(1)',
                'nth:perfect?(2)',
                'nth:perfect?(3)',
                'nth:perfect?(4)',
                'nth:perfect?(5)',
                'nth:perfect?(6)',
                'nth:perfect?(7)',
                'nth:perfect?(8)',
                'nth:perfect?(9)',
            ],
        },
    };

    var perfectSquareReference = {
        'nth:perfect-square-seq': {
            title: 'nth:perfect-square-seq',
            category: 'Number Theory',
            description: 'Generates the perfect square numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:perfect-square-seq(5)',
                'nth:perfect-square-seq(20)',
            ],
        },
        'nth:perfect-square-take-while': {
            title: 'nth:perfect-square-take-while',
            category: 'Number Theory',
            description: 'Generates the perfect square numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:perfect-square-take-while(-> $ <= 100)',
            ],
        },
        'nth:perfect-square-nth': {
            title: 'nth:perfect-square-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the perfect square numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:perfect-square-nth(1)',
                'nth:perfect-square-nth(5)',
            ],
        },
        'nth:perfect-square?': {
            title: 'nth:perfect-square?',
            category: 'Number Theory',
            description: 'Checks if a number is a perfect square.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:perfect-square?(16)',
                'nth:perfect-square?(20)',
            ],
        },
    };

    var perfectCubeReference = {
        'nth:perfect-cube-seq': {
            title: 'nth:perfect-cube-seq',
            category: 'Number Theory',
            description: 'Generates the perfect cube numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:perfect-cube-seq(5)',
                'nth:perfect-cube-seq(20)',
            ],
        },
        'nth:perfect-cube-take-while': {
            title: 'nth:perfect-cube-take-while',
            category: 'Number Theory',
            description: 'Generates the perfect cube numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:perfect-cube-take-while(-> $ <= 100)',
            ],
        },
        'nth:perfect-cube-nth': {
            title: 'nth:perfect-cube-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the perfect cube numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:perfect-cube-nth(1)',
                'nth:perfect-cube-nth(5)',
            ],
        },
        'nth:perfect-cube?': {
            title: 'nth:perfect-cube?',
            category: 'Number Theory',
            description: 'Checks if a number is in the perfect cube numbers.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:perfect-cube?(7)',
                'nth:perfect-cube?(8)',
                'nth:perfect-cube?(9)',
            ],
        },
    };

    var perfectPowerReference = {
        'nth:perfect-power-seq': {
            title: 'nth:perfect-power-seq',
            category: 'Number Theory',
            description: 'Generates the perfect power numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:perfect-power-seq(5)',
                'nth:perfect-power-seq(20)',
            ],
        },
        'nth:perfect-power-take-while': {
            title: 'nth:perfect-power-take-while',
            category: 'Number Theory',
            description: 'Generates the perfect power numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:perfect-power-take-while(-> $ <= 100)',
            ],
        },
        'nth:perfect-power-nth': {
            title: 'nth:perfect-power-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the perfect power numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:perfect-power-nth(3)',
                'nth:perfect-power-nth(15)',
            ],
        },
        'nth:perfect-power?': {
            title: 'nth:perfect-power?',
            category: 'Number Theory',
            description: 'Checks if a number is in the perfect power numbers.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:perfect-power?(7)',
                'nth:perfect-power?(8)',
                'nth:perfect-power?(9)',
                'nth:perfect-power?(10)',
            ],
        },
    };

    var polygonalReference = {
        'nth:polygonal-seq': {
            title: 'nth:polygonal-seq',
            category: 'Number Theory',
            description: 'Generates the polygonal sequence for a given number of sides and length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: __assign({ sides: {
                    type: 'integer',
                    description: 'The number of sides of the polygon.',
                }, length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                } }, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['sides', 'length'] },
            ],
            examples: [
                'nth:polygonal-seq(3, 2)',
                'nth:polygonal-seq(4, 2)',
                'nth:polygonal-seq(5, 3)',
                'nth:polygonal-seq(6, 5)',
                'nth:polygonal-seq(100, 10)',
            ],
        },
        'nth:polygonal-take-while': {
            title: 'nth:polygonal-take-while',
            category: 'Number Theory',
            description: 'Generates the polygonal sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: __assign({ sides: {
                    type: 'integer',
                    description: 'The number of sides of the polygon.',
                }, takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                } }, getOperatorArgs('integer', 'function')),
            variants: [
                { argumentNames: ['sides', 'takeWhile'] },
            ],
            examples: [
                'nth:polygonal-take-while(15, -> $ < 1000)',
            ],
        },
        'nth:polygonal-nth': {
            title: 'nth:polygonal-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the polygonal sequence.',
            returns: {
                type: 'integer',
            },
            args: __assign({ sides: {
                    type: 'integer',
                    description: 'The number of sides of the polygon.',
                }, n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                } }, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['sides', 'n'] },
            ],
            examples: [
                'nth:polygonal-nth(3, 9)',
                'nth:polygonal-nth(4, 5)',
                'nth:polygonal-nth(5, 5)',
            ],
        },
        'nth:polygonal?': {
            title: 'nth:polygonal?',
            category: 'Number Theory',
            description: 'Checks if a number is in the polygonal sequence.',
            returns: {
                type: 'boolean',
            },
            args: __assign({ sides: {
                    type: 'integer',
                    description: 'The number of sides of the polygon.',
                }, n: {
                    type: 'integer',
                    description: 'The number to check.',
                } }, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['sides', 'n'] },
            ],
            examples: [
                'nth:polygonal?(3, 10)',
                'nth:polygonal?(3, 9)',
                'nth:polygonal?(4, 10000)',
                'nth:polygonal?(4, 1000)',
                'nth:polygonal?(6, 45)',
            ],
        },
    };

    var primeReference = {
        'nth:prime-seq': {
            title: 'nth:prime-seq',
            category: 'Number Theory',
            description: 'Generates the prime sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:prime-seq(1)',
                'nth:prime-seq(2)',
                'nth:prime-seq(10)',
            ],
        },
        'nth:prime-take-while': {
            title: 'nth:prime-take-while',
            category: 'Number Theory',
            description: 'Generates the prime sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:prime-take-while(-> $ < 50)',
            ],
        },
        'nth:prime-nth': {
            title: 'nth:prime-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the prime sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:prime-nth(1)',
                'nth:prime-nth(2)',
                'nth:prime-nth(10)',
            ],
        },
        'nth:prime?': {
            title: 'nth:prime?',
            category: 'Number Theory',
            description: 'Determines if a number is prime.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:prime?(1)',
                'nth:prime?(2)',
                'nth:prime?(3)',
                'nth:prime?(4)',
                'nth:prime?(997)',
                'nth:prime?(1001)',
            ],
        },
    };

    var recamanReference = {
        'nth:recaman-seq': {
            title: 'nth:recaman-seq',
            category: 'Number Theory',
            description: 'Generates the Recaman sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:recaman-seq(5)',
                'nth:recaman-seq(10)',
                'nth:recaman-seq(20)',
            ],
        },
        'nth:recaman-take-while': {
            title: 'nth:recaman-take-while',
            category: 'Number Theory',
            description: 'Generates the Recaman sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:recaman-take-while(-> $ < 10)',
            ],
        },
        'nth:recaman-nth': {
            title: 'nth:recaman-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Recaman sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:recaman-nth(5)',
                'nth:recaman-nth(10)',
                'nth:recaman-nth(20)',
            ],
        },
        'nth:recaman?': {
            title: 'nth:recaman?',
            category: 'Number Theory',
            description: 'Checks if a number is in the Recaman sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:recaman?(5)',
                'nth:recaman?(10)',
                'nth:recaman?(20)',
            ],
        },
    };

    var sylvesterReference = {
        'nth:sylvester-seq': {
            title: 'nth:sylvester-seq',
            category: 'Number Theory',
            description: 'Generates the Sylvester sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate. If not provided, the default is 6 (the maximum length of the pre-calculated Sylvester numbers).',
                },
            },
            variants: [
                { argumentNames: ['length'] },
                { argumentNames: [] },
            ],
            examples: [
                'nth:sylvester-seq(5)',
                'nth:sylvester-seq()',
                'nth:sylvester-seq()',
            ],
        },
        'nth:sylvester-take-while': {
            title: 'nth:sylvester-take-while',
            category: 'Number Theory',
            description: 'Generates the Sylvester sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:sylvester-take-while(-> $ < 100000)',
            ],
        },
        'nth:sylvester-nth': {
            title: 'nth:sylvester-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Sylvester sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:sylvester-nth(1)',
                'nth:sylvester-nth(5)',
            ],
        },
        'nth:sylvester?': {
            title: 'nth:sylvester?',
            category: 'Number Theory',
            description: 'Checks if a number is in the Sylvester sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:sylvester?(2)',
                'nth:sylvester?(3)',
                'nth:sylvester?(6)',
            ],
        },
    };

    var thueMorseReference = {
        'nth:thue-morse-seq': {
            title: 'nth:thue-morse-seq',
            category: 'Number Theory',
            description: 'Generates the Thue-Morse sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:thue-morse-seq(5)',
                'nth:thue-morse-seq(10)',
                'nth:thue-morse-seq(20)',
            ],
        },
        'nth:thue-morse-take-while': {
            title: 'nth:thue-morse-take-while',
            category: 'Number Theory',
            description: 'Generates the Thue-Morse sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:thue-morse-take-while(-> $2 < 10)',
            ],
        },
        'nth:thue-morse-nth': {
            title: 'nth:thue-morse-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the Thue-Morse sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term in the sequence.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:thue-morse-nth(5)',
                'nth:thue-morse-nth(10)',
                'nth:thue-morse-nth(20)',
            ],
        },
        'nth:thue-morse?': {
            title: 'nth:thue-morse?',
            category: 'Number Theory',
            description: 'Checks if a number is part of the Thue-Morse sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:thue-morse?(1)',
                'nth:thue-morse?(2)',
            ],
        },
    };

    var tribonacciReference = {
        'nth:tribonacci-seq': {
            title: 'nth:tribonacci-seq',
            category: 'Number Theory',
            description: 'Generates the tribonacci sequence up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:tribonacci-seq(1)',
                'nth:tribonacci-seq(2)',
                'nth:tribonacci-seq(10)',
            ],
        },
        'nth:tribonacci-take-while': {
            title: 'nth:tribonacci-take-while',
            category: 'Number Theory',
            description: 'Generates the tribonacci sequence while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:tribonacci-take-while(-> $ < 100)',
            ],
        },
        'nth:tribonacci-nth': {
            title: 'nth:tribonacci-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the tribonacci sequence.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the term to generate.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:tribonacci-nth(1)',
                'nth:tribonacci-nth(2)',
                'nth:tribonacci-nth(10)',
            ],
        },
        'nth:tribonacci?': {
            title: 'nth:tribonacci?',
            category: 'Number Theory',
            description: 'Determines if a number is in the tribonacci sequence.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:tribonacci?(0)',
                'nth:tribonacci?(1)',
                'nth:tribonacci?(2)',
                'nth:tribonacci?(3)',
                'nth:tribonacci?(4)',
                'nth:tribonacci?(5)',
                'nth:tribonacci?(6)',
                'nth:tribonacci?(7)',
                'nth:tribonacci?(8)',
                'nth:tribonacci?(9)',
                'nth:tribonacci?(10)',
            ],
        },
    };

    var deficientReference = {
        'nth:deficient-seq': {
            title: 'nth:deficient-seq',
            category: 'Number Theory',
            description: 'Generates the deficient numbers up to a specified length.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the sequence to generate.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            examples: [
                'nth:deficient-seq(1)',
                'nth:deficient-seq(5)',
            ],
        },
        'nth:deficient-take-while': {
            title: 'nth:deficient-take-while',
            category: 'Number Theory',
            description: 'Generates the deficient numbers while a condition is met.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                takeWhile: {
                    type: 'function',
                    description: 'A function that takes an integer and an index and returns a boolean.',
                },
            },
            variants: [
                { argumentNames: ['takeWhile'] },
            ],
            examples: [
                'nth:deficient-take-while(-> $ < 100)',
            ],
        },
        'nth:deficient-nth': {
            title: 'nth:deficient-nth',
            category: 'Number Theory',
            description: 'Generates the nth term of the deficient numbers.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The index of the number in the sequence.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:deficient-nth(5)',
                'nth:deficient-nth(12)',
            ],
        },
        'nth:deficient?': {
            title: 'nth:deficient?',
            category: 'Number Theory',
            description: 'Checks if a number is deficient.',
            returns: {
                type: 'boolean',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:deficient?(12)',
                'nth:deficient?(15)',
            ],
        },
    };

    var numberTheoryReference = __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, abundantReference), arithmeticReference), bellReference), bernoulliReference), catalanReference), collatzReference), compositeReference), deficientReference), factorialReference), fibonacciReference), geometricReference), golombReference), happyReference), jugglerReference), lookAndSayReference), lucasReference), luckyReference), mersenneReference), padovanReference), partitionReference), pellReference), perfectReference), perfectSquareReference), perfectCubeReference), perfectPowerReference), polygonalReference), primeReference), recamanReference), sylvesterReference), thueMorseReference), tribonacciReference), { 'nth:count-combinations': {
            title: 'nth:count-combinations',
            category: 'Number Theory',
            description: 'Calculates the number of combinations of n items taken k at a time.',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'nth:count-combinations(5, 3)',
                'nth:binomial(10, 2)',
            ],
            aliases: ['nth:binomial'],
        }, 'nth:combinations': {
            title: 'nth:combinations',
            category: 'Number Theory',
            description: 'Generates all possible combinations of a specified size from a collection.',
            returns: {
                type: 'array',
                array: true,
            },
            args: __assign({ set: {
                    type: 'array',
                    array: true,
                    description: 'The input collection to generate combinations from.',
                }, n: {
                    type: 'integer',
                    description: 'The size of each combination.',
                } }, getOperatorArgs('array', 'integer')),
            variants: [
                { argumentNames: ['set', 'n'] },
            ],
            examples: [
                'nth:combinations([1, 2, 3], 2)',
                'nth:combinations(["a", "b", "c"], 2)',
                'nth:combinations([1, 2, 3], 0)',
                'nth:combinations([1, 2, 3], 1)',
                'nth:combinations([1, 2, 3], 3)',
            ],
        }, 'nth:count-derangements': {
            title: 'nth:count-derangements',
            category: 'Number Theory',
            description: 'Calculates the number of derangements (permutations where no element appears in its original position) of n items.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The total number of items.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:count-derangements(4)',
                'nth:count-derangements(5)',
            ],
        }, 'nth:derangements': {
            title: 'nth:derangements',
            category: 'Number Theory',
            description: 'Generates all derangements (permutations where no element appears in its original position) of a set.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                set: {
                    type: 'array',
                    array: true,
                    description: 'The input collection to generate derangements from.',
                },
            },
            variants: [
                { argumentNames: ['set'] },
            ],
            examples: [
                'nth:derangements([1, 2, 3, 4])',
                'nth:derangements(["a", "b", "c"])',
            ],
        }, 'nth:divisors': {
            title: 'nth:divisors',
            category: 'Number Theory',
            description: 'Returns the divisors of a number.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to find divisors for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:divisors(12)',
                'nth:divisors(100)',
                'nth:divisors(37)',
            ],
        }, 'nth:count-divisors': {
            title: 'nth:count-divisors',
            category: 'Number Theory',
            description: 'Returns the number of divisors of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count divisors for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:count-divisors(12)',
                'nth:count-divisors(100)',
                'nth:count-divisors(37)',
            ],
        }, 'nth:proper-divisors': {
            title: 'nth:proper-divisors',
            category: 'Number Theory',
            description: 'Returns the proper divisors of a number.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to find proper divisors for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:proper-divisors(12)',
                'nth:proper-divisors(100)',
                'nth:proper-divisors(37)',
            ],
        }, 'nth:count-proper-divisors': {
            title: 'nth:count-proper-divisors',
            category: 'Number Theory',
            description: 'Returns the number of proper divisors of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count proper divisors for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:count-proper-divisors(12)',
                'nth:count-proper-divisors(100)',
                'nth:count-proper-divisors(37)',
            ],
        }, 'nth:factorial': {
            title: 'nth:factorial',
            category: 'Number Theory',
            description: 'Calculates the factorial of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the factorial for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:factorial(5)',
                'nth:factorial(0)',
                'nth:!(10)',
                'nth:!(20)',
            ],
            aliases: ['nth:!'],
        }, 'nth:partitions': {
            title: 'nth:partitions',
            category: 'Number Theory',
            description: 'Generates all partitions of a number.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to partition.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:partitions(4)',
                'nth:partitions(8)',
            ],
        }, 'nth:count-partitions': {
            title: 'nth:count-partitions',
            category: 'Number Theory',
            description: 'Returns the number of partitions of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count partitions for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:count-partitions(4)',
                'nth:count-partitions(8)',
                'nth:count-partitions(15)',
            ],
        }, 'nth:permutations': {
            title: 'nth:permutations',
            category: 'Number Theory',
            description: 'Generates all permutations of a collection.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                set: {
                    type: 'array',
                    array: true,
                    description: 'The input collection to generate permutations from.',
                },
            },
            variants: [
                { argumentNames: ['set'] },
            ],
            examples: [
                'nth:permutations([1, 2, 3])',
                'nth:permutations(["a", "b", "c"])',
                'nth:permutations([1, 2, 3, 4])',
                'nth:permutations([1, 2])',
                'nth:permutations([1])',
                'nth:permutations([])',
            ],
        }, 'nth:count-permutations': {
            title: 'nth:count-permutations',
            category: 'Number Theory',
            description: 'Returns the number of permutations of n items taken k at a time.',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'nth:count-permutations(5, 3)',
                'nth:count-permutations(10, 2)',
                'nth:count-permutations(10, 10)',
                'nth:count-permutations(10, 0)',
                'nth:count-permutations(10, 1)',
            ],
        }, 'nth:power-set': {
            title: 'nth:power-set',
            category: 'Number Theory',
            description: 'Generates the power set of a collection.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                set: {
                    type: 'any',
                    array: true,
                    description: 'The input collection to generate the power set from.',
                },
            },
            variants: [
                { argumentNames: ['set'] },
            ],
            examples: [
                'nth:power-set(["a", "b", "c"])',
                'nth:power-set([1, 2])',
                'nth:power-set([1])',
                'nth:power-set([])',
            ],
        }, 'nth:count-power-set': {
            title: 'nth:count-power-set',
            category: 'Number Theory',
            description: 'Returns the number of subsets of a set.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The size of the set.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:count-power-set(3)',
                'nth:count-power-set(5)',
                'nth:count-power-set(10)',
            ],
        }, 'nth:prime-factors': {
            title: 'nth:prime-factors',
            category: 'Number Theory',
            description: 'Returns the prime factors of a number.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to factor.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:prime-factors(12)',
                'nth:prime-factors(100)',
                'nth:prime-factors(37)',
            ],
        }, 'nth:count-prime-factors': {
            title: 'nth:count-prime-factors',
            category: 'Number Theory',
            description: 'Returns the number of prime factors of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count prime factors for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:count-prime-factors(12)',
                'nth:count-prime-factors(100)',
                'nth:count-prime-factors(37)',
            ],
        }, 'nth:distinct-prime-factors': {
            title: 'nth:distinct-prime-factors',
            category: 'Number Theory',
            description: 'Returns the distinct prime factors of a number.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to find distinct prime factors for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:distinct-prime-factors(12)',
                'nth:distinct-prime-factors(100)',
                'nth:distinct-prime-factors(37)',
            ],
        }, 'nth:count-distinct-prime-factors': {
            title: 'nth:count-distinct-prime-factors',
            category: 'Number Theory',
            description: 'Returns the number of distinct prime factors of a number.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to count distinct prime factors for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:count-distinct-prime-factors(12)',
                'nth:count-distinct-prime-factors(100)',
                'nth:count-distinct-prime-factors(37)',
            ],
        }, 'nth:coprime?': {
            title: 'nth:coprime?',
            category: 'Number Theory',
            description: 'Checks if two numbers are coprime (i.e., their GCD is 1).',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'nth:coprime?(12, 8)',
                'nth:coprime?(12, 5)',
                'nth:coprime?(37, 1)',
                'nth:coprime?(0, 0)',
                'nth:coprime?(0, 5)',
                'nth:coprime?(5, 0)',
                'nth:coprime?(1, 0)',
                'nth:coprime?(0, 1)',
                'nth:coprime?(1, 1)',
                'nth:coprime?(2, 3)',
            ],
        }, 'nth:divisible-by?': {
            title: 'nth:divisible-by?',
            category: 'Number Theory',
            description: 'Checks if a number is divisible by another number.',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                '12 nth:divisible-by? 4',
                'nth:divisible-by?(12, 4)',
                'nth:divisible-by?(12, 5)',
                'nth:divisible-by?(37, 1)',
                'nth:divisible-by?(0, 0)',
                'nth:divisible-by?(0, 5)',
                'nth:divisible-by?(5, 0)',
            ],
        }, 'nth:gcd': {
            title: 'nth:gcd',
            category: 'Number Theory',
            description: 'Calculates the greatest common divisor (GCD) of two numbers.',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                '12 nth:gcd  8',
                'nth:gcd(100, 25)',
                'nth:gcd(37, 1)',
                'nth:gcd(0, 0)',
                'nth:gcd(0, 5)',
                'nth:gcd(5, 0)',
            ],
        }, 'nth:lcm': {
            title: 'nth:lcm',
            category: 'Number Theory',
            description: 'Calculates the least common multiple (LCM) of two numbers.',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                '12 nth:lcm  8',
                'nth:lcm(100, 25)',
                'nth:lcm(37, 1)',
                'nth:lcm(0, 5)',
                'nth:lcm(5, 0)',
            ],
        }, 'nth:multinomial': {
            title: 'nth:multinomial',
            category: 'Number Theory',
            description: 'Calculates the multinomial coefficient from of a list of numbers representing the sizes of each group.',
            returns: {
                type: 'integer',
            },
            args: {
                args: {
                    type: 'integer',
                    rest: true,
                    description: 'The numbers representing the sizes of each group.',
                },
            },
            variants: [
                { argumentNames: ['args'] },
            ],
            examples: [
                'nth:multinomial(5, 2, 3)',
                'nth:multinomial(10, 2, 3, 5)',
            ],
            noOperatorDocumentation: true,
        }, 'nth:amicable?': {
            title: 'nth:amicable?',
            category: 'Number Theory',
            description: 'Checks if two numbers are amicable (i.e., the sum of the proper divisors of each number equals the other number).',
            returns: {
                type: 'boolean',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'nth:amicable?(220, 284)',
                'nth:amicable?(1184, 1210)',
                'nth:amicable?(2620, 2924)',
                'nth:amicable?(5020, 5564)',
                'nth:amicable?(6232, 6368)',
            ],
        }, 'nth:euler-totient': {
            title: 'nth:euler-totient',
            category: 'Number Theory',
            description: 'Calculates the Euler\'s totient function (φ(n)) of a number, which counts the integers up to n that are coprime to n.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the totient for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:euler-totient(1)',
                'nth:euler-totient(2)',
                'nth:euler-totient(10)',
                'nth:euler-totient(20)',
            ],
        }, 'nth:mobius': {
            title: 'nth:mobius',
            category: 'Number Theory',
            description: 'Calculates the Möbius function (μ(n)) of a number, which is used in number theory.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the Möbius function for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:mobius(1)',
                'nth:mobius(2)',
                'nth:mobius(3)',
                'nth:mobius(4)',
                'nth:mobius(6)',
                'nth:mobius(12)',
                'nth:mobius(30)',
            ],
            aliases: ['nth:möbius'],
        }, 'nth:mertens': {
            title: 'nth:mertens',
            category: 'Number Theory',
            description: 'Calculates the Mertens function (M(n)) of a number, which is the sum of the Möbius function up to n.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the Mertens function for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:mobius(1)',
                'nth:mobius(2)',
                'nth:mobius(3)',
                'nth:mobius(4)',
                'nth:mobius(6)',
                'nth:mobius(12)',
                'nth:mobius(30)',
            ],
        }, 'nth:sigma': {
            title: 'nth:sigma',
            category: 'Number Theory',
            description: 'Calculates the sum of divisors function (σ(n)) of a number, which is the sum of all positive divisors of n.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the sum of divisors for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:sigma(1)',
                'nth:sigma(2)',
                'nth:sigma(3)',
                'nth:sigma(4)',
                'nth:sigma(6)',
                'nth:sigma(12)',
                'nth:sigma(30)',
            ],
        }, 'nth:carmichael-lambda': {
            title: 'nth:carmichael-lambda',
            category: 'Number Theory',
            description: 'Calculates the Carmichael function (λ(n)) of a number, which is the smallest positive integer m such that a^m ≡ 1 (mod n) for all integers a coprime to n.',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to calculate the Carmichael function for.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:carmichael-lambda(1)',
                'nth:carmichael-lambda(2)',
                'nth:carmichael-lambda(3)',
                'nth:carmichael-lambda(4)',
                'nth:carmichael-lambda(6)',
                'nth:carmichael-lambda(12)',
                'nth:carmichael-lambda(30)',
            ],
        }, 'nth:cartesian-product': {
            title: 'nth:cartesian-product',
            category: 'Number Theory',
            description: 'Calculates the Cartesian product of two or more sets.',
            returns: {
                type: 'array',
                array: true,
            },
            args: __assign({ sets: {
                    type: 'array',
                    array: true,
                    description: 'The input collections to calculate the Cartesian product from.',
                } }, getOperatorArgs('array', 'array')),
            variants: [
                { argumentNames: ['sets'] },
            ],
            examples: [
                'nth:cartesian-product([1, 2], ["a", "b"])',
                'nth:cartesian-product([1, 2], ["a", "b"], [true, false])',
                'nth:cartesian-product([1, 2, 3], ["x", "y", "z"])',
            ],
        }, 'nth:perfect-power': {
            title: 'nth:perfect-power',
            category: 'Number Theory',
            description: 'Returns a tuple of the base and exponent if the number is a perfect power, otherwise returns null.',
            returns: {
                type: 'array',
                array: true,
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number to check.',
                },
            },
            variants: [
                { argumentNames: ['n'] },
            ],
            examples: [
                'nth:perfect-power(1)',
                'nth:perfect-power(2)',
                'nth:perfect-power(4)',
                'nth:perfect-power(8)',
                'nth:perfect-power(9)',
                'nth:perfect-power(16)',
                'nth:perfect-power(19)',
            ],
        }, 'nth:mod-exp': {
            title: 'nth:mod-exp',
            category: 'Number Theory',
            description: 'Calculates the modular exponentiation of a base raised to an exponent modulo a modulus.',
            returns: {
                type: 'integer',
            },
            args: {
                base: {
                    type: 'integer',
                },
                exponent: {
                    type: 'integer',
                },
                modulus: {
                    type: 'integer',
                },
            },
            variants: [
                { argumentNames: ['base', 'exponent', 'modulus'] },
            ],
            examples: [
                'nth:mod-exp(2, 3, 5)',
                'nth:mod-exp(3, 4, 7)',
                'nth:mod-exp(5, 6, 11)',
                'nth:mod-exp(7, 8, 13)',
            ],
        }, 'nth:mod-inv': {
            title: 'nth:mod-inv',
            category: 'Number Theory',
            description: 'Calculates the modular multiplicative inverse of a number modulo another number.',
            returns: {
                type: 'integer',
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'm'] },
            ],
            examples: [
                'nth:mod-inv(3, 11)',
                'nth:mod-inv(10, 17)',
                'nth:mod-inv(5, 13)',
                'nth:mod-inv(7, 19)',
            ],
        }, 'nth:extended-gcd': {
            title: 'nth:extended-gcd',
            category: 'Number Theory',
            description: 'Calculates the extended greatest common divisor (GCD) of two numbers, returning the GCD and the coefficients of Bézout\'s identity.',
            returns: {
                type: 'integer',
                array: true,
            },
            args: __assign({}, getOperatorArgs('integer', 'integer')),
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'nth:extended-gcd(30, 12)',
                'nth:extended-gcd(56, 98)',
                'nth:extended-gcd(101, 10)',
                'nth:extended-gcd(17, 13)',
            ],
        }, 'nth:chinese-remainder': {
            title: 'nth:chinese-remainder',
            category: 'Number Theory',
            description: 'Solves a system of simultaneous congruences using the Chinese Remainder Theorem.',
            returns: {
                type: 'integer',
            },
            args: __assign({ remainders: {
                    type: 'integer',
                    array: true,
                    description: 'The remainders of the congruences.',
                }, moduli: {
                    type: 'integer',
                    array: true,
                    description: 'The moduli of the congruences.',
                } }, getOperatorArgs('array', 'array')),
            variants: [
                { argumentNames: ['remainders', 'moduli'] },
            ],
            examples: [
                'nth:chinese-remainder([2, 3], [3, 5])',
                'nth:chinese-remainder([1, 2], [3, 4])',
                'nth:chinese-remainder([0, 1], [2, 3])',
                'nth:chinese-remainder([1, 2, 3], [4, 5, 7])',
            ],
        }, 'nth:stirling-first': {
            title: 'nth:stirling-first',
            category: 'Number Theory',
            description: 'Calculates the Stirling numbers of the first kind, which count the number of permutations of n elements with k cycles.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                    description: 'The number of elements.',
                },
                b: {
                    type: 'integer',
                    description: 'The number of cycles.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'nth:stirling-first(5, 2)',
                'nth:stirling-first(4, 3)',
                'nth:stirling-first(6, 1)',
                'nth:stirling-first(7, 4)',
                'nth:stirling-first(8, 5)',
            ],
        }, 'nth:stirling-second': {
            title: 'nth:stirling-second',
            category: 'Number Theory',
            description: 'Calculates the Stirling numbers of the second kind, which count the number of ways to partition n elements into k non-empty subsets.',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                    description: 'The number of elements.',
                },
                b: {
                    type: 'integer',
                    description: 'The number of subsets.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            examples: [
                'nth:stirling-second(5, 2)',
                'nth:stirling-second(4, 3)',
                'nth:stirling-second(6, 1)',
                'nth:stirling-second(7, 4)',
                'nth:stirling-second(8, 5)',
            ],
        } });

    var randomReference = {
        '!:random': {
            title: '!:random',
            category: 'Random',
            returns: {
                type: 'number',
            },
            args: {},
            variants: [
                { argumentNames: [] },
            ],
            description: 'Returns a random number between 0 and 1.',
            examples: [
                '!:random()',
            ],
        },
        '!:random-int': {
            title: '!:random-int',
            category: 'Random',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                    description: 'The minimum value.',
                },
                b: {
                    type: 'integer',
                    description: 'The maximum value (exclusive).',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns a random integer between min and max (exclusive).',
            examples: [
                '!:random-int(0, 10)',
                '!:random-int(1, 100)',
            ],
        },
        '!:random-int-inclusive': {
            title: '!:random-int-inclusive',
            category: 'Random',
            returns: {
                type: 'integer',
            },
            args: {
                a: {
                    type: 'integer',
                    description: 'The minimum value.',
                },
                b: {
                    type: 'integer',
                    description: 'The maximum value (inclusive).',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns a random integer between min and max (inclusive).',
            examples: [
                '!:random-int-inclusive(0, 10)',
            ],
        },
        '!:random-float': {
            title: '!:random-float',
            category: 'Random',
            returns: {
                type: 'number',
            },
            args: {
                a: {
                    type: 'number',
                    description: 'The minimum value.',
                },
                b: {
                    type: 'number',
                    description: 'The maximum value.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns a random float between min and max.',
            examples: [
                '!:random-float(0, 10)',
                '!:random-float(1, 100)',
            ],
        },
        '!:random-boolean': {
            title: '!:random-boolean',
            category: 'Random',
            returns: {
                type: 'boolean',
            },
            args: {
                prob: {
                    type: 'number',
                    description: 'The probability of returning true (between 0 and 1).',
                },
            },
            variants: [
                { argumentNames: ['prob'] },
            ],
            description: 'Returns a random boolean.',
            examples: [
                '!:random-boolean()',
                '!:random-boolean(0.99)',
            ],
        },
        '!:random-item': {
            title: '!:random-item',
            category: 'Random',
            returns: {
                type: 'any',
            },
            args: {
                a: {
                    type: 'array',
                    description: 'The array to sample from.',
                },
            },
            variants: [
                { argumentNames: ['a'] },
            ],
            description: 'Returns a random item from the array.',
            examples: [
                '!:random-item([1, 2, 3, 4, 5])',
                '!:random-item(["apple", "banana", "cherry"])',
            ],
        },
        '!:random-sample-unique': {
            title: '!:random-sample-unique',
            category: 'Random',
            returns: {
                type: 'array',
            },
            args: {
                a: {
                    type: 'array',
                    description: 'The array to sample from.',
                },
                b: {
                    type: 'integer',
                    description: 'The number of items to sample.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns a random sample of n unique items from the array.',
            examples: [
                '!:random-sample-unique([1, 2, 3, 4, 5], 3)',
                '!:random-sample-unique(["apple", "banana", "cherry"], 2)',
            ],
        },
        '!:random-sample': {
            title: '!:random-sample',
            category: 'Random',
            returns: {
                type: 'array',
            },
            args: {
                a: {
                    type: 'array',
                    description: 'The array to sample from.',
                },
                b: {
                    type: 'integer',
                    description: 'The number of items to sample.',
                },
            },
            variants: [
                { argumentNames: ['a', 'b'] },
            ],
            description: 'Returns a random sample of n items from the array.',
            examples: [
                '!:random-sample([1, 2, 3, 4, 5], 3)',
                '!:random-sample(["apple", "banana", "cherry"], 10)',
            ],
        },
        '!:shuffle': {
            title: '!:shuffle',
            category: 'Random',
            returns: {
                type: 'array',
            },
            args: {
                a: {
                    type: 'array',
                    description: 'The array to shuffle.',
                },
            },
            variants: [
                { argumentNames: ['a'] },
            ],
            description: 'Returns a shuffled version of the array.',
            examples: [
                '!:shuffle([1, 2, 3, 4, 5])',
                '!:shuffle(["apple", "banana", "cherry"])',
            ],
        },
        '!:random-normal': {
            title: '!:random-normal',
            category: 'Random',
            returns: {
                type: 'number',
            },
            args: {
                mean: {
                    type: 'number',
                    description: 'The mean of the normal distribution.',
                },
                stdDev: {
                    type: 'number',
                    description: 'The standard deviation of the normal distribution.',
                },
            },
            variants: [
                { argumentNames: ['mean', 'stdDev'] },
            ],
            description: 'Returns a random number from a normal distribution with the given mean and standard deviation.',
            examples: [
                '!:random-normal(0, 1)',
                '!:random-normal(5, 2)',
            ],
            noOperatorDocumentation: true,
        },
        '!:random-exponential': {
            title: '!:random-exponential',
            category: 'Random',
            returns: {
                type: 'number',
            },
            args: {
                lambda: {
                    type: 'number',
                    description: 'The rate parameter of the exponential distribution.',
                },
            },
            variants: [
                { argumentNames: ['lambda'] },
            ],
            description: 'Returns a random number from an exponential distribution with the given rate parameter.',
            examples: [
                '!:random-exponential(1)',
                '!:random-exponential(0.5)',
            ],
        },
        '!:random-binomial': {
            title: '!:random-binomial',
            category: 'Random',
            returns: {
                type: 'integer',
            },
            args: {
                n: {
                    type: 'integer',
                    description: 'The number of trials.',
                },
                p: {
                    type: 'number',
                    description: 'The probability of success on each trial.',
                },
            },
            variants: [
                { argumentNames: ['n', 'p'] },
            ],
            description: 'Returns a random number from a binomial distribution with the given number of trials and probability of success.',
            examples: [
                '!:random-binomial(10, 0.5)',
                '!:random-binomial(20, 0.3)',
            ],
            noOperatorDocumentation: true,
        },
        '!:random-poisson': {
            title: '!:random-poisson',
            category: 'Random',
            returns: {
                type: 'integer',
            },
            args: {
                lambda: {
                    type: 'number',
                    description: 'The rate parameter of the Poisson distribution.',
                },
            },
            variants: [
                { argumentNames: ['lambda'] },
            ],
            description: 'Returns a random number from a Poisson distribution with the given rate parameter.',
            examples: [
                '!:random-poisson(1)',
                '!:random-poisson(5)',
            ],
        },
        '!:random-gamma': {
            title: '!:random-gamma',
            category: 'Random',
            returns: {
                type: 'number',
            },
            args: {
                shape: {
                    type: 'number',
                    description: 'The shape parameter of the gamma distribution.',
                },
                scale: {
                    type: 'number',
                    description: 'The scale parameter of the gamma distribution.',
                },
            },
            variants: [
                { argumentNames: ['shape', 'scale'] },
            ],
            description: 'Returns a random number from a gamma distribution with the given shape and scale parameters.',
            examples: [
                '!:random-gamma(2, 2)',
                '!:random-gamma(5, 1)',
            ],
            noOperatorDocumentation: true,
        },
        '!:random-pareto': {
            title: '!:random-pareto',
            category: 'Random',
            returns: {
                type: 'number',
            },
            args: {
                alpha: {
                    type: 'number',
                    description: 'The shape parameter of the Pareto distribution.',
                },
            },
            variants: [
                { argumentNames: ['alpha'] },
            ],
            description: 'Returns a random number from a Pareto distribution with the given shape parameter.',
            examples: [
                '!:random-pareto(1)',
                '!:random-pareto(2)',
            ],
        },
        '!:uuid': {
            title: '!:uuid',
            category: 'Random',
            returns: {
                type: 'string',
            },
            args: {},
            variants: [
                { argumentNames: [] },
            ],
            description: 'Returns a random UUID v4 (Universally Unique Identifier).',
            examples: [
                '!:uuid()',
            ],
        },
        '!:random-char': {
            title: '!:random-char',
            category: 'Random',
            returns: {
                type: 'string',
            },
            args: {
                charSet: {
                    type: 'string',
                    description: 'The string to sample from.',
                },
            },
            variants: [
                { argumentNames: ['charSet'] },
            ],
            description: 'Returns a random character from the given string.',
            examples: [
                '!:random-char("abcde")',
                '!:random-char("ABCDEFGHIJKLMNOPQRSTUVWXYZ")',
            ],
        },
        '!:random-string': {
            title: '!:random-string',
            category: 'Random',
            returns: {
                type: 'string',
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the random string.',
                },
                charSet: {
                    type: 'string',
                    description: 'The string to sample from.',
                },
            },
            variants: [
                { argumentNames: ['length', 'charSet'] },
            ],
            description: 'Returns a random string of the given length from the given string.',
            examples: [
                '!:random-string(10, "abcde")',
                '!:random-string(5, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")',
            ],
            noOperatorDocumentation: true,
        },
        '!:random-id': {
            title: '!:random-id',
            category: 'Random',
            returns: {
                type: 'string',
            },
            args: {
                length: {
                    type: 'integer',
                    description: 'The length of the random ID.',
                },
            },
            variants: [
                { argumentNames: ['length'] },
            ],
            description: 'Returns a random ID of the given length.',
            examples: [
                '!:random-id(10)',
                '!:random-id(5)',
            ],
        },
        '!:random-color': {
            title: '!:random-color',
            category: 'Random',
            returns: {
                type: 'string',
            },
            args: {},
            variants: [
                { argumentNames: [] },
            ],
            description: 'Returns a random color in hex format.',
            examples: [
                '!:random-color()',
            ],
        },
    };

    function isFunctionReference(ref) {
        return 'returns' in ref && 'args' in ref && 'variants' in ref;
    }
    var normalExpressionReference = __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, collectionReference), arrayReference), sequenceReference), mathReference), functionalReference), miscReference), objectReference), predicateReference), regularExpressionReference), stringReference), bitwiseReference), assertReference), vectorReference), linAlgReference), matrixReference), numberTheoryReference), gridReference), randomReference);
    Object.entries(normalExpressionReference).forEach(function (_a) {
        var _b = __read(_a, 2), key = _b[0], obj = _b[1];
        if (!normalExpressions[key]) {
            throw new Error("Missing normal expression ".concat(key, " in normalExpressions"));
        }
        var paramCount = normalExpressions[key].paramCount;
        if (!obj.noOperatorDocumentation && canBeOperator(paramCount)) {
            obj._isOperator = true;
            if (isSymbolicOperator(key)) {
                obj._prefereOperator = true;
            }
        }
    });
    Object.entries(specialExpressionsReference).forEach(function (_a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], obj = _c[1];
        if (isFunctionReference(obj)) {
            var paramCount = (_b = specialExpressions[specialExpressionTypes[key]]) === null || _b === void 0 ? void 0 : _b.paramCount;
            if (paramCount && canBeOperator(paramCount)) {
                obj._isOperator = true;
            }
        }
    });
    var functionReference = __assign(__assign({}, normalExpressionReference), specialExpressionsReference);
    var apiReference = __assign(__assign(__assign({}, functionReference), shorthand), datatype);
    Object.values(apiReference).forEach(function (ref) {
        ref.title = ref.title.replace(/"/g, '&quot;');
    });

    var getUndefinedSymbols = function (ast, contextStack, builtin, evaluateNode) {
        var e_1, _a;
        var _b;
        var nodes = Array.isArray(ast)
            ? ast
            : [[NodeTypes.SpecialExpression, [specialExpressionTypes.block, ast.body]]];
        var unresolvedSymbols = new Set();
        try {
            for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
                var subNode = nodes_1_1.value;
                (_b = findUnresolvedSymbolsInNode(subNode, contextStack, builtin, evaluateNode)) === null || _b === void 0 ? void 0 : _b.forEach(function (symbol) { return unresolvedSymbols.add(symbol); });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return unresolvedSymbols;
    };
    function findUnresolvedSymbolsInNode(node, contextStack, builtin, evaluateNode) {
        var e_2, _a;
        var _b, _c;
        var nodeType = node[0];
        switch (nodeType) {
            case NodeTypes.UserDefinedSymbol: {
                var symbolNode = node;
                var lookUpResult = contextStack.lookUp(symbolNode);
                if (lookUpResult === null)
                    return new Set([symbolNode[1]]);
                return null;
            }
            case NodeTypes.NormalBuiltinSymbol:
            case NodeTypes.SpecialBuiltinSymbol:
            case NodeTypes.String:
            case NodeTypes.Number:
            case NodeTypes.ReservedSymbol:
            case NodeTypes.Binding:
                return null;
            case NodeTypes.NormalExpression: {
                var normalExpressionNode = node;
                var unresolvedSymbols_1 = new Set();
                if (isNormalExpressionNodeWithName(normalExpressionNode)) {
                    var _d = __read(normalExpressionNode, 2), _e = __read(_d[1], 1), symbolNode = _e[0];
                    if (isUserDefinedSymbolNode(symbolNode)) {
                        var lookUpResult = contextStack.lookUp(symbolNode);
                        if (lookUpResult === null)
                            unresolvedSymbols_1.add(symbolNode[1]);
                    }
                }
                else {
                    var _f = __read(normalExpressionNode, 2), _g = __read(_f[1], 1), expressionNode = _g[0];
                    (_b = findUnresolvedSymbolsInNode(expressionNode, contextStack, builtin, evaluateNode)) === null || _b === void 0 ? void 0 : _b.forEach(function (symbol) { return unresolvedSymbols_1.add(symbol); });
                }
                try {
                    for (var _h = __values(normalExpressionNode[1][1]), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var subNode = _j.value;
                        (_c = findUnresolvedSymbolsInNode(subNode, contextStack, builtin, evaluateNode)) === null || _c === void 0 ? void 0 : _c.forEach(function (symbol) { return unresolvedSymbols_1.add(symbol); });
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_a = _h.return)) _a.call(_h);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return unresolvedSymbols_1;
            }
            case NodeTypes.SpecialExpression: {
                var specialExpressionNode = node;
                var specialExpressionType = specialExpressionNode[1][0];
                var specialExpression = builtin.specialExpressions[specialExpressionType];
                var castedGetUndefinedSymbols = specialExpression.getUndefinedSymbols;
                return castedGetUndefinedSymbols(specialExpressionNode, contextStack, {
                    getUndefinedSymbols: getUndefinedSymbols,
                    builtin: builtin,
                    evaluateNode: evaluateNode,
                });
            }
            case NodeTypes.Spread:
                return findUnresolvedSymbolsInNode(node[1], contextStack, builtin, evaluateNode);
            /* v8 ignore next 2 */
            default:
                throw new LitsError("Unhandled node type: ".concat(nodeType), node[2]);
        }
    }

    function checkParams(evaluatedFunction, nbrOfParams, sourceCodeInfo) {
        var minArity = evaluatedFunction[0].filter(function (arg) { return arg[0] !== bindingTargetTypes.rest && arg[1][1] === undefined; }).length;
        if (nbrOfParams < minArity) {
            throw new LitsError("Unexpected number of arguments. Expected at least ".concat(minArity, ", got ").concat(nbrOfParams, "."), sourceCodeInfo);
        }
    }
    var functionExecutors = {
        NativeJsFunction: function (fn, params, sourceCodeInfo) {
            var _a;
            try {
                return toAny((_a = fn.nativeFn).fn.apply(_a, __spreadArray([], __read(params), false)));
            }
            catch (error) {
                var message = typeof error === 'string'
                    ? error
                    : isUnknownRecord(error) && typeof error.message === 'string'
                        ? error.message
                        : '<no message>';
                throw new LitsError("Native function throwed: \"".concat(message, "\""), sourceCodeInfo);
            }
        },
        UserDefined: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var evaluateNode = _a.evaluateNode;
            var _loop_1 = function () {
                var e_1, _b;
                checkParams(fn.evaluatedfunction, params.length, sourceCodeInfo);
                var evaluatedFunction = fn.evaluatedfunction;
                var args = evaluatedFunction[0];
                var nbrOfNonRestArgs = args.filter(function (arg) { return arg[0] !== bindingTargetTypes.rest; }).length;
                var newContextStack = contextStack.create(fn.evaluatedfunction[2]);
                var newContext = {};
                var rest = [];
                for (var i = 0; i < params.length; i += 1) {
                    if (i < nbrOfNonRestArgs) {
                        var param = toAny(params[i]);
                        var valueRecord = evalueateBindingNodeValues(args[i], param, function (Node) {
                            return evaluateNode(Node, newContextStack.create(newContext));
                        });
                        Object.entries(valueRecord).forEach(function (_a) {
                            var _b = __read(_a, 2), key = _b[0], value = _b[1];
                            newContext[key] = { value: value };
                        });
                    }
                    else {
                        rest.push(toAny(params[i]));
                    }
                }
                for (var i = params.length; i < nbrOfNonRestArgs; i++) {
                    var arg = args[i];
                    var defaultValue = evaluateNode(arg[1][1], contextStack.create(newContext));
                    var valueRecord = evalueateBindingNodeValues(arg, defaultValue, function (Node) {
                        return evaluateNode(Node, contextStack.create(newContext));
                    });
                    Object.entries(valueRecord).forEach(function (_a) {
                        var _b = __read(_a, 2), key = _b[0], value = _b[1];
                        newContext[key] = { value: value };
                    });
                }
                var restArgument = args.find(function (arg) { return arg[0] === bindingTargetTypes.rest; });
                if (restArgument !== undefined) {
                    var valueRecord = evalueateBindingNodeValues(restArgument, rest, function (Node) { return evaluateNode(Node, contextStack.create(newContext)); });
                    Object.entries(valueRecord).forEach(function (_a) {
                        var _b = __read(_a, 2), key = _b[0], value = _b[1];
                        newContext[key] = { value: value };
                    });
                }
                try {
                    var result = null;
                    var newContextStack2 = newContextStack.create(newContext);
                    try {
                        for (var _c = (e_1 = void 0, __values(evaluatedFunction[1])), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var node = _d.value;
                            result = evaluateNode(node, newContextStack2);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    return { value: result };
                }
                catch (error) {
                    if (error instanceof RecurSignal) {
                        params = error.params;
                        return "continue";
                    }
                    throw error;
                }
            };
            for (;;) {
                var state_1 = _loop_1();
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        },
        Partial: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var e_2, _b;
            var executeFunction = _a.executeFunction;
            var actualParams = __spreadArray([], __read(fn.params), false);
            if (params.length !== fn.placeholders.length) {
                throw new LitsError("(partial) expects ".concat(fn.placeholders.length, " arguments, got ").concat(params.length, "."), sourceCodeInfo);
            }
            var paramsCopy = __spreadArray([], __read(params), false);
            try {
                for (var _c = __values(fn.placeholders), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var placeholderIndex = _d.value;
                    actualParams.splice(placeholderIndex, 0, paramsCopy.shift());
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return executeFunction(fn.function, actualParams, contextStack, sourceCodeInfo);
        },
        Comp: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            var f = fn.params;
            if (f.length === 0) {
                if (params.length !== 1)
                    throw new LitsError("(comp) expects one argument, got ".concat(valueToString(params.length), "."), sourceCodeInfo);
                return asAny(params[0], sourceCodeInfo);
            }
            return asAny(f.reduceRight(function (result, fun) {
                return [executeFunction(asFunctionLike(fun, sourceCodeInfo), result, contextStack, sourceCodeInfo)];
            }, params)[0], sourceCodeInfo);
        },
        Constantly: function (fn) {
            return fn.value;
        },
        Juxt: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            return fn.params.map(function (fun) { return executeFunction(asFunctionLike(fun, sourceCodeInfo), params, contextStack, sourceCodeInfo); });
        },
        Complement: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            return !executeFunction(fn.function, params, contextStack, sourceCodeInfo);
        },
        EveryPred: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var e_3, _b, e_4, _c;
            var executeFunction = _a.executeFunction;
            try {
                for (var _d = __values(fn.params), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var f = _e.value;
                    try {
                        for (var params_1 = (e_4 = void 0, __values(params)), params_1_1 = params_1.next(); !params_1_1.done; params_1_1 = params_1.next()) {
                            var param = params_1_1.value;
                            var result = executeFunction(asFunctionLike(f, sourceCodeInfo), [param], contextStack, sourceCodeInfo);
                            if (!result)
                                return false;
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (params_1_1 && !params_1_1.done && (_c = params_1.return)) _c.call(params_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return true;
        },
        SomePred: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var e_5, _b, e_6, _c;
            var executeFunction = _a.executeFunction;
            try {
                for (var _d = __values(fn.params), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var f = _e.value;
                    try {
                        for (var params_2 = (e_6 = void 0, __values(params)), params_2_1 = params_2.next(); !params_2_1.done; params_2_1 = params_2.next()) {
                            var param = params_2_1.value;
                            var result = executeFunction(asFunctionLike(f, sourceCodeInfo), [param], contextStack, sourceCodeInfo);
                            if (result)
                                return true;
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (params_2_1 && !params_2_1.done && (_c = params_2.return)) _c.call(params_2);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                }
                finally { if (e_5) throw e_5.error; }
            }
            return false;
        },
        Fnull: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            var fnulledParams = params.map(function (param, index) { return (param === null ? toAny(fn.params[index]) : param); });
            return executeFunction(asFunctionLike(fn.function, sourceCodeInfo), fnulledParams, contextStack, sourceCodeInfo);
        },
        Builtin: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            var normalExpression = asNonUndefined(allNormalExpressions[fn.normalBuitinSymbolType], sourceCodeInfo);
            return normalExpression.evaluate(params, sourceCodeInfo, contextStack, { executeFunction: executeFunction });
        },
        SpecialBuiltin: function (fn, params, sourceCodeInfo, contextStack, _a) {
            var executeFunction = _a.executeFunction;
            var specialExpression = asNonUndefined(specialExpressions[fn.specialBuiltinSymbolType], sourceCodeInfo);
            if (specialExpression.evaluateAsNormalExpression) {
                return specialExpression.evaluateAsNormalExpression(params, sourceCodeInfo, contextStack, { executeFunction: executeFunction });
            }
            else {
                throw new LitsError("Special builtin function ".concat(fn.specialBuiltinSymbolType, " is not supported as normal expression."), sourceCodeInfo);
            }
        },
    };

    function evaluate(ast, contextStack) {
        var e_1, _a;
        var result = null;
        try {
            for (var _b = __values(ast.body), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                result = evaluateNode(node, contextStack);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    function evaluateNode(node, contextStack) {
        switch (node[0]) {
            case NodeTypes.Number:
                return evaluateNumber(node);
            case NodeTypes.String:
                return evaluateString(node);
            case NodeTypes.NormalBuiltinSymbol:
            case NodeTypes.SpecialBuiltinSymbol:
            case NodeTypes.UserDefinedSymbol:
                return contextStack.evaluateSymbol(node);
            case NodeTypes.ReservedSymbol:
                return evaluateReservedSymbol(node);
            case NodeTypes.NormalExpression: {
                var result = evaluateNormalExpression(node, contextStack);
                if (typeof result === 'number' && Number.isNaN(result)) {
                    throw new LitsError('Number is NaN', node[2]);
                }
                return annotate(result);
            }
            case NodeTypes.SpecialExpression:
                return annotate(evaluateSpecialExpression(node, contextStack));
            /* v8 ignore next 2 */
            default:
                throw new LitsError("".concat(getNodeTypeName(node[0]), "-node cannot be evaluated"), node[2]);
        }
    }
    function evaluateNumber(node) {
        return node[1];
    }
    function evaluateString(node) {
        return node[1];
    }
    function evaluateReservedSymbol(node) {
        var reservedName = node[1];
        if (!['true', 'false', 'null'].includes(reservedName)) {
            throw new LitsError("Reserved symbol ".concat(reservedName, " cannot be evaluated"), node[2]);
        }
        var value = reservedSymbolRecord[reservedName];
        return asNonUndefined(value, node[2]);
    }
    function evaluateNormalExpression(node, contextStack) {
        var _a, _b;
        var sourceCodeInfo = node[2];
        var paramNodes = node[1][1];
        var params = [];
        var placeholders = [];
        paramNodes.forEach(function (paramNode, index) {
            if (isSpreadNode(paramNode)) {
                var spreadValue = evaluateNode(paramNode[1], contextStack);
                if (Array.isArray(spreadValue)) {
                    params.push.apply(params, __spreadArray([], __read(spreadValue), false));
                }
                else {
                    throw new LitsError("Spread operator requires an array, got ".concat(valueToString(paramNode)), paramNode[2]);
                }
            }
            else if (paramNode[0] === NodeTypes.ReservedSymbol && paramNode[1] === '_') {
                placeholders.push(index);
            }
            else {
                params.push(evaluateNode(paramNode, contextStack));
            }
        });
        if (isNormalExpressionNodeWithName(node)) {
            var nameSymbol = node[1][0];
            if (placeholders.length > 0) {
                var fn = evaluateNode(nameSymbol, contextStack);
                var partialFunction = (_a = {},
                    _a[FUNCTION_SYMBOL] = true,
                    _a.function = asFunctionLike(fn, sourceCodeInfo),
                    _a.functionType = 'Partial',
                    _a.params = params,
                    _a.placeholders = placeholders,
                    _a.sourceCodeInfo = sourceCodeInfo,
                    _a);
                return partialFunction;
            }
            if (isNormalBuiltinSymbolNode(nameSymbol)) {
                var type = nameSymbol[1];
                var normalExpression = builtin.allNormalExpressions[type];
                return normalExpression.evaluate(params, node[2], contextStack, { executeFunction: executeFunction });
            }
            else {
                var fn = contextStack.getValue(nameSymbol[1]);
                if (fn !== undefined) {
                    return executeFunction(asFunctionLike(fn, sourceCodeInfo), params, contextStack, sourceCodeInfo);
                }
                throw new UndefinedSymbolError(nameSymbol[1], node[2]);
            }
        }
        else {
            var fnNode = node[1][0];
            var fn = asFunctionLike(evaluateNode(fnNode, contextStack), sourceCodeInfo);
            if (placeholders.length > 0) {
                var partialFunction = (_b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.function = asFunctionLike(fn, sourceCodeInfo),
                    _b.functionType = 'Partial',
                    _b.params = params,
                    _b.placeholders = placeholders,
                    _b.sourceCodeInfo = sourceCodeInfo,
                    _b);
                return partialFunction;
            }
            return executeFunction(fn, params, contextStack, sourceCodeInfo);
        }
    }
    function executeFunction(fn, params, contextStack, sourceCodeInfo) {
        if (isLitsFunction(fn))
            return functionExecutors[fn.functionType](fn, params, sourceCodeInfo, contextStack, { evaluateNode: evaluateNode, executeFunction: executeFunction });
        if (Array.isArray(fn))
            return evaluateArrayAsFunction(fn, params, sourceCodeInfo);
        if (isObj(fn))
            return evalueateObjectAsFunction(fn, params, sourceCodeInfo);
        if (typeof fn === 'string')
            return evaluateStringAsFunction(fn, params, sourceCodeInfo);
        if (isNumber(fn)) {
            return evaluateNumberAsFunction(fn, params, sourceCodeInfo);
            /* v8 ignore next 4 */
        }
        throw new LitsError('Unexpected function type', sourceCodeInfo);
    }
    function evaluateSpecialExpression(node, contextStack) {
        var specialExpressionType = node[1][0];
        var specialExpression = asNonUndefined(builtin.specialExpressions[specialExpressionType], node[2]);
        var castedEvaluate = specialExpression.evaluate;
        return castedEvaluate(node, contextStack, { evaluateNode: evaluateNode, builtin: builtin, getUndefinedSymbols: getUndefinedSymbols });
    }
    function evalueateObjectAsFunction(fn, params, sourceCodeInfo) {
        if (params.length !== 1)
            throw new LitsError('Object as function requires one string parameter.', sourceCodeInfo);
        var key = params[0];
        assertString(key, sourceCodeInfo);
        return toAny(fn[key]);
    }
    function evaluateArrayAsFunction(fn, params, sourceCodeInfo) {
        if (params.length !== 1)
            throw new LitsError('Array as function requires one non negative integer parameter.', sourceCodeInfo);
        var index = params[0];
        assertNumber(index, sourceCodeInfo, { integer: true, nonNegative: true });
        return toAny(fn[index]);
    }
    function evaluateStringAsFunction(fn, params, sourceCodeInfo) {
        if (params.length !== 1)
            throw new LitsError('String as function requires one Obj parameter.', sourceCodeInfo);
        var param = toAny(params[0]);
        if (isObj(param))
            return toAny((param)[fn]);
        if (isNumber(param, { integer: true }))
            return toAny(fn[param]);
        throw new LitsError("string as function expects Obj or integer parameter, got ".concat(valueToString(param)), sourceCodeInfo);
    }
    function evaluateNumberAsFunction(fn, params, sourceCodeInfo) {
        assertNumber(fn, sourceCodeInfo, { integer: true });
        if (params.length !== 1)
            throw new LitsError('Number as function requires one Arr parameter.', sourceCodeInfo);
        var param = params[0];
        assertSeq(param, sourceCodeInfo);
        return toAny(param[fn]);
    }

    function isContextEntry(value) {
        return isUnknownRecord(value) && value.value !== undefined;
    }

    var ContextStackImpl = /** @class */ (function () {
        function ContextStackImpl(_a) {
            var contexts = _a.contexts, hostValues = _a.values, nativeJsFunctions = _a.nativeJsFunctions;
            this.globalContext = asNonUndefined(contexts[0]);
            this.contexts = contexts;
            this.values = hostValues;
            this.nativeJsFunctions = nativeJsFunctions;
        }
        ContextStackImpl.prototype.create = function (context) {
            var globalContext = this.globalContext;
            var contextStack = new ContextStackImpl({
                contexts: __spreadArray([context], __read(this.contexts), false),
                values: this.values,
                nativeJsFunctions: this.nativeJsFunctions,
            });
            contextStack.globalContext = globalContext;
            return contextStack;
        };
        ContextStackImpl.prototype.new = function (context) {
            var contexts = [{}, context];
            return new ContextStackImpl({ contexts: contexts });
        };
        ContextStackImpl.prototype.exportValues = function (values, sourceCodeInfo) {
            var e_1, _a;
            try {
                for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), name_1 = _d[0], value = _d[1];
                    if (this.globalContext[name_1]) {
                        throw new LitsError("Cannot redefine exported value \"".concat(name_1, "\""), sourceCodeInfo);
                    }
                    if (specialExpressionKeys.includes(name_1)) {
                        throw new LitsError("Cannot shadow special expression \"".concat(name_1, "\""), sourceCodeInfo);
                    }
                    if (normalExpressionKeys.includes(name_1)) {
                        throw new LitsError("Cannot shadow builtin function \"".concat(name_1, "\""), sourceCodeInfo);
                    }
                    this.globalContext[name_1] = { value: value };
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this.contexts[0] !== this.globalContext) {
                this.addValues(values, sourceCodeInfo);
            }
        };
        ContextStackImpl.prototype.addValues = function (values, sourceCodeInfo) {
            var e_2, _a;
            var currentContext = this.contexts[0];
            try {
                for (var _b = __values(Object.entries(values)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), name_2 = _d[0], value = _d[1];
                    if (currentContext[name_2]) {
                        throw new LitsError("Cannot redefine value \"".concat(name_2, "\""), sourceCodeInfo);
                    }
                    if (specialExpressionKeys.includes(name_2)) {
                        throw new LitsError("Cannot shadow special expression \"".concat(name_2, "\""), sourceCodeInfo);
                    }
                    if (normalExpressionKeys.includes(name_2)) {
                        throw new LitsError("Cannot shadow builtin function \"".concat(name_2, "\""), sourceCodeInfo);
                    }
                    currentContext[name_2] = { value: toAny(value) };
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        ContextStackImpl.prototype.getValue = function (name) {
            var e_3, _a;
            var _b, _c;
            try {
                for (var _d = __values(this.contexts), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var context = _e.value;
                    var contextEntry = context[name];
                    if (contextEntry)
                        return contextEntry.value;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_3) throw e_3.error; }
            }
            var nativeJsFunction = (_b = this.nativeJsFunctions) === null || _b === void 0 ? void 0 : _b[name];
            if (nativeJsFunction)
                return nativeJsFunction;
            return (_c = this.values) === null || _c === void 0 ? void 0 : _c[name];
        };
        ContextStackImpl.prototype.lookUp = function (node) {
            var e_4, _a;
            var _b, _c;
            var value = node[1];
            try {
                for (var _d = __values(this.contexts), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var context = _e.value;
                    var contextEntry = context[value];
                    if (contextEntry)
                        return contextEntry;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_4) throw e_4.error; }
            }
            var hostValue = (_b = this.values) === null || _b === void 0 ? void 0 : _b[value];
            if (hostValue !== undefined) {
                return {
                    value: toAny(hostValue),
                };
            }
            var nativeJsFunction = (_c = this.nativeJsFunctions) === null || _c === void 0 ? void 0 : _c[value];
            if (nativeJsFunction) {
                return {
                    value: nativeJsFunction,
                };
            }
            return null;
        };
        ContextStackImpl.prototype.evaluateSymbol = function (node) {
            var _a, _b;
            if (isSpecialBuiltinSymbolNode(node)) {
                var functionType = node[1];
                switch (functionType) {
                    case specialExpressionTypes['&&']:
                    case specialExpressionTypes['||']:
                    case specialExpressionTypes.array:
                    case specialExpressionTypes.object:
                    case specialExpressionTypes['defined?']:
                    case specialExpressionTypes.recur:
                    case specialExpressionTypes.throw:
                    case specialExpressionTypes['??']:
                        return _a = {},
                            _a[FUNCTION_SYMBOL] = true,
                            _a.functionType = 'SpecialBuiltin',
                            _a.specialBuiltinSymbolType = functionType,
                            _a.sourceCodeInfo = node[2],
                            _a;
                    default:
                        throw new LitsError("Unknown special builtin symbol type: ".concat(functionType), node[2]);
                }
            }
            if (isNormalBuiltinSymbolNode(node)) {
                var type = node[1];
                return _b = {},
                    _b[FUNCTION_SYMBOL] = true,
                    _b.functionType = 'Builtin',
                    _b.normalBuitinSymbolType = type,
                    _b.sourceCodeInfo = node[2],
                    _b;
            }
            var lookUpResult = this.lookUp(node);
            if (isContextEntry(lookUpResult))
                return lookUpResult.value;
            throw new UndefinedSymbolError(node[1], node[2]);
        };
        return ContextStackImpl;
    }());
    function createContextStack(params) {
        var _a;
        if (params === void 0) { params = {}; }
        var globalContext = (_a = params.globalContext) !== null && _a !== void 0 ? _a : {};
        // Contexts are checked from left to right
        var contexts = params.contexts ? __spreadArray([globalContext], __read(params.contexts), false) : [globalContext];
        var contextStack = new ContextStackImpl({
            contexts: contexts,
            values: params.values,
            nativeJsFunctions: params.jsFunctions
                && Object.entries(params.jsFunctions).reduce(function (acc, _a) {
                    var _b;
                    var _c = __read(_a, 2), name = _c[0], jsFunction = _c[1];
                    if (specialExpressionKeys.includes(name)) {
                        console.warn("Cannot shadow special expression \"".concat(name, "\", ignoring."));
                        return acc;
                    }
                    if (normalExpressionKeys.includes(name)) {
                        console.warn("Cannot shadow builtin function \"".concat(name, "\", ignoring."));
                        return acc;
                    }
                    acc[name] = (_b = {
                            functionType: 'NativeJsFunction',
                            nativeFn: jsFunction,
                            name: name
                        },
                        _b[FUNCTION_SYMBOL] = true,
                        _b);
                    return acc;
                }, {}),
        });
        return params.globalModuleScope ? contextStack : contextStack.create({});
    }

    var illegalSymbolCharacters = [
        '(',
        ')',
        '[',
        ']',
        '{',
        '}',
        '\'',
        '"',
        '`',
        ',',
        '.',
        ';',
        ' ',
        '\n',
        '\r',
        '\t',
    ];
    var illegalFirstSymbolCharacters = __spreadArray([
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9'
    ], __read(illegalSymbolCharacters), false);
    var illegalSymbolCharacterSet = new Set(illegalSymbolCharacters);
    var illegalFirstSymbolCharacterSet = new Set(illegalFirstSymbolCharacters);
    var whitespaceRegExp = /\s/;
    var NO_MATCH = [0];
    var tokenizeLParen = function (input, position) {
        return tokenizeToken('LParen', '(', input, position);
    };
    var tokenizeRParen = function (input, position) {
        return tokenizeToken('RParen', ')', input, position);
    };
    var tokenizeLBracket = function (input, position) {
        return tokenizeToken('LBracket', '[', input, position);
    };
    var tokenizeRBracket = function (input, position) {
        return tokenizeToken('RBracket', ']', input, position);
    };
    var tokenizeLBrace = function (input, position) {
        return tokenizeToken('LBrace', '{', input, position);
    };
    var tokenizeRBrace = function (input, position) {
        return tokenizeToken('RBrace', '}', input, position);
    };
    var tokenizeString = function (input, position) {
        if (input[position] !== '"')
            return NO_MATCH;
        var value = '"';
        var length = 1;
        var char = input[position + length];
        var escaping = false;
        while (char !== '"' || escaping) {
            if (char === undefined)
                throw new LitsError("Unclosed string at position ".concat(position, "."), undefined);
            length += 1;
            if (escaping) {
                escaping = false;
                value += char;
            }
            else {
                if (char === '\\') {
                    escaping = true;
                }
                value += char;
            }
            char = input[position + length];
        }
        value += '"'; // closing quote
        return [length + 1, ['String', value]];
    };
    var tokenizeRegexpShorthand = function (input, position) {
        if (input[position] !== '#')
            return NO_MATCH;
        var _a = __read(tokenizeString(input, position + 1), 2), stringLength = _a[0], token = _a[1];
        if (!token)
            return NO_MATCH;
        position += stringLength + 1;
        var length = stringLength + 1;
        var options = '';
        while (input[position] === 'g' || input[position] === 'i') {
            if (options.includes(input[position])) {
                throw new LitsError("Duplicated regexp option \"".concat(input[position], "\" at position ").concat(position, "."), undefined);
            }
            options += input[position];
            length += 1;
            position += 1;
        }
        return [length, ['RegexpShorthand', "#".concat(token[1]).concat(options)]];
    };
    function tokenizeToken(type, value, input, position) {
        if (value === input.slice(position, position + value.length))
            return [value.length, [type, value]];
        else
            return NO_MATCH;
    }
    var tokenizeWhitespace = function (input, position) {
        var char = input[position];
        if (!char || !whitespaceRegExp.test(char)) {
            return NO_MATCH;
        }
        var value = char;
        position += 1;
        char = input[position];
        while (char && whitespaceRegExp.test(char)) {
            value += char;
            position += 1;
            char = input[position];
        }
        return [value.length, ['Whitespace', value]];
    };
    var decimalNumberRegExp = /\d/;
    var octalNumberRegExp = /[0-7]/;
    var hexNumberRegExp = /[0-9a-f]/i;
    var binaryNumberRegExp = /[01]/;
    var postNumberRegExp = /[\s)\]}(,;]/;
    var tokenizeNumber = function (input, position) {
        var i;
        var negate = input[position] === '-';
        var plusPrefix = input[position] === '+';
        var start = negate || plusPrefix ? position + 1 : position;
        var hasDecimalPoint = false;
        var hasExponent = false;
        for (i = start; i < input.length; i += 1) {
            var char = input[i];
            if (char === '_') {
                if (!decimalNumberRegExp.test(input[i - 1]) || !decimalNumberRegExp.test(input[i + 1])) {
                    if (i === start) {
                        return NO_MATCH;
                    }
                    throw new LitsError("Invalid number format at position ".concat(i, "."), undefined);
                }
            }
            else if (char === '.') {
                if (i === start) {
                    return NO_MATCH;
                }
                if (hasDecimalPoint || hasExponent) {
                    throw new LitsError("Invalid number format at position ".concat(i, "."), undefined);
                }
                hasDecimalPoint = true;
            }
            else if (char === 'e' || char === 'E') {
                if (i === start) {
                    return NO_MATCH;
                }
                if (hasExponent) {
                    throw new LitsError("Invalid number format at position ".concat(i, "."), undefined);
                }
                if (input[i - 1] === '.' || input[i - 1] === '+' || input[i - 1] === '-') {
                    throw new LitsError("Invalid number format at position ".concat(i, "."), undefined);
                }
                if (input[i + 1] === '+' || input[i + 1] === '-') {
                    i += 1;
                }
                hasExponent = true;
            }
            else if (!decimalNumberRegExp.test(char)) {
                break;
            }
        }
        if ((negate || plusPrefix) && i === start) {
            return NO_MATCH;
        }
        var length = i - position;
        if (length === 0) {
            return NO_MATCH;
        }
        var nextChar = input[i];
        if (nextChar && nextChar !== ':' && !postNumberRegExp.test(nextChar)) {
            throw new LitsError("Invalid number format at position ".concat(i, "."), undefined);
        }
        return [length, ['Number', input.substring(position, i)]];
    };
    var tokenizeBasePrefixedNumber = function (input, position) {
        if (input[position] !== '0') {
            return NO_MATCH;
        }
        var baseChar = input[position + 1];
        var type = baseChar === 'b' || baseChar === 'B'
            ? 'binary'
            : baseChar === 'o' || baseChar === 'O'
                ? 'octal'
                : baseChar === 'x' || baseChar === 'X'
                    ? 'hex'
                    : null;
        if (type === null) {
            return NO_MATCH;
        }
        var i;
        for (i = position + 2; i < input.length; i += 1) {
            var char = input[i];
            if (type === 'binary' && !binaryNumberRegExp.test(char)) {
                break;
            }
            if (type === 'octal' && !octalNumberRegExp.test(char)) {
                break;
            }
            if (type === 'hex' && !hexNumberRegExp.test(char)) {
                break;
            }
        }
        var length = i - position;
        if (length <= 2) {
            return NO_MATCH;
        }
        var nextChar = input[i];
        if (nextChar && !postNumberRegExp.test(nextChar)) {
            return NO_MATCH;
        }
        return [length, ['BasePrefixedNumber', input.substring(position, i)]];
    };
    var tokenizeSymbol = function (input, position) {
        var value = input[position];
        if (value === '\'') {
            var length_1 = 1;
            var char = input[position + length_1];
            var escaping = false;
            while (char !== '\'' || escaping) {
                if (char === undefined)
                    throw new LitsError("Unclosed string at position ".concat(position, "."), undefined);
                length_1 += 1;
                if (escaping) {
                    escaping = false;
                    value += char;
                }
                else {
                    if (char === '\\') {
                        escaping = true;
                    }
                    value += char;
                }
                char = input[position + length_1];
            }
            value += '\''; // closing quote
            return [length_1 + 1, ['Symbol', value]];
        }
        if (!illegalFirstSymbolCharacterSet.has(value)) {
            var initialPosition = position;
            position += 1;
            var char = input[position];
            while (char && !illegalSymbolCharacterSet.has(char)) {
                value += char;
                position += 1;
                char = input[position];
            }
            // : can be used as symbol character, but it must not be the last character
            return value.endsWith(':')
                ? [position - initialPosition - 1, ['Symbol', value.slice(0, -1)]]
                : [position - initialPosition, ['Symbol', value]];
        }
        return NO_MATCH;
    };
    var tokenizeReservedSymbolToken = function (input, position) {
        var symbolMeta = tokenizeSymbol(input, position);
        if (symbolMeta[0] === 0 || !symbolMeta[1]) {
            return NO_MATCH;
        }
        var symbolName = symbolMeta[1][1];
        symbolName = symbolName.startsWith('\'') ? symbolName.slice(1, symbolName.length - 1) : symbolName;
        var info = reservedSymbolRecord[symbolName];
        if (info === undefined) {
            return NO_MATCH;
        }
        return [symbolMeta[0], ['ReservedSymbol', symbolName]];
    };
    var tokenizeOperator = function (input, position) {
        var _a;
        var threeChars = input.slice(position, position + 3);
        if (position + 2 < input.length && isSymbolicOperator(threeChars)) {
            return [3, ['Operator', threeChars]];
        }
        var twoChars = input.slice(position, position + 2);
        if (position + 1 < input.length && isSymbolicOperator(twoChars)) {
            return [2, ['Operator', twoChars]];
        }
        var oneChar = (_a = input[position]) !== null && _a !== void 0 ? _a : '';
        if (isSymbolicOperator(oneChar)) {
            return [1, ['Operator', oneChar]];
        }
        return NO_MATCH;
    };
    var tokenizeMultiLineComment = function (input, position) {
        if (input[position] === '/' && input[position + 1] === '*') {
            var length_2 = 2;
            var value = '/*';
            while ((input[position + length_2] !== '*' || input[position + length_2 + 1] !== '/') && position + length_2 + 1 < input.length) {
                value += input[position + length_2];
                length_2 += 1;
            }
            if (position + length_2 + 1 >= input.length) {
                throw new LitsError('Comment not closed', undefined);
            }
            value += '*/';
            length_2 += 2;
            return [length_2, ['MultiLineComment', value]];
        }
        return NO_MATCH;
    };
    var tokenizeSingleLineComment = function (input, position) {
        if (input[position] === '/' && input[position + 1] === '/') {
            var length_3 = 2;
            var value = '//';
            while (input[position + length_3] !== '\n' && position + length_3 < input.length) {
                value += input[position + length_3];
                length_3 += 1;
            }
            return [length_3, ['SingleLineComment', value]];
        }
        return NO_MATCH;
    };
    // All tokenizers, order matters!
    var tokenizers = [
        tokenizeWhitespace,
        tokenizeMultiLineComment,
        tokenizeSingleLineComment,
        tokenizeReservedSymbolToken,
        tokenizeLParen,
        tokenizeRParen,
        tokenizeLBracket,
        tokenizeRBracket,
        tokenizeLBrace,
        tokenizeRBrace,
        tokenizeString,
        tokenizeRegexpShorthand,
        tokenizeBasePrefixedNumber,
        tokenizeNumber,
        tokenizeOperator,
        tokenizeSymbol,
    ];

    function tokenize$1(input, debug, filePath) {
        var position = 0;
        var tokenStream = {
            tokens: [],
            filePath: filePath,
            hasDebugData: debug,
        };
        while (position < input.length) {
            var sourceCodeInfo = debug
                ? createSourceCodeInfo(input, position, filePath)
                : undefined;
            var tokenDescriptor = getCurrentToken(input, position);
            if (!tokenDescriptor) {
                throw new LitsError("Unrecognized character '".concat(input[position], "'."), sourceCodeInfo);
            }
            var _a = __read(tokenDescriptor, 2), count = _a[0], token = _a[1];
            position += count;
            if (token) {
                if (sourceCodeInfo) {
                    token[2] = sourceCodeInfo;
                }
                tokenStream.tokens.push(token);
            }
        }
        return tokenStream;
    }
    function getSourceCodeLine(input, lineNbr) {
        return input.split(/\r\n|\r|\n/)[lineNbr];
    }
    function createSourceCodeInfo(input, position, filePath) {
        var lines = input.substring(0, position + 1).split(/\r\n|\r|\n/);
        var lastLine = lines[lines.length - 1];
        var code = getSourceCodeLine(input, lines.length - 1);
        var line = lines.length;
        var column = lastLine.length;
        return {
            code: code,
            position: {
                line: line,
                column: column,
            },
            filePath: filePath,
        };
    }
    function getCurrentToken(input, position) {
        var e_1, _a;
        var initialPosition = position;
        try {
            for (var tokenizers_1 = __values(tokenizers), tokenizers_1_1 = tokenizers_1.next(); !tokenizers_1_1.done; tokenizers_1_1 = tokenizers_1.next()) {
                var tokenizer = tokenizers_1_1.value;
                var _b = __read(tokenizer(input, position), 2), nbrOfCharacters = _b[0], token = _b[1];
                position += nbrOfCharacters;
                if (nbrOfCharacters === 0) {
                    continue;
                }
                return [position - initialPosition, token];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tokenizers_1_1 && !tokenizers_1_1.done && (_a = tokenizers_1.return)) _a.call(tokenizers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
    }

    function isSymbolToken(token, symbolName) {
        if ((token === null || token === void 0 ? void 0 : token[0]) !== 'Symbol') {
            return false;
        }
        if (symbolName && token[1] !== symbolName) {
            return false;
        }
        return true;
    }
    function assertSymbolToken(token, symbolName) {
        if (!isSymbolToken(token, symbolName)) {
            throwUnexpectedToken('Symbol', undefined, token);
        }
    }
    function asSymbolToken(token, symbolName) {
        assertSymbolToken(token, symbolName);
        return token;
    }
    function isReservedSymbolToken(token, symbolName) {
        if ((token === null || token === void 0 ? void 0 : token[0]) !== 'ReservedSymbol') {
            return false;
        }
        if (symbolName && token[1] !== symbolName) {
            return false;
        }
        return true;
    }
    function assertReservedSymbolToken(token, symbolName) {
        if (!isReservedSymbolToken(token, symbolName)) {
            throwUnexpectedToken('ReservedSymbol', symbolName, token);
        }
    }
    function asReservedSymbolToken(token, symbolName) {
        assertReservedSymbolToken(token, symbolName);
        return token;
    }
    function isSingleLineCommentToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'SingleLineComment';
    }
    function isMultiLineCommentToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'MultiLineComment';
    }
    function isOperatorToken(token, operatorName) {
        if ((token === null || token === void 0 ? void 0 : token[0]) !== 'Operator') {
            return false;
        }
        if (operatorName && token[1] !== operatorName) {
            return false;
        }
        return true;
    }
    function assertOperatorToken(token, operatorName) {
        if (!isOperatorToken(token, operatorName)) {
            throwUnexpectedToken('Operator', operatorName, token);
        }
    }
    function isWhitespaceToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'Whitespace';
    }
    function isLParenToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'LParen';
    }
    function assertLParenToken(token) {
        if (!isLParenToken(token)) {
            throwUnexpectedToken('LParen', undefined, token);
        }
    }
    function isRParenToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'RParen';
    }
    function assertRParenToken(token) {
        if (!isRParenToken(token)) {
            throwUnexpectedToken('RParen', undefined, token);
        }
    }
    function isLBracketToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'LBracket';
    }
    function assertLBracketToken(token) {
        if (!isLBracketToken(token)) {
            throwUnexpectedToken('LBracket', undefined, token);
        }
    }
    function asLBracketToken(token) {
        assertLBracketToken(token);
        return token;
    }
    function isRBracketToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'RBracket';
    }
    function assertRBracketToken(token) {
        if (!isRBracketToken(token)) {
            throwUnexpectedToken('RBracket', undefined, token);
        }
    }
    function isLBraceToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'LBrace';
    }
    function assertLBraceToken(token) {
        if (!isLBraceToken(token)) {
            throwUnexpectedToken('LBrace', undefined, token);
        }
    }
    function asLBraceToken(token) {
        assertLBraceToken(token);
        return token;
    }
    function isRBraceToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'RBrace';
    }
    function assertRBraceToken(token) {
        if (!isRBraceToken(token)) {
            throwUnexpectedToken('RBrace', undefined, token);
        }
    }
    function isStringToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'String';
    }
    function isA_BinaryOperatorToken(token) {
        return (token === null || token === void 0 ? void 0 : token[0]) === 'Operator' && isBinaryOperator(token[1]);
    }
    function throwUnexpectedToken(expected, expectedValue, actual) {
        var actualOutput = actual ? "".concat(actual[0], " '").concat(actual[1], "'") : 'end of input';
        throw new LitsError("Unexpected token: ".concat(actualOutput, ", expected ").concat(expected).concat(expectedValue ? " '".concat(expectedValue, "'") : ''), actual === null || actual === void 0 ? void 0 : actual[2]);
    }

    function minifyTokenStream(tokenStream, _a) {
        var removeWhiteSpace = _a.removeWhiteSpace;
        var tokens = tokenStream.tokens
            .filter(function (token) {
            if (isSingleLineCommentToken(token)
                || isMultiLineCommentToken(token)
                || (removeWhiteSpace && isWhitespaceToken(token))) {
                return false;
            }
            return true;
        });
        return __assign(__assign({}, tokenStream), { tokens: tokens });
    }

    function transformSymbolTokens(tokenStram, transformer) {
        return __assign(__assign({}, tokenStram), { tokens: tokenStram.tokens.map(function (token) { return isSymbolToken(token)
                ? [token[0], transformer(token[1])]
                : token; }) });
    }

    function untokenize(tokenStream) {
        return tokenStream.tokens.reduce(function (acc, token) {
            return "".concat(acc).concat(token[1]);
        }, '');
    }

    var exponentiationPrecedence = 12;
    var binaryFunctionalOperatorPrecedence = 3;
    var conditionalOperatorPrecedence = 1;
    var placeholderRegexp = /^\$([1-9]\d?)?$/;
    function withSourceCodeInfo(node, sourceCodeInfo) {
        if (sourceCodeInfo) {
            node[2] = sourceCodeInfo;
        }
        return node;
    }
    function getPrecedence(operatorSign, sourceCodeInfo) {
        switch (operatorSign) {
            case '^': // exponentiation
                return exponentiationPrecedence;
            case '*': // multiplication
            case '/': // division
            case '%': // remainder
                return 11;
            case '+': // addition
            case '-': // subtraction
                return 10;
            case '<<': // left shift
            case '>>': // signed right shift
            case '>>>': // unsigned right shift
                return 9;
            case '++': // string concatenation
                return 8;
            case '<': // less than
            case '<=': // less than or equal
            case '≤': // less than or equal
            case '>': // greater than
            case '>=': // greater than or equal
            case '≥': // greater than or equal
                return 7;
            case '==': // equal
            case '!=': // not equal
            case '≠': // not equal
                return 6;
            case '&': // bitwise AND
            case 'xor': // bitwise XOR
            case '|': // bitwise OR
                return 5;
            case '&&': // logical AND
            case '||': // logical OR
            case '??': // nullish coalescing
                return 4;
            // leave room for binaryFunctionalOperatorPrecedence = 3
            case '|>': // pipe
                return 2;
            // leave room for conditionalOperatorPrecedence = 1
            /* v8 ignore next 2 */
            default:
                throw new LitsError("Unknown binary operator: ".concat(operatorSign), sourceCodeInfo);
        }
    }
    function createNamedNormalExpressionNode(symbolNode, params, sourceCodeInfo) {
        var node = withSourceCodeInfo([NodeTypes.NormalExpression, [symbolNode, params]], sourceCodeInfo);
        if (isNormalBuiltinSymbolNode(symbolNode)) {
            assertNumberOfParams(allNormalExpressions[symbolNode[1]].paramCount, node);
        }
        return node;
    }
    function createAccessorNode(left, right, sourceCodeInfo) {
        // Unnamed normal expression
        return withSourceCodeInfo([NodeTypes.NormalExpression, [left, [right]]], sourceCodeInfo);
    }
    function fromBinaryOperatorToNode(operator, symbolNode, left, right, sourceCodeInfo) {
        var operatorName = operator[1];
        switch (operatorName) {
            case '^': // exponentiation
            case '*':
            case '/':
            case '%':
            case '+':
            case '-':
            case '<<':
            case '>>':
            case '>>>':
            case '++':
            case '<':
            case '<=':
            case '≤':
            case '>':
            case '>=':
            case '≥':
            case '==':
            case '!=':
            case '≠':
            case '&':
            case 'xor':
            case '|':
            case '|>':
                return createNamedNormalExpressionNode(symbolNode, [left, right], sourceCodeInfo);
            case '&&':
            case '||':
            case '??':
                return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes[operatorName], [left, right]]], sourceCodeInfo);
            /* v8 ignore next 11 */
            case '.':
            case ';':
            case ':':
            case '=':
            case ',':
            case '->':
            case '...':
            case '?':
                throw new LitsError("Unknown binary operator: ".concat(operatorName), sourceCodeInfo);
            default:
                throw new LitsError("Unknown binary operator: ".concat(operatorName), sourceCodeInfo);
        }
    }
    var Parser = /** @class */ (function () {
        function Parser(tokenStream, parseState) {
            this.tokenStream = tokenStream;
            this.parseState = parseState;
        }
        Parser.prototype.peek = function () {
            return this.tokenStream.tokens[this.parseState.position];
        };
        Parser.prototype.peekSourceCodeInfo = function () {
            var _a;
            var currentToken = this.peek();
            return currentToken ? currentToken[2] : (_a = this.tokenStream.tokens.at(-1)) === null || _a === void 0 ? void 0 : _a[2];
        };
        Parser.prototype.peekAhead = function (count) {
            return this.tokenStream.tokens[this.parseState.position + count];
        };
        Parser.prototype.advance = function () {
            this.parseState.position += 1;
        };
        Parser.prototype.parse = function () {
            var nodes = [];
            while (!this.isAtEnd()) {
                nodes.push(this.parseExpression(0, true));
                if (isOperatorToken(this.peek(), ';')) {
                    this.advance();
                }
                else {
                    if (!this.isAtEnd()) {
                        throw new LitsError('Expected ;', this.peekSourceCodeInfo());
                    }
                }
            }
            return nodes;
        };
        Parser.prototype.parseExpression = function (precedence, moduleScope) {
            if (precedence === void 0) { precedence = 0; }
            if (moduleScope === void 0) { moduleScope = false; }
            var firstToken = this.peek();
            var left;
            if (isSymbolToken(firstToken)) {
                switch (firstToken[1]) {
                    case 'let':
                        return this.parseLet(firstToken);
                    case 'if':
                    case 'unless':
                        left = this.parseIfOrUnless(firstToken);
                        break;
                    case 'cond':
                        left = this.parseCond(firstToken);
                        break;
                    case 'switch':
                        left = this.parseSwitch(firstToken);
                        break;
                    case 'for':
                    case 'doseq':
                        left = this.parseForOrDoseq(firstToken);
                        break;
                    // cas:
                    //   left = this.parseDo(firstToken)
                    //   break
                    case 'loop':
                        left = this.parseLoop(firstToken);
                        break;
                    case 'try':
                        left = this.parseTry(firstToken);
                        break;
                }
            }
            else if (isReservedSymbolToken(firstToken, 'function')) {
                return this.parseFunction(firstToken);
            }
            else if (isReservedSymbolToken(firstToken, 'export')) {
                if (!moduleScope) {
                    throw new LitsError('export is only allowed in module scope', firstToken[2]);
                }
                return this.parseExport(firstToken);
            }
            left || (left = this.parseOperand());
            var operator = this.peek();
            while (!this.isAtExpressionEnd()) {
                if (isA_BinaryOperatorToken(operator)) {
                    var name_1 = operator[1];
                    var newPrecedece = getPrecedence(name_1, operator[2]);
                    if (newPrecedece <= precedence
                        // ^ (exponentiation) is right associative
                        && !(newPrecedece === exponentiationPrecedence && precedence === exponentiationPrecedence)) {
                        break;
                    }
                    var symbol = specialExpressionTypes[name_1]
                        ? withSourceCodeInfo([NodeTypes.SpecialBuiltinSymbol, specialExpressionTypes[name_1]], operator[2])
                        : withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol, normalExpressionTypes[name_1]], operator[2]);
                    this.advance();
                    var right = this.parseExpression(newPrecedece);
                    left = fromBinaryOperatorToNode(operator, symbol, left, right, operator[2]);
                }
                else if (isSymbolToken(operator)) {
                    if (!isFunctionOperator(operator[1])) {
                        break;
                    }
                    var newPrecedece = binaryFunctionalOperatorPrecedence;
                    if (newPrecedece <= precedence) {
                        break;
                    }
                    var operatorSymbol = this.parseSymbol();
                    var right = this.parseExpression(newPrecedece);
                    if (isSpecialBuiltinSymbolNode(operatorSymbol)) {
                        throw new LitsError('Special expressions are not allowed in binary functional operators', operatorSymbol[2]);
                    }
                    left = createNamedNormalExpressionNode(operatorSymbol, [left, right], operator[2]);
                }
                else if ((operator === null || operator === void 0 ? void 0 : operator[1]) === '?') {
                    if (conditionalOperatorPrecedence <= precedence) {
                        break;
                    }
                    this.advance();
                    var trueNode = this.parseExpression();
                    if (!isOperatorToken(this.peek(), ':')) {
                        throw new LitsError('Expected :', this.peekSourceCodeInfo());
                    }
                    this.advance();
                    var falseNode = this.parseExpression();
                    left = withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.if, [left, trueNode, falseNode]]], left[2]);
                }
                else {
                    break;
                }
                operator = this.peek();
            }
            return left;
        };
        Parser.prototype.asToken = function (token) {
            if (!token) {
                throw new LitsError('Unexpected end of input', this.peekSourceCodeInfo());
            }
            return token;
        };
        Parser.prototype.parseOperand = function () {
            var operand = this.parseOperandPart();
            var token = this.peek();
            while (isOperatorToken(token, '.') || isLBracketToken(token) || isLParenToken(token)) {
                if (token[1] === '.') {
                    this.advance();
                    var symbolToken = this.asToken(this.peek());
                    if (!isSymbolToken(symbolToken)) {
                        throw new LitsError('Expected symbol', this.peekSourceCodeInfo());
                    }
                    var stringNode = withSourceCodeInfo([NodeTypes.String, symbolToken[1]], symbolToken[2]);
                    operand = createAccessorNode(operand, stringNode, token[2]);
                    this.advance();
                    token = this.peek();
                }
                else if (isLBracketToken(token)) {
                    this.advance();
                    var expression = this.parseExpression();
                    if (!isRBracketToken(this.peek())) {
                        throw new LitsError('Expected closing bracket', this.peekSourceCodeInfo());
                    }
                    operand = createAccessorNode(operand, expression, token[2]);
                    this.advance();
                    token = this.peek();
                }
                else if (isLParenToken(token)) {
                    operand = this.parseFunctionCall(operand);
                    token = this.peek();
                }
            }
            return operand;
        };
        Parser.prototype.parseOperandPart = function () {
            var token = this.asToken(this.peek());
            // Parentheses
            if (isLParenToken(token)) {
                var positionBefore = this.parseState.position;
                var lamdaFunction = this.parseLambdaFunction();
                if (lamdaFunction) {
                    return lamdaFunction;
                }
                this.parseState.position = positionBefore;
                this.advance();
                var expression = this.parseExpression();
                if (!isRParenToken(this.peek())) {
                    throw new LitsError('Expected closing parenthesis', this.peekSourceCodeInfo());
                }
                this.advance();
                return expression;
            }
            else if (isOperatorToken(token)) {
                var operatorName = token[1];
                if (isBinaryOperator(operatorName)) {
                    this.advance();
                    if (specialExpressionTypes[operatorName] !== undefined) {
                        return withSourceCodeInfo([NodeTypes.SpecialBuiltinSymbol, specialExpressionTypes[operatorName]], token[2]);
                    }
                    return withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol, normalExpressionTypes[operatorName]], token[2]);
                }
                if (operatorName === '->') {
                    return this.parseShorthandLamdaFunction();
                }
                else {
                    throw new LitsError("Illegal operator: ".concat(operatorName), token[2]);
                }
            }
            // Object litteral, e.g. {a: 1, b: 2}
            // Or block.
            if (isLBraceToken(token)) {
                var positionBefore = this.parseState.position;
                try {
                    return this.parseObject();
                }
                catch (_a) {
                    this.parseState.position = positionBefore;
                    return this.parseBlock();
                }
            }
            // Array litteral, e.g. [1, 2]
            if (isLBracketToken(token)) {
                return this.parseArray();
            }
            var tokenType = token[0];
            switch (tokenType) {
                case 'Number':
                case 'BasePrefixedNumber':
                    return this.parseNumber();
                case 'String':
                    return this.parseString();
                case 'Symbol': {
                    var positionBefore = this.parseState.position;
                    var lamdaFunction = this.parseLambdaFunction();
                    if (lamdaFunction) {
                        return lamdaFunction;
                    }
                    this.parseState.position = positionBefore;
                    return this.parseSymbol();
                }
                case 'ReservedSymbol':
                    return this.parseReservedSymbol();
                case 'RegexpShorthand':
                    return this.parseRegexpShorthand();
                default:
                    throw new LitsError("Unknown token type: ".concat(tokenType), token[2]);
            }
        };
        Parser.prototype.parseObject = function () {
            var firstToken = asLBraceToken(this.peek());
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isRBraceToken(this.peek())) {
                if (isOperatorToken(this.peek(), '...')) {
                    this.advance();
                    params.push(withSourceCodeInfo([NodeTypes.Spread, this.parseExpression()], this.peekSourceCodeInfo()));
                }
                else {
                    var token = this.peek();
                    if (isStringToken(token)) {
                        var stringNode = this.parseString();
                        params.push(withSourceCodeInfo([NodeTypes.String, stringNode[1]], token[2]));
                    }
                    else if (isSymbolToken(token)) {
                        var value = token[1].startsWith('\'')
                            ? this.stringFromQuotedSymbol(token[1])
                            : token[1];
                        params.push(withSourceCodeInfo([NodeTypes.String, value], token[2]));
                        this.advance();
                    }
                    else {
                        throw new LitsError('Expected key to be a symbol or a string', this.peekSourceCodeInfo());
                    }
                    assertOperatorToken(this.peek(), ':');
                    this.advance();
                    params.push(this.parseExpression());
                }
                var nextToken = this.peek();
                if (!isOperatorToken(nextToken, ',') && !isRBraceToken(nextToken)) {
                    throw new LitsError('Expected comma or closing brace', this.peekSourceCodeInfo());
                }
                if (isOperatorToken(nextToken, ',')) {
                    this.advance();
                }
            }
            assertRBraceToken(this.peek());
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.object, params]], firstToken[2]);
        };
        Parser.prototype.parseArray = function () {
            var firstToken = asLBracketToken(this.peek());
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isRBracketToken(this.peek())) {
                if (isOperatorToken(this.peek(), '...')) {
                    this.advance();
                    params.push(withSourceCodeInfo([NodeTypes.Spread, this.parseExpression()], this.peekSourceCodeInfo()));
                }
                else {
                    params.push(this.parseExpression());
                }
                var nextToken = this.peek();
                if (!isOperatorToken(nextToken, ',') && !isRBracketToken(nextToken)) {
                    throw new LitsError('Expected comma or closing parenthesis', this.peekSourceCodeInfo());
                }
                if (isOperatorToken(nextToken, ',')) {
                    this.advance();
                }
            }
            assertRBracketToken(this.peek());
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.array, params]], firstToken[2]);
        };
        Parser.prototype.parseFunctionCall = function (symbol) {
            var _a;
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isRParenToken(this.peek())) {
                if (isOperatorToken(this.peek(), '...')) {
                    this.advance();
                    params.push(withSourceCodeInfo([NodeTypes.Spread, this.parseExpression()], this.peekSourceCodeInfo()));
                }
                else {
                    params.push(this.parseExpression());
                }
                var nextToken = this.peek();
                if (!isOperatorToken(nextToken, ',') && !isRParenToken(nextToken)) {
                    throw new LitsError('Expected comma or closing parenthesis', (_a = this.peek()) === null || _a === void 0 ? void 0 : _a[2]);
                }
                if (isOperatorToken(nextToken, ',')) {
                    this.advance();
                }
            }
            if (!isRParenToken(this.peek())) {
                throw new LitsError('Expected closing parenthesis', this.peekSourceCodeInfo());
            }
            this.advance();
            if (isSpecialBuiltinSymbolNode(symbol)) { // Named function
                var specialExpressionType = symbol[1];
                var type = specialExpressionType;
                switch (type) {
                    case specialExpressionTypes['||']:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes['&&']:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes.recur:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes.array:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes.object:
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, params]], symbol[2]);
                    case specialExpressionTypes['??']: {
                        if (params.length === 1) {
                            return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, [params[0], undefined]]], symbol[2]);
                        }
                        if (params.length === 2) {
                            return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, [params[0], params[1]]]], symbol[2]);
                        }
                        throw new LitsError('Expected exactly two parameters', symbol[2]);
                    }
                    case specialExpressionTypes['defined?']: {
                        if (params.length !== 1) {
                            throw new LitsError('Expected exactly one parameter', symbol[2]);
                        }
                        var _b = __read(params, 1), param = _b[0];
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, param]], symbol[2]);
                    }
                    case specialExpressionTypes.throw: {
                        if (params.length !== 1) {
                            throw new LitsError('Expected exactly one parameter', symbol[2]);
                        }
                        var _c = __read(params, 1), param = _c[0];
                        return withSourceCodeInfo([NodeTypes.SpecialExpression, [type, param]], symbol[2]);
                    }
                    case specialExpressionTypes['0_fn']:
                    case specialExpressionTypes['0_def']:
                    case specialExpressionTypes['0_defn']:
                        throw new LitsError("".concat(type, " is not allowed"), symbol[2]);
                    /* v8 ignore next 2 */
                    default:
                        throw new LitsError("Unknown special expression: ".concat(type), symbol[2]);
                }
            }
            else if (isNormalBuiltinSymbolNode(symbol) || isNormalBuiltinSymbolNode(symbol)) {
                return createNamedNormalExpressionNode(symbol, params, symbol[2]);
            }
            else {
                return withSourceCodeInfo([NodeTypes.NormalExpression, [symbol, params]], symbol[2]);
            }
        };
        Parser.prototype.parseLambdaFunction = function () {
            var firstToken = this.asToken(this.peek());
            if (isLParenToken(firstToken)
                && isSymbolToken(this.peekAhead(1))
                && isOperatorToken(this.peekAhead(2), '->')) {
                return null;
            }
            try {
                var functionArguments = this.parseFunctionArguments();
                if (!isOperatorToken(this.peek(), '->')) {
                    return null;
                }
                this.advance();
                var body = this.parseExpression();
                return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes['0_fn'], [
                            functionArguments,
                            [body],
                        ]]], firstToken[2]);
            }
            catch (_a) {
                return null;
            }
        };
        Parser.prototype.parseFunctionArguments = function () {
            var firstToken = this.peek();
            if (isSymbolToken(firstToken)) {
                return [withSourceCodeInfo([bindingTargetTypes.symbol, [this.parseSymbol(), undefined]], firstToken[2])];
            }
            assertLParenToken(firstToken);
            this.advance();
            var rest = false;
            var defaults = false;
            var functionArguments = [];
            while (!this.isAtEnd() && !isRParenToken(this.peek()) && !isSymbolToken(this.peek(), 'let')) {
                if (rest) {
                    throw new LitsError('Rest argument must be last', this.peekSourceCodeInfo());
                }
                var bindingTarget = this.parseBindingTarget();
                if (bindingTarget[1][1] !== undefined) {
                    defaults = true;
                }
                if (bindingTarget[0] === bindingTargetTypes.rest) {
                    rest = true;
                }
                if (defaults && !bindingTarget[1][1]) {
                    throw new LitsError('Default arguments must be last', this.peekSourceCodeInfo());
                }
                functionArguments.push(bindingTarget);
                if (!isOperatorToken(this.peek(), ',') && !isRParenToken(this.peek()) && !isSymbolToken(this.peek(), 'let')) {
                    throw new LitsError('Expected comma or closing parenthesis', this.peekSourceCodeInfo());
                }
                if (isOperatorToken(this.peek(), ',')) {
                    this.advance();
                }
            }
            if (!isRParenToken(this.peek())) {
                throw new LitsError('Expected closing parenthesis', this.peekSourceCodeInfo());
            }
            this.advance();
            return functionArguments;
        };
        Parser.prototype.parseShorthandLamdaFunction = function () {
            var _a;
            var firstToken = this.asToken(this.peek());
            this.advance();
            var startPos = this.parseState.position;
            var exprNode = this.parseExpression();
            var endPos = this.parseState.position - 1;
            var arity = 0;
            var dollar1 = 'NOT_SET'; // referring to argument bindings. $ = NAKED, $1, $2, $3, etc = WITH_1
            for (var pos = startPos; pos <= endPos; pos += 1) {
                var token = this.tokenStream.tokens[pos];
                if (isSymbolToken(token)) {
                    var match = placeholderRegexp.exec(token[1]);
                    if (match) {
                        var number = (_a = match[1]) !== null && _a !== void 0 ? _a : '1';
                        if (number === '1') {
                            var mixedPercent1 = (!match[1] && dollar1 === 'WITH_1') || (match[1] && dollar1 === 'NAKED');
                            if (mixedPercent1)
                                throw new LitsError('Please make up your mind, either use $ or $1', firstToken[2]);
                            dollar1 = match[1] ? 'WITH_1' : 'NAKED';
                        }
                        arity = Math.max(arity, Number(number));
                        if (arity > 20)
                            throw new LitsError('Can\'t specify more than 20 arguments', firstToken[2]);
                    }
                }
            }
            var functionArguments = [];
            for (var i = 1; i <= arity; i += 1) {
                if (i === 1 && dollar1 === 'NAKED') {
                    functionArguments.push(withSourceCodeInfo([bindingTargetTypes.symbol, [[NodeTypes.UserDefinedSymbol, '$'], undefined]], firstToken[2]));
                }
                else {
                    functionArguments.push(withSourceCodeInfo([bindingTargetTypes.symbol, [[NodeTypes.UserDefinedSymbol, "$".concat(i)], undefined]], firstToken[2]));
                }
            }
            var node = withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes['0_fn'], [
                        functionArguments,
                        [exprNode],
                    ]]], firstToken[2]);
            return node;
        };
        Parser.prototype.parseOptionalDefaulValue = function () {
            if (isOperatorToken(this.peek(), '=')) {
                this.advance();
                return this.parseExpression();
            }
            return undefined;
        };
        Parser.prototype.parseBindingTarget = function (_a) {
            var _b = _a === void 0 ? {} : _a, requireDefaultValue = _b.requireDefaultValue, noRest = _b.noRest;
            var firstToken = this.peek();
            // Symbol
            if (isSymbolToken(firstToken)) {
                var symbol = this.parseSymbol();
                if (!isUserDefinedSymbolNode(symbol)) {
                    throw new LitsError('Expected user defined symbol', firstToken[2]);
                }
                var defaultValue = this.parseOptionalDefaulValue();
                if (requireDefaultValue && !defaultValue) {
                    throw new LitsError('Expected assignment', this.peekSourceCodeInfo());
                }
                return withSourceCodeInfo([bindingTargetTypes.symbol, [symbol, defaultValue]], firstToken[2]);
            }
            // Rest
            if (isOperatorToken(firstToken, '...')) {
                if (noRest) {
                    throw new LitsError('Rest element not allowed', firstToken[2]);
                }
                this.advance();
                var symbol = asUserDefinedSymbolNode(this.parseSymbol());
                if (isOperatorToken(this.peek(), '=')) {
                    throw new LitsError('Rest argument can not have default value', this.peekSourceCodeInfo());
                }
                return withSourceCodeInfo([bindingTargetTypes.rest, [symbol[1], undefined]], firstToken[2]);
            }
            // Array
            if (isLBracketToken(firstToken)) {
                this.advance();
                var elements = [];
                var token = this.asToken(this.peek());
                var rest = false;
                while (!isRBracketToken(token)) {
                    if (rest) {
                        throw new LitsError('Rest argument must be last', token[2]);
                    }
                    if (isOperatorToken(token, ',')) {
                        elements.push(null);
                        this.advance();
                        token = this.asToken(this.peek());
                        continue;
                    }
                    var target = this.parseBindingTarget();
                    if (target[0] === bindingTargetTypes.rest) {
                        rest = true;
                    }
                    elements.push(target);
                    token = this.asToken(this.peek());
                    if (!isRBracketToken(token)) {
                        assertOperatorToken(token, ',');
                        this.advance();
                    }
                    token = this.asToken(this.peek());
                }
                this.advance();
                var defaultValue = this.parseOptionalDefaulValue();
                if (requireDefaultValue && !defaultValue) {
                    throw new LitsError('Expected assignment', this.peekSourceCodeInfo());
                }
                return withSourceCodeInfo([bindingTargetTypes.array, [elements, defaultValue]], firstToken[2]);
            }
            // Object
            if (isLBraceToken(firstToken)) {
                this.advance();
                var elements = {};
                var token = this.asToken(this.peek());
                var rest = false;
                while (!isRBraceToken(token)) {
                    if (rest) {
                        throw new LitsError('Rest argument must be last', token[2]);
                    }
                    if (isOperatorToken(token, '...')) {
                        rest = true;
                        this.advance();
                    }
                    var key = asUserDefinedSymbolNode(this.parseSymbol());
                    token = this.asToken(this.peek());
                    if (isReservedSymbolToken(token, 'as')) {
                        if (rest) {
                            throw new LitsError('Rest argument can not have alias', token[2]);
                        }
                        this.advance();
                        var name_2 = asUserDefinedSymbolNode(this.parseSymbol());
                        if (elements[name_2[1]]) {
                            throw new LitsError("Duplicate binding name: ".concat(name_2), token[2]);
                        }
                        elements[key[1]] = withSourceCodeInfo([bindingTargetTypes.symbol, [name_2, this.parseOptionalDefaulValue()]], firstToken[2]);
                    }
                    else if (isRBraceToken(token) || isOperatorToken(token, ',') || isOperatorToken(token, '=')) {
                        if (elements[key[1]]) {
                            throw new LitsError("Duplicate binding name: ".concat(key), token[2]);
                        }
                        if (rest && isOperatorToken(this.peek(), '=')) {
                            throw new LitsError('Rest argument can not have default value', this.peekSourceCodeInfo());
                        }
                        elements[key[1]] = rest
                            ? withSourceCodeInfo([bindingTargetTypes.rest, [key[1], this.parseOptionalDefaulValue()]], firstToken[2])
                            : withSourceCodeInfo([bindingTargetTypes.symbol, [key, this.parseOptionalDefaulValue()]], firstToken[2]);
                    }
                    else if (isLBraceToken(token) || isLBracketToken(token)) {
                        elements[key[1]] = this.parseBindingTarget();
                    }
                    if (!isRBraceToken(this.peek())) {
                        assertOperatorToken(this.peek(), ',');
                        this.advance();
                    }
                    token = this.asToken(this.peek());
                }
                this.advance();
                token = this.asToken(this.peek());
                var defaultValue = this.parseOptionalDefaulValue();
                if (requireDefaultValue && !defaultValue) {
                    throw new LitsError('Expected assignment', token[2]);
                }
                return withSourceCodeInfo([bindingTargetTypes.object, [elements, defaultValue]], firstToken[2]);
            }
            throw new LitsError('Expected symbol', this.peekSourceCodeInfo());
        };
        Parser.prototype.parseLet = function (token) {
            this.advance();
            var target = this.parseBindingTarget({ requireDefaultValue: true, noRest: true });
            var value = target[1][1];
            target[1][1] = undefined;
            var bindingTarget = withSourceCodeInfo([NodeTypes.Binding, [target, value]], token[2]);
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.let, bindingTarget]], token[2]);
        };
        Parser.prototype.parseBlock = function () {
            var token = asLBraceToken(this.peek());
            this.advance();
            var expressions = [];
            while (!this.isAtEnd() && !isRBraceToken(this.peek())) {
                expressions.push(this.parseExpression());
                if (isOperatorToken(this.peek(), ';')) {
                    this.advance();
                }
                else if (!isRBraceToken(this.peek())) {
                    throw new LitsError('Expected }', this.peekSourceCodeInfo());
                }
            }
            if (expressions.length === 0) {
                expressions.push(withSourceCodeInfo([NodeTypes.ReservedSymbol, 'null'], token[2]));
            }
            assertRBraceToken(this.peek());
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.block, expressions]], token[2]);
        };
        Parser.prototype.parseLoop = function (firstToken) {
            this.advance();
            assertLParenToken(this.peek());
            this.advance();
            var bindingNodes = [];
            var token = this.peek();
            while (!this.isAtEnd() && !isRParenToken(token)) {
                var target = this.parseBindingTarget({ requireDefaultValue: true, noRest: true });
                var value = target[1][1];
                target[1][1] = undefined;
                bindingNodes.push(withSourceCodeInfo([NodeTypes.Binding, [target, value]], target[2]));
                if (isOperatorToken(this.peek(), ',')) {
                    this.advance();
                }
                token = this.peek();
            }
            if (bindingNodes.length === 0) {
                throw new LitsError('Expected binding', this.peekSourceCodeInfo());
            }
            assertRParenToken(token);
            this.advance();
            assertLBraceToken(this.peek());
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isRBraceToken(this.peek())) {
                params.push(this.parseExpression());
                if (isOperatorToken(this.peek(), ';')) {
                    this.advance();
                }
                else if (!isRBraceToken(this.peek())) {
                    throw new LitsError('Expected ;', this.peekSourceCodeInfo());
                }
            }
            assertRBraceToken(this.peek());
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.loop, bindingNodes, params]], firstToken[2]);
        };
        Parser.prototype.parseTry = function (token) {
            this.advance();
            var tryExpression = this.parseBlock();
            assertReservedSymbolToken(this.peek(), 'catch');
            this.advance();
            var errorSymbol;
            if (isLParenToken(this.peek())) {
                this.advance();
                errorSymbol = this.parseSymbol();
                assertRParenToken(this.peek());
                this.advance();
            }
            var catchExpression = this.parseBlock();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.try, tryExpression, errorSymbol, catchExpression]], token[2]);
        };
        Parser.prototype.parseForOrDoseq = function (firstToken) {
            var isDoseq = firstToken[1] === 'doseq';
            this.advance();
            assertLParenToken(this.peek());
            this.advance();
            var forLoopBindings = [];
            var _loop_1 = function () {
                var loopBinding = this_1.parseForLoopBinding();
                var existingBoundNames = forLoopBindings.flatMap(function (b) { return Object.keys(getAllBindingTargetNames(b[0][1][0])); });
                var newBoundNames = getAllBindingTargetNames(loopBinding[0][1][0]);
                if (Object.keys(newBoundNames).some(function (n) { return existingBoundNames.includes(n); })) {
                    throw new LitsError('Duplicate binding', loopBinding[0][2]);
                }
                forLoopBindings.push(loopBinding);
                if (isOperatorToken(this_1.peek(), ';')) {
                    this_1.advance();
                }
            };
            var this_1 = this;
            while (!this.isAtEnd() && !isRParenToken(this.peek())) {
                _loop_1();
            }
            assertRParenToken(this.peek());
            this.advance();
            var expression = this.parseExpression();
            return isDoseq
                ? withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.doseq, forLoopBindings, expression]], firstToken[2])
                : withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.for, forLoopBindings, expression]], firstToken[2]);
        };
        Parser.prototype.parseForLoopBinding = function () {
            var bindingNode = this.parseBinding();
            var modifiers = [];
            var token = this.asToken(this.peek());
            if (!isRParenToken(token) && !isOperatorToken(this.peek(), ';') && !isOperatorToken(token, ',')) {
                throw new LitsError('Expected ")", ";" or ","', token[2]);
            }
            if (isOperatorToken(token, ',')) {
                this.advance();
                token = this.asToken(this.peek());
            }
            if (!isSymbolToken(token, 'let')
                && !isReservedSymbolToken(token, 'when')
                && !isReservedSymbolToken(token, 'while')
                && !isRParenToken(token)
                && !isOperatorToken(token, ';')) {
                throw new LitsError('Expected symbol ";", ")", let, when or while', token[2]);
            }
            var letBindings = [];
            if (token[1] === 'let') {
                modifiers.push('&let');
                var _loop_2 = function () {
                    var letNode = this_2.parseLet(token);
                    var existingBoundNames = letBindings.flatMap(function (b) { return Object.keys(getAllBindingTargetNames(b[1][0])); });
                    var newBoundNames = Object.keys(getAllBindingTargetNames(letNode[1][1][1][0]));
                    if (newBoundNames.some(function (n) { return existingBoundNames.includes(n); })) {
                        throw new LitsError('Duplicate binding', letNode[1][1][2]);
                    }
                    letBindings.push(letNode[1][1]);
                    token = this_2.asToken(this_2.peek());
                    if (!isRParenToken(token) && !isOperatorToken(token, ';') && !isOperatorToken(token, ',')) {
                        throw new LitsError('Expected ")", ";" or ","', token[2]);
                    }
                    if (isOperatorToken(token, ',')) {
                        this_2.advance();
                    }
                    token = this_2.asToken(this_2.peek());
                };
                var this_2 = this;
                while (isSymbolToken(token, 'let')) {
                    _loop_2();
                }
            }
            var whenNode;
            var whileNode;
            while (isReservedSymbolToken(token, 'when')
                || isReservedSymbolToken(token, 'while')) {
                this.advance();
                if (token[1] === 'when') {
                    if (modifiers.includes('&when')) {
                        throw new LitsError('Multiple when modifiers in for loop', token[2]);
                    }
                    modifiers.push('&when');
                    whenNode = this.parseExpression();
                }
                else {
                    if (modifiers.includes('&while')) {
                        throw new LitsError('Multiple while modifiers in for loop', token[2]);
                    }
                    modifiers.push('&while');
                    whileNode = this.parseExpression();
                }
                token = this.asToken(this.peek());
                if (!isRParenToken(token) && !isOperatorToken(token, ';') && !isOperatorToken(token, ',')) {
                    throw new LitsError('Expected do or comma', token[2]);
                }
                if (isOperatorToken(token, ',')) {
                    this.advance();
                }
                token = this.asToken(this.peek());
            }
            if (!isRParenToken(token) && !isOperatorToken(token, ';')) {
                throw new LitsError('Expected "{" or ";"', token[2]);
            }
            return [bindingNode, letBindings, whenNode, whileNode];
        };
        Parser.prototype.parseBinding = function () {
            var firstToken = asSymbolToken(this.peek());
            var name = asUserDefinedSymbolNode(this.parseSymbol());
            assertReservedSymbolToken(this.peek(), 'in');
            this.advance();
            var value = this.parseExpression();
            var node = withSourceCodeInfo([
                NodeTypes.Binding,
                [
                    withSourceCodeInfo([bindingTargetTypes.symbol, [name, undefined]], firstToken[2]),
                    value,
                ],
            ], firstToken[2]);
            return node;
        };
        Parser.prototype.parseIfOrUnless = function (token) {
            var isUnless = token[1] === 'unless';
            this.advance();
            assertLParenToken(this.peek());
            this.advance();
            var condition = this.parseExpression();
            assertRParenToken(this.peek());
            this.advance();
            var thenExpression = this.parseExpression();
            var elseExpression;
            if (isReservedSymbolToken(this.peek(), 'else')) {
                this.advance();
                elseExpression = this.parseExpression();
            }
            return isUnless
                ? withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.unless, [condition, thenExpression, elseExpression]]], token[2])
                : withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.if, [condition, thenExpression, elseExpression]]], token[2]);
        };
        Parser.prototype.parseCond = function (token) {
            this.advance();
            assertLBraceToken(this.peek());
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isRBraceToken(this.peek())) {
                assertReservedSymbolToken(this.peek(), 'case');
                this.advance();
                var caseExpression = this.parseExpression();
                assertOperatorToken(this.peek(), ':');
                this.advance();
                var expressions = [];
                while (!this.isAtEnd()
                    && !isReservedSymbolToken(this.peek(), 'case')
                    && !isRBraceToken(this.peek())) {
                    expressions.push(this.parseExpression());
                    if (isOperatorToken(this.peek(), ';')) {
                        this.advance();
                    }
                    else if (!isReservedSymbolToken(this.peek(), 'case') && !isRBraceToken(this.peek())) {
                        throw new LitsError('Expected ;', this.peekSourceCodeInfo());
                    }
                }
                var thenExpression = expressions.length === 1
                    ? expressions[0]
                    : withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.block, expressions]], token[2]);
                params.push([caseExpression, thenExpression]);
                if (isRBraceToken(this.peek())) {
                    break;
                }
                assertReservedSymbolToken(this.peek(), 'case');
            }
            assertRBraceToken(this.peek());
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.cond, params]], token[2]);
        };
        Parser.prototype.parseSwitch = function (token) {
            this.advance();
            assertLParenToken(this.peek());
            this.advance();
            var valueExpression = this.parseExpression();
            assertRParenToken(this.peek());
            this.advance();
            assertLBraceToken(this.peek());
            this.advance();
            var params = [];
            while (!this.isAtEnd() && !isRBraceToken(this.peek())) {
                assertReservedSymbolToken(this.peek(), 'case');
                this.advance();
                var caseExpression = this.parseExpression();
                assertOperatorToken(this.peek(), ':');
                this.advance();
                var expressions = [];
                while (!this.isAtEnd()
                    && !isReservedSymbolToken(this.peek(), 'case')
                    && !isRBraceToken(this.peek())) {
                    expressions.push(this.parseExpression());
                    if (isOperatorToken(this.peek(), ';')) {
                        this.advance();
                    }
                    else if (!isReservedSymbolToken(this.peek(), 'case') && !isRBraceToken(this.peek())) {
                        throw new LitsError('Expected ;', this.peekSourceCodeInfo());
                    }
                }
                var thenExpression = expressions.length === 1
                    ? expressions[0]
                    : withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.block, expressions]], token[2]);
                params.push([caseExpression, thenExpression]);
                if (isRBraceToken(this.peek())) {
                    break;
                }
                assertReservedSymbolToken(this.peek(), 'case');
            }
            assertRBraceToken(this.peek());
            this.advance();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.switch, valueExpression, params]], token[2]);
        };
        Parser.prototype.parseFunction = function (token) {
            this.advance();
            var symbol = this.parseSymbol();
            var functionArguments = this.parseFunctionArguments();
            var block = this.parseBlock();
            return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes.function, symbol, [
                        functionArguments,
                        block[1][1],
                    ]]], token[2]);
        };
        Parser.prototype.isAtEnd = function () {
            return this.parseState.position >= this.tokenStream.tokens.length;
        };
        Parser.prototype.isAtExpressionEnd = function () {
            if (this.isAtEnd()) {
                return true;
            }
            var token = this.peek();
            if (isOperatorToken(token)) {
                return [';', ',', ':'].includes(token[1]);
            }
            if (isReservedSymbolToken(token)) {
                return ['else', 'when', 'while', 'case', 'catch'].includes(token[1]);
            }
            return false;
        };
        Parser.prototype.parseExport = function (exportToken) {
            this.advance();
            var token = this.peek();
            if (isSymbolToken(token, 'let')) {
                var letNode = this.parseLet(asSymbolToken(token));
                return withSourceCodeInfo([NodeTypes.SpecialExpression, [specialExpressionTypes['0_def'], letNode[1][1]]], exportToken[2]);
            }
            else if (isReservedSymbolToken(token, 'function')) {
                var functionNode = this.parseFunction(token);
                functionNode[1][0] = specialExpressionTypes['0_defn'];
                return functionNode;
            }
            else {
                throw new LitsError('Expected let or function', this.peekSourceCodeInfo());
            }
        };
        Parser.prototype.stringToSymbolNode = function (value, sourceCodeInfo) {
            if (specialExpressionTypes[value] !== undefined && value !== 'fn' && value !== 'def' && value !== 'defn') {
                return withSourceCodeInfo([NodeTypes.SpecialBuiltinSymbol, specialExpressionTypes[value]], sourceCodeInfo);
            }
            if (normalExpressionTypes[value] !== undefined) {
                return withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol, normalExpressionTypes[value]], sourceCodeInfo);
            }
            return withSourceCodeInfo([NodeTypes.UserDefinedSymbol, value], sourceCodeInfo);
        };
        Parser.prototype.stringFromQuotedSymbol = function (value) {
            return value.substring(1, value.length - 1)
                .replace(/(\\{2})|(\\')|\\(.)/g, function (_, backslash, singleQuote, normalChar) {
                if (backslash) {
                    return '\\';
                }
                if (singleQuote) {
                    return '\'';
                }
                return "\\".concat(normalChar);
            });
        };
        Parser.prototype.parseSymbol = function () {
            var token = this.asToken(this.peek());
            this.advance();
            if (!isSymbolToken(token)) {
                throw new LitsError("Expected symbol token, got ".concat(token[0]), token[2]);
            }
            if (token[1][0] === '\'') {
                return this.stringToSymbolNode(this.stringFromQuotedSymbol(token[1]), token[2]);
            }
            else {
                return this.stringToSymbolNode(token[1], token[2]);
            }
        };
        Parser.prototype.parseReservedSymbol = function () {
            var token = asReservedSymbolToken(this.peek());
            this.advance();
            var symbol = token[1];
            if (isNumberReservedSymbol(symbol)) {
                return withSourceCodeInfo([NodeTypes.Number, numberReservedSymbolRecord[symbol]], token[2]);
            }
            return withSourceCodeInfo([NodeTypes.ReservedSymbol, token[1]], token[2]);
        };
        Parser.prototype.parseNumber = function () {
            var token = this.asToken(this.peek());
            this.advance();
            var value = token[1];
            var negative = value[0] === '-';
            var numberString = (negative ? value.substring(1) : value).replace(/_/g, '');
            return withSourceCodeInfo([NodeTypes.Number, negative ? -Number(numberString) : Number(numberString)], token[2]);
        };
        Parser.prototype.parseString = function () {
            var token = this.asToken(this.peek());
            this.advance();
            var value = token[1].substring(1, token[1].length - 1)
                .replace(/(\\{2})|(\\")|(\\n)|(\\t)|(\\r)|(\\b)|(\\f)|\\(.)/g, function (_, backslash, doubleQuote, newline, tab, carriageReturn, backspace, formFeed, normalChar) {
                // If it's a double escape (\\x), return \x
                if (backslash) {
                    return '\\';
                }
                // If it's a special character (\n, \t, \r, \b, \f), return the special character
                else if (newline) {
                    return '\n';
                }
                else if (tab) {
                    return '\t';
                }
                else if (carriageReturn) {
                    return '\r';
                }
                else if (backspace) {
                    return '\b';
                }
                else if (formFeed) {
                    return '\f';
                }
                else if (doubleQuote) {
                    return '"';
                }
                return normalChar;
            });
            return withSourceCodeInfo([NodeTypes.String, value], token[2]);
        };
        Parser.prototype.parseRegexpShorthand = function () {
            var token = this.asToken(this.peek());
            this.advance();
            var endStringPosition = token[1].lastIndexOf('"');
            var regexpString = token[1].substring(2, endStringPosition);
            var optionsString = token[1].substring(endStringPosition + 1);
            var stringNode = withSourceCodeInfo([NodeTypes.String, regexpString], token[2]);
            var optionsNode = withSourceCodeInfo([NodeTypes.String, optionsString], token[2]);
            var node = withSourceCodeInfo([
                NodeTypes.NormalExpression,
                [
                    withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol, normalExpressionTypes.regexp], token[2]),
                    [stringNode, optionsNode],
                ],
            ], token[2]);
            return node;
        };
        return Parser;
    }());

    var litsCommands = new Set(__spreadArray(__spreadArray([], __read(normalExpressionKeys), false), __read(specialExpressionKeys), false));
    // TODO: replace with get suggestions function
    var AutoCompleter = /** @class */ (function () {
        function AutoCompleter(originalProgram, originalPosition, lits, params) {
            this.originalProgram = originalProgram;
            this.originalPosition = originalPosition;
            this.prefixProgram = '';
            this.suffixProgram = '';
            this.searchString = '';
            this.suggestions = [];
            this.suggestionIndex = null;
            var partialProgram = this.originalProgram.slice(0, this.originalPosition);
            var tokenStream = null;
            try {
                tokenStream = lits.tokenize(partialProgram);
            }
            catch (_a) {
                // do nothing
            }
            if (!tokenStream) {
                return;
            }
            var lastToken = tokenStream.tokens.at(-1);
            if (!lastToken) {
                return;
            }
            this.searchString = lastToken[1];
            this.prefixProgram = this.originalProgram.slice(0, this.originalPosition - this.searchString.length);
            this.suffixProgram = this.originalProgram.slice(this.prefixProgram.length + this.searchString.length);
            this.originalProgram.slice(this.prefixProgram.length + this.searchString.length);
            this.suggestions = this.generateSuggestions(params);
        }
        AutoCompleter.prototype.getNextSuggestion = function () {
            return this.getAutoCompleteSuggestionResult(this.getNextSuggestionSymbol());
        };
        AutoCompleter.prototype.getPreviousSuggestion = function () {
            return this.getAutoCompleteSuggestionResult(this.getPreviousSuggestionSymbol());
        };
        AutoCompleter.prototype.getAutoCompleteSuggestionResult = function (suggestion) {
            if (suggestion === null) {
                return null;
            }
            return {
                program: this.prefixProgram + suggestion + this.suffixProgram,
                position: this.prefixProgram.length + suggestion.length,
            };
        };
        AutoCompleter.prototype.getNextSuggestionSymbol = function () {
            if (this.suggestions.length === 0) {
                return null;
            }
            if (this.suggestionIndex === null) {
                this.suggestionIndex = 0;
            }
            else {
                this.suggestionIndex += 1;
                if (this.suggestionIndex >= this.suggestions.length) {
                    this.suggestionIndex = 0;
                }
            }
            return this.suggestions[this.suggestionIndex];
        };
        AutoCompleter.prototype.getPreviousSuggestionSymbol = function () {
            if (this.suggestions.length === 0) {
                return null;
            }
            if (this.suggestionIndex === null) {
                this.suggestionIndex = this.suggestions.length - 1;
            }
            else {
                this.suggestionIndex -= 1;
                if (this.suggestionIndex < 0) {
                    this.suggestionIndex = this.suggestions.length - 1;
                }
            }
            return this.suggestions[this.suggestionIndex];
        };
        AutoCompleter.prototype.getSuggestions = function () {
            return __spreadArray([], __read(this.suggestions), false);
        };
        AutoCompleter.prototype.getSearchString = function () {
            return this.searchString;
        };
        AutoCompleter.prototype.generateSuggestions = function (params) {
            var _this = this;
            var _a, _b, _c, _d;
            var suggestions = new Set();
            litsCommands.forEach(function (name) {
                if (name.startsWith(_this.searchString)) {
                    suggestions.add(name);
                }
            });
            Object.keys((_a = params.globalContext) !== null && _a !== void 0 ? _a : {})
                .filter(function (name) { return name.startsWith(_this.searchString); })
                .forEach(function (name) { return suggestions.add(name); });
            (_b = params.contexts) === null || _b === void 0 ? void 0 : _b.forEach(function (context) {
                Object.keys(context)
                    .filter(function (name) { return name.startsWith(_this.searchString); })
                    .forEach(function (name) { return suggestions.add(name); });
            });
            Object.keys((_c = params.jsFunctions) !== null && _c !== void 0 ? _c : {})
                .filter(function (name) { return name.startsWith(_this.searchString); })
                .forEach(function (name) { return suggestions.add(name); });
            Object.keys((_d = params.values) !== null && _d !== void 0 ? _d : {})
                .filter(function (name) { return name.startsWith(_this.searchString); })
                .forEach(function (name) { return suggestions.add(name); });
            return __spreadArray([], __read(suggestions), false).sort(function (a, b) { return a.localeCompare(b); });
        };
        return AutoCompleter;
    }());

    var Cache = /** @class */ (function () {
        function Cache(maxSize) {
            this.cache = {};
            this.firstEntry = undefined;
            this.lastEntry = undefined;
            this._size = 0;
            this.maxSize = maxSize === null ? null : toNonNegativeInteger(maxSize);
            if (typeof this.maxSize === 'number' && this.maxSize < 1)
                throw new Error("1 is the minimum maxSize, got ".concat(valueToString(maxSize)));
        }
        Cache.prototype.getContent = function () {
            return Object.entries(this.cache).reduce(function (result, _a) {
                var _b = __read(_a, 2), key = _b[0], entry = _b[1];
                result[key] = entry.value;
                return result;
            }, {});
        };
        Object.defineProperty(Cache.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        Cache.prototype.get = function (key) {
            var _a;
            return (_a = this.cache[key]) === null || _a === void 0 ? void 0 : _a.value;
        };
        Cache.prototype.clear = function () {
            this.cache = {};
            this.firstEntry = undefined;
            this.lastEntry = undefined;
            this._size = 0;
        };
        Cache.prototype.has = function (key) {
            return !!this.cache[key];
        };
        Cache.prototype.set = function (key, value) {
            if (this.has(key))
                throw new Error("AstCache - key already present: ".concat(key));
            var newEntry = { value: value, nextEntry: undefined, key: key };
            this.cache[key] = newEntry;
            this._size += 1;
            if (this.lastEntry)
                this.lastEntry.nextEntry = newEntry;
            this.lastEntry = newEntry;
            if (!this.firstEntry)
                this.firstEntry = this.lastEntry;
            while (this.maxSize !== null && this.size > this.maxSize)
                this.dropFirstEntry();
        };
        Cache.prototype.dropFirstEntry = function () {
            var firstEntry = this.firstEntry;
            delete this.cache[firstEntry.key];
            this._size -= 1;
            this.firstEntry = firstEntry.nextEntry;
        };
        return Cache;
    }());

    var Lits = /** @class */ (function () {
        function Lits(config) {
            var e_1, _a;
            if (config === void 0) { config = {}; }
            var _b, _c, _d;
            this.debug = (_b = config.debug) !== null && _b !== void 0 ? _b : false;
            this.astCacheSize = (_c = config.astCacheSize) !== null && _c !== void 0 ? _c : null;
            if (this.astCacheSize) {
                this.astCache = new Cache(this.astCacheSize);
                var initialCache = (_d = config.initialCache) !== null && _d !== void 0 ? _d : {};
                try {
                    for (var _e = __values(Object.keys(initialCache)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var cacheEntry = _f.value;
                        this.astCache.set(cacheEntry, initialCache[cacheEntry]);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                this.astCache = null;
            }
        }
        Lits.prototype.getRuntimeInfo = function () {
            return {
                astCacheSize: this.astCacheSize,
                astCache: this.astCache,
                debug: this.debug,
            };
        };
        Lits.prototype.run = function (program, params) {
            if (params === void 0) { params = {}; }
            var ast = this.generateAst(program, params);
            return this.evaluate(ast, params);
        };
        Lits.prototype.context = function (programOrAst, params) {
            if (params === void 0) { params = {}; }
            var ast = typeof programOrAst === 'string' ? this.generateAst(programOrAst, params) : programOrAst;
            var contextStack = createContextStack(params);
            evaluate(ast, contextStack);
            return contextStack.globalContext;
        };
        Lits.prototype.getUndefinedSymbols = function (programOrAst, params) {
            if (params === void 0) { params = {}; }
            var ast = typeof programOrAst === 'string' ? this.generateAst(programOrAst, params) : programOrAst;
            var contextStack = createContextStack(params);
            return getUndefinedSymbols(ast, contextStack, builtin, evaluateNode);
        };
        Lits.prototype.tokenize = function (program, tokenizeParams) {
            if (tokenizeParams === void 0) { tokenizeParams = {}; }
            var tokenStream = tokenize$1(program, this.debug, tokenizeParams.filePath);
            return tokenizeParams.minify ? minifyTokenStream(tokenStream, { removeWhiteSpace: false }) : tokenStream;
        };
        Lits.prototype.parse = function (tokenStream) {
            tokenStream = minifyTokenStream(tokenStream, { removeWhiteSpace: true });
            var ast = {
                body: [],
                hasDebugData: tokenStream.hasDebugData,
            };
            var parseState = {
                position: 0,
            };
            ast.body = new Parser(tokenStream, parseState).parse();
            return ast;
        };
        Lits.prototype.evaluate = function (ast, params) {
            var contextStack = createContextStack(params);
            return evaluate(ast, contextStack);
        };
        Lits.prototype.transformSymbols = function (tokenStream, transformer) {
            return transformSymbolTokens(tokenStream, transformer);
        };
        Lits.prototype.untokenize = function (tokenStream) {
            return untokenize(tokenStream);
        };
        Lits.prototype.apply = function (fn, fnParams, params) {
            var _a;
            if (params === void 0) { params = {}; }
            var fnName = 'FN_2eb7b316_471c_5bfa_90cb_d3dfd9164a59';
            var program = this.generateApplyFunctionCall(fnName, fnParams);
            var ast = this.generateAst(program, params);
            var hostValues = fnParams.reduce(function (result, param, index) {
                result["".concat(fnName, "_").concat(index)] = param;
                return result;
            }, (_a = {}, _a[fnName] = fn, _a));
            params.values = __assign(__assign({}, params.values), hostValues);
            return this.evaluate(ast, params);
        };
        Lits.prototype.generateApplyFunctionCall = function (fnName, fnParams) {
            var paramsString = fnParams
                .map(function (_, index) {
                return "".concat(fnName, "_").concat(index);
            })
                .join(', ');
            return "".concat(fnName, "(").concat(paramsString, ")");
        };
        Lits.prototype.generateAst = function (program, params) {
            var _a;
            if (this.astCache) {
                var cachedAst = this.astCache.get(program);
                if (cachedAst)
                    return cachedAst;
            }
            var tokenStream = this.tokenize(program, {
                filePath: params.filePath,
            });
            var ast = this.parse(tokenStream);
            (_a = this.astCache) === null || _a === void 0 ? void 0 : _a.set(program, ast);
            return ast;
        };
        Lits.prototype.getAutoCompleter = function (program, position, params) {
            if (params === void 0) { params = {}; }
            return new AutoCompleter(program, position, this, params);
        };
        return Lits;
    }());

    var csvApi = Object.values(apiReference)
        .map(function (ref) {
        var title = ref.title;
        var description = ref.description.replaceAll(';', ':');
        var titleParts = title.split(':');
        var namespace = titleParts.length > 1 ? titleParts[0] : 'core';
        return "".concat(namespace, ";").concat(title, ";").concat(description);
    })
        .join('\n');
    console.log("Namespace;Title;Description\n".concat(csvApi));
    console.log(Object.keys(apiReference));
    var getLits = (function () {
        var lits = new Lits({ debug: true });
        var litsNoDebug = new Lits({ debug: false });
        return function (forceDebug) { return forceDebug || getState('debug') ? lits : litsNoDebug; };
    })();
    var elements = {
        wrapper: document.getElementById('wrapper'),
        playground: document.getElementById('playground'),
        sidebar: document.getElementById('sidebar'),
        mainPanel: document.getElementById('main-panel'),
        contextPanel: document.getElementById('context-panel'),
        litsPanel: document.getElementById('lits-panel'),
        outputPanel: document.getElementById('output-panel'),
        moreMenu: document.getElementById('more-menu'),
        addContextMenu: document.getElementById('add-context-menu'),
        newContextName: document.getElementById('new-context-name'),
        newContextValue: document.getElementById('new-context-value'),
        newContextError: document.getElementById('new-context-error'),
        contextTextArea: document.getElementById('context-textarea'),
        outputResult: document.getElementById('output-result'),
        litsTextArea: document.getElementById('lits-textarea'),
        resizePlayground: document.getElementById('resize-playground'),
        resizeDevider1: document.getElementById('resize-divider-1'),
        resizeDevider2: document.getElementById('resize-divider-2'),
        toggleDebugMenuLabel: document.getElementById('toggle-debug-menu-label'),
        litsPanelDebugInfo: document.getElementById('lits-panel-debug-info'),
        contextUndoButton: document.getElementById('context-undo-button'),
        contextRedoButton: document.getElementById('context-redo-button'),
        litsCodeUndoButton: document.getElementById('lits-code-undo-button'),
        litsCodeRedoButton: document.getElementById('lits-code-redo-button'),
        contextTitle: document.getElementById('context-title'),
        litsCodeTitle: document.getElementById('lits-code-title'),
        litsCodeTitleString: document.getElementById('lits-code-title-string'),
    };
    var moveParams = null;
    var ignoreSelectionChange = false;
    function calculateDimensions() {
        return {
            windowHeight: window.innerHeight,
            windowWidth: window.innerWidth,
        };
    }
    function openMoreMenu() {
        elements.moreMenu.style.display = 'block';
    }
    function closeMoreMenu() {
        elements.moreMenu.style.display = 'none';
    }
    function openAddContextMenu() {
        elements.newContextName.value = getState('new-context-name');
        elements.newContextValue.value = getState('new-context-value');
        elements.addContextMenu.style.display = 'block';
        elements.newContextName.focus();
    }
    function closeAddContextMenu() {
        elements.addContextMenu.style.display = 'none';
        elements.newContextError.style.display = 'none';
        elements.newContextError.textContent = '';
        elements.newContextName.value = '';
        elements.newContextValue.value = '';
    }
    function share() {
        addOutputSeparator();
        appendOutput('Sharable link:', 'comment');
        var href = "".concat(location.origin).concat(location.pathname, "?state=").concat(encodeState());
        var a = document.createElement('a');
        a.textContent = href;
        a.className = 'share-link';
        a.href = href;
        addOutputElement(a);
    }
    function onDocumentClick(event) {
        var target = event.target;
        if (!(target === null || target === void 0 ? void 0 : target.closest('#more-menu')) && elements.moreMenu.style.display === 'block')
            closeMoreMenu();
        if (!(target === null || target === void 0 ? void 0 : target.closest('#add-context-menu')) && elements.addContextMenu.style.display === 'block')
            closeAddContextMenu();
    }
    var layout = throttle(function () {
        var _a = calculateDimensions(), windowWidth = _a.windowWidth, windowHeight = _a.windowHeight;
        var playgroundHeight = Math.min(getState('playground-height'), windowHeight);
        var contextPanelWidth = (windowWidth * getState('resize-divider-1-percent')) / 100;
        var outputPanelWidth = (windowWidth * (100 - getState('resize-divider-2-percent'))) / 100;
        var litsPanelWidth = windowWidth - contextPanelWidth - outputPanelWidth;
        elements.playground.style.height = "".concat(playgroundHeight, "px");
        elements.contextPanel.style.width = "".concat(contextPanelWidth, "px");
        elements.litsPanel.style.width = "".concat(litsPanelWidth, "px");
        elements.outputPanel.style.width = "".concat(outputPanelWidth, "px");
        elements.sidebar.style.bottom = "".concat(playgroundHeight, "px");
        elements.mainPanel.style.bottom = "".concat(playgroundHeight, "px");
        elements.wrapper.style.display = 'block';
    });
    var undoContextHistory = throttle(function () {
        ignoreSelectionChange = true;
        if (undoContext()) {
            applyState();
            focusContext();
        }
        setTimeout(function () { return ignoreSelectionChange = false; });
    });
    var redoContextHistory = throttle(function () {
        ignoreSelectionChange = true;
        if (redoContext()) {
            applyState();
            focusContext();
        }
        setTimeout(function () { return ignoreSelectionChange = false; });
    });
    var undoLitsCodeHistory = throttle(function () {
        ignoreSelectionChange = true;
        if (undoLitsCode()) {
            applyState();
            focusLitsCode();
        }
        setTimeout(function () { return ignoreSelectionChange = false; });
    });
    var redoLitsCodeHistory = throttle(function () {
        ignoreSelectionChange = true;
        if (redoLitsCode()) {
            applyState();
            focusLitsCode();
        }
        setTimeout(function () { return ignoreSelectionChange = false; });
    });
    function resetPlayground() {
        clearAllStates();
        resetContext();
        resetLitsCode();
        resetOutput();
        Search.closeSearch();
        Search.clearSearch();
        layout();
        updateCSS();
    }
    function resetContext() {
        elements.contextTextArea.value = '';
        clearState('context', 'context-scroll-top', 'context-selection-start', 'context-selection-end');
        focusContext();
    }
    function setContext(value, pushToHistory, scroll) {
        elements.contextTextArea.value = value;
        if (pushToHistory) {
            saveState({
                'context': value,
                'context-selection-start': elements.contextTextArea.selectionStart,
                'context-selection-end': elements.contextTextArea.selectionEnd,
            }, true);
        }
        else {
            saveState({ context: value }, false);
        }
        if (scroll === 'top')
            elements.contextTextArea.scrollTo(0, 0);
        else if (scroll === 'bottom')
            elements.contextTextArea.scrollTo({ top: elements.contextTextArea.scrollHeight, behavior: 'smooth' });
    }
    function getParsedContext() {
        try {
            return asUnknownRecord(JSON.parse(getState('context')));
        }
        catch (e) {
            return {};
        }
    }
    function addContextEntry() {
        var name = elements.newContextName.value;
        if (name === '') {
            elements.newContextError.textContent = 'Name is required';
            elements.newContextError.style.display = 'block';
            elements.newContextName.focus();
            return;
        }
        var value = elements.newContextValue.value;
        try {
            var parsedValue = JSON.parse(value);
            var context = getParsedContext();
            var values = Object.assign({}, context.values);
            values[name] = parsedValue;
            context.values = values;
            setContext(JSON.stringify(context, null, 2), true);
            closeAddContextMenu();
        }
        catch (e) {
            elements.newContextError.textContent = 'Invalid JSON';
            elements.newContextError.style.display = 'block';
            elements.newContextValue.focus();
        }
        clearState('new-context-name');
        clearState('new-context-value');
    }
    function addSampleContext() {
        var context = getParsedContext();
        var values = {
            'a-number': 42,
            'a-string': 'foo bar',
            'an-array': ['foo', 'bar', 1, 2, true, false, null],
            'an-object': {
                name: 'John Doe',
                age: 42,
                married: true,
                children: ['Alice', 'Bob'],
                address: {
                    street: '123 Main St',
                    city: 'Springfield',
                    state: 'IL',
                    zip: '62701',
                },
            },
            'matrix-a': [
                [1, 2, 3],
                [4, 5, 6],
            ],
            'matrix-b': [
                [7, 8],
                [9, 10],
                [11, 12],
            ],
            'matrix-c': [
                [3, 0, 2],
                [2, 0, -2],
                [0, 1, 1],
            ],
        };
        var jsFunctions = {
            'prompt!': '(title) => prompt(title)',
        };
        context.values = Object.assign(values, context.values);
        context.jsFunctions = Object.assign(jsFunctions, context.jsFunctions);
        setContext(JSON.stringify(context, null, 2), true);
    }
    function resetLitsCode() {
        elements.litsTextArea.value = '';
        clearState('lits-code', 'lits-code-scroll-top', 'lits-code-selection-start', 'lits-code-selection-end');
        focusLitsCode();
    }
    function setLitsCode(value, pushToHistory, scroll) {
        elements.litsTextArea.value = value;
        if (pushToHistory) {
            saveState({
                'lits-code': value,
                'lits-code-selection-start': elements.litsTextArea.selectionStart,
                'lits-code-selection-end': elements.litsTextArea.selectionEnd,
            }, true);
        }
        else {
            saveState({ 'lits-code': value }, false);
        }
        if (scroll === 'top')
            elements.litsTextArea.scrollTo(0, 0);
        else if (scroll === 'bottom')
            elements.litsTextArea.scrollTo({ top: elements.litsTextArea.scrollHeight, behavior: 'smooth' });
    }
    function appendLitsCode(value) {
        var oldContent = getState('lits-code').trimEnd();
        var newContent = oldContent ? "".concat(oldContent, "\n\n").concat(value) : value.trim();
        setLitsCode(newContent, true, 'bottom');
    }
    function resetOutput() {
        elements.outputResult.innerHTML = '';
        clearState('output');
    }
    function hasOutput() {
        return getState('output').trim() !== '';
    }
    function setOutput(value, pushToHistory) {
        elements.outputResult.innerHTML = value;
        saveState({ output: value }, pushToHistory);
    }
    function appendOutput(output, className) {
        var outputElement = document.createElement('span');
        outputElement.className = className;
        outputElement.textContent = "".concat(output);
        addOutputElement(outputElement);
    }
    function addOutputSeparator() {
        if (hasOutput()) {
            var separator = document.createElement('div');
            separator.className = 'separator';
            addOutputElement(separator);
        }
    }
    function addOutputElement(element) {
        elements.outputResult.appendChild(element);
        elements.outputResult.scrollTop = elements.outputResult.scrollHeight;
        saveState({ output: elements.outputResult.innerHTML });
    }
    window.onload = function () {
        elements.contextUndoButton.classList.add('disabled');
        elements.contextRedoButton.classList.add('disabled');
        elements.litsCodeUndoButton.classList.add('disabled');
        elements.litsCodeRedoButton.classList.add('disabled');
        setContextHistoryListener(function (status) {
            if (status.canUndo) {
                elements.contextUndoButton.classList.remove('disabled');
            }
            else {
                elements.contextUndoButton.classList.add('disabled');
            }
            if (status.canRedo) {
                elements.contextRedoButton.classList.remove('disabled');
            }
            else {
                elements.contextRedoButton.classList.add('disabled');
            }
        });
        setLitsCodeHistoryListener(function (status) {
            if (status.canUndo) {
                elements.litsCodeUndoButton.classList.remove('disabled');
            }
            else {
                elements.litsCodeUndoButton.classList.add('disabled');
            }
            if (status.canRedo) {
                elements.litsCodeRedoButton.classList.remove('disabled');
            }
            else {
                elements.litsCodeRedoButton.classList.add('disabled');
            }
        });
        document.addEventListener('click', onDocumentClick, true);
        elements.resizePlayground.onmousedown = function (event) {
            moveParams = {
                id: 'playground',
                startMoveY: event.clientY,
                heightBeforeMove: getState('playground-height'),
            };
        };
        elements.resizeDevider1.onmousedown = function (event) {
            moveParams = {
                id: 'resize-divider-1',
                startMoveX: event.clientX,
                percentBeforeMove: getState('resize-divider-1-percent'),
            };
        };
        elements.resizeDevider2.onmousedown = function (event) {
            moveParams = {
                id: 'resize-divider-2',
                startMoveX: event.clientX,
                percentBeforeMove: getState('resize-divider-2-percent'),
            };
        };
        window.onresize = layout;
        window.onmouseup = function () {
            document.body.classList.remove('no-select');
            moveParams = null;
        };
        window.onmousemove = function (event) {
            var _a = calculateDimensions(), windowHeight = _a.windowHeight, windowWidth = _a.windowWidth;
            if (moveParams === null)
                return;
            document.body.classList.add('no-select');
            if (moveParams.id === 'playground') {
                var playgroundHeight = moveParams.heightBeforeMove + moveParams.startMoveY - event.clientY;
                if (playgroundHeight < 30)
                    playgroundHeight = 30;
                if (playgroundHeight > windowHeight)
                    playgroundHeight = windowHeight;
                saveState({ 'playground-height': playgroundHeight });
                layout();
            }
            else if (moveParams.id === 'resize-divider-1') {
                var resizeDivider1XPercent = moveParams.percentBeforeMove + ((event.clientX - moveParams.startMoveX) / windowWidth) * 100;
                if (resizeDivider1XPercent < 10)
                    resizeDivider1XPercent = 10;
                if (resizeDivider1XPercent > getState('resize-divider-2-percent') - 10)
                    resizeDivider1XPercent = getState('resize-divider-2-percent') - 10;
                saveState({ 'resize-divider-1-percent': resizeDivider1XPercent });
                layout();
            }
            else if (moveParams.id === 'resize-divider-2') {
                var resizeDivider2XPercent = moveParams.percentBeforeMove + ((event.clientX - moveParams.startMoveX) / windowWidth) * 100;
                if (resizeDivider2XPercent < getState('resize-divider-1-percent') + 10)
                    resizeDivider2XPercent = getState('resize-divider-1-percent') + 10;
                if (resizeDivider2XPercent > 90)
                    resizeDivider2XPercent = 90;
                saveState({ 'resize-divider-2-percent': resizeDivider2XPercent });
                layout();
            }
        };
        window.addEventListener('keydown', function (evt) {
            if (Search.handleKeyDown(evt))
                return;
            if (evt.ctrlKey) {
                switch (evt.key) {
                    case 'r':
                        evt.preventDefault();
                        run();
                        break;
                    case 'a':
                        evt.preventDefault();
                        analyze();
                        break;
                    case 't':
                        evt.preventDefault();
                        tokenize();
                        break;
                    case 'p':
                        evt.preventDefault();
                        parse();
                        break;
                    case 'f':
                        evt.preventDefault();
                        format();
                        break;
                    case 'd':
                        evt.preventDefault();
                        toggleDebug();
                        break;
                    case '1':
                        evt.preventDefault();
                        focusContext();
                        break;
                    case '2':
                        evt.preventDefault();
                        focusLitsCode();
                        break;
                }
            }
            if (evt.key === 'Escape') {
                closeMoreMenu();
                closeAddContextMenu();
                evt.preventDefault();
            }
            if (((isMac() && evt.metaKey) || (!isMac && evt.ctrlKey)) && !evt.shiftKey && evt.key === 'z') {
                evt.preventDefault();
                if (document.activeElement === elements.contextTextArea)
                    undoContextHistory();
                else if (document.activeElement === elements.litsTextArea)
                    undoLitsCodeHistory();
            }
            if (((isMac() && evt.metaKey) || (!isMac && evt.ctrlKey)) && evt.shiftKey && evt.key === 'z') {
                evt.preventDefault();
                if (document.activeElement === elements.contextTextArea)
                    redoContextHistory();
                else if (document.activeElement === elements.litsTextArea)
                    redoLitsCodeHistory();
            }
        });
        elements.contextTextArea.addEventListener('keydown', function (evt) {
            keydownHandler(evt, function () { return setContext(elements.contextTextArea.value, true); });
        });
        elements.contextTextArea.addEventListener('input', function () {
            setContext(elements.contextTextArea.value, true);
        });
        elements.contextTextArea.addEventListener('scroll', function () {
            saveState({ 'context-scroll-top': elements.contextTextArea.scrollTop });
        });
        elements.contextTextArea.addEventListener('selectionchange', function () {
            if (!ignoreSelectionChange) {
                saveState({
                    'context-selection-start': elements.contextTextArea.selectionStart,
                    'context-selection-end': elements.contextTextArea.selectionEnd,
                });
            }
        });
        elements.contextTextArea.addEventListener('focusin', function () {
            saveState({ 'focused-panel': 'context' });
            updateCSS();
        });
        elements.contextTextArea.addEventListener('focusout', function () {
            saveState({ 'focused-panel': null });
            updateCSS();
        });
        elements.litsTextArea.addEventListener('keydown', function (evt) {
            keydownHandler(evt, function () { return setLitsCode(elements.litsTextArea.value, true); });
        });
        elements.litsTextArea.addEventListener('input', function () {
            setLitsCode(elements.litsTextArea.value, true);
        });
        elements.litsTextArea.addEventListener('scroll', function () {
            saveState({ 'lits-code-scroll-top': elements.litsTextArea.scrollTop });
        });
        elements.litsTextArea.addEventListener('selectionchange', function () {
            if (!ignoreSelectionChange) {
                saveState({
                    'lits-code-selection-start': elements.litsTextArea.selectionStart,
                    'lits-code-selection-end': elements.litsTextArea.selectionEnd,
                });
            }
        });
        elements.litsTextArea.addEventListener('focusin', function () {
            saveState({ 'focused-panel': 'lits-code' });
            updateCSS();
        });
        elements.litsTextArea.addEventListener('focusout', function () {
            saveState({ 'focused-panel': null });
            updateCSS();
        });
        elements.outputResult.addEventListener('scroll', function () {
            saveState({ 'output-scroll-top': elements.outputResult.scrollTop });
        });
        elements.newContextName.addEventListener('input', function () {
            saveState({ 'new-context-name': elements.newContextName.value });
        });
        elements.newContextValue.addEventListener('input', function () {
            saveState({ 'new-context-value': elements.newContextValue.value });
        });
        applyState(true);
        var id = location.hash.substring(1) || 'index';
        showPage(id, 'instant', 'replace');
        Search.onClose(function () {
            applyState();
        });
    };
    function getDataFromUrl() {
        var urlParams = new URLSearchParams(window.location.search);
        var urlState = urlParams.get('state');
        if (urlState) {
            addOutputSeparator();
            if (applyEncodedState(urlState))
                appendOutput("Data parsed from url parameter state: ".concat(urlState), 'comment');
            else
                appendOutput("Invalid url parameter state: ".concat(urlState), 'error');
            urlParams.delete('state');
            history.replaceState(null, '', "".concat(location.pathname).concat(urlParams.toString() ? '?' : '').concat(urlParams.toString()));
        }
    }
    function keydownHandler(evt, onChange) {
        if (['Tab', 'Backspace', 'Enter', 'Delete'].includes(evt.key)) {
            var target = evt.target;
            var start = target.selectionStart;
            var end = target.selectionEnd;
            var indexOfReturn = target.value.lastIndexOf('\n', start - 1);
            var rowLength = start - indexOfReturn - 1;
            var onTabStop = rowLength % 2 === 0;
            switch (evt.key) {
                case 'Tab':
                    evt.preventDefault();
                    if (!evt.shiftKey) {
                        target.value = target.value.substring(0, start) + (onTabStop ? '  ' : ' ') + target.value.substring(end);
                        target.selectionStart = target.selectionEnd = start + (onTabStop ? 2 : 1);
                        onChange();
                    }
                    break;
                case 'Backspace':
                    if (onTabStop && start === end && target.value.substring(start - 2, start + 2) === '  ') {
                        evt.preventDefault();
                        target.value = target.value.substring(0, start - 2) + target.value.substring(end);
                        target.selectionStart = target.selectionEnd = start - 2;
                        onChange();
                    }
                    break;
                case 'Enter': {
                    evt.preventDefault();
                    // eslint-disable-next-line regexp/optimal-quantifier-concatenation
                    var spaceCount = target.value.substring(indexOfReturn + 1, start).replace(/^( *).*/, '$1').length;
                    target.value = "".concat(target.value.substring(0, start), "\n").concat(' '.repeat(spaceCount)).concat(target.value.substring(end));
                    target.selectionStart = target.selectionEnd = start + 1 + spaceCount;
                    onChange();
                    break;
                }
                case 'Delete':
                    if (onTabStop && start === end && target.value.substring(start, start + 2) === '  ') {
                        evt.preventDefault();
                        target.value = target.value.substring(0, start) + target.value.substring(end + 2);
                        target.selectionStart = target.selectionEnd = start;
                        onChange();
                    }
                    break;
            }
        }
    }
    window.addEventListener('popstate', function () {
        var id = location.hash.substring(1) || 'index';
        showPage(id, 'instant', 'none');
    });
    function truncateCode(code) {
        var oneLiner = getLits().tokenize(code, { minify: true }).tokens.map(function (t) { return t[0] === 'Whitespace' ? ' ' : t[1]; }).join('').trim();
        var count = 100;
        if (oneLiner.length <= count)
            return oneLiner;
        else
            return "".concat(oneLiner.substring(0, count - 3), "...");
    }
    function run() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Run selection' : 'Run';
        appendOutput("".concat(title, ": ").concat(truncateCode(code)), 'comment');
        var litsParams = getLitsParamsFromContext();
        var hijacker = hijackConsole();
        try {
            var result = getLits().run(code, litsParams);
            var content = stringifyValue(result, false);
            appendOutput(content, 'result');
        }
        catch (error) {
            appendOutput(error, 'error');
        }
        finally {
            hijacker.releaseConsole();
            focusLitsCode();
        }
    }
    function analyze() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Analyze selection' : 'Analyze';
        appendOutput("".concat(title, ": ").concat(truncateCode(code)), 'comment');
        var litsParams = getLitsParamsFromContext();
        var hijacker = hijackConsole();
        try {
            var result = getLits('debug').getUndefinedSymbols(code, litsParams);
            var unresolvedSymbols = __spreadArray([], __read(result), false).join(', ');
            var unresolvedSymbolsOutput = "Unresolved symbols: ".concat(unresolvedSymbols || '-');
            appendOutput("".concat(unresolvedSymbolsOutput), 'analyze');
        }
        catch (error) {
            appendOutput(error, 'error');
        }
        finally {
            hijacker.releaseConsole();
            focusLitsCode();
        }
    }
    function parse() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Parse selection' : 'Parse';
        appendOutput("".concat(title).concat(getState('debug') ? ' (debug):' : ':', " ").concat(truncateCode(code)), 'comment');
        var hijacker = hijackConsole();
        try {
            var tokens = getLits().tokenize(code);
            var result = getLits().parse(tokens);
            var content = JSON.stringify(result, null, 2);
            appendOutput(content, 'parse');
            hijacker.releaseConsole();
            console.log(result);
        }
        catch (error) {
            appendOutput(error, 'error');
            hijacker.releaseConsole();
        }
        finally {
            focusLitsCode();
        }
    }
    function tokenize() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Tokenize selection' : 'Tokenize';
        appendOutput("".concat(title).concat(getState('debug') ? ' (debug):' : ':', " ").concat(truncateCode(code)), 'comment');
        var hijacker = hijackConsole();
        try {
            var result = getLits().tokenize(code);
            var content = JSON.stringify(result, null, 2);
            appendOutput(content, 'tokenize');
            hijacker.releaseConsole();
            console.log(result);
        }
        catch (error) {
            appendOutput(error, 'error');
            hijacker.releaseConsole();
            return;
        }
        finally {
            focusLitsCode();
        }
    }
    function format() {
        addOutputSeparator();
        var selectedCode = getSelectedLitsCode();
        var code = selectedCode.code || getState('lits-code');
        var title = selectedCode.code ? 'Format selection' : 'Format';
        appendOutput("".concat(title, ": ").concat(truncateCode(code)), 'comment');
        setLitsCode(code, true);
        if (selectedCode.code) {
            saveState({
                'focused-panel': 'lits-code',
                'lits-code-selection-start': selectedCode.selectionStart,
                'lits-code-selection-end': selectedCode.selectionStart + code.length,
            });
        }
        else {
            saveState({
                'focused-panel': 'lits-code',
                'lits-code-selection-start': selectedCode.selectionStart,
                'lits-code-selection-end': selectedCode.selectionEnd,
            });
        }
        applyState();
    }
    function toggleDebug() {
        var debug = !getState('debug');
        saveState({ debug: debug });
        updateCSS();
        addOutputSeparator();
        appendOutput("Debug mode toggled ".concat(debug ? 'ON' : 'OFF'), 'comment');
        focusLitsCode();
    }
    function focusContext() {
        elements.contextTextArea.focus();
    }
    function focusLitsCode() {
        elements.litsTextArea.focus();
    }
    function getLitsParamsFromContext() {
        var _a, _b;
        var contextString = getState('context');
        try {
            var parsedContext = contextString.trim().length > 0
                ? JSON.parse(contextString)
                : {};
            var parsedJsFunctions = asUnknownRecord((_a = parsedContext.jsFunctions) !== null && _a !== void 0 ? _a : {});
            var values = asUnknownRecord((_b = parsedContext.values) !== null && _b !== void 0 ? _b : {});
            var jsFunctions = Object.entries(parsedJsFunctions).reduce(function (acc, _a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                if (typeof value !== 'string') {
                    console.log(key, value);
                    throw new TypeError("Invalid jsFunction value. \"".concat(key, "\" should be a javascript function string"));
                }
                // eslint-disable-next-line no-eval
                var fn = eval(value);
                if (typeof fn !== 'function') {
                    throw new TypeError("Invalid jsFunction value. \"".concat(key, "\" should be a javascript function"));
                }
                acc[key] = {
                    fn: fn,
                };
                return acc;
            }, {});
            return {
                values: values,
                jsFunctions: jsFunctions,
            };
        }
        catch (err) {
            appendOutput("Error: ".concat(err.message, "\nCould not parse context:\n").concat(contextString), 'error');
            return {};
        }
    }
    function getSelectedLitsCode() {
        var selectionStart = getState('lits-code-selection-start');
        var selectionEnd = getState('lits-code-selection-end');
        return {
            leadingCode: elements.litsTextArea.value.substring(0, selectionStart),
            trailingCode: elements.litsTextArea.value.substring(selectionEnd),
            code: elements.litsTextArea.value.substring(selectionStart, selectionEnd),
            selectionStart: selectionStart,
            selectionEnd: selectionEnd,
        };
    }
    function applyState(scrollToTop) {
        if (scrollToTop === void 0) { scrollToTop = false; }
        var contextTextAreaSelectionStart = getState('context-selection-start');
        var contextTextAreaSelectionEnd = getState('context-selection-end');
        var litsTextAreaSelectionStart = getState('lits-code-selection-start');
        var litsTextAreaSelectionEnd = getState('lits-code-selection-end');
        setOutput(getState('output'), false);
        getDataFromUrl();
        setContext(getState('context'), false);
        elements.contextTextArea.selectionStart = contextTextAreaSelectionStart;
        elements.contextTextArea.selectionEnd = contextTextAreaSelectionEnd;
        setLitsCode(getState('lits-code'), false, scrollToTop ? 'top' : undefined);
        elements.litsTextArea.selectionStart = litsTextAreaSelectionStart;
        elements.litsTextArea.selectionEnd = litsTextAreaSelectionEnd;
        updateCSS();
        layout();
        setTimeout(function () {
            if (getState('focused-panel') === 'context')
                focusContext();
            else if (getState('focused-panel') === 'lits-code')
                focusLitsCode();
            elements.contextTextArea.scrollTop = getState('context-scroll-top');
            elements.litsTextArea.scrollTop = getState('lits-code-scroll-top');
            elements.outputResult.scrollTop = getState('output-scroll-top');
        }, 0);
    }
    function updateCSS() {
        var debug = getState('debug');
        elements.toggleDebugMenuLabel.textContent = debug ? 'Debug: ON' : 'Debug: OFF';
        elements.litsPanelDebugInfo.style.display = debug ? 'flex' : 'none';
        elements.litsCodeTitle.style.color = (getState('focused-panel') === 'lits-code') ? 'white' : '';
        elements.litsCodeTitleString.textContent = 'Lits Code';
        elements.contextTitle.style.color = (getState('focused-panel') === 'context') ? 'white' : '';
    }
    function showPage(id, scroll, historyEvent) {
        if (historyEvent === void 0) { historyEvent = 'push'; }
        setTimeout(function () {
            inactivateAll();
            Search.closeSearch();
            var page = document.getElementById(id);
            var linkElementId = "".concat((!id || id === 'index') ? 'home-page' : id, "_link");
            var link = document.getElementById(linkElementId);
            if (!id || id === 'index' || id === 'example-page')
                elements.mainPanel.scrollTo({ top: 0 });
            if (!page) {
                showPage('index', scroll, 'replace');
                return;
            }
            page.classList.add('active-content');
            if (link) {
                link.classList.add('active-sidebar-entry');
                if (scroll !== 'none')
                    link.scrollIntoView({ block: 'center', behavior: scroll });
            }
            if (id === 'index')
                history.replaceState(null, 'Lits', window.location.pathname + window.location.search);
            else if (historyEvent === 'replace')
                history.replaceState(null, '', "#".concat(id));
            else if (historyEvent !== 'none')
                history.pushState(null, '', "#".concat(id));
        }, 0);
    }
    function inactivateAll() {
        var els = document.getElementsByClassName('active-content');
        while (els[0])
            els[0].classList.remove('active-content');
        els = document.getElementsByClassName('active-sidebar-entry');
        while (els[0])
            els[0].classList.remove('active-sidebar-entry');
    }
    function addToPlayground(name, encodedExample) {
        var example = decodeURIComponent(atob(encodedExample));
        appendLitsCode("// Example - ".concat(name, "\n\n").concat(example, ";\n"));
        saveState({ 'focused-panel': 'lits-code' });
        applyState();
    }
    function setPlayground(name, encodedExample) {
        var example = JSON.parse(decodeURIComponent(atob(encodedExample)));
        var context = example.context
            // eslint-disable-next-line ts/no-unsafe-return
            ? JSON.stringify(example.context, function (_k, v) { return (v === undefined ? null : v); }, 2)
            : '';
        setContext(context, true, 'top');
        var code = example.code ? example.code : '';
        var size = Math.max(name.length + 10, 40);
        var paddingLeft = Math.floor((size - name.length) / 2);
        var paddingRight = Math.ceil((size - name.length) / 2);
        setLitsCode("\n".concat("/*".concat('*'.repeat(size), "**"), "\n").concat(" *".concat(' '.repeat(paddingLeft)).concat(name).concat(' '.repeat(paddingRight), " *"), "\n").concat(" *".concat('*'.repeat(size), "**/"), "\n\n").concat(code, "\n").trimStart(), true, 'top');
        saveState({ 'focused-panel': 'lits-code' });
        applyState();
    }
    function hijackConsole() {
        var oldLog = console.log;
        console.log = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var logRow = args.map(function (arg) { return stringifyValue(arg); }).join(' ');
            appendOutput(logRow, 'output');
        };
        var oldWarn = console.warn;
        console.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            oldWarn.apply(console, args);
            appendOutput(args[0], 'warn');
        };
        var oldError = console.error;
        console.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            oldError.apply(console, args);
            appendOutput(args[0], 'error');
        };
        return {
            releaseConsole: function () {
                console.log = oldLog;
                console.warn = oldWarn;
            },
        };
    }

    exports.Search = Search;
    exports.addContextEntry = addContextEntry;
    exports.addSampleContext = addSampleContext;
    exports.addToPlayground = addToPlayground;
    exports.analyze = analyze;
    exports.closeAddContextMenu = closeAddContextMenu;
    exports.closeMoreMenu = closeMoreMenu;
    exports.focusContext = focusContext;
    exports.focusLitsCode = focusLitsCode;
    exports.format = format;
    exports.openAddContextMenu = openAddContextMenu;
    exports.openMoreMenu = openMoreMenu;
    exports.parse = parse;
    exports.redoContextHistory = redoContextHistory;
    exports.redoLitsCodeHistory = redoLitsCodeHistory;
    exports.resetContext = resetContext;
    exports.resetLitsCode = resetLitsCode;
    exports.resetOutput = resetOutput;
    exports.resetPlayground = resetPlayground;
    exports.run = run;
    exports.setPlayground = setPlayground;
    exports.share = share;
    exports.showPage = showPage;
    exports.toggleDebug = toggleDebug;
    exports.tokenize = tokenize;
    exports.undoContextHistory = undoContextHistory;
    exports.undoLitsCodeHistory = undoLitsCodeHistory;

    return exports;

})({});
