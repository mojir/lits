var Playground=function(exports){"use strict";class StateHistory{history=[];index;listener;lastStatus={canUndo:!1,canRedo:!1};constructor(e,t){this.history.push(e),this.index=0,this.listener=t}get canUndo(){return this.index>0}get canRedo(){return this.index<this.history.length-1}get current(){return this.history[this.index]}push(e){e.text!==this.current.text?(this.history.splice(this.index+1),this.history.push(e),this.index=this.history.length-1,this.notify()):this.replace(e)}replace(e){this.current.text=e.text,this.current.selectionStart=e.selectionStart,this.current.selectionEnd=e.selectionEnd,this.notify()}undo(){if(!this.canUndo)throw new Error("Cannot undo");return this.index-=1,this.notify(),this.history[this.index]}redo(){if(!this.canRedo)throw new Error("Cannot redo");return this.index+=1,this.notify(),this.current}peek(){return this.current}reset(e){this.history=[e],this.index=0,this.notify()}notify(){const e={canUndo:this.canUndo,canRedo:this.canRedo};e.canUndo===this.lastStatus.canUndo&&e.canRedo===this.lastStatus.canRedo||(this.lastStatus=e,setTimeout(()=>this.listener(e),0))}}const defaultState={"playground-height":350,"resize-divider-1-percent":20,"resize-divider-2-percent":60,context:"","context-scroll-top":0,"context-selection-start":0,"context-selection-end":0,"lits-code":"","lits-code-scroll-top":0,"lits-code-selection-start":0,"lits-code-selection-end":0,output:"","output-scroll-top":0,"new-context-name":"","new-context-value":"",debug:!1,"focused-panel":null};let contextHistoryListener,litsCodeHistoryListener;const state={...defaultState};Object.keys(defaultState).forEach(e=>{const t=localStorage.getItem(getStorageKey(e));state[e]="string"==typeof t?JSON.parse(t):defaultState[e]});const contextHistory=new StateHistory(createContextHistoryEntry(),e=>{contextHistoryListener?.(e)}),litsCodeHistory=new StateHistory(createLitsCodeHistoryEntry(),e=>{litsCodeHistoryListener?.(e)});function createContextHistoryEntry(){return{text:state.context,selectionStart:state["context-selection-start"],selectionEnd:state["context-selection-end"]}}function createLitsCodeHistoryEntry(){return{text:state["lits-code"],selectionStart:state["lits-code-selection-start"],selectionEnd:state["lits-code-selection-end"]}}function pushHistory(){contextHistory.push(createContextHistoryEntry()),litsCodeHistory.push(createLitsCodeHistoryEntry())}function setContextHistoryListener(e){contextHistoryListener=e}function setLitsCodeHistoryListener(e){litsCodeHistoryListener=e}function saveState(e,t=!0){Object.entries(e).forEach(e=>{const t=e[0],r=e[1];setState(t,r),localStorage.setItem(getStorageKey(t),JSON.stringify(r))}),t&&pushHistory()}function setState(e,t){state[e]=t}function clearAllStates(){localStorage.clear(),Object.assign(state,defaultState),litsCodeHistory.reset(createLitsCodeHistoryEntry()),contextHistory.reset(createContextHistoryEntry())}function clearState(...e){e.forEach(e=>{localStorage.removeItem(getStorageKey(e)),state[e]=defaultState[e]}),pushHistory()}function getState(e){return state[e]}function encodeState(){const e={"lits-code":state["lits-code"],context:state.context};return btoa(encodeURIComponent(JSON.stringify(e)))}function applyEncodedState(e){try{return saveState(JSON.parse(decodeURIComponent(atob(e))),!0),!0}catch(e){return!1}}function undoContext(){try{const e=contextHistory.undo();return saveState({context:e.text,"context-selection-start":e.selectionStart,"context-selection-end":e.selectionEnd},!1),!0}catch{return!1}}function redoContext(){try{const e=contextHistory.redo();return saveState({context:e.text,"context-selection-start":e.selectionStart,"context-selection-end":e.selectionEnd},!1),!0}catch{return!1}}function undoLitsCode(){try{const e=litsCodeHistory.undo();return saveState({"lits-code":e.text,"lits-code-selection-start":e.selectionStart,"lits-code-selection-end":e.selectionEnd},!1),!0}catch{return!1}}function redoLitsCode(){try{const e=litsCodeHistory.redo();return saveState({"lits-code":e.text,"lits-code-selection-start":e.selectionStart,"lits-code-selection-end":e.selectionEnd},!1),!0}catch{return!1}}function getStorageKey(e){return`playground-${e}`}function isNotNull(e){return null!=e}function assertNotNull(e){if(!isNotNull(e))throw new Error("Value is null or undefined")}function asNotNull(e){return assertNotNull(e),e}function throttle(e){let t=!0;return function(...r){t&&(requestAnimationFrame(()=>t=!0),t=!1,e.apply(this,r))}}function isMac(){return navigator.platform.includes("Mac")}let ctrlKeyTimer=0,ctrlKeyStarted=null,selectedIndex=null,onCloseCallback=null,previouslyFocusedPanel=getState("focused-panel");const searchInput=asNotNull(document.getElementById("search-input")),searchResult=asNotNull(document.getElementById("search-result")),noSearchResult=asNotNull(document.getElementById("no-search-result")),searchOverlay=asNotNull(document.getElementById("search-dialog-overlay")),searchDialog=asNotNull(document.getElementById("search-dialog"));function onClose(e){onCloseCallback=e}function handleKeyDown(e){if("Control"===e.key&&handleCtrlKey(),isOpen()){switch(e.key){case"Escape":e.preventDefault(),null!==selectedIndex&&selectedIndex>0?resetSelection():e.target?.closest("#search-input")&&searchInput.value?clearSearch():closeSearch();break;case"ArrowDown":e.preventDefault(),selectNext();break;case"ArrowUp":e.preventDefault(),selectPrevious();break;case"PageDown":e.preventDefault(),selectPageDown();break;case"PageUp":e.preventDefault(),selectPageUp();break;case"Home":e.preventDefault(),selectFirst();break;case"End":e.preventDefault(),selectLast();break;case"Enter":if(e.preventDefault(),"number"==typeof selectedIndex){const e=searchResult.children[selectedIndex];e?.click()}break;case"k":case"K":(e.ctrlKey||e.metaKey)&&(e.preventDefault(),openSearch());break;case"F3":e.preventDefault(),openSearch()}return"stop"}switch(e.key){case"k":case"K":(e.ctrlKey||e.metaKey)&&(e.preventDefault(),openSearch());break;case"F3":e.preventDefault(),openSearch()}}function handleCtrlKey(){null===ctrlKeyStarted?(ctrlKeyStarted=Date.now(),ctrlKeyTimer=window.setTimeout(resetCtrlKey,400)):(resetCtrlKey(),isOpen()?closeSearch():openSearch())}function resetCtrlKey(){window.clearTimeout(ctrlKeyTimer),ctrlKeyStarted=null,ctrlKeyTimer=0}function openSearch(){previouslyFocusedPanel=getState("focused-panel"),searchOverlay.style.display="block",0===searchResult.children.length&&updateSearchResult(searchInput.value),searchInput.focus()}function closeSearch(){"block"===searchOverlay.style.display&&(searchOverlay.style.display="none",saveState({"focused-panel":previouslyFocusedPanel}),onCloseCallback?.())}function isOpen(){return"block"===searchOverlay.style.display}function clearSearch(){searchInput.value="",updateSearchResult("")}function resetSelection(){selectedIndex=searchInput.value?0:null,updateSelection(),searchResult.scrollTo(0,0)}function updateSelection(){if(Array.from(searchResult.getElementsByClassName("selected")).forEach(e=>e.classList.remove("selected")),null!==selectedIndex){const e=searchResult.children.length;if(e){selectedIndex>=e?selectedIndex=e-1:selectedIndex<0&&(selectedIndex=0);const t=searchResult.children[selectedIndex];t.classList.add("selected"),t.scrollIntoView({block:"center"})}else selectedIndex=null}}function selectPrevious(){null!==selectedIndex&&(selectedIndex-=1),updateSelection()}function selectNext(){null!==selectedIndex?selectedIndex+=1:selectedIndex=0,updateSelection()}function selectPageUp(){null!==selectedIndex&&(selectedIndex-=10),updateSelection()}function selectPageDown(){null!==selectedIndex?selectedIndex+=10:selectedIndex=10,updateSelection()}function selectFirst(){selectedIndex=0,updateSelection()}function selectLast(){selectedIndex=searchResult.children.length-1,updateSelection()}function onSearch(e){const t=e.target;updateSearchResult(t?.value??"")}function updateSearchResult(e){searchResult.style.display="none",noSearchResult.style.display="none",searchResult.innerHTML="";const t=window.Playground.allSearchResultEntries.filter(t=>t.search.toLowerCase().includes(e.toLowerCase()));0===t.length?noSearchResult.style.display="flex":(searchResult.style.display="flex",searchResult.innerHTML=t.map(e=>e.html).join("")),resetSelection()}searchInput.addEventListener("input",onSearch),searchOverlay.addEventListener("click",closeSearch),searchDialog.addEventListener("click",e=>{searchInput.focus(),e.stopPropagation()});const Search={openSearch:openSearch,closeSearch:closeSearch,clearSearch:clearSearch,handleKeyDown:handleKeyDown,onClose:onClose};function getCodeMarker(e){if(!e.position||!e.code)return"";const t=e.position.column-1,r=e.code.length-t-1;return`${" ".repeat(Math.max(t,0))}^${" ".repeat(Math.max(r,0))}`}function getLitsErrorMessage(e,t){if(!t)return e;const r=`${t.position.line}:${t.position.column}`;return`${e}${t.filePath?`\n${t.filePath}:${r}`:`\nLocation ${r}`}${`\n${t.code}`}${`\n${getCodeMarker(t)}`}`}class RecurSignal extends Error{params;constructor(e){super(`recur, params: ${e}`),Object.setPrototypeOf(this,RecurSignal.prototype),this.name="RecurSignal",this.params=e}}class LitsError extends Error{sourceCodeInfo;shortMessage;constructor(e,t){const r=e instanceof Error?e.message:`${e}`;super(getLitsErrorMessage(r,t)),this.shortMessage=r,this.sourceCodeInfo=t,Object.setPrototypeOf(this,LitsError.prototype),this.name="LitsError"}getCodeMarker(){return this.sourceCodeInfo&&getCodeMarker(this.sourceCodeInfo)}}class UserDefinedError extends LitsError{userMessage;constructor(e,t){super(e,t),this.userMessage=e,Object.setPrototypeOf(this,UserDefinedError.prototype),this.name="UserDefinedError"}}class AssertionError extends LitsError{constructor(e,t){super(e,t),Object.setPrototypeOf(this,AssertionError.prototype),this.name="AssertionError"}}class UndefinedSymbolError extends LitsError{symbol;constructor(e,t){super(`Undefined symbol '${e}'.`,t),this.symbol=e,Object.setPrototypeOf(this,UndefinedSymbolError.prototype),this.name="UndefinedSymbolError"}}const NodeTypes={Number:1,String:2,NormalExpression:3,SpecialExpression:4,UserDefinedSymbol:5,NormalBuiltinSymbol:6,SpecialBuiltinSymbol:7,ReservedSymbol:8,Binding:9,Spread:10},NodeTypesSet=new Set(Object.values(NodeTypes));function getNodeTypeName(e){return Object.keys(NodeTypes).find(t=>NodeTypes[t]===e)}function isNodeType(e){return"number"==typeof e&&NodeTypesSet.has(e)}const functionTypes=["UserDefined","Partial","Comp","Constantly","Juxt","Complement","EveryPred","SomePred","Fnull","Builtin","SpecialBuiltin","NativeJsFunction","Module"],functionTypeSet=new Set(functionTypes);function isFunctionType(e){return"string"==typeof e&&functionTypeSet.has(e)}const FUNCTION_SYMBOL="^^fn^^",REGEXP_SYMBOL="^^re^^";function isLitsFunction$1(e){return null!==e&&"object"==typeof e&&(FUNCTION_SYMBOL in e&&"functionType"in e&&isFunctionType(e.functionType))}function isNode(e){return!(!Array.isArray(e)||e.length<2)&&isNodeType(e[0])}function valueToString(e){return isLitsFunction$1(e)?`<function ${e.name||"λ"}>`:isNode(e)?`${getNodeTypeName(e[0])}-node`:null===e?"null":"object"==typeof e&&e instanceof RegExp?`${e}`:"object"==typeof e&&e instanceof Error?e.toString():JSON.stringify(e)}function getSourceCodeInfo(e,t){return e?.sourceCodeInfo??t}function getAssertionError(e,t,r){return new LitsError(`Expected ${e}, got ${valueToString(t)}.`,getSourceCodeInfo(t,r))}function isNonUndefined(e){return void 0!==e}function asNonUndefined(e,t){return assertNonUndefined(e,t),e}function assertNonUndefined(e,t){if(!isNonUndefined(e))throw new LitsError("Unexpected undefined",getSourceCodeInfo(e,t))}function isUnknownRecord(e){return null!==e&&"object"==typeof e&&!Array.isArray(e)}function assertUnknownRecord(e,t){if(!isUnknownRecord(e))throw new LitsError(`Expected UnknownRecord, got ${valueToString(e)}.`,getSourceCodeInfo(e,t))}function asUnknownRecord(e,t){return assertUnknownRecord(e,t),e}function isLitsFunction(e){return null!==e&&"object"==typeof e&&!!e[FUNCTION_SYMBOL]}function isAny(e){return void 0!==e}function asAny(e,t){return assertAny(e,t),e}function assertAny(e,t){if(!isAny(e))throw getAssertionError("not undefined",e,t)}function isSeq(e){return Array.isArray(e)||"string"==typeof e}function asSeq(e,t){return assertSeq(e,t),e}function assertSeq(e,t){if(!isSeq(e))throw getAssertionError("string or array",e,t)}function isObj(e){return!(null===e||"object"!=typeof e||Array.isArray(e)||e instanceof RegExp||isLitsFunction(e)||isRegularExpression(e))}function assertObj(e,t){if(!isObj(e))throw getAssertionError("object",e,t)}function isColl(e){return isSeq(e)||isObj(e)}function asColl(e,t){return assertColl(e,t),e}function assertColl(e,t){if(!isColl(e))throw getAssertionError("string, array or object",e,t)}function isRegularExpression(e){return null!==e&&"object"==typeof e&&!!e[REGEXP_SYMBOL]}function assertRegularExpression(e,t){if(!isRegularExpression(e))throw getAssertionError("RegularExpression",e,t)}function isStringOrRegularExpression(e){return isRegularExpression(e)||"string"==typeof e}function assertStringOrRegularExpression(e,t){if(!isStringOrRegularExpression(e))throw getAssertionError("string or RegularExpression",e,t)}function isFunctionLike(e){return"number"==typeof e||(!!isColl(e)||!!isLitsFunction(e))}function asFunctionLike(e,t){return assertFunctionLike(e,t),e}function assertFunctionLike(e,t){if(!isFunctionLike(e))throw getAssertionError("FunctionLike",e,t)}function getRangeString(e){return!("number"!=typeof e.gt&&"number"!=typeof e.gte||"number"!=typeof e.lt&&"number"!=typeof e.lte)?`${"number"==typeof e.gt?`${e.gt} < n `:`${e.gte} <= n `}${"number"==typeof e.lt?`< ${e.lt}`:`<= ${e.lte}`}`:"number"==typeof e.gt||"number"==typeof e.gte?""+("number"==typeof e.gt?`n > ${e.gt}`:`n >= ${e.gte}`):"number"==typeof e.lt||"number"==typeof e.lte?""+("number"==typeof e.lt?`n < ${e.lt}`:`n <= ${e.lte}`):""}function getSignString(e){return e.positive?"positive":e.negative?"negative":e.nonNegative?"non negative":e.nonPositive?"non positive":e.nonZero?"non zero":""}function getNumberTypeName(e){if(e.zero)return"zero";const t=getSignString(e),r=e.integer?"integer":"number";return[t,e.finite?"finite":"",r,getRangeString(e)].filter(e=>!!e).join(" ")}function isNumber(e,t={}){return"number"==typeof e&&(!Number.isNaN(e)&&(!(t.integer&&!Number.isInteger(e))&&(!(t.finite&&!Number.isFinite(e))&&((!t.zero||0===e)&&((!t.nonZero||0!==e)&&(!(t.positive&&e<=0)&&(!(t.negative&&e>=0)&&(!(t.nonPositive&&e>0)&&(!(t.nonNegative&&e<0)&&(!("number"==typeof t.gt&&e<=t.gt)&&(!("number"==typeof t.gte&&e<t.gte)&&(!("number"==typeof t.lt&&e>=t.lt)&&!("number"==typeof t.lte&&e>t.lte)))))))))))))}function assertNumber(e,t,r={}){if(!isNumber(e,r))throw new LitsError(`Expected ${getNumberTypeName(r)}, got ${valueToString(e)}.`,getSourceCodeInfo(e,t))}function asNumber(e,t,r={}){return assertNumber(e,t,r),e}const annotatedArrays=new WeakSet,vectors=new WeakSet,notVectors=new WeakSet,matrices=new WeakSet,notMatrices=new WeakSet,grids=new WeakSet,notGrids=new WeakSet;function annotate(e){return Array.isArray(e)?(annotatedArrays.has(e)||(isVector(e),isMatrix(e)||isGrid(e)),e):e}function isVector(e){return!!Array.isArray(e)&&(!!vectors.has(e)||!notVectors.has(e)&&(e.every(e=>isNumber(e))?(annotatedArrays.add(e),vectors.add(e),!0):(notVectors.add(e),!1)))}function assertVector(e,t){if(!isVector(e))throw new LitsError(`Expected a vector, but got ${e}`,t)}function is2dVector(e){return!!isVector(e)&&2===e.length}function assert2dVector(e,t){if(!is2dVector(e))throw new LitsError(`Expected a 2d vector, but got ${e}`,t)}function is3dVector(e){return!!isVector(e)&&3===e.length}function assert3dVector(e,t){if(!is3dVector(e))throw new LitsError(`Expected a 3d vector, but got ${e}`,t)}function assertNonEmptyVector(e,t){if(assertVector(e,t),0===e.length)throw new LitsError(`Expected a non empty vector, but got ${e}`,t)}function isGrid(e){if(!Array.isArray(e))return!1;if(grids.has(e))return!0;if(notGrids.has(e))return!1;if(0===e.length)return notGrids.add(e),!1;if(!Array.isArray(e[0]))return notGrids.add(e),!1;const t=e[0].length;for(const r of e.slice(1)){if(!Array.isArray(r))return notGrids.add(e),!1;if(r.length!==t)return notGrids.add(e),!1}return annotatedArrays.add(e),grids.add(e),!0}function assertGrid(e,t){if(!isGrid(e))throw new LitsError(`Expected a grid, but got ${e}`,t)}function isMatrix(e){if(!Array.isArray(e))return!1;if(matrices.has(e))return!0;if(notMatrices.has(e))return!1;if(0===e.length)return notMatrices.add(e),!1;if(!Array.isArray(e[0])||0===e[0].length)return notMatrices.add(e),!1;const t=e[0].length;for(const r of e)if(!Array.isArray(r)||r.length!==t||r.some(e=>!isNumber(e)))return notMatrices.add(e),!1;return annotatedArrays.add(e),grids.add(e),matrices.add(e),!0}function assertMatrix(e,t){if(!isMatrix(e))throw new LitsError(`Expected a matrix, but got ${e}`,t)}function assertSquareMatrix(e,t){if(!isMatrix(e))throw new LitsError(`Expected a matrix, but got ${e}`,t);if(e.length!==e[0].length)throw new LitsError(`Expected square matrix, but got ${e.length} and ${e[0].length}`,t)}function isSquareMatrix(e){return!!isMatrix(e)&&e.length===e[0].length}function stringifyValue(e,t){return isLitsFunction(e)?"Builtin"===e.functionType?`<builtin function ${e.normalBuiltinSymbolType}>`:`<function ${e.n??"λ"}>`:null===e?"null":"object"==typeof e&&e instanceof Error?e.toString():"object"==typeof e&&e instanceof RegExp||"number"==typeof e?`${e}`:isRegularExpression(e)?`/${e.s}/${e.f}`:"string"==typeof e?`"${e}"`:Array.isArray(e)&&isMatrix(e)?stringifyMatrix(e):Array.isArray(e)&&isVector(e)?0===e.length?"[]":e.length>8?`[\n  ${e.map(e=>e).join(",\n  ")}\n]`:`[${e.map(e=>e).join(", ")}]`:JSON.stringify(replaceInfinities(e),null,2)}function replaceInfinities(e){if(e===Number.POSITIVE_INFINITY)return"∞";if(e===Number.NEGATIVE_INFINITY)return"-∞";if(Array.isArray(e))return e.map(replaceInfinities);if("object"==typeof e&&null!==e){const t={};for(const[r,n]of Object.entries(e))t[r]=replaceInfinities(n);return t}return e}function stringifyMatrix(e){const t=e.flat().reduce((e,t)=>Math.max(e,`${t}`.length),0)+1;return e.map(e=>`[${e.map(e=>`${e}`.padStart(t)).join(" ")} ]`).join("\n")}const specialExpressionTypes={"??":0,"&&":1,"||":2,array:3,cond:4,"0_def":5,"defined?":6,block:7,doseq:8,"0_lambda":9,for:10,if:11,let:12,loop:13,object:14,recur:15,switch:16,throw:17,try:18,unless:19};function isSymbolNode(e){const t=e[0];return NodeTypes.UserDefinedSymbol===t||NodeTypes.NormalBuiltinSymbol===t||NodeTypes.SpecialBuiltinSymbol===t}function assertSymbolNode(e,t){if(!isSymbolNode(e))throw getAssertionError("SymbolNode",e,t)}function isUserDefinedSymbolNode(e){return NodeTypes.UserDefinedSymbol===e[0]}function asUserDefinedSymbolNode(e,t){return assertUserDefinedSymbolNode(e,t),e}function assertUserDefinedSymbolNode(e,t){if(!isUserDefinedSymbolNode(e))throw getAssertionError("UserDefinedSymbolNode",e,t)}function isNormalBuiltinSymbolNode(e){return NodeTypes.NormalBuiltinSymbol===e[0]}function isSpecialBuiltinSymbolNode(e){return NodeTypes.SpecialBuiltinSymbol===e[0]}function isNormalExpressionNode(e){return e[0]===NodeTypes.NormalExpression}function isNormalExpressionNodeWithName(e){return!!isNormalExpressionNode(e)&&isSymbolNode(e[1][0])}function isSpreadNode(e){return e[0]===NodeTypes.Spread}const getUndefinedSymbols=(e,t,r,n)=>{const o=Array.isArray(e)?e:[[NodeTypes.SpecialExpression,[specialExpressionTypes.block,e.body]]],a=new Set;for(const e of o)findUnresolvedSymbolsInNode(e,t,r,n)?.forEach(e=>a.add(e));return a};function findUnresolvedSymbolsInNode(e,t,r,n){const o=e[0];switch(o){case NodeTypes.UserDefinedSymbol:{const r=e;return null===t.lookUp(r)?new Set([r[1]]):null}case NodeTypes.NormalBuiltinSymbol:case NodeTypes.SpecialBuiltinSymbol:case NodeTypes.String:case NodeTypes.Number:case NodeTypes.ReservedSymbol:case NodeTypes.Binding:return null;case NodeTypes.NormalExpression:{const o=e,a=new Set;if(isNormalExpressionNodeWithName(o)){const[,[e]]=o;if(isUserDefinedSymbolNode(e)){null===t.lookUp(e)&&a.add(e[1])}}else{const[,[e]]=o;findUnresolvedSymbolsInNode(e,t,r,n)?.forEach(e=>a.add(e))}for(const e of o[1][1])findUnresolvedSymbolsInNode(e,t,r,n)?.forEach(e=>a.add(e));return a}case NodeTypes.SpecialExpression:{const o=e,a=o[1][0];return(0,r.specialExpressions[a].getUndefinedSymbols)(o,t,{getUndefinedSymbols:getUndefinedSymbols,builtin:r,evaluateNode:n})}case NodeTypes.Spread:return findUnresolvedSymbolsInNode(e[1],t,r,n);default:throw new LitsError(`Unhandled node type: ${o}`,e[2])}}function arityAcceptsMin(e,t){const{min:r}=e;return!("number"==typeof r&&t<r)}function getCommonArityFromFunctions(e){return e.reduce((e,t)=>{if(null===e)return null;const r="number"==typeof t||isColl(t)?toFixedArity(1):t.arity,{min:n,max:o}=r,{min:a,max:i}=e,s="number"==typeof n&&"number"==typeof a?Math.max(n,a):"number"==typeof n?n:"number"==typeof a?a:void 0,c="number"==typeof o&&"number"==typeof i?Math.min(o,i):"number"==typeof o?o:"number"==typeof i?i:void 0;return"number"==typeof s&&"number"==typeof c&&s>c?null:{min:s,max:c}},{})}function getArityFromFunction(e){return"number"==typeof e||isColl(e)?toFixedArity(1):e.arity}function assertNumberOfParams(e,t,r){const{min:n,max:o}=e;if("number"==typeof n&&t<n)throw new LitsError(`Wrong number of arguments, expected at least ${n}, got ${valueToString(t)}.`,r);if("number"==typeof o&&t>o)throw new LitsError(`Wrong number of arguments, expected at most ${o}, got ${valueToString(t)}.`,r)}function canBeOperator(e){return!("number"==typeof e.max&&e.max<2)&&!("number"==typeof e.min&&e.min>2)}function toFixedArity(e){return{min:e,max:e}}function getOperatorArgs$1(e,t){return{a:{type:e},b:{type:t}}}const bitwiseNormalExpression={"<<":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0,nonNegative:!0}),e<<t),arity:toFixedArity(2),docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs$1("integer","integer")},variants:[{argumentNames:["a","b"]}],description:"Shifts $a arithmetically left by $b bit positions.",seeAlso:[">>",">>>"],examples:["1 << 10","<<(1, 10)","<<(-4, 2)"]}},">>":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0,nonNegative:!0}),e>>t),arity:toFixedArity(2),docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs$1("integer","integer")},variants:[{argumentNames:["a","b"]}],description:"Shifts $a arithmetically right by $b bit positions.",seeAlso:["<<",">>>"],examples:["2048 >> 10",">>(2048, 10)",">>>(-16, 2)",">>(4, 10)"]}},">>>":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0,nonNegative:!0}),e>>>t),arity:toFixedArity(2),docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs$1("integer","integer")},variants:[{argumentNames:["a","b"]}],description:"Shifts $a arithmetically right by $b bit positions without sign extension.",seeAlso:["<<",">>"],examples:["-16 >>> 2",">>>(2048, 10)",">>>(-16, 2)",">>>(4, 10)",">>>(-1, 10)"]}},"&":{evaluate:([e,...t],r)=>(assertNumber(e,r,{integer:!0}),t.reduce((e,t)=>(assertNumber(t,r,{integer:!0}),e&t),e)),arity:{min:2},docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs$1("integer","integer"),c:{type:"integer",rest:!0}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","c"]}],description:"Returns bitwise `and` of all arguments.",seeAlso:["|","xor","bitwise.bit-not","bitwise.bit-and-not"],examples:["0b0011 & 0b0110","&(0b0011, 0b0110)","&(0b0011, 0b0110, 0b1001)"]}},"|":{evaluate:([e,...t],r)=>(assertNumber(e,r,{integer:!0}),t.reduce((e,t)=>(assertNumber(t,r,{integer:!0}),e|t),e)),arity:{min:2},docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs$1("integer","integer"),c:{type:"integer",rest:!0}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","c"]}],description:"Returns bitwise `or` of all arguments.",seeAlso:["&","xor","bitwise.bit-not","bitwise.bit-and-not"],examples:["0b0011 | 0b0110","|(0b0011, 0b0110)","|(0b1000, 0b0100, 0b0010)"]}},xor:{evaluate:([e,...t],r)=>(assertNumber(e,r,{integer:!0}),t.reduce((e,t)=>(assertNumber(t,r,{integer:!0}),e^t),e)),arity:{min:2},docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs$1("integer","integer"),c:{type:"integer",rest:!0}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","c"]}],description:"Returns bitwise `xor` of all arguments.",seeAlso:["&","|","bitwise.bit-not","bitwise.bit-and-not"],examples:["0b0011 xor 0b0110","xor(0b0011, 0b0110)","xor(0b11110000, 0b00111100, 0b10101010)"]}}};function isString(e,t={}){return"string"==typeof e&&((!t.nonEmpty||0!==e.length)&&(!t.char||1===e.length))}function assertString(e,t,r={}){if(!isString(e,r))throw getAssertionError(""+(r.nonEmpty?"non empty string":r.char?"character":"string"),e,t)}function asString(e,t,r={}){return assertString(e,t,r),e}function isStringOrNumber(e){return"string"==typeof e||"number"==typeof e}function asStringOrNumber(e,t){return assertStringOrNumber(e,t),e}function assertStringOrNumber(e,t){if(!isStringOrNumber(e))throw getAssertionError("string or number",e,t)}function collHasKey(e,t){return!!isColl(e)&&("string"==typeof e||Array.isArray(e)?!!isNumber(t,{integer:!0})&&(t>=0&&t<e.length):!!Object.getOwnPropertyDescriptor(e,t))}function compare(e,t,r){if(assertStringOrNumber(e,r),assertStringOrNumber(t,r),"string"==typeof e&&"string"==typeof t)return e<t?-1:e>t?1:0;if("number"==typeof e&&"number"==typeof t)return Math.sign(e-t);throw new LitsError(`Cannot compare values of different types: ${typeof e} and ${typeof t}`,r)}function deepEqual(e,t,r){if(e===t)return!0;if("number"==typeof e&&"number"==typeof t)return approxEqual(e,t);if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n+=1)if(!deepEqual(asAny(e[n],r),asAny(t[n],r),r))return!1;return!0}if(isRegularExpression(e)&&isRegularExpression(t))return e.s===t.s&&e.f===t.f;if(isUnknownRecord(e)&&isUnknownRecord(t)){const n=Object.keys(e),o=Object.keys(t);if(n.length!==o.length)return!1;for(let o=0;o<n.length;o+=1){const a=asString(n[o],r);if(!deepEqual(e[a],t[a],r))return!1}return!0}return!1}function toNonNegativeInteger(e){return Math.max(0,Math.ceil(e))}function toAny(e){return e??null}function clone(e){return isObj(e)?Object.entries(e).reduce((e,t)=>{const[r,n]=t;return e[r]=clone(n),e},{}):Array.isArray(e)?e.map(e=>clone(e)):e}function cloneColl(e){return clone(e)}function joinSets(...e){const t=new Set;for(const r of e)r.forEach(e=>t.add(e));return t}function addToSet(e,t){t.forEach(t=>e.add(t))}const EPSILON=1e-10;function approxEqual(e,t,r=EPSILON){if(e===t)return!0;const n=Math.abs(e-t);if(0===e||0===t||n<r)return n<r;return n/(Math.abs(e)+Math.abs(t))<r}function approxZero(e){return Math.abs(e)<EPSILON}function smartTrim(e,t=0){const r=e.split("\n");for(;r[0]?.match(/^\s*$/);)r.shift();for(;r[r.length-1]?.match(/^\s*$/);)r.pop();const n=r.reduce((e,t)=>{if(t.match(/^\s*$/))return e;const r=t.match(/^\s*/)[0].length;return Math.min(e,r)},1/0);return r.map(e=>" ".repeat(t)+e.slice(n)).join("\n").trimEnd()}function asArray(e,t){return assertArray(e,t),e}function assertArray(e,t){if(!Array.isArray(e))throw getAssertionError("array",e,t)}function isStringArray(e){return Array.isArray(e)&&e.every(e=>"string"==typeof e)}function assertStringArray(e,t){if(!isStringArray(e))throw getAssertionError("array of strings",e,t)}function isCharArray(e){return Array.isArray(e)&&e.every(e=>"string"==typeof e&&1===e.length)}function assertCharArray(e,t){if(!isCharArray(e))throw getAssertionError("array of strings",e,t)}function chain(e,t){return e instanceof Promise?e.then(t):t(e)}function mapSequential(e,t){const r=[];for(let n=0;n<e.length;n++){const o=t(e[n],n);if(o instanceof Promise)return chainRemainingMap(o,r,e,t,n);r.push(o)}return r}async function chainRemainingMap(e,t,r,n,o){t.push(await e);for(let e=o+1;e<r.length;e++)t.push(await n(r[e],e));return t}function reduceSequential(e,t,r){let n=r;for(let r=0;r<e.length;r++){const o=t(n,e[r],r);if(o instanceof Promise)return chainRemainingReduce(o,e,t,r);n=o}return n}async function chainRemainingReduce(e,t,r,n){let o=await e;for(let e=n+1;e<t.length;e++)o=await r(o,t[e],e);return o}function forEachSequential(e,t){for(let r=0;r<e.length;r++){const n=t(e[r],r);if(n instanceof Promise)return chainRemainingForEach(n,e,t,r)}}async function chainRemainingForEach(e,t,r,n){await e;for(let e=n+1;e<t.length;e++)await r(t[e],e)}function tryCatch(e,t){try{const r=e();return r instanceof Promise?r.catch(t):r}catch(e){return t(e)}}function someSequential(e,t){for(let r=0;r<e.length;r++){const n=t(e[r],r);if(n instanceof Promise)return chainRemainingSome(n,e,t,r);if(n)return!0}return!1}async function chainRemainingSome(e,t,r,n){if(await e)return!0;for(let e=n+1;e<t.length;e++)if(await r(t[e],e))return!0;return!1}function everySequential(e,t){for(let r=0;r<e.length;r++){const n=t(e[r],r);if(n instanceof Promise)return chainRemainingEvery(n,e,t,r);if(!n)return!1}return!0}async function chainRemainingEvery(e,t,r,n){if(!await e)return!1;for(let e=n+1;e<t.length;e++)if(!await r(t[e],e))return!1;return!0}function filterSequential(e,t){const r=[];for(let n=0;n<e.length;n++){const o=t(e[n],n);if(o instanceof Promise)return chainRemainingFilter(o,r,e,t,n);o&&r.push(e[n])}return r}async function chainRemainingFilter(e,t,r,n,o){await e&&t.push(r[o]);for(let e=o+1;e<r.length;e++)await n(r[e],e)&&t.push(r[e]);return t}function findIndexSequential(e,t){for(let r=0;r<e.length;r++){const n=t(e[r],r);if(n instanceof Promise)return chainRemainingFindIndex(n,e,t,r);if(n)return r}return-1}async function chainRemainingFindIndex(e,t,r,n){if(await e)return n;for(let e=n+1;e<t.length;e++)if(await r(t[e],e))return e;return-1}function mapObjects({colls:e,contextStack:t,executeFunction:r,fn:n,sourceCodeInfo:o}){assertObj(e[0],o);const a=Object.keys(e[0]),i={};e.forEach(e=>{assertObj(e,o);const t=Object.keys(e);if(t.length!==a.length)throw new LitsError(`All objects must have the same keys. Expected: ${a.join(", ")}. Found: ${t.join(", ")}`,o);if(!t.every(e=>a.includes(e)))throw new LitsError(`All objects must have the same keys. Expected: ${a.join(", ")}. Found: ${t.join(", ")}`,o);Object.entries(e).forEach(([e,t])=>{i[e]||(i[e]=[]),i[e].push(t)})});return reduceSequential(a,(e,a)=>chain(r(n,i[a],t,o),t=>(e[a]=t,e)),{})}function get$1(e,t){if(isObj(e)){if("string"==typeof t&&collHasKey(e,t))return toAny(e[t])}else if(isNumber(t,{nonNegative:!0,integer:!0})&&t>=0&&t<e.length)return toAny(e[t])}function assoc$1(e,t,r,n){if(assertColl(e,n),assertStringOrNumber(t,n),Array.isArray(e)||"string"==typeof e){if(assertNumber(t,n,{integer:!0}),assertNumber(t,n,{gte:0}),assertNumber(t,n,{lte:e.length}),"string"==typeof e)return assertString(r,n,{char:!0}),`${e.slice(0,t)}${r}${e.slice(t+1)}`;const o=[...e];return o[t]=r,o}assertString(t,n);const o={...e};return o[t]=r,o}const collectionNormalExpression={filter:{evaluate:([e,t],r,n,{executeFunction:o})=>{if(assertColl(e,r),assertFunctionLike(t,r),Array.isArray(e))return reduceSequential(e,(e,a)=>chain(o(t,[a],n,r),t=>(t&&e.push(a),e)),[]);if(isString(e)){return chain(reduceSequential(e.split(""),(e,a)=>chain(o(t,[a],n,r),t=>(t&&e.push(a),e)),[]),e=>e.join(""))}return reduceSequential(Object.entries(e),(e,[a,i])=>chain(o(t,[i],n,r),t=>(t&&(e[a]=i),e)),{})},arity:toFixedArity(2),docs:{category:"collection",returns:{type:"collection"},args:{a:{type:"collection"},b:{type:"function"},coll:{type:"collection"},fun:{type:"function"}},variants:[{argumentNames:["coll","fun"]}],description:"Creates a new collection with all elements that pass the test implemented by $fun.",seeAlso:["collection.filteri","map","sequence.remove"],examples:['\nfilter(\n  ["Albert", "Mojir", 160, [1, 2]],\n  string?\n)',"\nfilter(\n  [5, 10, 15, 20],\n  -> $ > 10\n)","\nfilter(\n  { a: 1, b: 2 },\n  odd?\n)"]}},map:{evaluate:(e,t,r,{executeFunction:n})=>{const o=asFunctionLike(e.at(-1),t);if(isObj(e[0]))return mapObjects({colls:e.slice(0,-1),fn:o,sourceCodeInfo:t,contextStack:r,executeFunction:n});const a=e.slice(0,-1);assertSeq(a[0],t);const i="string"==typeof a[0];let s=a[0].length;a.slice(1).forEach(e=>{i?assertString(e,t):assertArray(e,t),s=Math.min(s,e.length)});const c=[];for(let e=0;e<s;e++)c.push(a.map(t=>t[e]));const l=mapSequential(c,e=>n(o,e,r,t));return i?chain(l,e=>(e.forEach(e=>assertString(e,t)),e.join(""))):l},arity:{min:2},docs:{category:"collection",returns:{type:"collection"},args:{a:{type:"collection"},b:{type:"function"},colls:{type:"collection",rest:!0,description:"At least one."},fun:{type:"function"}},variants:[{argumentNames:["colls","fun"]}],description:"Creates a new collection populated with the results of calling $fun on every element in $colls.",seeAlso:["collection.mapi","filter","reduce","mapcat","grid.map","grid.mapi"],examples:["[1, 2, 3] map -","[1, 2, 3] map -> -($)",'map(["Albert", "Mojir", 42], str)',"map([1, 2, 3], inc)","map([1, 2, 3], [1, 10, 100], *)","map({ a: 1, b: 2 }, inc)","map({ a: 1, b: 2 }, { a: 10, b: 20 }, +)"]}},reduce:{evaluate:([e,t,r],n,o,{executeFunction:a})=>(assertColl(e,n),assertFunctionLike(t,n),assertAny(r,n),"string"==typeof e?(assertString(r,n),0===e.length?r:reduceSequential(e.split(""),(e,r)=>a(t,[e,r],o,n),r)):Array.isArray(e)?0===e.length?r:reduceSequential(e,(e,r)=>a(t,[e,r],o,n),r):0===Object.keys(e).length?r:reduceSequential(Object.entries(e),(e,[,r])=>a(t,[e,r],o,n),r)),arity:toFixedArity(3),docs:{category:"collection",returns:{type:"any"},args:{fun:{type:"function"},coll:{type:"collection"},initial:{type:"any"}},variants:[{argumentNames:["coll","fun","initial"]}],description:"Runs $fun function on each element of the $coll, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value.",seeAlso:["collection.reduce-right","collection.reducei","collection.reductions","map","grid.reduce","grid.reducei"],examples:["reduce([1, 2, 3], +, 0)","reduce([], +, 0)","reduce({ a: 1, b: 2 }, +, 0)","\nreduce(\n  [1, 2, 3, 4, 5, 6, 7, 8, 9],\n  (result, value) -> result + (even?(value) ? value : 0),\n  0)"]}},get:{evaluate:(e,t)=>{const[r,n]=e,o=toAny(e[2]);if(assertStringOrNumber(n,t),null===r)return o;assertColl(r,t);const a=get$1(r,n);return void 0===a?o:a},arity:{min:2,max:3},docs:{category:"collection",returns:{type:"any"},args:{a:{type:"collection"},b:{type:["string","integer"]},"not-found":{type:"any",description:"Default value to return if $b is not found."}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","not-found"]}],description:"Returns value in $a mapped at $b.",seeAlso:["collection.get-in","contains?","find","nth"],examples:["[1, 2, 3] get 1",'{ a: 1 } get "a"','"Albert" get "3"',"\nget(\n  [1, 2, 3],\n  1, // Optional comma after last argument\n)","\nget(\n  [],\n  1\n)",'\nget(\n  [],\n  1,\n  "default"\n)','\nget(\n  { a: 1 },\n  "a"\n)','\nget(\n  { a: 1 },\n  "b"\n)','\nget(\n  { a: 1 },\n  "b",\n  "default"\n)','\nget(\n  null,\n  "a"\n)','\nget(\n  null,\n  "b",\n  "default"\n)']}},count:{evaluate:([e],t)=>null===e?0:"string"==typeof e?e.length:(assertColl(e,t),Array.isArray(e)?e.length:Object.keys(e).length),arity:toFixedArity(1),docs:{category:"collection",returns:{type:"number"},args:{coll:{type:["collection","null"]}},variants:[{argumentNames:["coll"]}],description:"Returns number of elements in $coll.",seeAlso:["empty?"],examples:["count([1, 2, 3])","count([])","count({ a: 1 })",'count("")','count("Albert")',"count(null)"]}},"contains?":{evaluate:([e,t],r)=>null!==e&&(assertColl(e,r),isString(e)?(assertString(t,r),e.includes(t)):isSeq(e)?(assertAny(t,r),!!e.find(e=>deepEqual(asAny(e),t,r))):(assertString(t,r),t in e)),arity:toFixedArity(2),docs:{category:"collection",returns:{type:"boolean"},args:{a:{type:["collection","null"]},b:{type:["string","integer"]}},variants:[{argumentNames:["a","b"]}],description:"Returns `true` if $a contains $b, otherwise returns `false`. For strings, it checks if substring is included.",seeAlso:["get","find","index-of"],examples:["[1, 2, 3] contains? 1","null contains? 1",'{ a: 1, b: 2 } contains? "a"',"\ncontains?(\n  [],\n  1\n)","\ncontains?(\n  [1],\n  1\n)","\ncontains?(\n  [1, 2, 3],\n  1\n)",'\ncontains?(\n  {},\n  "a"\n)','\ncontains?(\n  { a: 1, b: 2 },\n  "a"\n)']}},assoc:{evaluate:([e,t,r],n)=>(assertColl(e,n),assertStringOrNumber(t,n),assertAny(r,n),assoc$1(e,t,r,n)),arity:toFixedArity(3),docs:{category:"collection",returns:{type:"collection"},args:{coll:{type:"collection"},key:{type:["string","number"]},value:{type:"any"},kvs:{type:"any",description:"Key-value pairs to associate.",rest:!0}},variants:[{argumentNames:["coll","key","value"]},{argumentNames:["coll","key","value","kvs"]}],description:"\nAdd or replace the value of element $key to $value in $coll. Repeated for all key-value pairs in $kvs.\nIf $coll is an 'array', $key must be `number` satisfying `0 <=` $key `<= length`.",seeAlso:["collection.assoc-in","dissoc","merge","collection.update"],examples:['\nassoc(\n  [1, 2, 3],\n  1,\n  "Two"\n)','\nassoc(\n  [1, 2, 3],\n  3,\n  "Four"\n)','\nassoc(\n  { a: 1, b: 2 },\n  "a",\n  "One")','\nassoc(\n  { a: 1, b: 2 },\n  "c",\n  "Three")','\nassoc(\n  "Albert",\n  6,\n  "a")']}},"++":{evaluate:(e,t)=>(isNumber(e[0])||assertColl(e[0],t),Array.isArray(e[0])?e.reduce((e,r)=>(assertArray(r,t),e.concat(r)),[]):isStringOrNumber(e[0])?e.reduce((e,r)=>(assertStringOrNumber(r,t),`${e}${r}`),""):e.reduce((e,r)=>(assertObj(r,t),Object.assign(e,r)),{})),arity:{min:1},docs:{category:"collection",returns:{type:"collection"},args:{a:{type:"collection"},b:{type:"collection"},colls:{type:"collection",rest:!0}},variants:[{argumentNames:["a"]},{argumentNames:["a","colls"]}],description:"Concatenates collections into one collection.",seeAlso:["mapcat","str","join","push","sequence.unshift"],examples:['"Albert" ++ " " ++ "Mojir"','"Albert" ++ "Mojir"','++("Albert", "-", "Mojir")','++("Albert")','++("A", "l", "b", "e", "r", "t")',"++([1, 2], [3, 4])","++([], [3, 4])","++([1, 2], [])","++([1, 2], [3, 4], [5, 6])","++([])","++({ a: 1, b: 2 }, { b: 1, c: 2 })","++({}, { a: 1 })"]}}},arrayNormalExpression={range:{evaluate:(e,t)=>{const[r,n,o]=e;let a,i,s;assertNumber(r,t,{finite:!0}),1===e.length?(a=0,i=r,s=i>=0?1:-1):2===e.length?(assertNumber(n,t,{finite:!0}),a=r,i=n,s=i>=a?1:-1):(assertNumber(n,t,{finite:!0}),assertNumber(o,t,{finite:!0}),a=r,i=n,s=o,assertNumber(s,t,i>a?{positive:!0}:i<a?{negative:!0}:{nonZero:!0}));const c=[];for(let e=a;s<0?e>i:e<i;e+=s)c.push(e);return c},arity:{min:1,max:3},docs:{category:"array",returns:{type:"number",array:!0},args:{a:{type:"number"},b:{type:"number"},step:{type:"number"}},variants:[{argumentNames:["b"]},{argumentNames:["a","b"]},{argumentNames:["a","b","step"]}],description:"$range creates an array with a range of numbers from $a to $b (exclusive), by $step.\n\n$a defaults to 0.\n$step defaults to 1.",seeAlso:["repeat","vector.linspace"],examples:["range(4)","range(1, 4)","1 range 10","range(0.4, 4.9)","\nrange(\n  0.25, // start value\n  1,    // end value (exclusive)\n  0.25, // step value\n)"]}},repeat:{evaluate:([e,t],r)=>{assertNumber(t,r,{integer:!0,nonNegative:!0});const n=[];for(let r=0;r<t;r+=1)n.push(e);return n},arity:toFixedArity(2),docs:{category:"array",returns:{type:"any",array:!0},args:{a:{type:"any"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],description:"Returns an array with $a repeated $b times.",seeAlso:["range","vector.ones","vector.zeros","vector.fill","vector.generate","string.string-repeat"],examples:["repeat(10, 3)","repeat(10, 0)",'"Albert" repeat 5']}},flatten:{evaluate:([e,t],r)=>{assertArray(e,r);const n=void 0===t||t===Number.POSITIVE_INFINITY?Number.POSITIVE_INFINITY:asNumber(t,r,{integer:!0,nonNegative:!0});return e.flat(n)},arity:{min:1,max:2},docs:{category:"array",returns:{type:"any",array:!0},args:{x:{type:["array","any"],description:"If $x is not an array, `[ ]` is returned."}},variants:[{argumentNames:["x"]}],description:"Takes a nested array $x and flattens it.",seeAlso:["mapcat"],examples:["flatten([1, 2, [3, 4], 5])",'\nlet foo = "bar";\nflatten([\n  1,\n  " 2 A ",\n  [foo, [4, ["ABC"]]],\n  6,\n])'],hideOperatorForm:!0}},mapcat:{evaluate:([e,t],r,n,{executeFunction:o})=>(assertArray(e,r),assertFunctionLike(t,r),chain(mapSequential(e,e=>o(t,[e],n,r)),e=>e.flat(1))),arity:toFixedArity(2),docs:{category:"array",returns:{type:"collection"},args:{a:{type:"collection"},b:{type:"function"},colls:{type:"collection",array:!0},fun:{type:"function"}},variants:[{argumentNames:["colls","fun"]}],description:"Returns the result of applying concat to the result of applying map to $fun and $colls.",seeAlso:["flatten","map","++"],examples:["[[3, 2, 1, 0], [6, 5, 4], [9, 8, 7]] mapcat reverse","mapcat([[3, 2, 1, 0], [6, 5, 4], [9, 8, 7]], reverse)","[[3, 2, 1, 0,], [6, 5, 4,], [9, 8, 7]] mapcat reverse","\nlet foo = (n) -> do\n  [n - 1, n, n + 1]\nend;\n[1, 2, 3] mapcat foo","\nmapcat(\n  [[1, 2], [2, 2], [2, 3]],\n  -> $ filter odd?\n)"]}},"moving-fn":{evaluate:([e,t,r],n,o,{executeFunction:a})=>{assertArray(e,n),assertNumber(t,n,{integer:!0,lte:e.length}),assertFunctionLike(r,n);const i=[];for(let r=0;r<=e.length-t;r++)i.push(e.slice(r,r+t));return mapSequential(i,e=>a(r,[e],o,n))},arity:toFixedArity(3),docs:{category:"array",returns:{type:"array"},args:{arr:{type:"array"},windowSize:{type:"number",description:"The size of the moving window."},fn:{type:"function"}},variants:[{argumentNames:["arr","windowSize","fn"]}],description:"Returns the result of applying $fn to each moving window of size $windowSize in $arr.",seeAlso:["running-fn","vector.moving-mean"],examples:["moving-fn([1, 2, 3], 2, sum)","moving-fn([1, 2, 3], 1, sum)","moving-fn([1, 2, 3], 3, sum)"]}},"running-fn":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertArray(e,r),assertFunctionLike(t,r);const a=[];for(let t=0;t<e.length;t+=1)a.push(e.slice(0,t+1));return mapSequential(a,e=>o(t,[e],n,r))},arity:toFixedArity(2),docs:{category:"array",returns:{type:"array"},args:{a:{type:"array"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],description:"Returns the result of applying $b to each element of $a.",seeAlso:["moving-fn","vector.running-mean"],examples:["running-fn([1, 2, 3], sum)","running-fn([1, 2, 3], max)","running-fn([1, 2, 3], min)"]}}},sequenceNormalExpression={nth:{evaluate:(e,t)=>{const[r,n]=e,o=toAny(e[2]);if(assertNumber(n,t,{integer:!0}),null===r)return o;if(assertSeq(r,t),n>=0&&n<r.length){return toAny(r[n])}return o},arity:{min:2,max:3},docs:{category:"sequence",returns:{type:"any"},args:{a:{type:"sequence"},b:{type:"integer"},seq:{type:["sequence","null"]},n:{type:"integer"},"not-found":{type:"any"}},variants:[{argumentNames:["seq","n"]},{argumentNames:["seq","n","not-found"]}],description:"Accesses element $n of $seq. Accessing out-of-bounds indices returns $not-found, if present, else `null`.",seeAlso:["first","second","last","get","slice"],examples:["[1, 2, 3] nth 1",'"A string" nth 3',"nth([1, 2, 3], 1)","nth([1, 2, 3], 3)","nth([1, 2, 3], -1)","nth([1, 2, 3], 3, 99)",'nth("A string", 1)','nth("A string", 3)','nth("A string", -3)','nth("A string", 30, "X")',"nth(null, 1)",'nth(null, 1, "Default value")']}},first:{evaluate:([e],t)=>{if(null===e)return null;assertSeq(e,t);return toAny(e[0])},arity:toFixedArity(1),docs:{category:"sequence",returns:{type:"any"},args:{seq:{type:["sequence","null"]}},variants:[{argumentNames:["seq"]}],description:"Returns the first element of $seq. If $seq is empty or `null`, `null` is returned.",seeAlso:["second","last","nth","rest","next"],examples:['first(["Albert", "Mojir", 160, [1, 2]])',"first([])","first(null)"]}},last:{evaluate:([e],t)=>{if(null===e)return null;assertSeq(e,t);return toAny(e.at(-1))},arity:toFixedArity(1),docs:{category:"sequence",returns:{type:"any"},args:{seq:{type:["sequence","null"]}},variants:[{argumentNames:["seq"]}],description:"Returns the last element of $seq. If $seq is empty, `null` is returned.",seeAlso:["first","second","nth","pop"],examples:['last(["Albert", "Mojir", 160, [1, 2]])',"last([1, 2])","last([1])","last([])","last(null)"]}},pop:{evaluate:([e],t)=>(assertSeq(e,t),"string"==typeof e?e.substring(0,e.length-1):e.slice(0,e.length-1)),arity:toFixedArity(1),docs:{category:"sequence",returns:{type:["sequence","null"],rest:!0},args:{seq:{type:"sequence"}},variants:[{argumentNames:["seq"]}],description:"Returns a copy of $seq with last element removed. If $seq is empty `null` is returned.",seeAlso:["push","sequence.shift","last"],examples:["pop([1, 2, 3])","pop([])"]}},"index-of":{evaluate:([e,t],r)=>{if(assertAny(t,r),null===e)return null;if(assertSeq(e,r),"string"==typeof e){assertString(t,r);const n=e.indexOf(t);return-1!==n?n:null}{const n=e.findIndex(e=>deepEqual(asAny(e,r),t),r);return-1!==n?n:null}},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:["number","null"]},args:{a:{type:"sequence"},b:{type:"any"},seq:{type:["sequence","null"]},x:{type:"any"}},variants:[{argumentNames:["seq","x"]}],description:"Returns the index of $x in $seq. If element is not present in $seq `null` is returned.",seeAlso:["sequence.last-index-of","sequence.position","contains?"],examples:["[[1], [2], [1], [2]] index-of [1]",'index-of(["Albert", "Mojir", 160, [1, 2]], "Mojir")',"index-of([5, 10, 15, 20], 15)","index-of([5, 10, 15, 20], 1)","index-of(null, 1)"]}},push:{evaluate:([e,...t],r)=>(assertSeq(e,r),"string"==typeof e?(assertCharArray(t,r),[e,...t].join("")):[...e,...t]),arity:{min:2},docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"any"},seq:{type:"sequence"},values:{type:"any",rest:!0,description:"At least one."}},variants:[{argumentNames:["seq","values"]}],description:"Returns copy of $seq with $values added to the end of it.",seeAlso:["sequence.unshift","pop","++"],examples:["[1, 2, 3] push 4",'"Albert" push "!"',"push([1, 2, 3], 4)","push([1, 2, 3], 4, 5, 6)","\nlet l = [1, 2, 3];\npush(l, 4);\nl"]}},rest:{evaluate:([e],t)=>(assertSeq(e,t),Array.isArray(e)?e.length<=1?[]:e.slice(1):e.substring(1)),arity:toFixedArity(1),docs:{category:"sequence",returns:{type:["sequence","null"]},args:{seq:{type:"sequence"}},variants:[{argumentNames:["seq"]}],description:"If $seq is an array, returns a new array with all but the first element from $seq.\nIf $seq has less than two elements, an empty array is returned.\nFor string $seq returns all but the first characters in $seq.",seeAlso:["next","first","sequence.shift"],examples:['rest(["Albert", "Mojir", 160, [1, 2]])','rest(["Albert"])',"rest([])",'rest("Albert")','rest("A",)','rest("")']}},next:{evaluate:([e],t)=>(assertSeq(e,t),Array.isArray(e)?e.length<=1?null:e.slice(1):e.length<=1?null:e.substring(1)),arity:toFixedArity(1),docs:{category:"sequence",returns:{type:["sequence","null"]},args:{seq:{type:"sequence"}},variants:[{argumentNames:["seq"]}],description:"If $seq is an array, returns a new array with all but the first element from $seq. If $seq has less than two elements, `null` is returned. For string $seq returns all but the first characters in $seq. If length of string $seq is less than two, `null` is returned.",seeAlso:["rest","first"],examples:['next(["Albert", "Mojir", 160, [1, 2]])','next(["Albert"])',"next([])",'next("Albert")','next("A",)','next("")']}},reverse:{evaluate:([e],t)=>null===e?null:(assertSeq(e,t),Array.isArray(e)?[...e].reverse():e.split("").reverse().join("")),arity:toFixedArity(1),docs:{category:"sequence",returns:{type:["sequence","null"]},args:{seq:{type:["sequence","null"]}},variants:[{argumentNames:["seq"]}],description:"If $seq is an array, creates a new array with the elements from $seq in reversed order. If $seq is a string, returns new reversed string.",seeAlso:["sort"],examples:['reverse(["Albert", "Mojir", 160, [1, 2]])',"reverse([])",'reverse("Albert")',"reverse(null)"]}},second:{evaluate:([e],t)=>null===e?null:(assertSeq(e,t),toAny(e[1])),arity:toFixedArity(1),docs:{category:"sequence",returns:{type:"any"},args:{seq:{type:["sequence","null"]}},variants:[{argumentNames:["seq"]}],description:"Returns the second element of $seq. If $seq has less than two elements or is `null`, `null` is returned.",seeAlso:["first","last","nth"],examples:['second(["Albert", "Mojir", 160, [1, 2]])',"second([1])","second([])","second(null)"]}},slice:{evaluate:(e,t)=>{const[r,n,o]=e;return assertSeq(r,t),assertNumber(n,t,{integer:!0}),2===e.length?(Array.isArray(r),r.slice(n)):(assertNumber(o,t,{integer:!0}),Array.isArray(r),r.slice(n,o))},arity:{min:2,max:3},docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"integer"},seq:{type:"sequence",rest:!0},start:{type:"integer",description:"Defaults to `0`."},stop:{type:"integer",description:"Defaults lenght of sequence + 1."}},variants:[{argumentNames:["seq"]},{argumentNames:["seq","start"]},{argumentNames:["seq","start","stop"]}],description:"Returns a copy of a portion of $seq from index $start (inclusive) to $stop (exclusive).",seeAlso:["take","drop","sequence.splice","nth"],examples:["[1, 2, 3, 4, 5] slice 2","slice([1, 2, 3, 4, 5], 2, 4)","slice([1, 2, 3, 4, 5], 2)"]}},some:{evaluate:([e,t],r,n,{executeFunction:o})=>{if(assertFunctionLike(t,r),null===e)return null;if(assertSeq(e,r),0===e.length)return null;return reduceSequential("string"==typeof e?e.split(""):e,(e,a)=>null!==e?e:chain(o(t,[a],n,r),e=>e?toAny(a):null),null)},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"any"},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:["sequence","null"]},fun:{type:"function"}},variants:[{argumentNames:["seq","fun"]}],description:"Returns the first element that passes the test implemented by $fun. I no element was found, `null` is returned.",seeAlso:["sequence.position","collection.any?","find"],examples:['\nsome(\n  ["Albert", "Mojir", 160, [1, 2]],\n  string?\n)',"\nsome(\n  [5, 10, 15, 20],\n  -> $ > 10\n)","\nsome(\n  [1, 2, 3, 4],\n  -> $ > 10\n)","\nsome(\n  [],\n  -> $ > 10\n)","\nsome(\n  null,\n  -> $ > 10\n)"]}},sort:{evaluate:(e,t,r,{executeFunction:n})=>{const[o]=e,a=1===e.length,i=a?null:e[1];if(assertSeq(o,t),"string"==typeof o){const e=o.split("");return a?e.sort((e,r)=>compare(e,r,t)):(assertFunctionLike(i,t),e.sort((e,o)=>{const a=n(i,[e,o],r,t);if(a instanceof Promise)throw new TypeError("Async functions cannot be used as sort comparators");return assertNumber(a,t,{finite:!0}),a})),e.join("")}const s=[...o];return a?s.sort((e,r)=>(assertStringOrNumber(e,t),assertStringOrNumber(r,t),compare(e,r,t))):s.sort((e,o)=>{assertFunctionLike(i,t);const a=n(i,[e,o],r,t);if(a instanceof Promise)throw new TypeError("Async functions cannot be used as sort comparators");return assertNumber(a,t,{finite:!0}),a}),s},arity:{min:1,max:2},docs:{category:"sequence",returns:{type:"any",rest:!0},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:"sequence"},fun:{type:"function"}},variants:[{argumentNames:["seq"]},{argumentNames:["seq","fun"]}],description:"Returns a new sequence with the elements from $seq sorted according to $fun. If no $fun is supplied, builtin `compare` will be used.",seeAlso:["sequence.sort-by","compare","reverse","vector.sort-indices"],examples:["[3, 1, 2] sort (a, b) -> b - a","sort([3, 1, 2])","\nsort(\n  [3, 1, 2],\n  (a, b) -> cond case a < b then -1 case a > b then 1 case true then -1 end\n)","\nsort(\n  [3, 1, 2],\n  (a, b) -> cond case a > b then -1 case a < b then 1 case true then -1 end\n)"]}},take:{evaluate:([e,t],r)=>{assertNumber(t,r),assertSeq(e,r);const n=Math.max(Math.ceil(t),0);return e.slice(0,n)},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"integer"},n:{type:"integer"},seq:{type:"sequence"}},variants:[{argumentNames:["seq","n"]}],description:"Constructs a new array/string with the $n first elements from $seq.",seeAlso:["take-last","take-while","drop","slice","sequence.split-at"],examples:["take([1, 2, 3, 4, 5], 3)","[1, 2, 3, 4, 5] take 3","take([1, 2, 3, 4, 5], 0)",'take("Albert", 2)','take("Albert", 50)']}},"take-last":{evaluate:([e,t],r)=>{assertSeq(e,r),assertNumber(t,r);const n=Math.max(Math.ceil(t),0),o=e.length-n;return e.slice(o)},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"integer"},n:{type:"integer"},seq:{type:"sequence"}},variants:[{argumentNames:["seq","n"]}],description:"Constructs a new array with the $n last elements from $seq.",seeAlso:["take","drop-last"],examples:["take-last([1, 2, 3, 4, 5], 3)","[1, 2, 3, 4, 5] take-last 3","take-last([1, 2, 3, 4, 5], 0)"]}},drop:{evaluate:([e,t],r)=>{assertNumber(t,r);const n=Math.max(Math.ceil(t),0);return assertSeq(e,r),e.slice(n)},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"integer"},seq:{type:"sequence"},n:{type:"integer"}},variants:[{argumentNames:["seq","n"]}],description:"Constructs a new array/string with the $n first elements dropped from $seq.",seeAlso:["drop-last","drop-while","take","slice","sequence.split-at"],examples:["drop([1, 2, 3, 4, 5], 3)","[1, 2, 3, 4, 5] drop 0",'drop("Albert", 2)','drop("Albert", 50)']}},"drop-last":{evaluate:([e,t],r)=>{assertSeq(e,r),assertNumber(t,r);const n=Math.max(Math.ceil(t),0),o=e.length-n;return e.slice(0,o)},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"integer"},seq:{type:"sequence"},n:{type:"integer"}},variants:[{argumentNames:["seq","n"]}],description:"Constructs a new array with the $n last elements dropped from $seq.",seeAlso:["drop","take-last"],examples:["drop-last([1, 2, 3, 4, 5], 3)","[1, 2, 3, 4, 5] drop-last 3","drop-last([1, 2, 3, 4, 5], 0)"]}},"take-while":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertSeq(e,r),assertFunctionLike(t,r);const a="string"==typeof e?e.split(""):Array.from(e);return chain(findIndexSequential(a,e=>chain(o(t,[e],n,r),e=>!e)),t=>{const r=-1===t?a:a.slice(0,t);return"string"==typeof e?r.join(""):r})},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:"sequence"},fun:{type:"function"}},variants:[{argumentNames:["seq","fun"]}],description:"Returns the members of $seq in order, stopping before the first one for which `predicate` returns a falsy value.",seeAlso:["take","drop-while","sequence.split-with"],examples:["take-while(\n  [1, 2, 3, 2, 1],\n  -> $ < 3\n)","take-while(\n  [1, 2, 3, 2, 1],\n  -> $ > 3\n)"]}},"drop-while":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertSeq(e,r),assertFunctionLike(t,r);const a=Array.isArray(e)?e:e.split("");return chain(findIndexSequential(a,e=>chain(o(t,[e],n,r),e=>!e)),t=>-1===t?"string"==typeof e?"":[]:"string"==typeof e?a.slice(t).join(""):e.slice(t))},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:"sequence"},fun:{type:"function"}},variants:[{argumentNames:["seq","fun"]}],description:"Returns the members of $seq in order, skipping the fist elements for witch the `predicate` returns a truethy value.",seeAlso:["drop","take-while","sequence.split-with"],examples:["drop-while(\n  [1, 2, 3, 2, 1],\n  -> $ < 3\n)","drop-while(\n  [1, 2, 3, 2, 1],\n  -> $ > 3\n)"]}}};function getNumberVectorOrMatrixOperation$1(e,t){let r=!1,n=!1;for(const o of e)if(isVector(o))r=!0;else if(isMatrix(o))n=!0;else if(!isNumber(o))throw new LitsError("Invalid parameter type: "+typeof o,t);if(n){if(r)throw new LitsError("Cannot mix vector and matrix types",t);let n=null,o=null;for(const r of e)if(isMatrix(r))if(null===n)n=r.length,o=r[0].length;else if(r.length!==n||r[0].length!==o)throw new LitsError("Matrix dimensions do not match",t);return["matrix",e.map(e=>isMatrix(e)?e:Array.from({length:n},()=>Array.from({length:o},()=>e)))]}if(r){let r=null;for(const n of e)if(isVector(n))if(null===r)r=n.length;else if(n.length!==r)throw new LitsError("Vector lengths do not match",t);return["vector",e.map(e=>isVector(e)?e:Array.from({length:r},()=>e))]}return["number",e]}function unaryMathOp$1(e){return(t,r)=>{const[n,o]=getNumberVectorOrMatrixOperation$1(t,r);return"number"===n?e(o[0]):"vector"===n?o[0].map(t=>e(t)):o[0].map(t=>t.map(t=>e(t)))}}function binaryMathOp(e){return(t,r)=>{const[n,o]=getNumberVectorOrMatrixOperation$1(t,r);return"number"===n?e(o[0],o[1]):"vector"===n?o[0].map((t,r)=>e(t,o[1][r])):o[0].map((t,r)=>t.map((t,n)=>e(t,o[1][r][n])))}}function reduceMathOp(e,t){return(r,n)=>{if(0===r.length)return e;const[o,a]=getNumberVectorOrMatrixOperation$1(r,n);if("number"===o)return a.reduce((e,r)=>t(e,r),e);if("vector"===o){const[e,...r]=a;return r.reduce((e,r)=>e.map((e,n)=>t(e,r[n])),e)}{const[e,...r]=a;return r.reduce((e,r)=>e.map((e,n)=>e.map((e,o)=>t(e,r[n][o]))),e)}}}const mathNormalExpression={inc:{evaluate:unaryMathOp$1(e=>e+1),arity:toFixedArity(1),docs:{category:"math",returns:{type:"number"},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `inc` function increments its argument by 1, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it increases each element by 1 while preserving the original structure.",seeAlso:["dec","+"],examples:["inc(0)","inc(1)","inc(100.1)","inc([1, 2, 3])","inc([[1, 2], [3, 4]])"]}},dec:{evaluate:unaryMathOp$1(e=>e-1),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `dec` function decrements its argument by 1, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it decreases each element by 1 while preserving the original structure.",seeAlso:["inc","-"],examples:["dec(0)","dec(1)","dec(100.1)","dec([1, 2, 3])","dec([[1, 2], [3, 4]])"]}},"+":{evaluate:reduceMathOp(0,(e,t)=>e+t),arity:{},docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{a:{type:["number","vector","matrix"]},b:{type:["number","vector","matrix"]},xs:{type:["number","vector","matrix"],rest:!0}},variants:[{argumentNames:["xs"]}],description:"The `+` function performs addition of numbers and element-wise addition of `vectors` and `matrices` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it adds the scalar to each element of the collection.",seeAlso:["-","*","/","inc"],examples:["1 + 2","1 + 20 + 30","+(1, 2, 3, 4)","+()","+(1)","[1, 2, 3] + 2","[1, 2, 3] + [4, 5, 6]","[[1, 2, 3], [4, 5, 6]] + [[7, 8, 9], [10, 11, 12]]","[[1, 2, 3], [4, 5, 6]] + 2"]}},"*":{evaluate:reduceMathOp(1,(e,t)=>e*t),arity:{},docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{a:{type:["number","vector","matrix"]},b:{type:["number","vector","matrix"]},xs:{type:["number","vector","matrix"],rest:!0}},variants:[{argumentNames:["xs"]}],description:"The `*` function performs multiplication of `numbers` and element-wise multiplication of `vectors` and `matrices` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it multiplies each element of the collection by the scalar.",seeAlso:["/","+","-","^"],examples:["6 * 7","-1 * 4","*(4, 7)","*(1, 2, 3, 4, 5)","*()","*(8)","[1, 2, 3] * 2","[1, 2, 3] * [4, 5, 6]","[[1, 2, 3], [4, 5, 6]] * [[7, 8, 9], [10, 11, 12]]","[[1, 2, 3], [4, 5, 6]] * 2"]}},"/":{evaluate:(e,t)=>{if(0===e.length)return 1;const[r,n]=getNumberVectorOrMatrixOperation$1(e,t);if("number"===r){const[e,...t]=n;return 0===t.length?1/e:t.reduce((e,t)=>e/t,e)}if("vector"===r){const e=n[0];return n.slice(1).reduce((e,t)=>e.map((e,r)=>e/t[r]),e)}{const e=n[0];return n.slice(1).reduce((e,t)=>e.map((e,r)=>e.map((e,n)=>e/t[r][n])),e)}},arity:{},docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{a:{type:["number","vector","matrix"]},b:{type:["number","vector","matrix"]},xs:{type:["number","vector","matrix"],rest:!0}},variants:[{argumentNames:["xs"]}],description:"The `/` function performs division of `numbers` and element-wise division of `vectors` and `matrices` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it divides each element of the collection by the scalar.",seeAlso:["*","+","-","quot","mod","%"],examples:["12 / 100","-1 / 4","/(7, 4)","/(1, 2, 4, 8)","/()","/(8)","[1, 2, 3] / 2","[1, 2, 3] / [4, 5, 6]","[[1, 2, 3], [4, 5, 6]] / [[7, 8, 9], [10, 11, 12]]","[[1, 2, 3], [4, 5, 6]] / 2"]}},"-":{evaluate:(e,t)=>{if(0===e.length)return 0;const[r,n]=getNumberVectorOrMatrixOperation$1(e,t);if("number"===r){const[e,...t]=n;return 0===t.length?-e:t.reduce((e,t)=>e-t,e)}if("vector"===r){const e=n[0];return n.slice(1).reduce((e,t)=>e.map((e,r)=>e-t[r]),e)}{const e=n[0];return n.slice(1).reduce((e,t)=>e.map((e,r)=>e.map((e,n)=>e-t[r][n])),e)}},arity:{},docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{a:{type:["number","vector","matrix"]},b:{type:["number","vector","matrix"]},xs:{type:["number","vector","matrix"],rest:!0}},variants:[{argumentNames:["xs"]}],description:"Computes difference between first value and sum of the rest. When called with only one argument, it does negation.",seeAlso:["+","*","/","dec","abs"],examples:["50 - 8","1 - 1 - 1","-()","-(4, 2)","-(4, 3, 2, 1,)","[1, 2, 3] - 2","[1, 2, 3] - [4, 5, 6]","[[1, 2, 3], [4, 5, 6]] - [[7, 8, 9], [10, 11, 12]]","[[1, 2, 3], [4, 5, 6]] - 2"]}},quot:{evaluate:binaryMathOp((e,t)=>Math.trunc(e/t)),arity:toFixedArity(2),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{a:{type:["number","vector","matrix"]},b:{type:["number","vector","matrix"]}},variants:[{argumentNames:["a","b"]}],description:"The `quot` function performs integer division truncated toward zero, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies integer division between each element of the collection and the scalar.",seeAlso:["mod","%","/","trunc"],examples:["quot(5, 3)","quot(5.2, 3.1)","quot(-5, 3)","5 quot -3","-5 quot -3","quot(5, 0)","quot(0, 5)","[1, 2, 3] quot 2","2 quot [1, 2, 3]","quot([1, 2, 3], [4, 5, 6])","[[1, 2, 3], [4, 5, 6]] quot [[7, 8, 9], [10, 11, 12]]","quot([[1, 2, 3], [4, 5, 6]], 2)","[[1, 2, 3], [4, 5, 6]] quot [[7, 8, 9], [10, 11, 12]]"]}},mod:{evaluate:binaryMathOp((e,t)=>e-t*Math.floor(e/t)),arity:toFixedArity(2),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{a:{type:["number","vector","matrix"]},b:{type:["number","vector","matrix"]}},variants:[{argumentNames:["a","b"]}],description:"The `mod` function computes the modulo of division with the same sign as the divisor, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies the modulo operation between each element of the collection and the scalar.",seeAlso:["%","quot","/"],examples:["mod(5, 3)","mod(5.2, 3.1)","mod(-5, 3)","5 mod -3","-5 mod -3","[1, 2, 3] mod 2","2 mod [1, 2, 3]","mod([1, 2, 3], [4, 5, 6])","[[1, 2, 3], [4, 5, 6]] mod [[7, 8, 9], [10, 11, 12]]","mod([[1, 2, 3], [4, 5, 6]], 2)"]}},"%":{evaluate:binaryMathOp((e,t)=>e%t),arity:toFixedArity(2),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{a:{type:["number","vector","matrix"]},b:{type:["number","vector","matrix"]}},variants:[{argumentNames:["a","b"]}],description:"The `%` function computes the remainder of division with the same sign as the dividend, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies the remainder operation between each element of the collection and the scalar.",seeAlso:["mod","quot","/"],examples:["5 % 3","5.2 % 3.1","-5 % 3","%(5, -3)","%(-5, -3)","[1, 2, 3] % 2","2 % [1, 2, 3]","%([1, 2, 3], [4, 5, 6])","[[1, 2, 3], [4, 5, 6]] % [[7, 8, 9], [10, 11, 12]]","%([[1, 2, 3], [4, 5, 6]], 2)"]}},sqrt:{evaluate:unaryMathOp$1(e=>Math.sqrt(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `sqrt` function calculates the square root of `numbers` and computes element-wise square roots of `vectors` and `matrices`. When applied to collections, it returns the square root of each element while preserving the original structure.",seeAlso:["cbrt","^"],examples:["sqrt(0)","sqrt(9)","sqrt(2)","sqrt(0)","sqrt(9)","sqrt(2)","sqrt([1, 4, 9])","sqrt([[1, 4], [9, 16]])"]}},cbrt:{evaluate:unaryMathOp$1(e=>Math.cbrt(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `cbrt` function calculates the cube root of `numbers` and computes element-wise cube roots of `vectors` and `matrices`. When applied to collections, it returns the cube root of each element while preserving the original structure.",seeAlso:["sqrt","^"],examples:["cbrt(0)","cbrt(27)","cbrt(2)","cbrt(1)","cbrt(0)","cbrt(27)","cbrt(2)","cbrt(1)","cbrt([1, 8, 27])","cbrt([[1, 8], [27, 64]])"]}},"^":{evaluate:binaryMathOp((e,t)=>e**t),arity:toFixedArity(2),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{a:{type:["number","vector","matrix"]},b:{type:["number","vector","matrix"]}},variants:[{argumentNames:["a","b"]}],description:"The ^ function computes exponentiation, raising the first argument to the power of the second, working on `numbers` and element-wise on `vectors` and `matrices` of compatible dimensions. When used with mixed types, it applies the power operation between each element of the collection and the scalar.",seeAlso:["sqrt","cbrt","*","math.ln"],examples:["2 ^ 3","2 ^ 0","2 ^ -3","^(-2, 3)","^(-2, -3)","[1, 2, 3] ^ 2","2 ^ [1, 2, 3]","^([1, 2, 3], [4, 5, 6])","[[1, 2, 3], [4, 5, 6]] ^ [[7, 8, 9], [10, 11, 12]]","^([[1, 2, 3], [4, 5, 6]], 2)"]}},round:{evaluate:([e,t],r)=>{const[n,o]=getNumberVectorOrMatrixOperation$1([e],r);if("number"===n){if(void 0===t||0===t)return Math.round(o[0]);{assertNumber(t,r,{integer:!0,positive:!0});const e=10**t;return Math.round(o[0]*e)/e}}if("vector"===n){const e=o[0];if(void 0===t||0===t)return e.map(e=>Math.round(e));{assertNumber(t,r,{integer:!0,positive:!0});const n=10**t;return e.map(e=>Math.round(e*n)/n)}}{const e=o[0];if(void 0===t||0===t)return e.map(e=>e.map(e=>Math.round(e)));{assertNumber(t,r,{integer:!0,positive:!0});const n=10**t;return e.map(e=>e.map(e=>Math.round(e*n)/n))}}},arity:{min:1,max:2},docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{a:{type:["number","vector","matrix"]},b:{type:"integer"}},variants:[{argumentNames:["a"]},{argumentNames:["a","b"]}],description:"The `round` function rounds a `number` to the nearest `integer` or to a specified number of `decimal` places, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it rounds each element while preserving the original structure.",seeAlso:["floor","ceil","trunc"],examples:["round(2)","round(2.49)","round(2.5)","round(-2.49)","round(-2.5)","round(-2.501)","round(1.23456789, 4)","1.123456789 round 2","round([1.23456789, 2.3456789], 1)","[1.23456789, 2.3456789] round 4","[[1.23456789, 2.3456789], [3.456789, 4.56789]] round 4","round([[1.23456789, 2.3456789], [3.456789, 4.56789]], 2)"]}},trunc:{evaluate:unaryMathOp$1(e=>Math.trunc(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["integer","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `trunc` function truncates `numbers` toward zero (removing decimal portions without rounding), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it truncates each element while preserving the original structure.",seeAlso:["round","floor","ceil","quot"],examples:["trunc(2)","trunc(2.49)","trunc(2.5)","trunc(-2.49)","trunc(-2.5)","trunc(-2.501)","trunc([1.23456789, 2.3456789])","trunc([[1.23456789, 2.3456789], [3.456789, 4.56789]])"]}},floor:{evaluate:unaryMathOp$1(e=>Math.floor(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["integer","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `floor` function returns the largest `integer` less than or equal to a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the floor of each element while preserving the original structure.",seeAlso:["ceil","round","trunc"],examples:["floor(2)","floor(2.49)","floor(2.5)","floor(-2.49)","floor(-2.5)","floor(-2.501)","floor([1.23456789, 2.3456789])","floor([[1.23456789, 2.3456789], [3.456789, 4.56789]])"]}},ceil:{evaluate:unaryMathOp$1(e=>Math.ceil(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["integer","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `ceil` function returns the smallest `integer` greater than or equal to a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the ceiling of each element while preserving the original structure.",seeAlso:["floor","round","trunc"],examples:["ceil(2)","ceil(2.49)","ceil(2.5)","ceil(-2.49)","ceil(-2.5)","ceil(-2.501)","ceil([1.23456789, 2.3456789])","ceil([[1.23456789, 2.3456789], [3.456789, 4.56789]])"]}},min:{evaluate:(e,t)=>{if(1===e.length&&isVector(e[0])){const r=e[0];return assertNonEmptyVector(r,t),r.reduce((e,t)=>Math.min(e,t),1/0)}const[r,...n]=e;return assertNumber(r,t),n.reduce((e,r)=>(assertNumber(r,t),Math.min(e,r)),r)},arity:{min:1},docs:{category:"math",returns:{type:"number"},args:{a:{type:"number"},b:{type:"number"},xs:{type:"number",rest:!0},vector:{type:"vector"}},variants:[{argumentNames:["xs"]},{argumentNames:["vector"]}],description:"Returns the smallest value. Accepts either multiple numbers or a single vector of numbers.",seeAlso:["max","vector.span","vector.min-index"],examples:["2 min 3","min(2, 0, 1)","min(2, -1, 1)","min([2, 0, -1])","12 min 14"]}},max:{evaluate:(e,t)=>{if(1===e.length&&isVector(e[0])){const r=e[0];return assertNonEmptyVector(r,t),r.reduce((e,t)=>Math.max(e,t),-1/0)}const[r,...n]=e;return assertNumber(r,t),n.reduce((e,r)=>(assertNumber(r,t),Math.max(e,r)),r)},arity:{min:1},docs:{category:"math",returns:{type:"number"},args:{a:{type:"number"},b:{type:"number"},xs:{type:"number",rest:!0},vector:{type:"vector"}},variants:[{argumentNames:["xs"]},{argumentNames:["vector"]}],description:"Returns the largest value. Accepts either multiple numbers or a single vector of numbers.",seeAlso:["min","vector.span","vector.max-index"],examples:["2 max 3","max(2, 0, 1)","max(2, -1, 1)","max([2, 0, -1])","4 max 2"]}},abs:{evaluate:unaryMathOp$1(e=>Math.abs(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The abs function returns the absolute value (magnitude) of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the absolute value of each element while preserving the original structure.",seeAlso:["sign","-"],examples:["abs(-2.3)","abs(0)","abs(2.5)","abs([1, -2, 3])","abs([[1, -2], [3, -4]])"]}},sign:{evaluate:unaryMathOp$1(e=>Math.sign(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `sign` function returns the `sign` of a `number` (-1 for negative, 0 for zero, 1 for positive), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the sign of each element while preserving the original structure.",seeAlso:["abs"],examples:["sign(-2.3)","sign(-0)","sign(0)","sign(12312)","sign([1, -2, 3])","sign([[1, -2], [3, -4]])"]}}};function isEqual([e,...t],r){const n=asAny(e,r);for(const e of t)if(!deepEqual(n,asAny(e,r),r))return!1;return!0}function isIdentical([e,...t]){for(const r of t)if(r!==e)return!1;return!0}const miscNormalExpression={"==":{evaluate:(e,t)=>isEqual(e,t),arity:{min:1},docs:{category:"misc",returns:{type:"boolean"},args:{a:{type:"any"},b:{type:"any"},x:{type:"any"},ys:{type:"any",rest:!0}},variants:[{argumentNames:["x"]},{argumentNames:["x","ys"]}],description:"Returns `true` if all `values` are structaul equal to each other, otherwise result is `false`.",seeAlso:["!=","identical?"],examples:["1 == 1","[1, 2] == [1, 2]","\n{\n a: 1,\n b: 2,\n} == {\n b: 2,\n a: 1,\n}","==(1, 1)","==(1.01, 1)",'==("1", 1)','==("2", "2", "2", "2")',"==(2, 2, 1, 2)","==([1, 2], [1, 2])","==({ a: 1, b: 2 }, { b: 2, a: 1 })"]}},"!=":{evaluate:(e,t)=>!isEqual(e,t),arity:{min:1},docs:{category:"misc",returns:{type:"boolean"},args:{a:{type:"any"},b:{type:"any"},x:{type:"any"},ys:{type:"any",rest:!0}},variants:[{argumentNames:["x"]},{argumentNames:["x","ys"]}],description:"Returns `true` if all `values` are not equal to each other, otherwise result is `false`. `(!= a b c)` is same as `(not (== a b c))`.",seeAlso:["==","identical?"],examples:["1 != 2","3 != 3","!=(3)","!=(3, 3, 2)",'!=("3", "2", "1", "0",)',"!=(0, -0)"]}},"identical?":{evaluate:e=>isIdentical(e),arity:{min:1},docs:{category:"misc",returns:{type:"boolean"},args:{a:{type:"any"},b:{type:"any"}},variants:[{argumentNames:["a","b"]}],description:"Returns true if $a and $b are referential equal.",seeAlso:["==","!="],examples:["identical?({ a: 10, b: 20 }, { b: 20, a: 10 })","identical?([1, true, null], [1, true, null])","identical?(0.3, 0.1 + 0.2)"]}},">":{evaluate:([e,...t],r)=>{let n=asStringOrNumber(e);for(const e of t){if(compare(n,asStringOrNumber(e),r)<=0)return!1;n=asStringOrNumber(e)}return!0},arity:{min:1},docs:{category:"misc",returns:{type:"boolean"},args:{a:{type:["number","string"]},b:{type:["number","string"]},x:{type:["number","string"]},ys:{type:["number","string"],rest:!0}},variants:[{argumentNames:["x"]},{argumentNames:["x","ys"]}],description:"Returns `true` if $x and $ys are in decreasing order, `false` otherwise.",seeAlso:["<",">=","<=","compare"],examples:[">(1, 0)",">(1.01, 1)",">(1, 1)",">(4, 3, 2, 1)",">(3, 2, 2, 1)"]}},"<":{evaluate:([e,...t],r)=>{let n=asStringOrNumber(e);for(const e of t){if(compare(n,asStringOrNumber(e),r)>=0)return!1;n=asStringOrNumber(e)}return!0},arity:{min:1},docs:{category:"misc",returns:{type:"boolean"},args:{a:{type:["number","string"]},b:{type:["number","string"]},x:{type:["number","string"]},ys:{type:["number","string"],rest:!0}},variants:[{argumentNames:["x"]},{argumentNames:["x","ys"]}],description:"Returns `true` if $x and $ys are in increasing order, `false` otherwise.",seeAlso:[">",">=","<=","compare"],examples:["<(0, 1)","<(1, 1.01)","<(1, 1)","<(1, 2, 2, 3)",'<("a", "b")']}},">=":{evaluate:([e,...t],r)=>{let n=asStringOrNumber(e);for(const e of t){if(compare(n,asStringOrNumber(e),r)<0)return!1;n=asStringOrNumber(e)}return!0},arity:{min:1},docs:{category:"misc",returns:{type:"boolean"},args:{a:{type:["number","string"]},b:{type:["number","string"]},x:{type:["number","string"]},ys:{type:["number","string"],rest:!0}},variants:[{argumentNames:["x"]},{argumentNames:["x","ys"]}],description:"Returns `true` if $x and $ys are in non increasing order, `false` otherwise.",seeAlso:[">","<","<=","compare"],examples:["1 >= 1","0 >= 1",">=(1, 0)",">=(1.01, 1)",">=(1, 1)",">=(4, 3, 2, 1)",">=(3, 2, 2, 1)"]}},"<=":{evaluate:([e,...t],r)=>{let n=asStringOrNumber(e);for(const e of t){if(compare(n,asStringOrNumber(e),r)>0)return!1;n=asStringOrNumber(e)}return!0},arity:{min:1},docs:{category:"misc",returns:{type:"boolean"},args:{a:{type:["number","string"]},b:{type:["number","string"]},x:{type:["number","string"]},ys:{type:["number","string"],rest:!0}},variants:[{argumentNames:["x"]},{argumentNames:["x","ys"]}],description:"Returns `true` if $x and $ys are in non decreasing order, `false` otherwise.",seeAlso:[">","<",">=","compare"],examples:["1 <= 1","<=(0, 1)","<=(1, 1.01)","<=(1, 1)","<=(1, 2, 3, 4)","<=(1, 2, 2, 3)"]}},not:{evaluate:([e])=>!e,arity:toFixedArity(1),docs:{category:"misc",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Computes logical negation. Note that any other $x than `false`, `0`, `null` and `''` is truthy.",seeAlso:["boolean"],examples:["not(3)","not(true)",'not("A string")',"not(0)","not(false)","not(null)",'not("")']}},"epoch->iso-date":{evaluate:([e],t)=>(assertNumber(e,t),new Date(e).toISOString()),arity:toFixedArity(1),docs:{category:"misc",returns:{type:"string"},args:{ms:{type:"number"}},variants:[{argumentNames:["ms"]}],description:"Returns IOS date time string from `ms` (milliseconds elapsed since the UNIX epoch).",seeAlso:["iso-date->epoch"],examples:["epoch->iso-date(1649756230899)","epoch->iso-date(0)"]}},"iso-date->epoch":{evaluate:([e],t)=>{assertString(e,t);const r=new Date(e).valueOf();return assertNumber(r,t,{finite:!0}),r},arity:toFixedArity(1),docs:{category:"misc",returns:{type:"number"},args:{iso:{type:"string"}},variants:[{argumentNames:["iso"]}],description:"Returns milliseconds elapsed since the UNIX epoch to `iso`.",seeAlso:["epoch->iso-date"],examples:['iso-date->epoch("2022-04-12T09:37:10.899Z")','iso-date->epoch("1980-01-01")']}},"write!":{evaluate:(e,t)=>(console.log(...e),e.length>0?asAny(e[e.length-1],t):null),arity:{},docs:{category:"misc",returns:{type:"any"},args:{values:{type:"any",rest:!0}},variants:[{argumentNames:["values"]}],description:"It logs the $values and then returns the last argument. If called with no arguments `null` is returned.",examples:['write!("A string")','write!(100, "items")','write!(object("a", 10))','write!(["a", "b", "c"])','write!(#"^start")',"write!(null, true, false)"],hideOperatorForm:!0}},boolean:{evaluate:([e])=>!!e,arity:toFixedArity(1),docs:{category:"misc",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Coerces $x to boolean.",seeAlso:["not","boolean?","true?","false?"],examples:["boolean(0)","boolean(1)","boolean(null)",'boolean("Albert")']}},compare:{evaluate:([e,t],r)=>(assertStringOrNumber(e,r),assertStringOrNumber(t,r),compare(e,t,r)),arity:toFixedArity(2),docs:{category:"misc",returns:{type:"number"},args:{a:{type:["number","string"]},b:{type:["number","string"]}},variants:[{argumentNames:["a","b"]}],description:"Compares two values. Returns `-1` if $a < $b, `1` if $a > $b and `0` if $a and $b have the same sort order.",seeAlso:["<",">","<=",">=","sort","sequence.sort-by"],examples:["compare(0, 1)","compare(0, 0)","compare(1, 0)",'compare("Albert", "Mojir")']}},"json-parse":{evaluate:([e],t)=>(assertString(e,t),JSON.parse(e)),arity:toFixedArity(1),docs:{category:"misc",returns:{type:"any"},args:{x:{type:"string"}},variants:[{argumentNames:["x"]}],description:"Returns `JSON.parse(`$x`)`.",seeAlso:["json-stringify"],examples:['json-parse("[1, 2, 3]")']}},"json-stringify":{evaluate:([e,t],r)=>(assertAny(e,r),void 0===t?JSON.stringify(e):(assertNumber(t,r),JSON.stringify(e,null,t))),arity:{min:1,max:2},docs:{category:"misc",returns:{type:"string"},args:{x:{type:"any"},indent:{type:"integer",description:"Number of spaces to use for indentation."}},variants:[{argumentNames:["x"]},{argumentNames:["x","indent"]}],description:"Returns `JSON.stringify(`$x`)`. If second argument is provided, returns `JSON.stringify(`$x`, null, `$indent`)`.",seeAlso:["json-parse"],examples:["json-stringify([1, 2, 3])","json-stringify({ a: { b: 10 }}, 2)"],hideOperatorForm:!0}},import:{evaluate:([e],t,r)=>{assertString(e,t);const n=e.indexOf(".");if(-1!==n){const o=e.substring(0,n),a=e.substring(n+1),i=r.getModule(o);if(!i)throw new LitsError(`Unknown module: '${o}'`,t);const s=i.functions[a];if(!s)throw new LitsError(`Function '${a}' not found in module '${o}'`,t);return{[FUNCTION_SYMBOL]:!0,sourceCodeInfo:t,functionType:"Module",moduleName:o,functionName:a,arity:s.arity}}const o=e,a=r.getModule(o);if(!a)throw new LitsError(`Unknown module: '${o}'`,t);const i={};for(const[e,r]of Object.entries(a.functions))i[e]={[FUNCTION_SYMBOL]:!0,sourceCodeInfo:t,functionType:"Module",moduleName:o,functionName:e,arity:r.arity};return i},arity:toFixedArity(1),docs:{category:"misc",returns:{type:"any"},args:{path:{type:"string",description:'The module path to import. Can be a module name (e.g., "vector", "grid") or a fully qualified function name (e.g., "vector.mean", "grid.row").'}},variants:[{argumentNames:["path"]}],description:'Imports module functions. Use a module name (e.g., "vector") to import all functions as an object, or a fully qualified name (e.g., "vector.mean") to import a single function directly.',examples:['let v = import("vector"); v.mean([1, 2, 3, 4])','let v-sum = import("vector.sum"); v-sum([1, 2, 3])','let g = import("grid"); g.row([[1, 2], [3, 4]], 0)']}}},objectNormalExpression={keys:{evaluate:([e],t)=>(assertObj(e,t),Object.keys(e)),arity:toFixedArity(1),docs:{category:"object",returns:{type:"any",array:!0},args:{obj:{type:"object"}},variants:[{argumentNames:["obj"]}],description:"Returns array of all keys in $obj.",seeAlso:["vals","entries","zipmap","select-keys"],examples:["keys({})",'keys({ x: 10, y: true, z: "A string" })','keys(object("x", 10, "y", true, "z", "A string"))']}},vals:{evaluate:([e],t)=>(assertObj(e,t),Object.values(e)),arity:toFixedArity(1),docs:{category:"object",returns:{type:"any",array:!0},args:{obj:{type:"object"}},variants:[{argumentNames:["obj"]}],description:"Returns array of all values in $obj.",seeAlso:["keys","entries","zipmap"],examples:["vals({})",'vals({ x: 10, y: true, z: "A string" })','vals(object("x", 10, "y", true, "z", "A string"))']}},entries:{evaluate:([e],t)=>(assertObj(e,t),Object.entries(e)),arity:toFixedArity(1),docs:{category:"object",returns:{type:"array"},args:{obj:{type:"object"}},variants:[{argumentNames:["obj"]}],description:"Returns nested array of all key - value pairs in $obj.",seeAlso:["keys","vals","zipmap","find"],examples:["entries({})",'entries({ x: 10, y: true, z: "A string" })','entries(object("x", 10, "y", true, "z", "A string"))']}},find:{evaluate:([e,t],r)=>(assertObj(e,r),assertString(t,r),collHasKey(e,t)?[t,e[t]]:null),arity:toFixedArity(2),docs:{category:"object",returns:{type:["array","null"]},args:{a:{type:"object"},b:{type:"string"},obj:{type:"object"},key:{type:"string"}},variants:[{argumentNames:["obj","key"]}],description:"Returns entry (key-value pair) for $key, or `null` if $key not present in $obj.",seeAlso:["get","contains?","entries","sequence.position","some"],examples:['{ a: 1, "b": 2 } find "a"','find(object("a", 1, "b", 2), "b")','find(object("a", 1, "b", 2), "c")']}},dissoc:{evaluate:([e,t],r)=>{assertObj(e,r),assertString(t,r);const n={...e};return delete n[t],n},arity:toFixedArity(2),docs:{category:"object",returns:{type:"object"},args:{a:{type:"object"},b:{type:"string"},obj:{type:"object"},key:{type:"string"}},variants:[{argumentNames:["obj","key"]}],description:"Return shallow copy of $obj with $key deleted.",seeAlso:["assoc","select-keys"],examples:['{ x: 10, y: 20 } dissoc "y"','dissoc({ x: 10, y: 20 }, "x")','dissoc({ x: 10 }, "y")','\nlet o = { a: 5 };\ndissoc(o, "a");\no']}},merge:{evaluate:(e,t)=>{if(0===e.length)return null;const[r,...n]=e;return assertObj(r,t),n.reduce((e,r)=>(assertObj(r,t),{...e,...r}),{...r})},arity:{min:0},docs:{category:"object",returns:{type:"object"},args:{a:{type:"object"},b:{type:"object"},objs:{type:"object",rest:!0}},variants:[{argumentNames:["objs"]}],description:"Returns a new object created by merging together all arguments.\n\nIf two keys appears in more than one object the value from the last object is used.\nIf no arguments are provided `null` is returned.",seeAlso:["merge-with","assoc"],examples:["{ x: 10 } merge { y: 20 }",'merge(object("x", 10), object("y", 20))','merge(object("x", 10), object("x", 15, "y", 20))']}},"merge-with":{evaluate:(e,t,r,{executeFunction:n})=>{const o=e[0],a=e.at(-1),i=e.slice(1,-1);return assertObj(o,t),assertFunctionLike(a,t),reduceSequential(i,(e,o)=>{assertObj(o,t);return chain(reduceSequential(Object.entries(o),(e,o)=>{const i=asString(o[0],t),s=toAny(o[1]);return collHasKey(e,i)?chain(n(a,[e[i],s],r,t),t=>(e[i]=t,e)):(e[i]=s,e)},e),e=>e)},{...o})},arity:{min:2},docs:{category:"object",returns:{type:"object"},args:{objs:{type:"object",rest:!0},fun:{type:"function"}},variants:[{argumentNames:["objs","fun"]}],description:"\nReturns a new object created by merging together all arguments.\nIf two keys appears in more than one object $fun is used to calculate the new value.\n\nIf no arguments are provided `null` is returned.",seeAlso:["merge"],examples:['merge-with(object("x", 10), object("y", 20), +)','merge-with(object("x", 10), object("x", 15, "y", 20), +)',"merge-with({ x: 10 }, { x: 20 }, { x: 30 }, { x: 40 }, -)"],hideOperatorForm:!0}},zipmap:{evaluate:([e,t],r)=>{assertStringArray(e,r),assertArray(t,r);const n=Math.min(e.length,t.length),o={};for(let a=0;a<n;a+=1){o[asString(e[a],r)]=toAny(t[a])}return o},arity:toFixedArity(2),docs:{category:"object",returns:{type:"object"},args:{a:{type:"array"},b:{type:"array"}},variants:[{argumentNames:["a","b"]}],description:"Returns a new object created by mapping $a to $b.",seeAlso:["entries","keys","vals","sequence.interleave"],examples:['["a", "b", "c"] zipmap [1, 2, 3]','zipmap(["a", "b", "c"], [10, null, [1, 2, 3]])','zipmap(["a", "b", "c"], [1])',"zipmap([], [10, null, [1, 2, 3]])"]}},"select-keys":{evaluate:([e,t],r)=>(assertStringArray(t,r),assertObj(e,r),t.reduce((t,r)=>(collHasKey(e,r)&&(t[r]=toAny(e[r])),t),{})),arity:toFixedArity(2),docs:{category:"object",returns:{type:"object"},args:{a:{type:"object"},b:{type:"array"}},variants:[{argumentNames:["a","b"]}],description:"Returns an object containing only those entries in $a whose key is in $b.",seeAlso:["dissoc","keys"],examples:['{ a: 1, b: 2, c: 3 } select-keys ["a", "b"]','select-keys({ a: 1, b: 2, c: 3 }, ["a", "b"])','select-keys({ a: 1 }, ["a", "b"])']}}},predicatesNormalExpression={"function?":{evaluate:([e])=>isLitsFunction(e),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is a function, otherwise `false`.",seeAlso:["string?","number?","boolean?","null?","array?","object?","regexp?"],examples:["function?(+)","function?(/)","function?((x, y) -> x + y)","function?(false)",'function?("false")',"function?([1, 2, 3])"]}},"string?":{evaluate:([e])=>"string"==typeof e,arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is a string, otherwise `false`.",seeAlso:["blank?","number?","boolean?","null?","array?","object?","regexp?","function?","collection?","sequence?"],examples:['string?("")','string?("A string")','string?(true ? "A string" : false)',"string?(false)","string?([1, 2, 3])","string?(100)"]}},"number?":{evaluate:([e])=>"number"==typeof e,arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is a number, otherwise `false`.",seeAlso:["integer?","zero?","pos?","neg?","finite?","number","string?","boolean?","null?","function?"],examples:["number?(0)","number?(2)","number?(-0.12)","number?(false)","number?([1, 2, 3])",'number?("A string")']}},"integer?":{evaluate:([e])=>"number"==typeof e&&isNumber(e,{integer:!0}),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is an integer, otherwise `false`.",seeAlso:["number?","number","even?","odd?"],examples:["integer?(0)","integer?(-12)","integer?(42)","integer?(10.1)","integer?((x, y) -> x + y)","integer?(false)",'integer?("false")',"integer?([1, 2, 3])"]}},"boolean?":{evaluate:([e])=>"boolean"==typeof e,arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is a `boolean`, otherwise `false`.",seeAlso:["true?","false?","boolean","string?","number?","null?","function?"],examples:["boolean?(true)","boolean?(false)","boolean?([1, 2, 3])","boolean?(0)",'boolean?("A string")']}},"null?":{evaluate:([e])=>null==e,arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is `null`, otherwise `false`.",seeAlso:["empty?","not-empty?","string?","number?","boolean?","function?"],examples:["null?(null)","null?(false)","null?([1, 2, 3])","null?(0)",'null?("A string")']}},"zero?":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0}),Math.abs(e)<EPSILON),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"number"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is `0`, otherwise `false`.",seeAlso:["pos?","neg?","even?","number?"],examples:["zero?(0)","zero?(-0.0)","zero?(1)","zero?(0.1)"]}},"pos?":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0}),e>0),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"number"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is greater than `0`, otherwise `false`.",seeAlso:["neg?","zero?","number?"],examples:["pos?(0)","pos?(-0.0)","pos?(1)","pos?(-0.1)"]}},"neg?":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0}),e<0),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"number"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is less than `0`, otherwise `false`.",seeAlso:["pos?","zero?","number?"],examples:["neg?(0)","neg?(-0.0)","neg?(1)","neg?(-0.1)"]}},"even?":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0}),e%2==0),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"number"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is even, otherwise `false`.",seeAlso:["odd?","integer?","zero?"],examples:["even?(0)","even?(-0.0)","even?(-1)","even?(2.1)"]}},"odd?":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0}),isNumber(e,{integer:!0})&&e%2!=0),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"number"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is odd, otherwise `false`.",seeAlso:["even?","integer?"],examples:["odd?(1.0)","odd?(1.001)","odd?(-1)","odd?(2.1)"]}},"array?":{evaluate:([e])=>Array.isArray(e),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is an array, otherwise `false`.",seeAlso:["sequence?","collection?","object?","string?","vector?","matrix?","grid?","function?"],examples:["array?([])","array?([1, 2, 3])",'array?(object("a", 10))',"array?(42)","array?(10.1)","array?((x, y) -> x + y)"]}},"collection?":{evaluate:([e])=>isColl(e),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is a collection i.e. an array, an object or a string, otherwise `false`.",seeAlso:["sequence?","array?","object?","string?"],examples:["collection?([])","collection?([1, 2, 3])",'collection?(object("a", 10))','collection?("Albert")',"collection?(42)","collection?(10.1)","collection?((x, y) -> x + y)"]}},"sequence?":{evaluate:([e])=>isSeq(e),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is a sequence i.e. an array or a string, otherwise `false`.",seeAlso:["collection?","array?","string?"],examples:["sequence?([])","sequence?([1, 2, 3])",'sequence?(object("a", 10))','sequence?("Albert")',"sequence?(42)","sequence?(10.1)","sequence?((x, y) -> x + y)"]}},"object?":{evaluate:([e])=>isObj(e),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is an object, otherwise `false`.",seeAlso:["collection?","array?","string?","function?"],examples:['object?(object("a", 10))',"object?(42)","object?(10.1)","object?((x, y) -> x + y)",'object?(#"^start")','object?("false")',"object?([1, 2, 3])"]}},"regexp?":{evaluate:([e])=>isRegularExpression(e),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is a regexp, otherwise `false`.",seeAlso:["regexp","match","string?","function?"],examples:['regexp?(regexp("^start"))','regexp?(#"^start")',"regexp?(-12)","regexp?({})","regexp?(10.1)","regexp?((x, y) -> x + y)","regexp?(false)",'regexp?("false")',"regexp?([1, 2, 3])"]}},"finite?":{evaluate:([e],t)=>(assertNumber(e,t),Number.isFinite(e)),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"number"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is finite, otherwise `false`.",seeAlso:["positive-infinity?","negative-infinity?","number?"],examples:["finite?(1.0)","finite?(1 / 0)","finite?(-1 / 0)"]}},"positive-infinity?":{evaluate:([e],t)=>(assertNumber(e,t),e===Number.POSITIVE_INFINITY),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"number"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x equals positive infinity, otherwise `false`.",seeAlso:["negative-infinity?","finite?"],examples:["positive-infinity?(1.0)","positive-infinity?(1 / 0)","positive-infinity?(-1 / 0)"]}},"negative-infinity?":{evaluate:([e],t)=>(assertNumber(e,t),e===Number.NEGATIVE_INFINITY),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"number"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x equals negative infinity, otherwise `false`.",seeAlso:["positive-infinity?","finite?"],examples:["negative-infinity?(1.0)","negative-infinity?(1 / 0)","negative-infinity?(-1 / 0)"]}},"true?":{evaluate:([e])=>!0===e,arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is `true`, otherwise `false`.",seeAlso:["false?","boolean?","boolean"],examples:["true?(false)","true?(true)","true?(1)","true?(0)"]}},"false?":{evaluate:([e])=>!1===e,arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is `true`, otherwise `false`.",seeAlso:["true?","boolean?","boolean"],examples:["false?(false)","false?(true)","false?(1)","false?(0)"]}},"empty?":{evaluate:([e],t)=>null===e||(assertColl(e,t),"string"==typeof e||Array.isArray(e)?0===e.length:0===Object.keys(e).length),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:["collection","string","null"]}},variants:[{argumentNames:["x"]}],description:"Returns `true` if $x is empty or `null`, otherwise `false`.",seeAlso:["not-empty?","collection.not-empty","null?","blank?","count"],examples:["empty?([])","empty?([1, 2, 3])","empty?({})","empty?({ a: 2 })",'empty?("")','empty?("Albert")',"empty?(null)"]}},"not-empty?":{evaluate:([e],t)=>null!==e&&(assertColl(e,t),"string"==typeof e||Array.isArray(e)?e.length>0:Object.keys(e).length>0),arity:toFixedArity(1),docs:{category:"predicate",returns:{type:"boolean"},args:{x:{type:["collection","string","null"]}},variants:[{argumentNames:["x"]}],description:"Returns `false` if $x is empty or `null`, otherwise `true`.",seeAlso:["empty?","collection.not-empty","null?"],examples:["not-empty?([])","not-empty?([1, 2, 3])","not-empty?({})","not-empty?({ a: 2 })",'not-empty?("")','not-empty?("Albert")',"not-empty?(null)"]}},"vector?":{evaluate:([e])=>isVector(e),arity:toFixedArity(1),docs:{category:"predicate",description:"Checks if a value is a `vector`. A `vector` is an array of `numbers`.",seeAlso:["matrix?","grid?","array?"],returns:{type:"boolean"},args:{value:{type:"any",description:"The value to check."}},variants:[{argumentNames:["value"]}],examples:["vector?(1)","vector?([1, 2, 3])",'vector?([1, 2, "3"])']}},"matrix?":{evaluate:([e])=>isMatrix(e),arity:toFixedArity(1),docs:{category:"predicate",description:"Checks if a value is a `matrix`. A `matrix` is an array of arrays of `numbers`.",seeAlso:["vector?","grid?","array?"],returns:{type:"boolean"},args:{value:{type:"any",description:"The value to check."}},variants:[{argumentNames:["value"]}],examples:["matrix?(1)","matrix?([1, 2, 3])","matrix?([[1, 2], [3, 4]])",'matrix?([[1, 2], [3, "4"]])',"matrix?([[1, 2], [3]])"]}},"grid?":{evaluate:([e])=>isGrid(e),arity:toFixedArity(1),docs:{category:"predicate",description:"Checks if a `value` is a `grid`. A `grid` is an `array` of `arrays` where all inner `arrays` have the same length.",seeAlso:["vector?","matrix?","array?"],returns:{type:"boolean"},args:{value:{type:"any",description:"The value to check."}},variants:[{argumentNames:["value"]}],examples:['grid?("1")','grid?(["1", 2, 3])','grid?([["1", 2], [3, 4]])','grid?([["1", 2], [3, "4"]])','grid?([["1", 2], [3]])']}}},regexpNormalExpression={regexp:{evaluate:([e,t],r)=>{assertString(e,r);const n=e||"(?:)",o="string"==typeof t?t:"";try{new RegExp(n,o)}catch(e){throw new LitsError(`Invalid regular expression: ${n} ${o}`,r)}return{[REGEXP_SYMBOL]:!0,sourceCodeInfo:r,s:n,f:o}},arity:{min:1,max:2},docs:{category:"regular-expression",returns:{type:"regexp"},args:{pattern:{type:"string"},flags:{type:"string",description:"Optional flags for the regular expression. Possible values are the same as Javascript RegExp takes."}},variants:[{argumentNames:["pattern"]},{argumentNames:["pattern","flags"]}],description:"Creates a RegExp from $pattern and $flags.",examples:['regexp("^\\s*(.*)$")','#"^\\s*(.*)$"','regexp("albert", "ig")','#"albert"ig'],seeAlso:["-short-regexp","match","replace","replace-all","regexp?"],hideOperatorForm:!0}},match:{evaluate:([e,t],r)=>{if(assertRegularExpression(t,r),!isString(e))return null;const n=new RegExp(t.s,t.f).exec(e);return n?[...n]:null},arity:toFixedArity(2),docs:{category:"regular-expression",returns:{type:"any",array:!0},args:{a:{type:"regexp"},b:{type:"string"}},variants:[{argumentNames:["a","b"]}],description:"Matches $b against regular expression $a.\nIf $b is a string and matches the regular expression, a `match`-array is returned, otherwise `null` is returned.",seeAlso:["regexp","replace","replace-all","-short-regexp","regexp?"],examples:['match("  A string", regexp("^\\\\s*(.*)$"))','match("  A string", #"^\\s*(.*)$")','match("My name is Albert", #"albert"i)','match("My name is Ben", #"albert"i)','match(null, #"albert"i)','match(1, #"albert"i)','match({}, #"albert"i)']}},replace:{evaluate:([e,t,r],n)=>{assertString(e,n),assertStringOrRegularExpression(t,n),assertString(r,n);const o=isRegularExpression(t)?new RegExp(t.s,`${t.f}`):t;return e.replace(o,r)},arity:toFixedArity(3),docs:{category:"regular-expression",returns:{type:"any",array:!0},args:{a:{type:"string"},b:{type:["regexp","string"]},x:{type:"string"}},variants:[{argumentNames:["a","b","x"]}],description:"Returns a new string with first match of regular expression $b replaced by $x.",seeAlso:["replace-all","regexp","match","-short-regexp"],examples:['replace("Duck duck", "u", "i")','replace("Duck duck", #"u", "i")','replace("abcABC", regexp("a", "i"), "-")','replace("abcABC", regexp("a", "gi"), "-")','replace("abcABC", #"a"i, "-")','replace("abcABC", #"a"gi, "-")']}},"replace-all":{evaluate:([e,t,r],n)=>{assertString(e,n),assertStringOrRegularExpression(t,n),assertString(r,n);const o=isRegularExpression(t)?new RegExp(t.s,`${t.f.includes("g")?t.f:`${t.f}g`}`):t;return e.replaceAll(o,r)},arity:toFixedArity(3),docs:{category:"regular-expression",returns:{type:"any",array:!0},args:{a:{type:"string"},b:{type:["regexp","string"]},x:{type:"string"}},variants:[{argumentNames:["a","b","x"]}],description:"Returns a new string with all matches of regular expression $b replaced by $x.",seeAlso:["replace","regexp","match","-short-regexp"],examples:['replace-all("Duck duck", "u", "i")','replace-all("Duck duck", regexp("u"), "i")','replace-all("abcABC", regexp("a", "i"), "-")','replace-all("abcABC", regexp("a", "gi"), "-")','replace-all("abcABC", #"a"i, "-")','replace-all("abcABC", #"a"gi, "-")']}}},blankRegexp=/^\s*$/,stringNormalExpression={str:{evaluate:e=>e.reduce((e,t)=>e+(null==t?"":isObj(t)||Array.isArray(t)?JSON.stringify(t):`${t}`),""),arity:{},docs:{category:"string",returns:{type:"string"},args:{values:{type:"any",rest:!0}},variants:[{argumentNames:["values"]}],description:"Concatenats $values into one string. If `value` equals `null` empty string is returned.",seeAlso:["++","join","string.template","string.string-repeat","number"],examples:['str("A string", ", and another string", " ...and more")','str("Just one string")',"str()",'str(0, false, true, null, #"^kalle", [1, 2, 3], {a: "a"})'],hideOperatorForm:!0}},number:{evaluate:([e],t)=>{assertString(e,t);const r=Number(e);if(Number.isNaN(r))throw new LitsError(`Could not convert '${e}' to a number.`,t);return r},arity:toFixedArity(1),docs:{category:"string",returns:{type:"number"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Parses $s to a number.",seeAlso:["str","number?","integer?"],examples:['number("10")','number("010")','number("-1.01")']}},"lower-case":{evaluate:([e],t)=>(assertString(e,t),e.toLowerCase()),arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Returns $s converted to lower case.",seeAlso:["upper-case","string.capitalize"],examples:['lower-case("Albert")','lower-case("")']}},"upper-case":{evaluate:([e],t)=>(assertString(e,t),e.toUpperCase()),arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Returns $s converted to upper case.",seeAlso:["lower-case","string.capitalize"],examples:['upper-case("Albert")','upper-case("")']}},trim:{evaluate:([e],t)=>(assertString(e,t),e.trim()),arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Returns a new string with leading and trailing whitespaces removed.",seeAlso:["string.trim-left","string.trim-right","blank?"],examples:['trim("  Albert  ")','trim("   ")','trim("")']}},join:{evaluate:([e,t],r)=>(assertArray(e,r),e.forEach(e=>assertStringOrNumber(e,r)),assertString(t,r),e.join(t)),arity:toFixedArity(2),docs:{category:"string",returns:{type:"string"},args:{a:{type:"array"},b:{type:"string"},arr:{type:"array"},delimiter:{type:"string"}},variants:[{argumentNames:["arr","delimiter"]}],description:"Returns a new string by concatenating all of the elements in $arr, separated by $delimiter.",seeAlso:["split","str","++","sequence.interpose"],examples:['map([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], str) join ", "','([0, 1, 2, 3, 4, 5, 6, 7, 8, 9] map str) join ", "','join(["Albert", 10], ", ")','join(["Albert", "Mojir"], " ")','join(map([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], str), ", ")']}},split:{evaluate:([e,t,r],n)=>{assertString(e,n),assertStringOrRegularExpression(t,n),void 0!==r&&assertNumber(r,n,{integer:!0,nonNegative:!0});const o="string"==typeof t?t:new RegExp(t.s,t.f);return e.split(o,r)},arity:{min:2,max:3},docs:{category:"string",returns:{type:"string"},args:{a:{type:"string"},b:{type:"string"},s:{type:"string"},delimiter:{type:"string"},limit:{type:"integer"}},variants:[{argumentNames:["s","delimiter"]},{argumentNames:["s","delimiter","limit"]}],description:"Divides $s into an array of substrings. The division is done by searching for `delimiter`. If `limit` as provided, at most `limit` number of substrings are returned.",seeAlso:["join","string.split-lines"],examples:['"Albert Mojir" split " "','split("Albert Mojir", " ")','split("abcdefghijklmnopqrstuvw", #"[aoueiy]")','split("0123456789", "")','split("0123456789", "", 5) map number']}},"blank?":{evaluate:([e],t)=>null===e||(assertString(e,t),blankRegexp.test(e)),arity:toFixedArity(1),docs:{category:"string",returns:{type:"boolean"},args:{s:{type:["string","null"]}},variants:[{argumentNames:["s"]}],description:"Returns true if $s is null or only contains whitespace characters.",seeAlso:["trim","empty?","string?"],examples:['blank?("")',"blank?(null)",'blank?("\n")','blank?(" ")','blank?(".")']}}},functionalNormalExpression={"|>":{evaluate:([e,t],r,n,{executeFunction:o})=>(assertFunctionLike(t,r),o(t,[e],n,r)),arity:toFixedArity(2),docs:{category:"functional",returns:{type:"any"},args:{a:{type:"any"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],description:"Takes a value $a and a function $b, and returns the result of applying $b to $a.",seeAlso:["apply","comp"],examples:["\n1 |> inc |> inc","range(10)\n  |> map(_, -> $ ^ 2) // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n  |> filter(_, odd?)  // [1, 9, 25, 49, 81]\n  |> reduce(_, +, 0)  // 165\n  |> sqrt             // 12.84523257866513\n  |> round(_, 2)"]}},apply:{evaluate:([e,...t],r,n,{executeFunction:o})=>{assertFunctionLike(e,r);const a=t[t.length-1];assertArray(a,r);return o(e,[...t.slice(0,-1),...a],n,r)},arity:{min:2},docs:{category:"functional",returns:{type:"any"},args:{a:{type:"function"},b:{type:"array"},fun:{type:"function"},args:{type:"array"}},variants:[{argumentNames:["fun","args"]}],description:"Call supplied function $fun with specified arguments $args.",seeAlso:["|>"],examples:["\napply(+, [1, 2, 3])","\napply(\n  (x, y) -> sqrt(x ^ 2 + y ^ 2),\n  [3, 4]\n)","\n(x, y) -> sqrt(x ^ 2 + y ^ 2) apply [3, 4]"]}},identity:{evaluate:([e])=>toAny(e),arity:toFixedArity(1),docs:{category:"functional",returns:{type:"any"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns $x.",seeAlso:["constantly","functional.fnull"],examples:["identity(1)",'identity("Albert")',"identity({ a: 1 })","identity(null)"]}},comp:{evaluate:(e,t)=>(e.forEach(e=>assertFunctionLike(e,t)),{[FUNCTION_SYMBOL]:!0,sourceCodeInfo:t,functionType:"Comp",params:e,arity:e.length>0?getArityFromFunction(e.at(-1)):{min:1,max:1}}),arity:{},docs:{category:"functional",returns:{type:"function"},args:{a:{type:"function"},b:{type:"function"},fns:{type:"function",rest:!0}},variants:[{argumentNames:["fns"]}],description:"Takes a variable number of functions and returns a function that is the composition of those.\n\n  The returned function takes a variable number of arguments,\n  applies the rightmost function to the args,\n  the next function (right-to-left) to the result, etc.",seeAlso:["|>","functional.juxt","functional.complement"],examples:["\nlet negative-quotient = comp(-, /);\nnegative-quotient(9, 3)",'\nlet x = { bar: { foo: 42 } };\ncomp("foo", "bar")(x)']}},constantly:{evaluate:([e],t)=>({[FUNCTION_SYMBOL]:!0,sourceCodeInfo:t,functionType:"Constantly",value:toAny(e),arity:{}}),arity:toFixedArity(1),docs:{category:"functional",returns:{type:"function"},args:{x:{type:"any"}},variants:[{argumentNames:["x"]}],description:"Returns a function that takes any number of arguments and always returns $x.",seeAlso:["identity","functional.fnull"],examples:["\nlet always-true = constantly(true);\nalways-true(9, 3)"]}}};function generateDocString(e){return smartTrim(`\n    ${e.title}\n\n    ${e.description.replace(/`(.+?)`/g,"$1").replace(/\$(\w+)/g,"$1").replace(/\*\*\*(.+)\*\*\*/g,"$1").replace(/\*\*(.+)\*\*/g,"$1")}\n\n    Signature:\n    ${signature(e).join("\n    ")}\n\n    Arguments:\n      ${argStrings(e).join("\n      ")}\n\n    Examples:\n${e.examples.map(e=>smartTrim(e,4)).join("\n\n")}`)}function signature({title:e,variants:t,args:r,returns:n,_isOperator:o}){return[...t.map(t=>`${`  ${e}(${t.argumentNames.map(e=>{let t="";return r[e].rest&&(t+="..."),t+=e,t}).join(", ")})`} -> ${type(n)}`),...o?["","Operator:",`  a ${e} b -> ${type(n)}`]:[]]}function type(e){const t=e.type,r=(Array.isArray(t)?t:[t]).join(" | ");return e.array||e.rest?`Array<${r}>`:r}function argStrings(e){return Object.entries(e.args).map(([e,t])=>`${e}: ${type(t)}`)}function getMetaNormalExpression(e){return{doc:{evaluate:([t],r)=>{if(assertNonUndefined(e),assertFunctionLike(t,r),!isLitsFunction(t))return"";if("Builtin"===t.functionType){const r=e[t.name];return r?generateDocString(r):""}return"UserDefined"===t.functionType||"NativeJsFunction"===t.functionType?t.docString:""},arity:toFixedArity(1),docs:{category:"meta",returns:{type:"string"},args:{fun:{type:"function"}},variants:[{argumentNames:["fun"]}],description:"Returns documentation string of the $fun.",seeAlso:["arity"],examples:["doc(+)",'\nlet add = (x, y) -> do\n  """\n  Adds two numbers.\n  Args:\n    x: First number.\n    y: Second number.\n  Returns:\n    Sum of x and y.\n  """\n  x + y;\nend;\n\ndoc(add)']}},arity:{evaluate:([e],t)=>(assertFunctionLike(e,t),isLitsFunction(e)?e.arity:toFixedArity(1)),arity:toFixedArity(1),docs:{category:"meta",returns:{type:"object"},args:{fun:{type:"function"}},variants:[{argumentNames:["fun"]}],description:"Returns arity of the $fun. The arity is an object with the properties: `min` and `max`. If the function has fixed arity, `min` and `max` are equal to the number of required parameters. If no restrictions apply, empty object is returned.",seeAlso:["doc"],examples:["arity(+)","arity(defined?)","\nlet add = (x, y = 0) -> do\n  x + y;\nend;\n\narity(add)","\nlet foo = (k, ...x) -> do\n  k + x;\nend;\n  arity(foo)"]}}}}function calcMedian$1(e){const t=[...e].sort((e,t)=>e-t),r=Math.floor(t.length/2);return t.length%2==0?(t[r-1]+t[r])/2:t[r]}const vectorNormalExpression={sum:{evaluate:([e],t)=>(assertVector(e,t),e.reduce((e,t)=>e+t,0)),arity:toFixedArity(1),docs:{category:"vector",returns:{type:"number"},args:{vector:{type:"vector",description:"The vector to sum."}},variants:[{argumentNames:["vector"]}],description:"Returns the **sum** of all elements in the `vector`. Returns `0` for an empty vector.",seeAlso:["prod","mean","median","vector.sum"],examples:["sum([1, 2, 3, 4, 5])","sum([1, -2, 3])","sum([])"]}},prod:{evaluate:([e],t)=>(assertVector(e,t),e.reduce((e,t)=>e*t,1)),arity:toFixedArity(1),docs:{category:"vector",returns:{type:"number"},args:{vector:{type:"vector",description:"The vector to multiply."}},variants:[{argumentNames:["vector"]}],description:"Returns the **product** of all elements in the `vector`. Returns `1` for an empty vector.",seeAlso:["sum","mean","median","vector.prod"],examples:["prod([1, 2, 3, 4, 5])","prod([1, -2, 3])","prod([])"]}},mean:{evaluate:([e],t)=>(assertNonEmptyVector(e,t),e.reduce((e,t)=>e+t,0)/e.length),arity:toFixedArity(1),docs:{category:"vector",returns:{type:"number"},args:{vector:{type:"vector",description:"The vector to calculate the mean of."}},variants:[{argumentNames:["vector"]}],description:"Returns the arithmetic **mean** of all elements in the `vector`. Throws for an empty vector.",seeAlso:["median","sum","prod","vector.mean"],examples:["mean([1, 2, 3, 4, 5])","mean([1, -2, 3])"]}},median:{evaluate:([e],t)=>(assertNonEmptyVector(e,t),calcMedian$1(e)),arity:toFixedArity(1),docs:{category:"vector",returns:{type:"number"},args:{vector:{type:"vector",description:"The vector to calculate the median of."}},variants:[{argumentNames:["vector"]}],description:"Returns the **median** of all elements in the `vector`. For even-length vectors, returns the average of the two middle values. Throws for an empty vector.",seeAlso:["mean","sum","prod","vector.median"],examples:["median([1, 2, 3, 4, 5])","median([1, 2, 3, 4])","median([3, 1, 4, 1, 5])"]}}},normalExpressionReference$1={};function setNormalExpressionReference(e){Object.assign(normalExpressionReference$1,e)}const expressions={...bitwiseNormalExpression,...collectionNormalExpression,...arrayNormalExpression,...sequenceNormalExpression,...mathNormalExpression,...getMetaNormalExpression(normalExpressionReference$1),...miscNormalExpression,...objectNormalExpression,...predicatesNormalExpression,...regexpNormalExpression,...stringNormalExpression,...functionalNormalExpression,...vectorNormalExpression};Object.entries(expressions).forEach(([e,t])=>{t.name=e});const normalExpressions={...expressions},normalExpressionTypes={},allNormalExpressions=[];Object.entries(normalExpressions).forEach(([e,t],r)=>{normalExpressionTypes[e]=r,allNormalExpressions.push(t)});const docs$f={category:"special-expression",returns:{type:"any"},args:{a:{type:"any"},b:{type:"any"},c:{type:"any",rest:!0}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","c"]}],description:"\nComputes logical `and`. Evaluation of expressions starts from left.\nAs soon as an `expression` evaluates to a falsy value, the result is returned.\n\nIf all expressions evaluate to truthy values, the value of the last expression is returned.",examples:["true && 1","&&(1, 1)",'&&(3 > 2, "string")','&&(3 < 2, "string")',"&&(true, true, true, true)","&&(true, true, 0, true)"]},andSpecialExpression={arity:{},docs:docs$f,evaluate:(e,t,{evaluateNode:r})=>reduceSequential(e[1][1],(e,n)=>e?r(n,t):e,!0),evaluateAsNormalExpression:(e,t)=>{let r=!0;for(const n of e)if(r=asAny(n,t),!r)break;return r},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1],t,n,o)},docs$e={category:"special-expression",customVariants:["cond cond-branch cond-branch ... end"],details:[["cond-branch","case test then body","A branch of the cond expression."],["test","expression","The condition to test."],["body","expressions","The expressions to evaluate if the test is truthy."]],description:"Used for branching. `cond-branches` are tested sequentially from the top. If no branch is tested truthy, `null` is returned.",examples:['\ncond\n  case false then write!("FALSE")\n  case true then write!("TRUE")\nend','\ncond\n  case false then write!("FALSE")\n  case null then write!("null")\nend ?? write!("TRUE")','\ncond\n  case false then write!("FALSE")\n  case null then write!("null")\nend ?? write!("TRUE")']},condSpecialExpression={arity:{},docs:docs$e,evaluate:(e,t,{evaluateNode:r})=>{const n=e[1][1];return function e(o){if(o>=n.length)return null;const[a,i]=n[o];return chain(r(a,t),n=>n?r(i,t):e(o+1))}(0)},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1].flat(),t,n,o)},docs$d={category:"special-expression",customVariants:["switch value switch-branch switch-branch ... end"],details:[["value","any","The value to test."],["switch-branch","case test then body","A branch of the switch expression."],["test","expression","The condition to test."],["body","expressions","The expressions to evaluate if the test is truthy."]],description:"Used for branching. `switch-branches` are tested sequentially from the top against `value`. If no branch is tested truthy, `null` is returned.",examples:['\nswitch 1\n  case 1 then write!("One")\n  case 2 then write!("Two")\nend','\nswitch 2\n  case 1 then write!("One")\n  case 2 then write!("Two")\nend','\nswitch 3\n  case 1 then write!("One")\n  case 2 then write!("Two")\nend']},switchSpecialExpression={arity:{},docs:docs$d,evaluate:(e,t,{evaluateNode:r})=>{const[,n,o]=e[1];return chain(r(n,t),e=>function n(a){if(a>=o.length)return null;const[i,s]=o[a];return chain(r(i,t),o=>o===e?r(s,t):n(a+1))}(0))},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r([e[1][1],...e[1][2].flat()],t,n,o)},docs$c={category:"special-expression",returns:{type:"boolean"},args:{symbol:{type:"any"}},variants:[{argumentNames:["symbol"]}],description:"Returns `true` if `symbol` is defined, `false` otherwise.\n\nBuilt-in symbols are always considered defined. For user-defined symbols, checks if the symbol exists in the current scope.",examples:["let x = 42; defined?(x)","defined?(x)","defined?(+)"]},definedSpecialExpression={arity:toFixedArity(1),docs:docs$c,evaluate:(e,t)=>{const r=e[1][1];if(assertSymbolNode(r),!isUserDefinedSymbolNode(r))return!0;return null!==t.lookUp(r)},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r([e[1][1]],t,n,o)};function isJsFunction(e){return"object"==typeof e&&null!==e&&"fn"in e&&"function"==typeof e.fn}const bindingTargetTypes={symbol:11,rest:12,object:13,array:14};function walkDefaults(e,t){if(e[0]===bindingTargetTypes.object)Object.values(e[1][0]).forEach(e=>{e[1][1]&&t(e[1][1]),walkDefaults(e,t)});else if(e[0]===bindingTargetTypes.array)for(let r=0;r<e[1][0].length;r+=1){const n=e[1][0][r]??null;null!==n&&(n[1][1]&&t(n[1][1]),walkDefaults(n,t))}}function evaluateBindingNodeValues(e,t,r){const n=e[2],o={};return chain(createRecord(e,t,r,n,o),()=>o)}function createRecord(e,t,r,n,o){if(e[0]===bindingTargetTypes.object){assertUnknownRecord(t,n);const a=new Set;let i;return chain(forEachSequential(Object.entries(e[1][0]),([e,s])=>{if(s[0]===bindingTargetTypes.rest)return void(i=s);a.add(e);const c=t[e];return chain(void 0!==c?c:s[1][1]?r(s[1][1]):null,e=>{const t=e??null;return assertAny(t,n),createRecord(s,t,r,n,o)})}),()=>{if(i){const e=Object.entries(t).filter(([e])=>!a.has(e)).reduce((e,[t,r])=>(e[t]=asAny(r),e),{});o[i[1][0]]=e}})}if(e[0]===bindingTargetTypes.array){let a=null;assertArray(t,n);const i=[];for(let t=0;t<e[1][0].length;t+=1){const r=e[1][0][t]??null;if(null!==r){if(r[0]===bindingTargetTypes.rest){a=t;break}i.push({element:r,index:t})}}return chain(forEachSequential(i,({element:e,index:a})=>{const i=t[a];return chain(void 0!==i?i:e[1][1]?r(e[1][1]):null,t=>{const a=t??null;return assertAny(a,n),createRecord(e,a,r,n,o)})}),()=>{if(null!==a){const r=t.slice(a),n=e[1][0][a];o[n[1][0]]=r}})}e[0]===bindingTargetTypes.rest?o[e[1][0]]=asAny(t):o[e[1][0][1]]=asAny(t)}function getAllBindingTargetNames(e){const t={};return getNamesFromBindingTarget(e,t),t}function getNamesFromBindingTarget(e,t){if(null!==e)if(e[0]===bindingTargetTypes.array)for(const r of e[1][0])getNamesFromBindingTarget(r,t);else if(e[0]===bindingTargetTypes.object)for(const r of Object.values(e[1][0]))getNamesFromBindingTarget(r,t);else if(e[0]===bindingTargetTypes.rest){if(t[e[1][0]])throw new LitsError(`Duplicate binding name: ${e[1][0]}`,e[2]);t[e[1][0]]=!0}else{if(t[e[1][0][1]])throw new LitsError(`Duplicate binding name: ${e[1][0]}`,e[2]);t[e[1][0][1]]=!0}}const defSpecialExpression={arity:{},evaluate:(e,t,{evaluateNode:r})=>{const n=e[1][1],o=n[1][0],a=n[1][1];return chain(r(a,t),e=>chain(evaluateBindingNodeValues(o,e,e=>r(e,t)),r=>(t.exportValues(r,o[2]),e)))},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>{const a=e[1][1],i=a[1][0],s=a[1][1],c=r([s],t,n,o);return walkDefaults(i,e=>{addToSet(c,r([e],t,n,o))}),t.addValues(getAllBindingTargetNames(i),i[2]),c}},docs$b={category:"special-expression",customVariants:["do body end"],details:[["body","expressions","The expressions to evaluate."]],description:"Evaluates `body`. Resulting value is the value of the last expression.",examples:["\ndo\n  let a = 1 + 2 + 3 + 4;\n  let b = -> $ * ( $ + 1 );\n  b(a)\nend"]},doSpecialExpression={arity:{},docs:docs$b,evaluate:(e,t,{evaluateNode:r})=>{const n=t.create({});return reduceSequential(e[1][1],(e,t)=>r(t,n),null)},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1],t.create({}),n,o)},lambdaSpecialExpression={arity:{},evaluate:(e,t,{builtin:r,getUndefinedSymbols:n,evaluateNode:o})=>{const a=e[1][1],i=e[1][2],s=evaluateFunction(a,t,r,n,o),c=s[0].filter(e=>e[0]!==bindingTargetTypes.rest&&void 0===e[1][1]).length,l={min:c>0?c:void 0,max:s[0].some(e=>e[0]===bindingTargetTypes.rest)?void 0:s[0].length};return{[FUNCTION_SYMBOL]:!0,sourceCodeInfo:e[2],functionType:"UserDefined",name:void 0,evaluatedfunction:s,arity:l,docString:i}},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>getFunctionUnresolvedSymbols(e[1][1],t,r,n,o)};function evaluateFunction(e,t,r,n,o){const a={},i=e[0].reduce((e,t)=>(Object.keys(getAllBindingTargetNames(t)).forEach(t=>{e[t]={value:null}}),e),{});n(e[1],t.new(i),r,o).forEach(e=>{const r=t.getValue(e);isAny(r)&&(a[e]={value:r})});return[e[0],e[1],a]}function getFunctionUnresolvedSymbols(e,t,r,n,o){const a=new Set,i={self:{value:null}};e[0].forEach(e=>{Object.assign(i,getAllBindingTargetNames(e)),walkDefaults(e,e=>{addToSet(a,r([e],t,n,o))})});const s=t.create(i),c=r(e[1],s,n,o);return addToSet(a,c),a}const docs$a={category:"special-expression",customVariants:["if test then true-expr else false-expr","if test then true-expr"],details:[["test","expression","The condition to test."],["true-expr","expression","The expression to evaluate if the test is truthy."],["false-expr","expression","The expression to evaluate if the test is falsy."]],description:"Either `true-expr` or `false-expr` branch is taken. `true-expr` is selected when $test is truthy. If $test is falsy `false-expr` is executed, if no `false-expr` exists, `null` is returned.",examples:['\nif true then\n  write!("TRUE")\nelse\n  write!("FALSE")\nend','if false then write!("TRUE") else write!("FALSE") end','if true then write!("TRUE") end','if false then write!("TRUE") end']},ifSpecialExpression={arity:{min:2,max:3},docs:docs$a,evaluate:(e,t,{evaluateNode:r})=>{const[n,o,a]=e[1][1];return chain(r(n,t),e=>e?r(o,t):a?r(a,t):null)},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1].filter(e=>!!e),t,n,o)},docs$9={category:"special-expression",customVariants:["unless test then true-expr else false-expr end","unless test true-expr end"],details:[["test","expression","The condition to test."],["true-expr","expression","The expressions to evaluate if the test is falsy."],["false-expr","expression","The expressions to evaluate if the test is truthy."]],description:"Either `true-expr` or `false-expr` branch is taken. `true-expr` is selected when $test is falsy. If $test is truthy `false-expr` is executed, if no `false-expr` exists, `null` is returned.",examples:['\nunless true then\n  write!("TRUE")\nelse\n  write!("FALSE")\nend','unless false then write!("TRUE") else write!("FALSE") end','unless true then write!("TRUE") end','unless false then write!("TRUE") end']},unlessSpecialExpression={arity:{},docs:docs$9,evaluate:(e,t,{evaluateNode:r})=>{const[n,o,a]=e[1][1];return chain(r(n,t),e=>e?a?r(a,t):null:r(o,t))},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1].filter(e=>!!e),t,n,o)},docs$8={category:"special-expression",customVariants:["let s = value;"],details:[["s","symbol","The name of the variable to bind."],["value","any","The value to bind to the variable."]],description:"\n  Binds local variables s to `value`. `value` can be any expression. The scope of the variables is the body of the let expression.",examples:['\nlet a = 1 + 2 + 3 + 4;\nlet b = -> $ * ( $ + 1 );\nwrite!("a", a, "b", b)']},letSpecialExpression={arity:toFixedArity(0),docs:docs$8,evaluate:(e,t,{evaluateNode:r})=>{const n=e[1][1],o=n[1][0],a=n[1][1];return chain(r(a,t),e=>chain(evaluateBindingNodeValues(o,e,e=>r(e,t)),r=>(t.addValues(r,o[2]),e)))},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>{const a=e[1][1],i=a[1][0],s=a[1][1],c=r([s],t,n,o);return walkDefaults(i,e=>{addToSet(c,r([e],t,n,o))}),t.addValues(getAllBindingTargetNames(i),i[2]),c}},docs$7={category:"special-expression",customVariants:["loop (bindings) -> body"],details:[["bindings","binding pairs","Comma-separated bindings with initial values, e.g. `n = 10, acc = 0`."],["body","expression","The expression to evaluate repeatedly. Use `recur` to loop back with new values."]],description:"Creates a loop with initial bindings. Use `recur` inside the body to jump back to the loop head with new binding values.\n\nIf `recur` is not called, the loop terminates and returns the value of the body expression.",examples:["loop (n = 10, acc = 0) -> do\n  if n == 0 then\n    acc\n  else\n    recur(n - 1, acc + n)\n  end\nend","loop (n = 5, acc = 1) -> do\n  if n <= 1 then\n    acc\n  else\n    recur(n - 1, acc * n)\n  end\nend"]},loopSpecialExpression={arity:{},docs:docs$7,evaluate:(e,t,{evaluateNode:r})=>{const n=e[1][1],o=reduceSequential(n,(e,n)=>chain(r(n[1][1],t.create(e)),o=>chain(evaluateBindingNodeValues(n[1][0],o,e=>r(e,t)),t=>(Object.entries(t).forEach(([t,r])=>{e[t]={value:r}}),e))),{});return chain(o,o=>{const a=t.create(o),i=e[1][2];function s(a){if(a.length!==n.length)throw new LitsError(`recur expected ${n.length} parameters, got ${valueToString(a.length)}`,e[2]);return chain(forEachSequential(n,(e,n)=>chain(evaluateBindingNodeValues(e[1][0],asAny(a[n]),e=>r(e,t)),e=>{for(const[t,r]of Object.entries(e))o[t].value=r})),()=>c())}function c(){return tryCatch(()=>r(i,a),e=>{if(e instanceof RecurSignal)return s(e.params);throw e})}for(;;)try{const e=r(i,a);return e instanceof Promise?e.catch(e=>{if(e instanceof RecurSignal)return s(e.params);throw e}):e}catch(a){if(a instanceof RecurSignal){const i=a.params;if(i.length!==n.length)throw new LitsError(`recur expected ${n.length} parameters, got ${valueToString(i.length)}`,e[2]);for(let e=0;e<n.length;e+=1){const a=evaluateBindingNodeValues(n[e][1][0],asAny(i[e]),e=>r(e,t));if(a instanceof Promise)return a.then(a=>{for(const[e,t]of Object.entries(a))o[e].value=t;return chain(forEachSequential(n.slice(e+1),(n,a)=>chain(evaluateBindingNodeValues(n[1][0],asAny(i[e+1+a]),e=>r(e,t)),e=>{for(const[t,r]of Object.entries(e))o[t].value=r})),()=>c())});for(const[e,t]of Object.entries(a))o[e].value=t}continue}throw a}})},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>{const a=e[1][1],i=a.reduce((e,t)=>{const r=getAllBindingTargetNames(t[1][0]);return Object.keys(r).forEach(t=>{e[t]={value:!0}}),e},{});return joinSets(r(a.map(e=>e[1][1]),t,n,o),r([e[1][2]],t.create(i),n,o))}};function addToContext(e,t,r,n){let o;for(const a of e)o=chain(o,()=>{const[e,o]=a[1];return chain(n(o,r),o=>chain(evaluateBindingNodeValues(e,o,e=>n(e,r)),e=>{Object.entries(e).forEach(([e,r])=>{t[e]={value:r}})}))});return o}function evaluateLoop(e,t,r,n){const o=t[2],[,a,i]=t[1],s=[],c=a.map(()=>0);return function t(){const l={},u=r.create(l);return chain(function e(t){if(t>=a.length)return"continue";const[r,i,s,m]=a[t],[p,d]=r[1];return chain(n(d,u),r=>{const a=asColl(r,o),d=isSeq(a)?a:Object.entries(a);if(0===d.length)return"abort";const g=asNonUndefined(c[t],o);if(g>=d.length)return 0===t?"abort":(c[t]=0,c[t-1]=asNonUndefined(c[t-1],o)+1,"skip");const h=asAny(d[g],o);return chain(evaluateBindingNodeValues(p,h,e=>n(e,u)),r=>(Object.entries(r).forEach(([e,t])=>{l[e]={value:t}}),chain(i.length>0?addToContext(i,l,u,n):void 0,()=>s?chain(n(s,u),r=>r?m?chain(n(m,u),r=>r?e(t+1):(c[t]=Number.POSITIVE_INFINITY,"skip")):e(t+1):(c[t]=asNonUndefined(c[t],o)+1,"skip")):m?chain(n(m,u),r=>r?e(t+1):(c[t]=Number.POSITIVE_INFINITY,"skip")):e(t+1))))})}(0),r=>"abort"===r?e?s:null:"skip"===r?t():chain(n(i,u),r=>(e&&s.push(r),c.length>0&&(c[c.length-1]+=1),t())))}()}function analyze$1(e,t,r,n,o){const a=new Set,i={},[,s,c]=e[1];return s.forEach(e=>{const[s,c,l,u]=e,[m,p]=s[1];r([p],t.create(i),n,o).forEach(e=>a.add(e)),Object.assign(i,getAllBindingTargetNames(m)),c&&c.forEach(e=>{const[s,c]=e[1];r([c],t.create(i),n,o).forEach(e=>a.add(e)),Object.assign(i,getAllBindingTargetNames(s))}),l&&r([l],t.create(i),n,o).forEach(e=>a.add(e)),u&&r([u],t.create(i),n,o).forEach(e=>a.add(e))}),r([c],t.create(i),n,o).forEach(e=>a.add(e)),a}const forDocs={category:"special-expression",customVariants:["for (...binding) -> body"],details:[["binding","loop-var in collection [...let-binding] [where whereExpr] [while whileExp]","A for loop binding"],["loop-var","symbol","The name of the loop variable."],["collection","any","The collection to iterate over."],["let-binding","let binding","A let binding to create a local variable."],["whereExpr","expression","An expression that must evaluate to truthy for the loop body to be executed."],["whileExp","expression","An expression that must evaluate to truthy for the loop to continue."],["body","expressions","The expressions to evaluate for each iteration of the loop."]],returns:{type:"any",array:!0},description:"Iterates over `bindings`, evaluates `body` for each `binding` and returns an `array` of results.",examples:["\nfor (i in [1, 2, 3]) -> i * 2\n      ","\nfor (\n  i in range(10) let ii = i ^ 2 while ii < 40 when ii % 3 == 0,\n  j in range(10) when j % 2 == 1\n) -> ii + j\n      "]},forSpecialExpression={arity:toFixedArity(1),docs:forDocs,evaluate:(e,t,r)=>evaluateLoop(!0,e,t,r.evaluateNode),getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>analyze$1(e,t,r,n,o)},doseqDocs={category:"special-expression",customVariants:["doseq (...binding) -> body"],details:[["binding","loop-var in collection [...let-binding] [where whereExpr] [while whileExp]","A doseq loop binding"],["loop-var","symbol","The name of the loop variable."],["collection","any","The collection to iterate over."],["let-binding","let binding","A let binding to create a local variable."],["whereExpr","expression","An expression that must evaluate to truthy for the loop body to be executed."],["whileExp","expression","An expression that must evaluate to truthy for the loop to continue."],["body","expressions","The expressions to evaluate for each iteration of the loop."]],returns:{type:"null"},description:"Iterates over `bindings`, evaluates `body` for each `binding` and returns `null`. This is useful for side effects.",examples:["\ndoseq (i in [1, 2, 3]) -> write!(i * 2)\n      "]},doseqSpecialExpression={arity:toFixedArity(1),docs:doseqDocs,evaluate:(e,t,r)=>chain(evaluateLoop(!1,e,t,r.evaluateNode),()=>null),getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>analyze$1(e,t,r,n,o)},docs$6={category:"special-expression",returns:{type:"boolean"},args:{a:{type:"any"},b:{type:"any"},c:{type:"any",rest:!0}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","c"]}],description:"\n  Computes logical `or`. Evaluation of expressions evaluation starts from left.\n  As soon as a `expression` evaluates to a truthy value, the result is returned.\n\n  If all expressions evaluate to falsy values, the value of the last expression is returned.",examples:["false || 1","||(1, 1)",'||(3 > 2, "string")','||(3 < 2, "string")',"||(false, false, false, true)","||(1, 2, 3, 4)"]},orSpecialExpression={arity:{},docs:docs$6,evaluate:(e,t,{evaluateNode:r})=>reduceSequential(e[1][1],(e,n)=>e||r(n,t),!1),evaluateAsNormalExpression:(e,t)=>{let r=!1;for(const n of e)if(r=asAny(n,t),r)break;return r},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1],t,n,o)},docs$5={category:"special-expression",returns:{type:"any"},args:{a:{type:"any"},b:{type:"any"},c:{type:"any",rest:!0}},variants:[{argumentNames:["a"]},{argumentNames:["a","b"]},{argumentNames:["a","b","c"]}],description:"Nullish coalescing operator. Returns the first non-`null` value.\n\nEvaluation is short-circuited — as soon as a non-`null` value is found, the remaining expressions are not evaluated.\n\nIf all values are `null`, returns `null`.\n\nAlso works with undefined symbols — if a symbol is undefined, it is treated as `null`.",examples:["1 ?? 2","null ?? 2","??(null)",'??(null, "default")','??(1, "default")','false ?? "default"',"??(null, null, 3)"]},qqSpecialExpression={arity:{min:1},docs:docs$5,evaluate:(e,t,{evaluateNode:r})=>{const n=Symbol("qq-sentinel");return chain(reduceSequential(e[1][1],(e,o)=>e!==n?e:isUserDefinedSymbolNode(o)&&null===t.lookUp(o)?n:chain(r(o,t),e=>null!==e?e:n),n),e=>e===n?null:e)},evaluateAsNormalExpression:(e,t)=>{for(const r of e){const e=asAny(r,t);if(null!==e)return e}return null},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1],t,n,o)},docs$4={category:"special-expression",customVariants:["recur(...recur-args)"],description:"Recursevly calls enclosing function or loop with its evaluated `recur-args`.",examples:["\nlet foo = (n) -> do\n  write!(n);\n  if not(zero?(n)) then\n    recur(n - 1)\n  end\nend;\nfoo(3)","\n(n -> do\n  write!(n);\n  if not(zero?(n)) then\n    recur(n - 1)\n  end\nend)(3)","\nloop (n = 3) -> do\n  write!(n);\n  if not(zero?(n)) then\n    recur(n - 1)\n  end\nend"]},recurSpecialExpression={arity:{},docs:docs$4,evaluate:(e,t,{evaluateNode:r})=>chain(mapSequential(e[1][1],e=>r(e,t)),e=>{throw new RecurSignal(e)}),evaluateAsNormalExpression:e=>{throw new RecurSignal(e)},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1],t,n,o)},docs$3={category:"special-expression",returns:{type:"never"},args:{expr:{type:"any"}},variants:[{argumentNames:["expr"]}],description:"Throws `UserDefinedError` with message set to $expr evaluated. $expr must evaluate to a string.",examples:['try throw("You shall not pass!") catch(error) "Error: " ++ error.message end','try throw(slice("You shall not pass!", 0, 3)) catch(error) "Error: " ++ error.message end']},throwSpecialExpression={arity:toFixedArity(1),docs:docs$3,evaluate:(e,t,{evaluateNode:r})=>chain(r(e[1][1],t),t=>{const r=asString(t,e[2],{nonEmpty:!0});throw new UserDefinedError(r,e[2])}),evaluateAsNormalExpression:(e,t)=>{const r=asString(e[0],t,{nonEmpty:!0});throw new UserDefinedError(r,void 0)},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r([e[1][1]],t,n,o)},docs$2={category:"special-expression",customVariants:["try { try-body } catch { catch-body }","try { try-body } catch(error) { catch-body }"],details:[["try-body","expressions","The expressions to try."],["error","symbol","The error variable to bind."],["catch-body","expression","The expressions to evaluate if the try-body throws an error."]],description:"Executes `try-body`. If that throws, the `catch-body` gets executed. See examples for details.",examples:['\ntry\n  2 / 4\ncatch\n  "Oops!"\nend','\ntry\n  foo()\ncatch(error)\n  "Error: " ++ error.message\nend',"\ntry\n  foo()\ncatch\n  42\nend"]},trySpecialExpression={arity:{},docs:docs$2,evaluate:(e,t,{evaluateNode:r})=>{const[,n,o,a]=e[1];return tryCatch(()=>r(n,t),e=>{const n=o?{[o[1]]:{value:e}}:{};return r(a,t.create(n))})},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>{const[,a,i,s]=e[1],c=r([a],t,n,o),l=i?{[i[1]]:{value:!0}}:{};return joinSets(c,r([s],t.create(l),n,o))}},docs$1={category:"special-expression",returns:{type:"any",array:!0},args:{values:{type:"any",rest:!0}},variants:[{argumentNames:["values"]}],description:"Makes new array from $values.",examples:["array(1, 2, 3)","array(array(null, false, true))","[]","[1, 2, 3]","[1, 2, ...[3, 4, 5], 6]","[[null, false, true]]","[1, 2, 3][1]"],hideOperatorForm:!0},arraySpecialExpression={arity:{},docs:docs$1,evaluate:(e,t,{evaluateNode:r})=>{const n=[];return chain(forEachSequential(e[1][1],e=>isSpreadNode(e)?chain(r(e[1],t),t=>{if(!Array.isArray(t))throw new LitsError("Spread value is not an array",e[2]);n.push(...t)}):chain(r(e,t),e=>{n.push(e)})),()=>n)},evaluateAsNormalExpression:(e,t)=>{const r=[];for(const n of e)r.push(asAny(n,t));return r},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1],t,n,o)},docs={category:"special-expression",returns:{type:"object"},args:{kvps:{type:"any",rest:!0,description:"key - value pairs, where key is a string"}},variants:[{argumentNames:["kvps"]}],description:"Constructs a new object. Object members are created from the $kvps key-value pairs. Requires an even number of arguments.",examples:["object()",'\nlet default = {\n  type: "Person",\n  name: "John Doe",\n  age: 42\n};\n\n{\n  ...default,\n  name: "Lisa"\n}','object("x", 10, "y", true, "z", "A string")',"{}","{ a: 1, b: 2 }"],hideOperatorForm:!0},objectSpecialExpression={arity:{},docs:docs,evaluate:(e,t,{evaluateNode:r})=>{const n={},o=e[1][1];return function e(a){if(a>=o.length)return n;const i=o[a];if(isSpreadNode(i))return chain(r(i[1],t),t=>{if(!isUnknownRecord(t))throw new LitsError("Spread value is not an object",i[2]);return Object.assign(n,t),e(a+1)});{const s=o[a+1];if(void 0===s)throw new LitsError("Missing value for key",i[2]);return chain(r(i,t),o=>chain(r(s,t),t=>(assertString(o,i[2]),n[o]=t,e(a+2))))}}(0)},evaluateAsNormalExpression:(e,t)=>{const r={};for(let n=0;n<e.length;n+=2){const o=e[n],a=e[n+1];assertString(o,t),r[o]=a??null}return r},getUndefinedSymbols:(e,t,{getUndefinedSymbols:r,builtin:n,evaluateNode:o})=>r(e[1][1],t,n,o)},specialExpressions=[qqSpecialExpression,andSpecialExpression,orSpecialExpression,arraySpecialExpression,condSpecialExpression,defSpecialExpression,definedSpecialExpression,doSpecialExpression,doseqSpecialExpression,lambdaSpecialExpression,forSpecialExpression,ifSpecialExpression,letSpecialExpression,loopSpecialExpression,objectSpecialExpression,recurSpecialExpression,switchSpecialExpression,throwSpecialExpression,trySpecialExpression,unlessSpecialExpression],builtin={normalExpressions:normalExpressions,specialExpressions:specialExpressions,allNormalExpressions:allNormalExpressions},normalExpressionKeys=Object.keys(normalExpressions),specialExpressionKeys=Object.keys(specialExpressionTypes),nonNumberReservedSymbolRecord={true:!0,false:!1,null:null,do:null,else:null,case:null,each:null,in:null,when:null,while:null,catch:null,function:null,export:null,as:null,then:null,end:null,_:null},phi=(1+Math.sqrt(5))/2,numberReservedSymbolRecord={E:Math.E,"-E":-Math.E,"ε":Math.E,"-ε":-Math.E,PI:Math.PI,"-PI":-Math.PI,"π":Math.PI,"-π":-Math.PI,PHI:phi,"-PHI":-phi,"φ":phi,"-φ":-phi,POSITIVE_INFINITY:Number.POSITIVE_INFINITY,"∞":Number.POSITIVE_INFINITY,NEGATIVE_INFINITY:Number.NEGATIVE_INFINITY,"-∞":Number.NEGATIVE_INFINITY,MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER,MIN_SAFE_INTEGER:Number.MIN_SAFE_INTEGER,MAX_VALUE:Number.MAX_VALUE,MIN_VALUE:Number.MIN_VALUE,NaN:Number.NaN},reservedSymbolRecord={...nonNumberReservedSymbolRecord,...numberReservedSymbolRecord};function isNumberReservedSymbol(e){return e in numberReservedSymbolRecord}const functionExecutors={NativeJsFunction:(e,t,r)=>{try{const n=e.nativeFn.fn(...t);return n instanceof Promise?n.then(e=>toAny(e),e=>{const t="string"==typeof e?e:isUnknownRecord(e)&&"string"==typeof e.message?e.message:"<no message>";throw new LitsError(`Native function threw: "${t}"`,r)}):toAny(n)}catch(e){const t="string"==typeof e?e:isUnknownRecord(e)&&"string"==typeof e.message?e.message:"<no message>";throw new LitsError(`Native function threw: "${t}"`,r)}},UserDefined:(e,t,r,n,{evaluateNode:o})=>{function a(t){if(!arityAcceptsMin(e.arity,t.length))throw new LitsError(`Expected ${e.arity} arguments, got ${t.length}.`,r);const i=e.evaluatedfunction,s=i[0],c=s.filter(e=>e[0]!==bindingTargetTypes.rest).length,l=n.create(e.evaluatedfunction[2]),u={self:{value:e}},m=[];let p,d;for(let e=0;e<t.length;e+=1)if(e<c){const r=e;p=chain(p,()=>{const e=toAny(t[r]);return chain(evaluateBindingNodeValues(s[r],e,e=>o(e,l.create(u))),e=>{Object.entries(e).forEach(([e,t])=>{u[e]={value:t}})})})}else m.push(toAny(t[e]));for(let e=t.length;e<c;e++){const t=e;d=chain(d,()=>{const e=s[t];return chain(o(e[1][1],n.create(u)),t=>chain(evaluateBindingNodeValues(e,t,e=>o(e,n.create(u))),e=>{Object.entries(e).forEach(([e,t])=>{u[e]={value:t}})}))})}return chain(p,()=>chain(d,()=>{const e=s.find(e=>e[0]===bindingTargetTypes.rest),t=void 0!==e?chain(evaluateBindingNodeValues(e,m,e=>o(e,n.create(u))),e=>{Object.entries(e).forEach(([e,t])=>{u[e]={value:t}})}):void 0;return chain(t,()=>{const e=l.create(u),t=reduceSequential(i[1],(t,r)=>o(r,e),null);return t instanceof Promise?t.catch(e=>{if(e instanceof RecurSignal)return a(e.params);throw e}):t})}))}for(;;)try{return a(t)}catch(e){if(e instanceof RecurSignal){t=e.params;continue}throw e}},Partial:(e,t,r,n,{executeFunction:o})=>{const a=[...e.params];if(t.length!==e.placeholders.length)throw new LitsError(`(partial) expects ${e.placeholders.length} arguments, got ${t.length}.`,r);const i=[...t];for(const t of e.placeholders)a.splice(t,0,i.shift());return o(e.function,a,n,r)},Comp:(e,t,r,n,{executeFunction:o})=>{const{params:a}=e;if(0===a.length){if(1!==t.length)throw new LitsError(`(comp) expects one argument, got ${valueToString(t.length)}.`,r);return asAny(t[0],r)}let i=t;for(let e=a.length-1;e>=0;e--){const t=a[e];i=chain(i,e=>chain(o(asFunctionLike(t,r),e,n,r),e=>[e]))}return chain(i,e=>asAny(e[0],r))},Constantly:e=>e.value,Juxt:(e,t,r,n,{executeFunction:o})=>mapSequential(e.params,e=>o(asFunctionLike(e,r),t,n,r)),Complement:(e,t,r,n,{executeFunction:o})=>chain(o(e.function,t,n,r),e=>!e),EveryPred:(e,t,r,n,{executeFunction:o})=>{const a=[];for(const i of e.params)for(const e of t)a.push(()=>o(asFunctionLike(i,r),[e],n,r));return reduceSequential(a,(e,t)=>!!e&&chain(t(),e=>!!e),!0)},SomePred:(e,t,r,n,{executeFunction:o})=>{const a=[];for(const i of e.params)for(const e of t)a.push(()=>o(asFunctionLike(i,r),[e],n,r));return reduceSequential(a,(e,t)=>!!e||chain(t(),e=>!!e),!1)},Fnull:(e,t,r,n,{executeFunction:o})=>{const a=t.map((t,r)=>null===t?toAny(e.params[r]):t);return o(asFunctionLike(e.function,r),a,n,r)},Builtin:(e,t,r,n,{executeFunction:o})=>asNonUndefined(allNormalExpressions[e.normalBuiltinSymbolType],r).evaluate(t,r,n,{executeFunction:o}),SpecialBuiltin:(e,t,r,n,{executeFunction:o})=>{const a=asNonUndefined(specialExpressions[e.specialBuiltinSymbolType],r);if(a.evaluateAsNormalExpression)return a.evaluateAsNormalExpression(t,r,n,{executeFunction:o});throw new LitsError(`Special builtin function ${e.specialBuiltinSymbolType} is not supported as normal expression.`,r)},Module:(e,t,r,n,{executeFunction:o})=>{const a=n.getModule(e.moduleName);if(!a)throw new LitsError(`Module '${e.moduleName}' not found.`,r);const i=a.functions[e.functionName];if(!i)throw new LitsError(`Function '${e.functionName}' not found in module '${e.moduleName}'.`,r);return assertNumberOfParams(i.arity,t.length,r),i.evaluate(t,r,n,{executeFunction:o})}};function evaluate(e,t){return reduceSequential(e.body,(e,r)=>evaluateNode(r,t),null)}function evaluateNode(e,t){switch(e[0]){case NodeTypes.Number:return evaluateNumber(e);case NodeTypes.String:return evaluateString(e);case NodeTypes.NormalBuiltinSymbol:case NodeTypes.SpecialBuiltinSymbol:case NodeTypes.UserDefinedSymbol:return t.evaluateSymbol(e);case NodeTypes.ReservedSymbol:return evaluateReservedSymbol(e);case NodeTypes.NormalExpression:return chain(evaluateNormalExpression(e,t),t=>{if("number"==typeof t&&Number.isNaN(t))throw new LitsError("Number is NaN",e[2]);return annotate(t)});case NodeTypes.SpecialExpression:return chain(evaluateSpecialExpression(e,t),e=>annotate(e));default:throw new LitsError(`${getNodeTypeName(e[0])}-node cannot be evaluated`,e[2])}}function evaluateNumber(e){return e[1]}function evaluateString(e){return e[1]}function evaluateReservedSymbol(e){const t=e[1];if(!["true","false","null"].includes(t))throw new LitsError(`Reserved symbol ${t} cannot be evaluated`,e[2]);return asNonUndefined(reservedSymbolRecord[t],e[2])}function evaluateParams(e,t){const r=[],n=[],o=forEachSequential(e,(e,o)=>isSpreadNode(e)?chain(evaluateNode(e[1],t),t=>{if(!Array.isArray(t))throw new LitsError(`Spread operator requires an array, got ${valueToString(e)}`,e[2]);r.push(...t)}):e[0]!==NodeTypes.ReservedSymbol||"_"!==e[1]?chain(evaluateNode(e,t),e=>{r.push(e)}):void n.push(o));return chain(o,()=>({params:r,placeholders:n}))}function evaluateNormalExpression(e,t){const r=e[2];return chain(evaluateParams(e[1][1],t),({params:n,placeholders:o})=>{if(isNormalExpressionNodeWithName(e)){const a=e[1][0];if(o.length>0){return chain(evaluateNode(a,t),e=>({[FUNCTION_SYMBOL]:!0,function:asFunctionLike(e,r),functionType:"Partial",params:n,placeholders:o,sourceCodeInfo:r,arity:toFixedArity(o.length)}))}if(isNormalBuiltinSymbolNode(a)){const r=a[1];return builtin.allNormalExpressions[r].evaluate(n,e[2],t,{executeFunction:executeFunction})}{const o=t.getValue(a[1]);if(void 0!==o)return executeFunction(asFunctionLike(o,r),n,t,r);throw new UndefinedSymbolError(a[1],e[2])}}return chain(evaluateNode(e[1][0],t),e=>{const a=asFunctionLike(e,r);if(o.length>0){return{[FUNCTION_SYMBOL]:!0,function:a,functionType:"Partial",params:n,placeholders:o,sourceCodeInfo:r,arity:toFixedArity(o.length)}}return executeFunction(a,n,t,r)})})}function executeFunction(e,t,r,n){if(isLitsFunction(e))return functionExecutors[e.functionType](e,t,n,r,{evaluateNode:evaluateNode,executeFunction:executeFunction});if(Array.isArray(e))return evaluateArrayAsFunction(e,t,n);if(isObj(e))return evalueateObjectAsFunction(e,t,n);if("string"==typeof e)return evaluateStringAsFunction(e,t,n);if(isNumber(e))return evaluateNumberAsFunction(e,t,n);throw new LitsError("Unexpected function type",n)}function evaluateSpecialExpression(e,t){const r=e[1][0];return(0,asNonUndefined(builtin.specialExpressions[r],e[2]).evaluate)(e,t,{evaluateNode:evaluateNode,builtin:builtin,getUndefinedSymbols:getUndefinedSymbols})}function evalueateObjectAsFunction(e,t,r){if(1!==t.length)throw new LitsError("Object as function requires one string parameter.",r);const n=t[0];return assertString(n,r),toAny(e[n])}function evaluateArrayAsFunction(e,t,r){if(1!==t.length)throw new LitsError("Array as function requires one non negative integer parameter.",r);const n=t[0];return assertNumber(n,r,{integer:!0,nonNegative:!0}),toAny(e[n])}function evaluateStringAsFunction(e,t,r){if(1!==t.length)throw new LitsError("String as function requires one Obj parameter.",r);const n=toAny(t[0]);if(isObj(n))return toAny(n[e]);if(isNumber(n,{integer:!0}))return toAny(e[n]);throw new LitsError(`string as function expects Obj or integer parameter, got ${valueToString(n)}`,r)}function evaluateNumberAsFunction(e,t,r){if(assertNumber(e,r,{integer:!0}),1!==t.length)throw new LitsError("Number as function requires one Arr parameter.",r);const n=t[0];return assertSeq(n,r),toAny(n[e])}function isContextEntry(e){return isUnknownRecord(e)&&void 0!==e.value}class ContextStackImpl{contexts;globalContext;values;nativeJsFunctions;modules;constructor({contexts:e,values:t,nativeJsFunctions:r,modules:n}){this.globalContext=asNonUndefined(e[0]),this.contexts=e,this.values=t,this.nativeJsFunctions=r,this.modules=n??new Map}getModule(e){return this.modules.get(e)}create(e){const t=this.globalContext,r=new ContextStackImpl({contexts:[e,...this.contexts],values:this.values,nativeJsFunctions:this.nativeJsFunctions,modules:this.modules});return r.globalContext=t,r}new(e){return new ContextStackImpl({contexts:[{},e],modules:this.modules})}exportValues(e,t){for(const[r,n]of Object.entries(e)){if(this.globalContext[r])throw new LitsError(`Cannot redefine exported value "${r}"`,t);const e=getShadowedBuiltinName(r);if(e)throw new LitsError(`Cannot shadow ${e}`,t);this.globalContext[r]={value:n}}this.contexts[0]!==this.globalContext&&this.addValues(e,t)}addValues(e,t){const r=this.contexts[0];for(const[n,o]of Object.entries(e)){if(r[n])throw new LitsError(`Cannot redefine value "${n}"`,t);const e=getShadowedBuiltinName(n);if(e)throw new LitsError(`Cannot shadow ${e}`,t);r[n]={value:toAny(o)}}}getValue(e){for(const t of this.contexts){const r=t[e];if(r)return r.value}const t=this.nativeJsFunctions?.[e];return t||this.values?.[e]}lookUp(e){const t=e[1];for(const e of this.contexts){const r=e[t];if(r)return r}const r=this.values?.[t];if(void 0!==r)return{value:toAny(r)};const n=this.nativeJsFunctions?.[t];return n?{value:n}:null}evaluateSymbol(e){if(isSpecialBuiltinSymbolNode(e)){const t=e[1];switch(t){case specialExpressionTypes["&&"]:case specialExpressionTypes["||"]:case specialExpressionTypes.array:case specialExpressionTypes.object:case specialExpressionTypes["defined?"]:case specialExpressionTypes.recur:case specialExpressionTypes.throw:case specialExpressionTypes["??"]:{const r=asNonUndefined(builtin.specialExpressions[t],e[2]);return{[FUNCTION_SYMBOL]:!0,functionType:"SpecialBuiltin",specialBuiltinSymbolType:t,sourceCodeInfo:e[2],arity:r.arity}}default:throw new LitsError(`Unknown special builtin symbol type: ${t}`,e[2])}}if(isNormalBuiltinSymbolNode(e)){const t=e[1],r=allNormalExpressions[t],n=r.name;return{[FUNCTION_SYMBOL]:!0,functionType:"Builtin",normalBuiltinSymbolType:t,sourceCodeInfo:e[2],arity:r.arity,name:n}}const t=this.lookUp(e);if(isContextEntry(t))return t.value;throw new UndefinedSymbolError(e[1],e[2])}}function getShadowedBuiltinName(e){return specialExpressionKeys.includes(e)?`special expression "${e}"`:normalExpressionKeys.includes(e)?`builtin function "${e}"`:"self"===e?`builtin value "${e}"`:null}function assertNotShadowingBuiltin(e){const t=getShadowedBuiltinName(e);if(t)throw new LitsError(`Cannot shadow ${t}`,void 0)}function createContextStack(e={},t){const r=e.globalContext??{},n=e.contexts?[r,...e.contexts]:[r];let o,a;if(e.bindings)for(const[t,r]of Object.entries(e.bindings)){const e="function"==typeof r,n=isJsFunction(r);if(e||n){const e=n?r:{fn:r},o=t.split("."),i=o.pop();if(/^[A-Z]/.test(i))throw new LitsError(`Invalid identifier "${t}" in bindings, function name must not start with an uppercase letter`,void 0);if(o.length>0){a||(a={});let r=a;for(const e of o){if(0===e.length)throw new LitsError(`Invalid empty identifier "${t}" in bindings`,void 0);if(!/^[A-Z]/.test(e))throw new LitsError(`Invalid identifier "${t}" in bindings, module name must start with an uppercase letter`,void 0);r[e]||(r[e]={}),r=r[e]}r[i]={functionType:"NativeJsFunction",nativeFn:e,name:i,[FUNCTION_SYMBOL]:!0,arity:e.arity??{},docString:e.docString??""}}else assertNotShadowingBuiltin(i),a||(a={}),a[i]={functionType:"NativeJsFunction",nativeFn:e,name:i,[FUNCTION_SYMBOL]:!0,arity:e.arity??{},docString:e.docString??""}}else o||(o={}),o[t]=r}const i=new ContextStackImpl({contexts:n,values:o,modules:t,nativeJsFunctions:a});return e.globalModuleScope?i:i.create({})}const binaryOperators=["^","*","/","%","+","-","<<",">>",">>>","++","<","<=","≤",">",">=","≥","==","!=","!=","&","xor","|","&&","||","??","|>"],otherOperators=["?",":","->","...",".",",","=",":",";"],symbolicOperators=[...binaryOperators,...otherOperators],nonFunctionOperators=["comment","cond","def","defined?","block","doseq","if","let","loop","recur","throw","try","unless","while"],nonFunctionOperatorSet=new Set(nonFunctionOperators);function isFunctionOperator(e){return!nonFunctionOperatorSet.has(e)}const binaryOperatorSet=new Set(binaryOperators);function isBinaryOperator(e){return binaryOperatorSet.has(e)}const symbolicOperatorSet=new Set(symbolicOperators);function isSymbolicOperator(e){return symbolicOperatorSet.has(e)}const illegalSymbolCharacters=["(",")","[","]","{","}","'",'"',"`",",",".",";"," ","\n","\r","\t"],illegalFirstSymbolCharacters=["0","1","2","3","4","5","6","7","8","9",...illegalSymbolCharacters],illegalSymbolCharacterSet=new Set(illegalSymbolCharacters),illegalFirstSymbolCharacterSet=new Set(illegalFirstSymbolCharacters),whitespaceRegExp=/\s/,NO_MATCH=[0],tokenizeLParen=(e,t)=>tokenizeToken("LParen","(",e,t),tokenizeRParen=(e,t)=>tokenizeToken("RParen",")",e,t),tokenizeLBracket=(e,t)=>tokenizeToken("LBracket","[",e,t),tokenizeRBracket=(e,t)=>tokenizeToken("RBracket","]",e,t),tokenizeLBrace=(e,t)=>tokenizeToken("LBrace","{",e,t),tokenizeRBrace=(e,t)=>tokenizeToken("RBrace","}",e,t),tokenizeDocString=(e,t)=>{if('"'!==e[t]||'"'!==e[t+1]||'"'!==e[t+2])return NO_MATCH;let r='"""',n=3,o=e[t+n],a=e.slice(t+n,t+n+3),i=!1;for(;o&&('"""'!==a||i);)n+=1,i?(i=!1,r+=o):("\\"===o&&(i=!0),r+=o),o=e[t+n],a=e.slice(t+n,t+n+3);return o?(r+='"""',[n+3,["DocString",r]]):[n,["Error",r,void 0,`Unclosed doc string at position ${t}`]]},tokenizeString=(e,t)=>{if('"'!==e[t])return NO_MATCH;let r='"',n=1,o=e[t+n],a=!1;for(;o&&('"'!==o||a);)n+=1,a?(a=!1,r+=o):("\\"===o&&(a=!0),r+=o),o=e[t+n];return o?(r+='"',[n+1,["string",r]]):[n,["Error",r,void 0,`Unclosed string at position ${t}`]]},tokenizeRegexpShorthand=(e,t)=>{if("#"!==e[t])return NO_MATCH;const[r,n]=tokenizeString(e,t+1);if(!n)return NO_MATCH;if("Error"===n[0]){return[r+1,["Error",`#${n[1]}`,void 0,`Unclosed regexp at position ${t}`]]}t+=r+1;let o=r+1,a="";for(;"g"===e[t]||"i"===e[t];)if(a+=e[t],o+=1,t+=1,a.includes(e[t]))return[o,["Error",`#${n[1]}${a}`,void 0,`Duplicated regexp option "${e[t]}"`]];return[o,["RegexpShorthand",`#${n[1]}${a}`]]};function tokenizeToken(e,t,r,n){return t===r.slice(n,n+t.length)?[t.length,[e,t]]:NO_MATCH}const tokenizeWhitespace=(e,t)=>{let r=e[t];if(!r||!whitespaceRegExp.test(r))return NO_MATCH;let n=r;for(r=e[t+=1];r&&whitespaceRegExp.test(r);)n+=r,r=e[t+=1];return[n.length,["Whitespace",n]]},decimalNumberRegExp=/\d/,octalNumberRegExp=/[0-7]/,hexNumberRegExp=/[0-9a-f]/i,binaryNumberRegExp=/[01]/,postNumberRegExp=/[\s)\]}(,;]/,tokenizeNumber=(e,t)=>{let r;const n="-"===e[t],o="+"===e[t],a=n||o?t+1:t;let i=!1,s=!1;for(r=a;r<e.length;r+=1){const n=e[r];if("_"===n){if(!decimalNumberRegExp.test(e[r-1])||!decimalNumberRegExp.test(e[r+1]))return r===a?NO_MATCH:[r-t+1,["Error",e.substring(t,r+1),void 0,`Invalid number format at position ${r+1}`]]}else if("."===n){if(r===a)return NO_MATCH;if(i||s)return[r-t+1,["Error",e.substring(t,r+1),void 0,`Invalid number format at position ${r+1}`]];i=!0}else if("e"===n||"E"===n){if(r===a)return NO_MATCH;if(s)return[r-t+1,["Error",e.substring(t,r+1),void 0,`Invalid number format at position ${r+1}`]];if("."===e[r-1]||"+"===e[r-1]||"-"===e[r-1])return[r-t+1,["Error",e.substring(t,r+1),void 0,`Invalid number format at position ${r+1}`]];"+"!==e[r+1]&&"-"!==e[r+1]||(r+=1),s=!0}else if(!decimalNumberRegExp.test(n))break}if((n||o)&&r===a)return NO_MATCH;const c=r-t;if(0===c)return NO_MATCH;const l=e[r];return l&&":"!==l&&!postNumberRegExp.test(l)?[r-t+1,["Error",e.substring(t,r+1),void 0,`Invalid number format at position ${r+1}`]]:[c,["Number",e.substring(t,r)]]},tokenizeBasePrefixedNumber=(e,t)=>{if("0"!==e[t])return NO_MATCH;const r=e[t+1],n="b"===r||"B"===r?"binary":"o"===r||"O"===r?"octal":"x"===r||"X"===r?"hex":null;if(null===n)return NO_MATCH;let o;for(o=t+2;o<e.length;o+=1){const t=e[o];if("binary"===n&&!binaryNumberRegExp.test(t))break;if("octal"===n&&!octalNumberRegExp.test(t))break;if("hex"===n&&!hexNumberRegExp.test(t))break}const a=o-t;if(a<=2)return NO_MATCH;const i=e[o];return i&&!postNumberRegExp.test(i)?NO_MATCH:[a,["BasePrefixedNumber",e.substring(t,o)]]},tokenizeSymbol=(e,t)=>{let r=e[t];if("'"===r){let n=1,o=e[t+n],a=!1;for(;"'"!==o||a;){if(void 0===o)return[n,["Error",r,void 0,`Unclosed quoted symbol at position ${t}`]];n+=1,a?(a=!1,r+=o):("\\"===o&&(a=!0),r+=o),o=e[t+n]}return r+="'",[n+1,["Symbol",r]]}if(!illegalFirstSymbolCharacterSet.has(r)){const n=t;let o=e[t+=1];for(;o&&!illegalSymbolCharacterSet.has(o);)r+=o,o=e[t+=1];return r.endsWith(":")?[t-n-1,["Symbol",r.slice(0,-1)]]:[t-n,["Symbol",r]]}return NO_MATCH},tokenizeReservedSymbolToken=(e,t)=>{const r=tokenizeSymbol(e,t);if(0===r[0]||!r[1])return NO_MATCH;let n=r[1][1];n=n.startsWith("'")?n.slice(1,n.length-1):n;return void 0===reservedSymbolRecord[n]?NO_MATCH:[r[0],["ReservedSymbol",n]]},tokenizeOperator=(e,t)=>{const r=e.slice(t,t+3);if(t+2<e.length&&isSymbolicOperator(r))return[3,["Operator",r]];const n=e.slice(t,t+2);if(t+1<e.length&&isSymbolicOperator(n))return[2,["Operator",n]];const o=e[t]??"";return isSymbolicOperator(o)?[1,["Operator",o]]:NO_MATCH},tokenizeMultiLineComment=(e,t)=>{if("/"===e[t]&&"*"===e[t+1]){let r=2,n="/*";for(;("*"!==e[t+r]||"/"!==e[t+r+1])&&t+r+1<e.length;)n+=e[t+r],r+=1;return t+r+1>=e.length?[r,["Error",n,void 0,`Unclosed multi-line comment at position ${t}`]]:(n+="*/",r+=2,[r,["MultiLineComment",n]])}return NO_MATCH},tokenizeShebang=(e,t)=>{if("#"===e[t]&&"!"===e[t+1]){let r=2,n="#!";for(;"\n"!==e[t+r]&&t+r<e.length;)n+=e[t+r],r+=1;return[r,["SingleLineComment",n]]}return NO_MATCH},tokenizeSingleLineComment=(e,t)=>{if("/"===e[t]&&"/"===e[t+1]){let r=2,n="//";for(;"\n"!==e[t+r]&&t+r<e.length;)n+=e[t+r],r+=1;return[r,["SingleLineComment",n]]}return NO_MATCH},tokenizers=[tokenizeWhitespace,tokenizeMultiLineComment,tokenizeSingleLineComment,tokenizeReservedSymbolToken,tokenizeLParen,tokenizeRParen,tokenizeLBracket,tokenizeRBracket,tokenizeLBrace,tokenizeRBrace,tokenizeDocString,tokenizeString,tokenizeRegexpShorthand,tokenizeBasePrefixedNumber,tokenizeNumber,tokenizeOperator,tokenizeSymbol];function tokenize$1(e,t,r){let n=0;const o={tokens:[],filePath:r,hasDebugData:t};for(;n<e.length;){const a=t?createSourceCodeInfo(e,n,r):void 0,i=getCurrentToken(e,n),[s,c]=i;n+=s,c&&(a&&(c[2]=a),o.tokens.push(c))}return o}function getSourceCodeLine(e,t){return e.split(/\r\n|\r|\n/)[t]}function createSourceCodeInfo(e,t,r){const n=e.substring(0,t+1).split(/\r\n|\r|\n/),o=n[n.length-1];return{code:getSourceCodeLine(e,n.length-1),position:{line:n.length,column:o.length},filePath:r}}function getCurrentToken(e,t){const r=t;if(0===t){const[n,o]=tokenizeShebang(e,t);if(t+=n,n>0)return[t-r,o]}for(const n of tokenizers){const[o,a]=n(e,t);if(t+=o,0!==o)return[t-r,a]}return[1,["Error",e[r],void 0,"Unrecognized character"]]}function isSymbolToken(e,t){return"Symbol"===e?.[0]&&(!t||e[1]===t)}function assertSymbolToken(e,t){isSymbolToken(e,t)||throwUnexpectedToken("Symbol",void 0,e)}function asSymbolToken(e,t){return assertSymbolToken(e,t),e}function isReservedSymbolToken(e,t){return"ReservedSymbol"===e?.[0]&&(!t||e[1]===t)}function assertReservedSymbolToken(e,t){isReservedSymbolToken(e,t)||throwUnexpectedToken("ReservedSymbol",t,e)}function asReservedSymbolToken(e,t){return assertReservedSymbolToken(e,t),e}function isShebangToken(e){return"Shebang"===e?.[0]}function isSingleLineCommentToken(e){return"SingleLineComment"===e?.[0]}function isMultiLineCommentToken(e){return"MultiLineComment"===e?.[0]}function isOperatorToken(e,t){return"Operator"===e?.[0]&&(!t||e[1]===t)}function assertOperatorToken(e,t){isOperatorToken(e,t)||throwUnexpectedToken("Operator",t,e)}function isWhitespaceToken(e){return"Whitespace"===e?.[0]}function isLParenToken(e){return"LParen"===e?.[0]}function assertLParenToken(e){isLParenToken(e)||throwUnexpectedToken("LParen",void 0,e)}function isRParenToken(e){return"RParen"===e?.[0]}function assertRParenToken(e){isRParenToken(e)||throwUnexpectedToken("RParen",void 0,e)}function isLBracketToken(e){return"LBracket"===e?.[0]}function assertLBracketToken(e){isLBracketToken(e)||throwUnexpectedToken("LBracket",void 0,e)}function asLBracketToken(e){return assertLBracketToken(e),e}function isRBracketToken(e){return"RBracket"===e?.[0]}function assertRBracketToken(e){isRBracketToken(e)||throwUnexpectedToken("RBracket",void 0,e)}function isLBraceToken(e){return"LBrace"===e?.[0]}function assertLBraceToken(e){isLBraceToken(e)||throwUnexpectedToken("LBrace",void 0,e)}function asLBraceToken(e){return assertLBraceToken(e),e}function isRBraceToken(e){return"RBrace"===e?.[0]}function assertRBraceToken(e){isRBraceToken(e)||throwUnexpectedToken("RBrace",void 0,e)}function isStringToken(e){return"string"===e?.[0]}function isDocStringToken(e){return"DocString"===e?.[0]}function isA_BinaryOperatorToken(e){return"Operator"===e?.[0]&&isBinaryOperator(e[1])}function throwUnexpectedToken(e,t,r){const n=r?`${r[0]} '${r[1]}'`:"end of input";throw new LitsError(`Unexpected token: ${n}, expected ${e}${t?` '${t}'`:""}`,r?.[2])}function minifyTokenStream(e,{removeWhiteSpace:t}){const r=e.tokens.filter(e=>!(isSingleLineCommentToken(e)||isMultiLineCommentToken(e)||isShebangToken(e)||t&&isWhitespaceToken(e)));return{...e,tokens:r}}function transformSymbolTokens(e,t){return{...e,tokens:e.tokens.map(e=>isSymbolToken(e)?[e[0],t(e[1])]:e)}}function untokenize(e){return e.tokens.reduce((e,t)=>`${e}${t[1]}`,"")}const litsCommands=new Set([...normalExpressionKeys,...specialExpressionKeys,...Object.keys(reservedSymbolRecord)]);class AutoCompleter{originalProgram;originalPosition;prefixProgram="";suffixProgram="";searchString="";suggestions=[];suggestionIndex=null;constructor(e,t,r,n){this.originalProgram=e,this.originalPosition=t;const o=this.originalProgram.slice(0,this.originalPosition),a=r.tokenize(o).tokens.at(-1);a&&"Error"!==a[0]&&(this.searchString=a[1],this.prefixProgram=this.originalProgram.slice(0,this.originalPosition-this.searchString.length),this.suffixProgram=this.originalProgram.slice(this.prefixProgram.length+this.searchString.length),this.originalProgram.slice(this.prefixProgram.length+this.searchString.length),this.suggestions=this.generateSuggestions(n))}getNextSuggestion(){return this.getAutoCompleteSuggestionResult(this.getNextSuggestionSymbol())}getPreviousSuggestion(){return this.getAutoCompleteSuggestionResult(this.getPreviousSuggestionSymbol())}getAutoCompleteSuggestionResult(e){return null===e?null:{program:this.prefixProgram+e+this.suffixProgram,position:this.prefixProgram.length+e.length}}getNextSuggestionSymbol(){return 0===this.suggestions.length?null:(null===this.suggestionIndex?this.suggestionIndex=0:(this.suggestionIndex+=1,this.suggestionIndex>=this.suggestions.length&&(this.suggestionIndex=0)),this.suggestions[this.suggestionIndex])}getPreviousSuggestionSymbol(){return 0===this.suggestions.length?null:(null===this.suggestionIndex?this.suggestionIndex=this.suggestions.length-1:(this.suggestionIndex-=1,this.suggestionIndex<0&&(this.suggestionIndex=this.suggestions.length-1)),this.suggestions[this.suggestionIndex])}getSuggestions(){return[...this.suggestions]}getSearchString(){return this.searchString}generateSuggestions(e){const t=new Set(["0_def","0_defn","0_lambda"]),r=this.generateWithPredicate(e,e=>!t.has(e)&&e.startsWith(this.searchString));r.forEach(e=>t.add(e));const n=this.generateWithPredicate(e,e=>!t.has(e)&&e.toLowerCase().startsWith(this.searchString.toLowerCase()));n.forEach(e=>t.add(e));const o=this.generateWithPredicate(e,e=>!t.has(e)&&e.includes(this.searchString));o.forEach(e=>t.add(e));const a=this.generateWithPredicate(e,e=>!t.has(e)&&e.includes(this.searchString.toLowerCase()));return a.forEach(e=>t.add(e)),[...r,...n,...o,...a]}generateWithPredicate(e,t){const r=new Set;return litsCommands.forEach(e=>{t(e)&&r.add(e)}),Object.keys(e.globalContext??{}).filter(t).forEach(e=>r.add(e)),e.contexts?.forEach(e=>{Object.keys(e).filter(t).forEach(e=>r.add(e))}),Object.keys(e.bindings??{}).filter(t).forEach(e=>r.add(e)),[...r].sort((e,t)=>e.localeCompare(t))}}const exponentiationPrecedence=12,binaryFunctionalOperatorPrecedence=3,conditionalOperatorPrecedence=1;function withSourceCodeInfo(e,t){return t&&(e[2]=t),e}function stringToSymbolNode(e,t){return void 0!==specialExpressionTypes[e]&&"fn"!==e&&"def"!==e&&"defn"!==e?withSourceCodeInfo([NodeTypes.SpecialBuiltinSymbol,specialExpressionTypes[e]],t):void 0!==normalExpressionTypes[e]?withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol,normalExpressionTypes[e]],t):withSourceCodeInfo([NodeTypes.UserDefinedSymbol,e],t)}function stringFromQuotedSymbol(e){return e.substring(1,e.length-1).replace(/(\\{2})|(\\')|\\(.)/g,(e,t,r,n)=>t?"\\":r?"'":`\\${n}`)}const normalExpressionNames=Object.entries(normalExpressionTypes).reduce((e,[t,r])=>(e[r]=t,e),[]),specialExpressionNames=Object.entries(specialExpressionTypes).reduce((e,[t,r])=>(e[r]=t,e),[]);function getSymbolName(e){return isUserDefinedSymbolNode(e)?e[1]:isNormalBuiltinSymbolNode(e)?normalExpressionNames[e[1]]:specialExpressionNames[e[1]]}function createNamedNormalExpressionNode(e,t,r){const n=withSourceCodeInfo([NodeTypes.NormalExpression,[e,t]],r);return isNormalBuiltinSymbolNode(e)&&assertNumberOfParams(allNormalExpressions[e[1]].arity,n[1][1].length,r),n}function isAtExpressionEnd(e){if(e.isAtEnd())return!0;const t=e.tryPeek();return isOperatorToken(t)?[";",",",":"].includes(t[1]):!!isReservedSymbolToken(t)&&["else","when","while","case","catch","let","then","end","do"].includes(t[1])}function fromBinaryOperatorToNode(e,t,r,n,o){const a=e[1];switch(a){case"^":case"*":case"/":case"%":case"+":case"-":case"<<":case">>":case">>>":case"++":case"<":case"<=":case"≤":case">":case">=":case"≥":case"==":case"!=":case"&":case"xor":case"|":case"|>":return createNamedNormalExpressionNode(t,[r,n],o);case"&&":case"||":case"??":return withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes[a],[r,n]]],o);default:throw new LitsError(`Unknown binary operator: ${a}`,o)}}class ParserContext{tokens;position;storedPosition=0;parseExpression;constructor(e){this.tokens=e.tokens,this.position=0}advance(){this.position+=1}tryPeek(){return this.tokens[this.position]}peek(){const e=this.tokens[this.position];if(!e){const e=this.tokens.at(-1),t=e?e[2]:void 0;throw new LitsError("Unexpected end of input",t)}return e}isAtEnd(){return this.position>=this.tokens.length}peekSourceCodeInfo(){const e=this.tryPeek();return e?e[2]:this.tokens.at(-1)?.[2]}storePosition(){return this.storedPosition=this.position}restorePosition(){this.position=this.storedPosition}peekAhead(e){return this.tokens[this.position+e]}getPosition(){return this.position}getTokenAt(e){return this.tokens[e]}}function getPrecedence(e,t){switch(e){case"^":return exponentiationPrecedence;case"*":case"/":case"%":return 11;case"+":case"-":return 10;case"<<":case">>":case">>>":return 9;case"++":return 8;case"<":case"<=":case"≤":case">":case">=":case"≥":return 7;case"==":case"!=":return 6;case"&":case"xor":case"|":return 5;case"&&":case"||":case"??":return 4;case"|>":return 2;default:throw new LitsError(`Unknown binary operator: ${e}`,t)}}function parseImplicitBlock(e,t){const r=[];for(;!e.isAtEnd()&&!isImplicitBlockEnd(e,t);)isOperatorToken(e.tryPeek(),";")?e.advance():r.push(e.parseExpression());if(assertImplicitBlockEnd(e,t),0===r.length)throw new LitsError("Expected expression",e.peekSourceCodeInfo());return 1===r.length?r[0]:withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.block,r]],e.peekSourceCodeInfo())}function assertImplicitBlockEnd(e,t){if(!isImplicitBlockEnd(e,t))throw new LitsError(`Expected ${t.map(e=>e[1]).join(" or ")}`,e.peekSourceCodeInfo())}function isImplicitBlockEnd(e,t){for(const r of t)if(isReservedSymbolToken(e.tryPeek(),r))return!0;return!1}function parseCond(e,t){e.advance();const r=[];for(;!e.isAtEnd()&&!isReservedSymbolToken(e.tryPeek(),"end");){assertReservedSymbolToken(e.tryPeek(),"case"),e.advance();const t=e.parseExpression();assertReservedSymbolToken(e.tryPeek(),"then"),e.advance();const n=parseImplicitBlock(e,["case","end"]);if(r.push([t,n]),isReservedSymbolToken(e.tryPeek(),"end"))break}return assertReservedSymbolToken(e.tryPeek()),e.advance(),withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.cond,r]],t[2])}function parseString(e,t){e.advance();const r=t[1].substring(1,t[1].length-1).replace(/(\\{2})|(\\")|(\\n)|(\\t)|(\\r)|(\\b)|(\\f)|\\(.)/g,(e,t,r,n,o,a,i,s,c)=>t?"\\":n?"\n":o?"\t":a?"\r":i?"\b":s?"\f":r?'"':c);return withSourceCodeInfo([NodeTypes.String,r],t[2])}function parseDo(e,t=!1){const r=asReservedSymbolToken(e.tryPeek(),"do");e.advance();let n="";t&&isDocStringToken(e.tryPeek())&&(n=parseDocString(e));const o=[];for(;!e.isAtEnd()&&!isReservedSymbolToken(e.tryPeek(),"end");)if(o.push(e.parseExpression()),isOperatorToken(e.tryPeek(),";"))e.advance();else if(!isReservedSymbolToken(e.tryPeek(),"end"))throw new LitsError("Expected end",e.peekSourceCodeInfo());return assertReservedSymbolToken(e.tryPeek(),"end"),e.advance(),[withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.block,o]],r[2]),n]}function parseDocString(e){const t=e.peek();return smartTrim(parseString(e,t[2]?["string",t[1].slice(2,-2),t[2]]:["string",t[1].slice(2,-2)])[1])}function parseSymbol(e){const t=e.peek();if(e.advance(),!isSymbolToken(t))throw new LitsError(`Expected symbol token, got ${t[0]}`,t[2]);return"'"===t[1][0]?stringToSymbolNode(stringFromQuotedSymbol(t[1]),t[2]):stringToSymbolNode(t[1],t[2])}function parseBindingTarget(e,{requireDefaultValue:t,noRest:r}={}){const n=e.tryPeek();if(isSymbolToken(n)){const r=parseSymbol(e);if(!isUserDefinedSymbolNode(r))throw new LitsError("Expected user defined symbol",n[2]);const o=parseOptionalDefaulValue(e);if(t&&!o)throw new LitsError("Expected assignment",e.peekSourceCodeInfo());return withSourceCodeInfo([bindingTargetTypes.symbol,[r,o]],n[2])}if(isOperatorToken(n,"...")){if(r)throw new LitsError("Rest element not allowed",n[2]);e.advance();const t=asUserDefinedSymbolNode(parseSymbol(e));if(isOperatorToken(e.tryPeek(),"="))throw new LitsError("Rest argument can not have default value",e.peekSourceCodeInfo());return withSourceCodeInfo([bindingTargetTypes.rest,[t[1],void 0]],n[2])}if(isLBracketToken(n)){e.advance();const r=[];let o=e.peek(),a=!1;for(;!isRBracketToken(o);){if(a)throw new LitsError("Rest argument must be last",o[2]);if(isOperatorToken(o,",")){r.push(null),e.advance(),o=e.peek();continue}const t=parseBindingTarget(e);t[0]===bindingTargetTypes.rest&&(a=!0),r.push(t),o=e.peek(),isRBracketToken(o)||(assertOperatorToken(o,","),e.advance()),o=e.peek()}e.advance();const i=parseOptionalDefaulValue(e);if(t&&!i)throw new LitsError("Expected assignment",e.peekSourceCodeInfo());return withSourceCodeInfo([bindingTargetTypes.array,[r,i]],n[2])}if(isLBraceToken(n)){e.advance();const r={};let o=e.peek(),a=!1;for(;!isRBraceToken(o);){if(a)throw new LitsError("Rest argument must be last",o[2]);isOperatorToken(o,"...")&&(a=!0,e.advance());const t=parseSymbol(e),i=getSymbolName(t);if(o=e.peek(),isReservedSymbolToken(o,"as")){if(a)throw new LitsError("Rest argument can not have alias",o[2]);e.advance();const t=asUserDefinedSymbolNode(parseSymbol(e));if(r[t[1]])throw new LitsError(`Duplicate binding name: ${t}`,o[2]);r[i]=withSourceCodeInfo([bindingTargetTypes.symbol,[t,parseOptionalDefaulValue(e)]],n[2])}else if(isRBraceToken(o)||isOperatorToken(o,",")||isOperatorToken(o,"=")){const i=asUserDefinedSymbolNode(t,t[2]);if(r[i[1]])throw new LitsError(`Duplicate binding name: ${i}`,o[2]);if(a&&isOperatorToken(e.tryPeek(),"="))throw new LitsError("Rest argument can not have default value",e.peekSourceCodeInfo());r[i[1]]=withSourceCodeInfo(a?[bindingTargetTypes.rest,[i[1],parseOptionalDefaulValue(e)]]:[bindingTargetTypes.symbol,[i,parseOptionalDefaulValue(e)]],n[2])}else if(isOperatorToken(o,":")){if(e.advance(),o=e.peek(),!isLBraceToken(o)&&!isLBracketToken(o))throw new LitsError("Expected object or array",o[2]);r[i]=parseBindingTarget(e)}isRBraceToken(e.peek())||(assertOperatorToken(e.peek(),","),e.advance()),o=e.peek()}e.advance(),o=e.peek();const i=parseOptionalDefaulValue(e);if(t&&!i)throw new LitsError("Expected assignment",o[2]);return withSourceCodeInfo([bindingTargetTypes.object,[r,i]],n[2])}throw new LitsError("Expected symbol",e.peekSourceCodeInfo())}function parseOptionalDefaulValue(e){if(isOperatorToken(e.tryPeek(),"="))return e.advance(),e.parseExpression()}function parseLet(e,t){e.advance();const r=parseBindingTarget(e,{requireDefaultValue:!0,noRest:!0}),n=r[1][1];r[1][1]=void 0;const o=withSourceCodeInfo([NodeTypes.Binding,[r,n]],t[2]);return withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.let,o]],t[2])}function parseForOrDoseq(e,t){const r="doseq"===t[1];e.advance(),assertLParenToken(e.tryPeek()),e.advance();const n=[];for(;!e.isAtEnd()&&!isRParenToken(e.tryPeek());){const t=parseForLoopBinding(e),r=n.flatMap(e=>Object.keys(getAllBindingTargetNames(e[0][1][0]))),o=getAllBindingTargetNames(t[0][1][0]);if(Object.keys(o).some(e=>r.includes(e)))throw new LitsError("Duplicate binding",t[0][2]);n.push(t),isOperatorToken(e.tryPeek(),",")&&e.advance()}assertRParenToken(e.tryPeek()),e.advance(),assertOperatorToken(e.tryPeek(),"->"),e.advance();const o=e.parseExpression();return withSourceCodeInfo(r?[NodeTypes.SpecialExpression,[specialExpressionTypes.doseq,n,o]]:[NodeTypes.SpecialExpression,[specialExpressionTypes.for,n,o]],t[2])}function parseForLoopBinding(e){const t=parseBinding(e),r=[];let n=e.peek();assertInternalLoopBindingDelimiter(n,["let","when","while"]);const o=[];if("let"===n[1])for(r.push("&let");isSymbolToken(n,"let");){const t=parseLet(e,n),r=o.flatMap(e=>Object.keys(getAllBindingTargetNames(e[1][0])));if(Object.keys(getAllBindingTargetNames(t[1][1][1][0])).some(e=>r.includes(e)))throw new LitsError("Duplicate binding",t[1][1][2]);o.push(t[1][1]),n=e.peek(),assertInternalLoopBindingDelimiter(n,["let","when","while"]),n=e.peek()}let a,i;for(;isReservedSymbolToken(n,"when")||isReservedSymbolToken(n,"while");){e.advance(),"when"===n[1]?(r.push("&when"),a=e.parseExpression()):(r.push("&while"),i=e.parseExpression()),n=e.peek();assertInternalLoopBindingDelimiter(n,r.includes("&when")&&r.includes("&while")?[]:r.includes("&when")?["while"]:["when"]),n=e.peek()}return assertInternalLoopBindingDelimiter(n,[]),[t,o,a,i]}function parseBinding(e){const t=asSymbolToken(e.tryPeek()),r=asUserDefinedSymbolNode(parseSymbol(e));assertReservedSymbolToken(e.tryPeek(),"in"),e.advance();const n=e.parseExpression();return withSourceCodeInfo([NodeTypes.Binding,[withSourceCodeInfo([bindingTargetTypes.symbol,[r,void 0]],t[2]),n]],t[2])}function assertInternalLoopBindingDelimiter(e,t){if(!isInternalLoopBindingDelimiter(e,t)){const r=`${[...t,","].map(e=>`"${e}"`).join(", ")} or ")"`;throw new LitsError(`Expected symbol ${r}`,e[2])}}function isInternalLoopBindingDelimiter(e,t){if(isOperatorToken(e,",")||isRParenToken(e))return!0;for(const r of t){if("let"===r&&isSymbolToken(e,"let"))return!0;if(["when","while"].includes(r)&&isReservedSymbolToken(e,r))return!0}return!1}function parseIfOrUnless(e,t){const r="unless"===t[1];e.advance();const n=e.parseExpression();assertReservedSymbolToken(e.tryPeek(),"then"),e.advance();const o=parseImplicitBlock(e,["else","end"]);let a;return isReservedSymbolToken(e.tryPeek(),"else")&&(e.advance(),a=parseImplicitBlock(e,["end"])),e.advance(),withSourceCodeInfo(r?[NodeTypes.SpecialExpression,[specialExpressionTypes.unless,[n,o,a]]]:[NodeTypes.SpecialExpression,[specialExpressionTypes.if,[n,o,a]]],t[2])}function parseLoop(e,t){e.advance(),assertLParenToken(e.tryPeek()),e.advance();const r=[];let n=e.tryPeek();for(;!e.isAtEnd()&&!isRParenToken(n);){const t=parseBindingTarget(e,{requireDefaultValue:!0,noRest:!0}),o=t[1][1];t[1][1]=void 0,r.push(withSourceCodeInfo([NodeTypes.Binding,[t,o]],t[2])),isOperatorToken(e.tryPeek(),",")&&e.advance(),n=e.tryPeek()}if(0===r.length)throw new LitsError("Expected binding",e.peekSourceCodeInfo());assertRParenToken(n),e.advance(),assertOperatorToken(e.tryPeek(),"->"),e.advance();const o=e.parseExpression();return withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.loop,r,o]],t[2])}function parseRegexpShorthand(e){const t=e.peek();e.advance();const r=t[1].lastIndexOf('"'),n=t[1].substring(2,r),o=t[1].substring(r+1),a=withSourceCodeInfo([NodeTypes.String,n],t[2]),i=withSourceCodeInfo([NodeTypes.String,o],t[2]);return withSourceCodeInfo([NodeTypes.NormalExpression,[withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol,normalExpressionTypes.regexp],t[2]),[a,i]]],t[2])}function parseReservedSymbol(e){const t=asReservedSymbolToken(e.tryPeek());e.advance();const r=t[1];return isNumberReservedSymbol(r)?withSourceCodeInfo([NodeTypes.Number,numberReservedSymbolRecord[r]],t[2]):withSourceCodeInfo([NodeTypes.ReservedSymbol,t[1]],t[2])}function parseArray(e){const t=asLBracketToken(e.tryPeek());e.advance();const r=[];for(;!e.isAtEnd()&&!isRBracketToken(e.tryPeek());){isOperatorToken(e.tryPeek(),"...")?(e.advance(),r.push(withSourceCodeInfo([NodeTypes.Spread,e.parseExpression()],e.peekSourceCodeInfo()))):r.push(e.parseExpression());const t=e.tryPeek();if(!isOperatorToken(t,",")&&!isRBracketToken(t))throw new LitsError("Expected comma or closing parenthesis",e.peekSourceCodeInfo());isOperatorToken(t,",")&&e.advance()}return assertRBracketToken(e.tryPeek()),e.advance(),withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.array,r]],t[2])}const placeholderRegexp=/^\$([1-9]\d?)?$/,maxShorthandLambdaArity=20;function parseLambdaFunction(e){const t=e.peek();if(isLParenToken(t)&&isSymbolToken(e.peekAhead(1))&&isOperatorToken(e.peekAhead(2),"->"))return null;try{const r=parseFunctionArguments(e);if(!isOperatorToken(e.peek(),"->"))return null;let n;e.advance();let o="";if(isReservedSymbolToken(e.peek(),"do")){const t=parseDo(e,!0);o=t[1],n=t[0][1][1]}else n=[e.parseExpression()];return withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes["0_lambda"],[r,n],o]],t[2])}catch{return null}}function parseFunctionArguments(e){const t=e.peek();if(isSymbolToken(t))return[withSourceCodeInfo([bindingTargetTypes.symbol,[parseSymbol(e),void 0]],t[2])];assertLParenToken(t),e.advance();let r=!1,n=!1;const o=[];for(;!e.isAtEnd()&&!isRParenToken(e.peek())&&!isSymbolToken(e.peek(),"let");){if(r)throw new LitsError("Rest argument must be last",e.peekSourceCodeInfo());const t=parseBindingTarget(e);if(void 0!==t[1][1]&&(n=!0),t[0]===bindingTargetTypes.rest&&(r=!0),n&&!t[1][1])throw new LitsError("Default arguments must be last",e.peekSourceCodeInfo());if(o.push(t),!isOperatorToken(e.peek(),",")&&!isRParenToken(e.peek())&&!isSymbolToken(e.peek(),"let"))throw new LitsError("Expected comma or closing parenthesis",e.peekSourceCodeInfo());isOperatorToken(e.peek(),",")&&e.advance()}if(!isRParenToken(e.peek()))throw new LitsError("Expected closing parenthesis",e.peekSourceCodeInfo());return e.advance(),o}function parseShorthandLambdaFunction(e){const t=e.peek();e.advance();const r=e.getPosition();let n,o="";if(isReservedSymbolToken(e.peek(),"do")){const t=parseDo(e,!0);o=t[1],n=t[0][1][1]}else n=[e.parseExpression()];const a=e.getPosition()-1;let i=0,s="NOT_SET";for(let n=r;n<=a;n+=1){const r=e.getTokenAt(n);if(isSymbolToken(r)){const e=placeholderRegexp.exec(r[1]);if(e){const r=e[1]??"1";if("1"===r){if(!e[1]&&"WITH_1"===s||e[1]&&"NAKED"===s)throw new LitsError("Please make up your mind, either use $ or $1",t[2]);s=e[1]?"WITH_1":"NAKED"}if(i=Math.max(i,Number(r)),i>maxShorthandLambdaArity)throw new LitsError("Can't specify more than 20 arguments",t[2])}}}const c=[];for(let e=1;e<=i;e+=1)1===e&&"NAKED"===s?c.push(withSourceCodeInfo([bindingTargetTypes.symbol,[[NodeTypes.UserDefinedSymbol,"$"],void 0]],t[2])):c.push(withSourceCodeInfo([bindingTargetTypes.symbol,[[NodeTypes.UserDefinedSymbol,`$${e}`],void 0]],t[2]));return withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes["0_lambda"],[c,n],o]],t[2])}function parseFunctionCall(e,t){e.advance();const r=[];for(;!e.isAtEnd()&&!isRParenToken(e.tryPeek());){isOperatorToken(e.tryPeek(),"...")?(e.advance(),r.push(withSourceCodeInfo([NodeTypes.Spread,e.parseExpression()],e.peekSourceCodeInfo()))):r.push(e.parseExpression());const t=e.tryPeek();if(!isOperatorToken(t,",")&&!isRParenToken(t))throw new LitsError("Expected comma or closing parenthesis",e.tryPeek()?.[2]);isOperatorToken(t,",")&&e.advance()}if(!isRParenToken(e.tryPeek()))throw new LitsError("Expected closing parenthesis",e.peekSourceCodeInfo());if(e.advance(),!isSpecialBuiltinSymbolNode(t))return isNormalBuiltinSymbolNode(t)||isUserDefinedSymbolNode(t)?createNamedNormalExpressionNode(t,r,t[2]):withSourceCodeInfo([NodeTypes.NormalExpression,[t,r]],t[2]);{const e=t[1];switch(assertNumberOfParams(builtin.specialExpressions[e].arity,r.length,t[2]),e){case specialExpressionTypes["||"]:case specialExpressionTypes["&&"]:case specialExpressionTypes.recur:case specialExpressionTypes.array:case specialExpressionTypes.object:case specialExpressionTypes["??"]:return withSourceCodeInfo([NodeTypes.SpecialExpression,[e,r]],t[2]);case specialExpressionTypes["defined?"]:{const[n]=r;return withSourceCodeInfo([NodeTypes.SpecialExpression,[e,n]],t[2])}case specialExpressionTypes.throw:{const[n]=r;return withSourceCodeInfo([NodeTypes.SpecialExpression,[e,n]],t[2])}case specialExpressionTypes["0_lambda"]:case specialExpressionTypes["0_def"]:throw new LitsError(`${e} is not allowed`,t[2]);default:throw new LitsError(`Unknown special expression: ${e}`,t[2])}}}function parseNumber(e){const t=e.peek();e.advance();const r=t[1],n="-"===r[0],o=(n?r.substring(1):r).replace(/_/g,"");return withSourceCodeInfo([NodeTypes.Number,n?-Number(o):Number(o)],t[2])}function parseObject(e){const t=asLBraceToken(e.tryPeek());e.advance();const r=[];for(;!e.isAtEnd()&&!isRBraceToken(e.tryPeek());){if(isOperatorToken(e.tryPeek(),"..."))e.advance(),r.push(withSourceCodeInfo([NodeTypes.Spread,e.parseExpression()],e.peekSourceCodeInfo()));else{const t=e.tryPeek();if(isStringToken(t)){const n=parseString(e,t);r.push(withSourceCodeInfo([NodeTypes.String,n[1]],t[2]))}else if(isSymbolToken(t)){const n=t[1].startsWith("'")?stringFromQuotedSymbol(t[1]):t[1];r.push(withSourceCodeInfo([NodeTypes.String,n],t[2])),e.advance()}else{if(!isLBracketToken(t))throw new LitsError("Expected key to be a symbol or a string",e.peekSourceCodeInfo());e.advance(),r.push(e.parseExpression()),assertRBracketToken(e.tryPeek()),e.advance()}assertOperatorToken(e.tryPeek(),":"),e.advance(),r.push(e.parseExpression())}const t=e.tryPeek();if(!isOperatorToken(t,",")&&!isRBraceToken(t))throw new LitsError("Expected comma or closing brace",e.peekSourceCodeInfo());isOperatorToken(t,",")&&e.advance()}return assertRBraceToken(e.tryPeek()),e.advance(),withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.object,r]],t[2])}function parseOperand(e){let t=parseOperandPart(e),r=e.tryPeek();for(;isOperatorToken(r,".")||isLBracketToken(r)||isLParenToken(r);)if("."===r[1]){e.advance();const n=e.tryPeek();if(!isSymbolToken(n))throw new LitsError("Expected symbol",e.peekSourceCodeInfo());t=createAccessorNode(t,withSourceCodeInfo([NodeTypes.String,n[1]],n[2]),r[2]),e.advance(),r=e.tryPeek()}else if(isLBracketToken(r)){e.advance();const n=e.parseExpression();if(!isRBracketToken(e.tryPeek()))throw new LitsError("Expected closing bracket",e.peekSourceCodeInfo());t=createAccessorNode(t,n,r[2]),e.advance(),r=e.tryPeek()}else isLParenToken(r)&&(t=parseFunctionCall(e,t),r=e.tryPeek());return t}function parseOperandPart(e){const t=e.peek();if(isLParenToken(t)){e.storePosition();const t=parseLambdaFunction(e);if(t)return t;e.restorePosition(),e.advance();const r=e.parseExpression();if(!isRParenToken(e.peek()))throw new LitsError("Expected closing parenthesis",e.peekSourceCodeInfo());return e.advance(),r}if(isOperatorToken(t)){const r=t[1];if(isBinaryOperator(r))return e.advance(),void 0!==specialExpressionTypes[r]?withSourceCodeInfo([NodeTypes.SpecialBuiltinSymbol,specialExpressionTypes[r]],t[2]):withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol,normalExpressionTypes[r]],t[2]);if("->"===r)return parseShorthandLambdaFunction(e);throw new LitsError(`Illegal operator: ${r}`,t[2])}if(isLBraceToken(t))return parseObject(e);if(isLBracketToken(t))return parseArray(e);const r=t[0];switch(r){case"Number":case"BasePrefixedNumber":return parseNumber(e);case"string":return parseString(e,t);case"Symbol":{e.storePosition();const t=parseLambdaFunction(e);return t||(e.restorePosition(),parseSymbol(e))}case"ReservedSymbol":return parseReservedSymbol(e);case"RegexpShorthand":return parseRegexpShorthand(e);default:throw new LitsError(`Unknown token type: ${r}`,t[2])}}function createAccessorNode(e,t,r){return withSourceCodeInfo([NodeTypes.NormalExpression,[[NodeTypes.NormalBuiltinSymbol,normalExpressionTypes.get],[e,t]]],r)}function parseSwitch(e,t){e.advance();const r=e.parseExpression(),n=[];for(;!e.isAtEnd()&&!isReservedSymbolToken(e.tryPeek(),"end");){assertReservedSymbolToken(e.tryPeek(),"case"),e.advance();const t=e.parseExpression();assertReservedSymbolToken(e.tryPeek(),"then"),e.advance();const r=parseImplicitBlock(e,["case","end"]);if(n.push([t,r]),isReservedSymbolToken(e.tryPeek(),"end"))break}return assertReservedSymbolToken(e.tryPeek(),"end"),e.advance(),withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.switch,r,n]],t[2])}function parseTry(e,t){e.advance();const r=parseImplicitBlock(e,["catch"]);let n;e.advance(),isLParenToken(e.tryPeek())&&(e.advance(),n=parseSymbol(e),assertRParenToken(e.tryPeek()),e.advance());const o=parseImplicitBlock(e,["end"]);return e.advance(),withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.try,r,n,o]],t[2])}function createParserContext(e){const t=new ParserContext(e);return t.parseExpression=(e=0,r=!1)=>parseExpression(t,e,r),t}function parseExpression(e,t=0,r=!1){const n=e.tryPeek();let o;if(isSymbolToken(n))switch(n[1]){case"let":return parseLet(e,n);case"if":case"unless":o=parseIfOrUnless(e,n);break;case"cond":o=parseCond(e,n);break;case"switch":o=parseSwitch(e,n);break;case"for":case"doseq":o=parseForOrDoseq(e,n);break;case"loop":o=parseLoop(e,n);break;case"try":o=parseTry(e,n)}else if(isReservedSymbolToken(n,"do"))o=parseDo(e)[0];else if(isReservedSymbolToken(n,"export")){if(!r)throw new LitsError("export is only allowed in module scope",n[2]);return parseExport(e,n)}o||=parseOperand(e);let a=e.tryPeek();for(;!isAtExpressionEnd(e);){if(isA_BinaryOperatorToken(a)){const r=a[1],n=getPrecedence(r,a[2]);if(n<=t&&(n!==exponentiationPrecedence||t!==exponentiationPrecedence))break;const i=specialExpressionTypes[r]?withSourceCodeInfo([NodeTypes.SpecialBuiltinSymbol,specialExpressionTypes[r]],a[2]):withSourceCodeInfo([NodeTypes.NormalBuiltinSymbol,normalExpressionTypes[r]],a[2]);e.advance();o=fromBinaryOperatorToNode(a,i,o,parseExpression(e,n),a[2])}else if(isSymbolToken(a)){if(!isFunctionOperator(a[1]))break;const r=binaryFunctionalOperatorPrecedence;if(r<=t)break;const n=parseSymbol(e),i=parseExpression(e,r);if(isSpecialBuiltinSymbolNode(n))throw new LitsError("Special expressions are not allowed in binary functional operators",n[2]);o=createNamedNormalExpressionNode(n,[o,i],a[2])}else{if("?"!==a?.[1])break;{if(conditionalOperatorPrecedence<=t)break;e.advance();const r=parseExpression(e);if(!isOperatorToken(e.tryPeek(),":"))throw new LitsError("Expected :",e.peekSourceCodeInfo());e.advance();const n=parseExpression(e);o=withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes.if,[o,r,n]]],o[2])}}a=e.tryPeek()}return o}function parseExport(e,t){e.advance();const r=e.tryPeek();if(isSymbolToken(r,"let")){const n=parseLet(e,asSymbolToken(r));return withSourceCodeInfo([NodeTypes.SpecialExpression,[specialExpressionTypes["0_def"],n[1][1]]],t[2])}throw new LitsError("Expected let",e.peekSourceCodeInfo())}function parse$1(e){e.tokens.forEach(e=>{if("Error"===e[0])throw new LitsError(e[3],e[2])});const t=[],r=createParserContext(e);for(;!r.isAtEnd();)if(t.push(parseExpression(r,0,!0)),isOperatorToken(r.tryPeek(),";"))r.advance();else if(!r.isAtEnd())throw new LitsError("Expected ;",r.peekSourceCodeInfo());return t}class Cache{cache={};firstEntry=void 0;lastEntry=void 0;_size=0;maxSize;constructor(e){if(this.maxSize=null===e?null:toNonNegativeInteger(e),"number"==typeof this.maxSize&&this.maxSize<1)throw new Error(`1 is the minimum maxSize, got ${valueToString(e)}`)}getContent(){return Object.entries(this.cache).reduce((e,[t,r])=>(e[t]=r.value,e),{})}get size(){return this._size}get(e){return this.cache[e]?.value}clear(){this.cache={},this.firstEntry=void 0,this.lastEntry=void 0,this._size=0}has(e){return!!this.cache[e]}set(e,t){if(this.has(e))throw new Error(`AstCache - key already present: ${e}`);const r={value:t,nextEntry:void 0,key:e};for(this.cache[e]=r,this._size+=1,this.lastEntry&&(this.lastEntry.nextEntry=r),this.lastEntry=r,this.firstEntry||(this.firstEntry=this.lastEntry);null!==this.maxSize&&this.size>this.maxSize;)this.dropFirstEntry()}dropFirstEntry(){const e=this.firstEntry;delete this.cache[e.key],this._size-=1,this.firstEntry=e.nextEntry}}class Lits{astCache;astCacheSize;debug;modules;constructor(e={}){if(this.debug=e.debug??!1,this.astCacheSize=e.astCacheSize??null,this.astCacheSize){this.astCache=new Cache(this.astCacheSize);const t=e.initialCache??{};for(const e of Object.keys(t))this.astCache.set(e,t[e])}else this.astCache=null;const t=e.modules??[];this.modules=new Map(t.map(e=>[e.name,e]))}getRuntimeInfo(){return{astCacheSize:this.astCacheSize,astCache:this.astCache,debug:this.debug}}async={run:async(e,t={})=>{const r=this.generateAst(e,t);return this.evaluate(r,t)},context:async(e,t={})=>{const r="string"==typeof e?this.generateAst(e,t):e,n=createContextStack(t,this.modules);return await evaluate(r,n),n.globalContext},apply:async(e,t,r={})=>this.apply(e,t,r)};run(e,t={}){const r=this.generateAst(e,t),n=this.evaluate(r,t);if(n instanceof Promise)throw new TypeError("Unexpected async result in synchronous run(). Use lits.async.run() for async operations.");return n}context(e,t={}){const r="string"==typeof e?this.generateAst(e,t):e,n=createContextStack(t,this.modules);if(evaluate(r,n)instanceof Promise)throw new TypeError("Unexpected async result in synchronous context(). Use lits.async.context() for async operations.");return n.globalContext}getUndefinedSymbols(e,t={}){const r="string"==typeof e?this.generateAst(e,t):e,n=createContextStack(t,this.modules);return getUndefinedSymbols(r,n,builtin,evaluateNode)}tokenize(e,t={}){const r=tokenize$1(e,this.debug,t.filePath);return t.minify?minifyTokenStream(r,{removeWhiteSpace:!1}):r}parse(e){const t={body:[],hasDebugData:(e=minifyTokenStream(e,{removeWhiteSpace:!0})).hasDebugData};return t.body=parse$1(e),t}evaluate(e,t){return evaluate(e,createContextStack(t,this.modules))}transformSymbols(e,t){return transformSymbolTokens(e,t)}untokenize(e){return untokenize(e)}apply(e,t,r={}){const n="FN_2eb7b316_471c_5bfa_90cb_d3dfd9164a59",o=this.generateApplyFunctionCall(n,t),a=this.generateAst(o,r),i=t.reduce((e,t,r)=>(e[`${n}_${r}`]=t,e),{[n]:e});return r.bindings={...r.bindings,...i},this.evaluate(a,r)}generateApplyFunctionCall(e,t){const r=t.map((t,r)=>`${e}_${r}`).join(", ");return`${e}(${r})`}generateAst(e,t){if(this.astCache){const t=this.astCache.get(e);if(t)return t}const r=this.tokenize(e,{filePath:t.filePath}),n=this.parse(r);return this.astCache?.set(e,n),n}getAutoCompleter(e,t,r={}){return new AutoCompleter(e,t,this,r)}}const moduleDocs$6={assert:{category:"assert",description:"If $value is falsy it throws `AssertionError` with $message. If no $message is provided, message is set to $value.",returns:{type:"any"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert } = import("assert");\ntry assert(0, "Expected a positive value") catch (e) e.message end'],seeAlso:["assert.assert-truthy","assert.assert-true"],hideOperatorForm:!0},"assert!=":{category:"assert",description:"If $a is the same as $b it throws `AssertionError`.",returns:{type:"null"},args:{a:{type:"any"},b:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","message"]}],examples:['let { assert!= } = import("assert");\ntry assert!=(0, 0, "Expected different values") catch (e) e.message end','let { assert!= } = import("assert");\ntry assert!=(0, 0) catch (e) e.message end','let { assert!= } = import("assert");\ntry 0 assert!= 0 catch (e) e.message end','let { assert!= } = import("assert");\ntry assert!=(0, 1) catch (e) e.message end'],seeAlso:["assert.assert="],hideOperatorForm:!0},"assert=":{category:"assert",description:"If $a is not structural equal to $b it throws `AssertionError`.",returns:{type:"null"},args:{a:{type:"any"},b:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","message"]}],examples:['let { assert= } = import("assert");\ntry assert=({ "a": 1 }, { "a": 2 }, "Expected equal values") catch (e) e.message end','let { assert= } = import("assert");\ntry assert=({ "a": 1 }, { "a": 2 }) catch (e) e.message end','let { assert= } = import("assert");\ntry assert=({ "a": 1 }, { "a": 1 }) catch (e) e.message end'],seeAlso:["assert.assert!="],hideOperatorForm:!0},"assert-gt":{category:"assert",description:"If $a is not greater than $b it throws `AssertionError`.",returns:{type:"null"},args:{a:{type:"any"},b:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","message"]}],examples:['let { assert-gt } = import("assert");\ntry assert-gt(0, 1, "Expected greater value") catch (e) e.message end','let { assert-gt } = import("assert");\ntry assert-gt(0, 0) catch (e) e.message end','let { assert-gt } = import("assert");\ntry assert-gt(1, 0) catch (e) e.message end'],seeAlso:["assert.assert-lt","assert.assert-gte","assert.assert-lte"],hideOperatorForm:!0},"assert-lt":{category:"assert",description:"If $a is not less than $b it throws `AssertionError`.",returns:{type:"null"},args:{a:{type:"any"},b:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","message"]}],examples:['let { assert-lt } = import("assert");\ntry assert-lt(1, 0, "Expected smaller value value") catch (e) e.message end','let { assert-lt } = import("assert");\ntry assert-lt(1, 1) catch (e) e.message end','let { assert-lt } = import("assert");\ntry assert-lt(0, 1) catch (e) e.message end'],seeAlso:["assert.assert-gt","assert.assert-lte","assert.assert-gte"],hideOperatorForm:!0},"assert-gte":{category:"assert",description:"If $a is less than $b it throws `AssertionError`.",returns:{type:"null"},args:{a:{type:"any"},b:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","message"]}],examples:['let { assert-gte } = import("assert");\ntry assert-gte(0, 1, "Expected greater value") catch (e) e.message end','let { assert-gte } = import("assert");\ntry assert-gte(0, 1) catch (e) e.message end','let { assert-gte } = import("assert");\ntry assert-gte(1, 1) catch (e) e.message end'],seeAlso:["assert.assert-lte","assert.assert-gt","assert.assert-lt"],hideOperatorForm:!0},"assert-lte":{category:"assert",description:"If $a is grater than $b it throws `AssertionError`.",returns:{type:"null"},args:{a:{type:"any"},b:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","message"]}],examples:['let { assert-lte } = import("assert");\ntry assert-lte(1, 0, "Expected smaller value value") catch (e) e.message end','let { assert-lte } = import("assert");\ntry assert-lte(1, 0) catch (e) e.message end','let { assert-lte } = import("assert");\ntry assert-lte(1, 1) catch (e) e.message end'],seeAlso:["assert.assert-gte","assert.assert-lt","assert.assert-gt"],hideOperatorForm:!0},"assert-true":{category:"assert",description:"If $value is not `true` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-true } = import("assert");\ntry assert-true(false, "Expected true") catch (e) e.message end','let { assert-true } = import("assert");\ntry assert-true(false) catch (e) e.message end','let { assert-true } = import("assert");\ntry assert-true(true) catch (e) e.message end'],seeAlso:["assert.assert-false","assert.assert-truthy","assert.assert-falsy","assert.assert","assert.assert-boolean"],hideOperatorForm:!0},"assert-false":{category:"assert",description:"If $value is not `false` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-false } = import("assert");\ntry assert-false(true, "Expected false") catch (e) e.message end','let { assert-false } = import("assert");\ntry assert-false(true) catch (e) e.message end','let { assert-false } = import("assert");\ntry assert-false(false) catch (e) e.message end'],seeAlso:["assert.assert-true","assert.assert-falsy","assert.assert-truthy","assert.assert-boolean"],hideOperatorForm:!0},"assert-truthy":{category:"assert",description:"If $value is not `truthy` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-truthy } = import("assert");\ntry assert-truthy(false, "Expected truthy") catch (e) e.message end','let { assert-truthy } = import("assert");\ntry assert-truthy(false) catch (e) e.message end','let { assert-truthy } = import("assert");\ntry assert-truthy(0) catch (e) e.message end','let { assert-truthy } = import("assert");\ntry assert-truthy(null) catch (e) e.message end','let { assert-truthy } = import("assert");\ntry assert-truthy("") catch (e) e.message end','let { assert-truthy } = import("assert");\ntry assert-truthy(true) catch (e) e.message end','let { assert-truthy } = import("assert");\ntry assert-truthy(1) catch (e) e.message end','let { assert-truthy } = import("assert");\ntry assert-truthy("x") catch (e) e.message end','let { assert-truthy } = import("assert");\ntry assert-truthy([]) catch (e) e.message end','let { assert-truthy } = import("assert");\ntry assert-truthy(nd) catch (e) e.message end'],seeAlso:["assert.assert-falsy","assert.assert-true","assert.assert-false","assert.assert","assert.assert-null"],hideOperatorForm:!0},"assert-falsy":{category:"assert",description:"If $value is not `falsy` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-falsy } = import("assert");\ntry assert-falsy(true, "Expected falsy") catch (e) e.message end','let { assert-falsy } = import("assert");\ntry assert-falsy("x") catch (e) e.message end','let { assert-falsy } = import("assert");\ntry assert-falsy([]) catch (e) e.message end','let { assert-falsy } = import("assert");\ntry assert-falsy(nd) catch (e) e.message end','let { assert-falsy } = import("assert");\ntry assert-falsy(1) catch (e) e.message end','let { assert-falsy } = import("assert");\ntry assert-falsy(false) catch (e) e.message end','let { assert-falsy } = import("assert");\ntry assert-falsy(0) catch (e) e.message end','let { assert-falsy } = import("assert");\ntry assert-falsy(null) catch (e) e.message end','let { assert-falsy } = import("assert");\ntry assert-falsy("") catch (e) e.message end'],seeAlso:["assert.assert-truthy","assert.assert-false","assert.assert-true","assert.assert-null"],hideOperatorForm:!0},"assert-null":{category:"assert",description:"If $value is not `null` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-null } = import("assert");\ntry assert-null(null) catch (e) e.message end','let { assert-null } = import("assert");\ntry assert-null(true, "Expected null") catch (e) e.message end','let { assert-null } = import("assert");\ntry assert-null("x") catch (e) e.message end','let { assert-null } = import("assert");\ntry assert-null([]) catch (e) e.message end','let { assert-null } = import("assert");\ntry assert-null(nd) catch (e) e.message end','let { assert-null } = import("assert");\ntry assert-null(1) catch (e) e.message end','let { assert-null } = import("assert");\ntry assert-null(false) catch (e) e.message end','let { assert-null } = import("assert");\ntry assert-null(0) catch (e) e.message end','let { assert-null } = import("assert");\ntry assert-null("") catch (e) e.message end'],seeAlso:["assert.assert-truthy","assert.assert-falsy"],hideOperatorForm:!0},"assert-throws":{category:"assert",description:"If $fun does not throw, it throws `AssertionError`.",returns:{type:"null"},args:{fun:{type:"function"},message:{type:"string"}},variants:[{argumentNames:["fun"]},{argumentNames:["fun","message"]}],examples:['let { assert-throws } = import("assert");\nassert-throws(-> throw("Error"))','let { assert-throws } = import("assert");\ntry assert-throws(-> identity("Error")) catch (e) e.message end'],seeAlso:["assert.assert-throws-error","assert.assert-not-throws"],hideOperatorForm:!0},"assert-throws-error":{category:"assert",description:"If $fun does not throw $error-message, it throws `AssertionError`.",returns:{type:"null"},args:{fun:{type:"function"},"error-message":{type:"string"},message:{type:"string"}},variants:[{argumentNames:["value","error-message"]},{argumentNames:["value","error-message","message"]}],examples:['let { assert-throws-error } = import("assert");\ntry assert-throws-error(-> throw("Error"), "Error") catch (e) e.message end','let { assert-throws-error } = import("assert");\ntry assert-throws-error(-> identity("Error"), "Error") catch (e) e.message end'],seeAlso:["assert.assert-throws","assert.assert-not-throws"],hideOperatorForm:!0},"assert-not-throws":{category:"assert",description:"If $fun throws, it throws `AssertionError`.",returns:{type:"null"},args:{fun:{type:"function"},message:{type:"string"}},variants:[{argumentNames:["fun"]},{argumentNames:["fun","message"]}],examples:['let { assert-not-throws } = import("assert");\ntry assert-not-throws(-> identity("Error")) catch (e) e.message end','let { assert-not-throws } = import("assert");\ntry assert-not-throws(-> throw("Error")) catch (e) e.message end'],seeAlso:["assert.assert-throws","assert.assert-throws-error"],hideOperatorForm:!0},"assert-array":{category:"assert",description:"If $value is not an `array` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-array } = import("assert");\ntry assert-array([1, 2, 3]) catch (e) e.message end','let { assert-array } = import("assert");\ntry assert-array("string") catch (e) e.message end','let { assert-array } = import("assert");\ntry assert-array(42, "Expected an array") catch (e) e.message end'],seeAlso:["assert.assert-object","assert.assert-collection","assert.assert-sequence"],hideOperatorForm:!0},"assert-boolean":{category:"assert",description:"If $value is not a `boolean` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-boolean } = import("assert");\ntry assert-boolean(true) catch (e) e.message end','let { assert-boolean } = import("assert");\ntry assert-boolean(false) catch (e) e.message end','let { assert-boolean } = import("assert");\ntry assert-boolean(1, "Expected a boolean") catch (e) e.message end'],seeAlso:["assert.assert-true","assert.assert-false","assert.assert-number","assert.assert-string"],hideOperatorForm:!0},"assert-collection":{category:"assert",description:"If $value is not a `collection` (array, object, or string) it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-collection } = import("assert");\ntry assert-collection([1, 2]) catch (e) e.message end','let { assert-collection } = import("assert");\ntry assert-collection({ a: 1 }) catch (e) e.message end','let { assert-collection } = import("assert");\ntry assert-collection("hello") catch (e) e.message end','let { assert-collection } = import("assert");\ntry assert-collection(42, "Expected a collection") catch (e) e.message end'],seeAlso:["assert.assert-sequence","assert.assert-array","assert.assert-object"],hideOperatorForm:!0},"assert-function":{category:"assert",description:"If $value is not a `function` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-function } = import("assert");\ntry assert-function(-> $ + 1) catch (e) e.message end','let { assert-function } = import("assert");\ntry assert-function(42, "Expected a function") catch (e) e.message end'],seeAlso:["assert.assert-number","assert.assert-string"],hideOperatorForm:!0},"assert-grid":{category:"assert",description:"If $value is not a `grid` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-grid } = import("assert");\ntry assert-grid([[1, 2], [3, 4]]) catch (e) e.message end','let { assert-grid } = import("assert");\ntry assert-grid([1, 2], "Expected a grid") catch (e) e.message end'],seeAlso:["assert.assert-matrix","assert.assert-vector"],hideOperatorForm:!0},"assert-integer":{category:"assert",description:"If $value is not an `integer` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-integer } = import("assert");\ntry assert-integer(42) catch (e) e.message end','let { assert-integer } = import("assert");\ntry assert-integer(3.14, "Expected an integer") catch (e) e.message end'],seeAlso:["assert.assert-number"],hideOperatorForm:!0},"assert-matrix":{category:"assert",description:"If $value is not a `matrix` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-matrix } = import("assert");\ntry assert-matrix([[1, 2], [3, 4]]) catch (e) e.message end','let { assert-matrix } = import("assert");\ntry assert-matrix([1, 2], "Expected a matrix") catch (e) e.message end'],seeAlso:["assert.assert-vector","assert.assert-grid"],hideOperatorForm:!0},"assert-number":{category:"assert",description:"If $value is not a `number` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-number } = import("assert");\ntry assert-number(42) catch (e) e.message end','let { assert-number } = import("assert");\ntry assert-number("hello", "Expected a number") catch (e) e.message end'],seeAlso:["assert.assert-integer","assert.assert-boolean","assert.assert-string","assert.assert-function"],hideOperatorForm:!0},"assert-object":{category:"assert",description:"If $value is not an `object` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-object } = import("assert");\ntry assert-object({ a: 1 }) catch (e) e.message end','let { assert-object } = import("assert");\ntry assert-object([1, 2], "Expected an object") catch (e) e.message end'],seeAlso:["assert.assert-array","assert.assert-collection"],hideOperatorForm:!0},"assert-regexp":{category:"assert",description:"If $value is not a `regexp` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-regexp } = import("assert");\ntry assert-regexp(#"^start") catch (e) e.message end','let { assert-regexp } = import("assert");\ntry assert-regexp("hello", "Expected a regexp") catch (e) e.message end'],seeAlso:["assert.assert-string"],hideOperatorForm:!0},"assert-sequence":{category:"assert",description:"If $value is not a `sequence` (array or string) it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-sequence } = import("assert");\ntry assert-sequence([1, 2]) catch (e) e.message end','let { assert-sequence } = import("assert");\ntry assert-sequence("hello") catch (e) e.message end','let { assert-sequence } = import("assert");\ntry assert-sequence({ a: 1 }, "Expected a sequence") catch (e) e.message end'],seeAlso:["assert.assert-collection","assert.assert-array"],hideOperatorForm:!0},"assert-string":{category:"assert",description:"If $value is not a `string` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-string } = import("assert");\ntry assert-string("hello") catch (e) e.message end','let { assert-string } = import("assert");\ntry assert-string(42, "Expected a string") catch (e) e.message end'],seeAlso:["assert.assert-number","assert.assert-boolean","assert.assert-regexp","assert.assert-function"],hideOperatorForm:!0},"assert-vector":{category:"assert",description:"If $value is not a `vector` it throws `AssertionError`.",returns:{type:"null"},args:{value:{type:"any"},message:{type:"string"}},variants:[{argumentNames:["value"]},{argumentNames:["value","message"]}],examples:['let { assert-vector } = import("assert");\ntry assert-vector([1, 2, 3]) catch (e) e.message end','let { assert-vector } = import("assert");\ntry assert-vector(["a", "b"], "Expected a vector") catch (e) e.message end'],seeAlso:["assert.assert-matrix","assert.assert-grid"],hideOperatorForm:!0}},assertNormalExpression={assert:{evaluate:(e,t)=>{const r=e[0],n=2===e.length?e[1]:`${r}`;if(assertString(n,t),!r)throw new AssertionError(n,t);return asAny(r,t)},arity:{min:1,max:2}},"assert=":{evaluate:([e,t,r],n)=>{if(void 0!==r&&(assertString(r,n),r=` ${r}`),r??="",!deepEqual(asAny(e,n),asAny(t,n),n))throw new AssertionError(`Expected ${JSON.stringify(e,null,2)} to deep equal ${JSON.stringify(t,null,2)}.${r}`,n);return null},arity:{min:2,max:3}},"assert!=":{evaluate:([e,t,r],n)=>{if(void 0!==r&&(assertString(r,n),r=` ${r}`),r??="",deepEqual(asAny(e,n),asAny(t,n),n))throw new AssertionError(`Expected ${JSON.stringify(e)} not to deep equal ${JSON.stringify(t)}.${r}`,n);return null},arity:{min:2,max:3}},"assert-gt":{evaluate:([e,t,r],n)=>{if(assertStringOrNumber(e,n),assertStringOrNumber(t,n),void 0!==r&&(assertString(r,n),r=` ${r}`),r??="",compare(e,t,n)<=0)throw new AssertionError(`Expected ${e} to be grater than ${t}.${r}`,n);return null},arity:{min:2,max:3}},"assert-gte":{evaluate:([e,t,r],n)=>{if(assertStringOrNumber(e,n),assertStringOrNumber(t,n),void 0!==r&&(assertString(r,n),r=` ${r}`),r??="",compare(e,t,n)<0)throw new AssertionError(`Expected ${e} to be grater than or equal to ${t}.${r}`,n);return null},arity:{min:2,max:3}},"assert-lt":{evaluate:([e,t,r],n)=>{if(assertStringOrNumber(e,n),assertStringOrNumber(t,n),void 0!==r&&(assertString(r,n),r=` ${r}`),r??="",compare(e,t,n)>=0)throw new AssertionError(`Expected ${e} to be less than ${t}.${r}`,n);return null},arity:{min:2,max:3}},"assert-lte":{evaluate:([e,t,r],n)=>{if(assertStringOrNumber(e,n),assertStringOrNumber(t,n),void 0!==r&&(assertString(r,n),r=` ${r}`),r??="",compare(e,t,n)>0)throw new AssertionError(`Expected ${e} to be less than or equal to ${t}.${r}`,n);return null},arity:{min:2,max:3}},"assert-true":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!0!==e)throw new AssertionError(`Expected ${e} to be true.${t}`,r);return null},arity:{min:1,max:2}},"assert-false":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!1!==e)throw new AssertionError(`Expected ${e} to be false.${t}`,r);return null},arity:{min:1,max:2}},"assert-truthy":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!e)throw new AssertionError(`Expected ${e} to be truthy.${t}`,r);return null},arity:{min:1,max:2}},"assert-falsy":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",e)throw new AssertionError(`Expected ${e} to be falsy.${t}`,r);return null},arity:{min:1,max:2}},"assert-null":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",null!==e)throw new AssertionError(`Expected ${e} to be null.${t}`,r);return null},arity:{min:1,max:2}},"assert-throws":{evaluate:([e,t],r,n,{executeFunction:o})=>(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",assertFunctionLike(e,r),tryCatch(()=>chain(o(e,[],n,r),()=>{throw new AssertionError(`Expected function to throw.${t}`,r)}),()=>null)),arity:{min:1,max:2}},"assert-throws-error":{evaluate:([e,t,r],n,o,{executeFunction:a})=>(void 0!==r&&(assertString(r,n),r=` ${r}`),r??="",assertString(t,n),assertFunctionLike(e,n),tryCatch(()=>chain(a(e,[],o,n),()=>{throw new AssertionError(`Expected function to throw "${t}".${r}`,n)}),e=>{const o=e.shortMessage;if(o!==t)throw new AssertionError(`Expected function to throw "${t}", but thrown "${o}".${r}`,n);return null})),arity:{min:2,max:3}},"assert-not-throws":{evaluate:([e,t],r,n,{executeFunction:o})=>(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",assertFunctionLike(e,r),tryCatch(()=>chain(o(e,[],n,r),()=>null),()=>{throw new AssertionError(`Expected function not to throw.${t}`,r)})),arity:{min:1,max:2}},"assert-array":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!Array.isArray(e))throw new AssertionError(`Expected ${JSON.stringify(e)} to be an array.${t}`,r);return null},arity:{min:1,max:2}},"assert-boolean":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="","boolean"!=typeof e)throw new AssertionError(`Expected ${JSON.stringify(e)} to be a boolean.${t}`,r);return null},arity:{min:1,max:2}},"assert-collection":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!isColl(e))throw new AssertionError(`Expected ${JSON.stringify(e)} to be a collection.${t}`,r);return null},arity:{min:1,max:2}},"assert-function":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!isLitsFunction(e))throw new AssertionError(`Expected ${JSON.stringify(e)} to be a function.${t}`,r);return null},arity:{min:1,max:2}},"assert-grid":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!isGrid(e))throw new AssertionError(`Expected ${JSON.stringify(e)} to be a grid.${t}`,r);return null},arity:{min:1,max:2}},"assert-integer":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="","number"!=typeof e||!isNumber(e,{integer:!0}))throw new AssertionError(`Expected ${JSON.stringify(e)} to be an integer.${t}`,r);return null},arity:{min:1,max:2}},"assert-matrix":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!isMatrix(e))throw new AssertionError(`Expected ${JSON.stringify(e)} to be a matrix.${t}`,r);return null},arity:{min:1,max:2}},"assert-number":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="","number"!=typeof e)throw new AssertionError(`Expected ${JSON.stringify(e)} to be a number.${t}`,r);return null},arity:{min:1,max:2}},"assert-object":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!isObj(e))throw new AssertionError(`Expected ${JSON.stringify(e)} to be an object.${t}`,r);return null},arity:{min:1,max:2}},"assert-regexp":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!isRegularExpression(e))throw new AssertionError(`Expected ${JSON.stringify(e)} to be a regexp.${t}`,r);return null},arity:{min:1,max:2}},"assert-sequence":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!isSeq(e))throw new AssertionError(`Expected ${JSON.stringify(e)} to be a sequence.${t}`,r);return null},arity:{min:1,max:2}},"assert-string":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="","string"!=typeof e)throw new AssertionError(`Expected ${JSON.stringify(e)} to be a string.${t}`,r);return null},arity:{min:1,max:2}},"assert-vector":{evaluate:([e,t],r)=>{if(void 0!==t&&(assertString(t,r),t=` ${t}`),t??="",!isVector(e))throw new AssertionError(`Expected ${JSON.stringify(e)} to be a vector.${t}`,r);return null},arity:{min:1,max:2}}};for(const[e,t]of Object.entries(moduleDocs$6))assertNormalExpression[e]&&(assertNormalExpression[e].docs=t);const assertModule={name:"assert",functions:assertNormalExpression},moduleDocs$5={"every?":{category:"grid",description:"Checks if all elements in a grid satisfy a predicate. Returns true only if the predicate returns true for every element in the grid.",returns:{type:"boolean"},args:{a:{type:"grid"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],examples:['// Using "as" alias because "every?" shadows a builtin function\nlet { every? as grid-every? } = import("grid");\ngrid-every?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], string?)','// Using "as" alias because "every?" shadows a builtin function\nlet { every? as grid-every? } = import("grid");\ngrid-every?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], string?)','// Using "as" alias because "every?" shadows a builtin function\nlet { every? as grid-every? } = import("grid");\ngrid-every?([\n  [1, 2],\n  [3, 4],\n], string?)'],seeAlso:["collection.every?","grid.some?","grid.every-row?","grid.every-col?"]},"some?":{category:"grid",description:"Checks if any element in a grid satisfies a predicate. Returns true if the predicate returns true for at least one element in the grid.",returns:{type:"boolean"},args:{a:{type:"grid"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],examples:['let { some? } = import("grid");\nsome?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], string?)','let { some? } = import("grid");\nsome?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], string?)','let { some? } = import("grid");\nsome?([\n  [1, 2],\n  [3, 4],\n], string?)'],seeAlso:["collection.any?","grid.every?","grid.some-row?","grid.some-col?"]},"every-row?":{category:"grid",description:"Checks if all rows in a grid satisfy a predicate. Returns true only if the predicate returns true for every row in the grid.",returns:{type:"boolean"},args:{a:{type:"grid"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],examples:['let { every-row? } = import("grid");\nevery-row?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> string?($[0]))','let { every-row? } = import("grid");\nevery-row?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], -> string?($[0]))','let { every-row? } = import("grid");\nevery-row?([\n  [1, 2],\n  [3, 4],\n], -> string?($[0]))'],seeAlso:["grid.some-row?","grid.every-col?","grid.every?"]},"some-row?":{category:"grid",description:"Checks if any row in a grid satisfies a predicate. Returns true if the predicate returns true for at least one row in the grid.",returns:{type:"boolean"},args:{a:{type:"grid"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],examples:['let { some-row? } = import("grid");\nsome-row?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> $ contains? "Albert")','let { some-row? } = import("grid");\nsome-row?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], -> $ contains? "Albert")','let { some-row? } = import("grid");\nsome-row?([\n  [1, 2],\n  [3, 4],\n], -> $ contains? "Albert")'],seeAlso:["grid.every-row?","grid.some-col?","grid.some?"]},"every-col?":{category:"grid",description:"Checks if all columns in a grid satisfy a predicate. Returns true only if the predicate returns true for every column in the grid.",returns:{type:"boolean"},args:{a:{type:"grid"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],examples:['let { every-col? } = import("grid");\nevery-col?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> string?($[0]))','let { every-col? } = import("grid");\nevery-col?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], -> string?($[0]))','let { every-col? } = import("grid");\nevery-col?([\n  [1, 2],\n  [3, 4],\n], -> string?($[0]))'],seeAlso:["grid.some-col?","grid.every-row?","grid.every?"]},"some-col?":{category:"grid",description:"Checks if any column in a grid satisfies a predicate. Returns true if the predicate returns true for at least one column in the grid.",returns:{type:"boolean"},args:{a:{type:"grid"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],examples:['let { some-col? } = import("grid");\nsome-col?([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> $ contains? "Albert")','let { some-col? } = import("grid");\nsome-col?([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], -> $ contains? "Albert")','let { some-col? } = import("grid");\nsome-col?([\n  [1, 2],\n  [3, 4],\n], -> $ contains? "Albert")'],seeAlso:["grid.every-col?","grid.some-row?","grid.some?"]},row:{category:"grid",description:"Returns the row at index $a in the grid $b.",returns:{type:"any"},args:{a:{type:"grid"},b:{type:"number"}},variants:[{argumentNames:["a","b"]}],examples:['let { row } = import("grid");\nrow([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 0)','let { row } = import("grid");\nrow([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1)','let { row } = import("grid");\nrow([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 2)'],seeAlso:["grid.col","grid.shape"]},col:{category:"grid",description:"Returns the column at index $a in the grid $b.",returns:{type:"any"},args:{a:{type:"grid"},b:{type:"number"}},variants:[{argumentNames:["a","b"]}],examples:['let { col } = import("grid");\ncol([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 0)','let { col } = import("grid");\ncol([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1)','let { col } = import("grid");\ncol([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 2)'],seeAlso:["grid.row","grid.shape"]},shape:{category:"grid",description:"Returns the shape of the grid `g` as a `vector` of two numbers, where the first number is the number of rows and the second number is the number of columns.",returns:{type:"vector"},args:{g:{type:"grid",description:"The grid to get the shape of."}},variants:[{argumentNames:["g"]}],examples:['let { shape } = import("grid");\nshape([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])','let { shape } = import("grid");\nshape([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])','let { shape } = import("grid");\nshape([\n  [1, 2],\n  [3, 4],\n])'],seeAlso:["grid.row","grid.col","grid.reshape"]},fill:{category:"grid",description:"Creates a grid of the specified size, filled with the specified value.",returns:{type:"grid"},args:{rows:{type:"integer",description:"The number of rows in the grid."},cols:{type:"integer",description:"The number of columns in the grid."},value:{type:"any",description:"The value to fill the grid with."}},variants:[{argumentNames:["rows","cols","value"]}],examples:['let { fill } = import("grid");\nfill(2, 3, 0)','let { fill } = import("grid");\nfill(2, 3, "x")'],seeAlso:["grid.generate","grid.from-array","vector.fill"]},generate:{category:"grid",description:"Generates a grid of the specified size, where each element is generated by the provided function.",returns:{type:"grid"},args:{rows:{type:"number",description:"The number of rows in the grid."},cols:{type:"number",description:"The number of columns in the grid."},fn:{type:"function",description:"The function to generate the grid. It takes two arguments: the row index and the column index."}},variants:[{argumentNames:["rows","cols","fn"]}],examples:['let { generate } = import("grid");\ngenerate(3, 3, (i, j) -> i + j)'],seeAlso:["grid.fill","grid.from-array","vector.generate"]},reshape:{category:"grid",description:"Reshapes the grid `a` into a new grid with the specified number of rows `b`. The number of columns is automatically calculated based on the total number of elements in the grid.",returns:{type:"grid"},args:{a:{type:"grid"},b:{type:"number"}},variants:[{argumentNames:["a","b"]}],examples:['let { reshape } = import("grid");\nreshape([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], 2)'],seeAlso:["grid.shape","grid.from-array"]},transpose:{category:"grid",description:"Transposes the grid `g`, swapping its rows and columns.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to transpose."}},variants:[{argumentNames:["g"]}],examples:['let { transpose } = import("grid");\ntranspose([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])','let { transpose } = import("grid");\ntranspose([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])','let { transpose } = import("grid");\ntranspose([\n  [1, 2],\n  [3, 4],\n])'],seeAlso:["grid.flip-h","grid.flip-v","grid.rotate"]},"flip-h":{category:"grid",description:"Flips the grid `g` horizontally.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to flip horizontally."}},variants:[{argumentNames:["g"]}],examples:['let { flip-h } = import("grid");\nflip-h([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])','let { flip-h } = import("grid");\nflip-h([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])','let { flip-h } = import("grid");\nflip-h([\n  [1, 2],\n  [3, 4],\n])'],seeAlso:["grid.flip-v","grid.transpose","grid.rotate","grid.reverse-cols"]},"flip-v":{category:"grid",description:"Flips the grid `g` vertically.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to flip vertically."}},variants:[{argumentNames:["g"]}],examples:['let { flip-v } = import("grid");\nflip-v([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])','let { flip-v } = import("grid");\nflip-v([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])','let { flip-v } = import("grid");\nflip-v([\n  [1, 2],\n  [3, 4],\n])'],seeAlso:["grid.flip-h","grid.transpose","grid.rotate","grid.reverse-rows"]},rotate:{category:"grid",description:"Rotates the grid `g` by the specified angle. The angle is given in terms of 90-degree rotations. Positive values rotate the grid clockwise, while negative values rotate it counterclockwise.",returns:{type:"grid"},args:{a:{type:"grid"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],examples:['let { rotate } = import("grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], 1)','let { rotate } = import("grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], 2)','let { rotate } = import("grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], 3)','let { rotate } = import("grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], 4)','let { rotate } = import("grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], -1)','let { rotate } = import("grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], -2)','let { rotate } = import("grid");\nrotate([\n  [1, 2],\n  [3, 4],\n], -3)'],seeAlso:["grid.transpose","grid.flip-h","grid.flip-v"]},"reverse-rows":{category:"grid",description:"Reverses the order of rows in the grid `g`.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to reverse rows."}},variants:[{argumentNames:["g"]}],examples:['let { reverse-rows } = import("grid");\nreverse-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])','let { reverse-rows } = import("grid");\nreverse-rows([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])','let { reverse-rows } = import("grid");\nreverse-rows([\n  [1, 2],\n  [3, 4],\n])'],seeAlso:["grid.reverse-cols","grid.flip-v"]},"reverse-cols":{category:"grid",description:"Reverses the order of columns in the grid `g`.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to reverse columns."}},variants:[{argumentNames:["g"]}],examples:['let { reverse-cols } = import("grid");\nreverse-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])','let { reverse-cols } = import("grid");\nreverse-cols([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])','let { reverse-cols } = import("grid");\nreverse-cols([\n  [1, 2],\n  [3, 4],\n])'],seeAlso:["grid.reverse-rows","grid.flip-h"]},slice:{category:"grid",description:"Slices the grid `g` from the starting index `begin` to the optional ending index `stop`. The slice is inclusive of the starting index and exclusive of the ending index.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to slice."},begin:{type:"vector",description:"The starting index of the slice as a vector of two numbers: `[row, col]`."},stop:{type:"vector",description:"Optional ending index of the slice as a vector of two numbers: `[row, col]`."}},variants:[{argumentNames:["g","begin"]},{argumentNames:["g","begin","stop"]}],examples:['// Using "as" alias because "slice" shadows a builtin function\nlet { slice as grid-slice } = import("grid");\ngrid-slice([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], [1, 1], [2, 2])','// Using "as" alias because "slice" shadows a builtin function\nlet { slice as grid-slice } = import("grid");\ngrid-slice([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], [1, 1])'],hideOperatorForm:!0,seeAlso:["grid.slice-rows","grid.slice-cols"]},"slice-rows":{category:"grid",description:"Slices rows of the grid `g` from the starting index `begin` to the optional ending index `stop`. The slice is inclusive of the starting index and exclusive of the ending index.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to slice."},begin:{type:"number",description:"The starting index of the slice."},stop:{type:"number",description:"Optional ending index of the slice."}},variants:[{argumentNames:["g","begin"]},{argumentNames:["g","begin","stop"]}],examples:['let { slice-rows } = import("grid");\nslice-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 2)','let { slice-rows } = import("grid");\nslice-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1)'],hideOperatorForm:!0,seeAlso:["grid.slice","grid.slice-cols","grid.splice-rows"]},"slice-cols":{category:"grid",description:"Slices columns of the grid `g` from the starting index `begin` to the optional ending index `stop`. The slice is inclusive of the starting index and exclusive of the ending index.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to slice."},begin:{type:"number",description:"The starting index of the slice."},stop:{type:"number",description:"Optional ending index of the slice."}},variants:[{argumentNames:["g","begin"]},{argumentNames:["g","begin","stop"]}],examples:['let { slice-cols } = import("grid");\nslice-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 2)','let { slice-cols } = import("grid");\nslice-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1)'],hideOperatorForm:!0,seeAlso:["grid.slice","grid.slice-rows","grid.splice-cols"]},"splice-rows":{category:"grid",description:"Splices rows of the grid `g` starting from the index `begin`. Deletes `deleteCount` rows and inserts the specified `items` at that position.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to splice."},begin:{type:"number",description:"The starting index of the splice."},deleteCount:{type:"number",description:"The number of rows to delete."},items:{type:"array",rest:!0,description:"The rows to insert."}},variants:[{argumentNames:["g","begin","deleteCount"]},{argumentNames:["g","begin","deleteCount","items"]}],examples:['let { splice-rows } = import("grid");\nsplice-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 2)','let { splice-rows } = import("grid");\nsplice-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 1, ["Nazanin", "mother", 40])'],hideOperatorForm:!0,seeAlso:["grid.splice-cols","grid.slice-rows"]},"splice-cols":{category:"grid",description:"Splices columns of the grid `g` starting from the index `begin`. Deletes `deleteCount` columns and inserts the specified `items` at that position.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to splice."},begin:{type:"number",description:"The starting index of the splice."},deleteCount:{type:"number",description:"The number of columns to delete."},items:{type:"array",rest:!0,description:"The columns to insert."}},variants:[{argumentNames:["g","begin","deleteCount"]},{argumentNames:["g","begin","deleteCount","items"]}],examples:['let { splice-cols } = import("grid");\nsplice-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 2)','let { splice-cols } = import("grid");\nsplice-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], 1, 1, ["f", "m", "s"])'],hideOperatorForm:!0,seeAlso:["grid.splice-rows","grid.slice-cols"]},"concat-rows":{category:"grid",description:"Concatenates two grids `a` and `b` by rows. The number of columns in both grids must be the same.",returns:{type:"grid"},args:{a:{type:"grid"},b:{type:"grid"}},variants:[{argumentNames:["a","b"]}],examples:['let { concat-rows } = import("grid");\nconcat-rows([\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n], [\n  [1, 2],\n  [3, 4],\n])'],seeAlso:["grid.concat-cols","grid.push-rows"]},"concat-cols":{category:"grid",description:"Concatenates two grids `a` and `b` by columns. The number of rows in both grids must be the same.",returns:{type:"grid"},args:{a:{type:"grid"},b:{type:"grid"}},variants:[{argumentNames:["a","b"]}],examples:['let { concat-cols } = import("grid");\nconcat-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], [\n  ["Albert", "father"],\n  ["Nina", "mother"],\n  ["Kian", "son"],\n])'],seeAlso:["grid.concat-rows","grid.push-cols"]},map:{category:"grid",description:"Maps a function `a` over each element of the grid `b`, returning a new grid with the results.",returns:{type:"grid"},args:{a:{type:"grid"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],examples:['// Using "as" alias because "map" shadows a builtin function\nlet { map as grid-map } = import("grid");\ngrid-map([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], str)'],seeAlso:["map","grid.mapi","grid.reduce"]},mapi:{category:"grid",description:"Maps a function `a` over each element of the grid `b`, passing the row and column index as additional arguments to the function.",returns:{type:"grid"},args:{a:{type:"grid"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],examples:['// Using "as" alias because "mapi" shadows a builtin function\nlet { mapi as grid-mapi } = import("grid");\ngrid-mapi([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], -> $1 ++ "(" ++ $2 ++ ", " ++ $3 ++ ")")'],seeAlso:["grid.map","grid.reducei","map"]},reduce:{category:"grid",description:"Reduces the grid `a` using the function `b`, returning a single value.",returns:{type:"any"},args:{g:{type:"grid",description:"The grid to reduce."},fn:{type:"function",description:"The function to reduce the grid. It takes two arguments: the accumulator and the current element."},"initial-value":{type:"any",description:"The initial value for the accumulator."}},variants:[{argumentNames:["g","fn","initial-value"]}],examples:['// Using "as" alias because "reduce" shadows a builtin function\nlet { reduce as grid-reduce } = import("grid");\ngrid-reduce([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ++, "")'],seeAlso:["reduce","grid.reducei","grid.map"]},reducei:{category:"grid",description:"Reduces the grid `a` using the function `b`, passing the row and column indices as additional arguments to the function.",returns:{type:"any"},args:{g:{type:"grid",description:"The grid to reduce."},fn:{type:"function",description:"The function to reduce the grid. It takes four arguments: the accumulator, the current element, the row index, and the column index."},"initial-value":{type:"any",description:"The initial value for the accumulator."}},variants:[{argumentNames:["g","fn","initial-value"]}],examples:['// Using "as" alias because "reducei" shadows a builtin function\nlet { reducei as grid-reducei } = import("grid");\ngrid-reducei([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ++, "")'],seeAlso:["grid.reduce","grid.mapi","reduce"]},"push-rows":{category:"grid",description:"Pushes the specified rows into the grid `g` and returns the new grid.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to push rows into."},rows:{type:"array",rest:!0,description:"The rows to push into the grid."}},variants:[{argumentNames:["g","rows"]}],examples:['let { push-rows } = import("grid");\npush-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ["Nazanin", "mother", 40])'],hideOperatorForm:!0,seeAlso:["grid.unshift-rows","grid.pop-row","grid.shift-row","grid.concat-rows"]},"unshift-rows":{category:"grid",description:"Unshifts the specified rows into the grid `g` and returns the new grid.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to unshift rows into."},rows:{type:"array",rest:!0,description:"The rows to unshift into the grid."}},variants:[{argumentNames:["g","rows"]}],examples:['let { unshift-rows } = import("grid");\nunshift-rows([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ["Nazanin", "mother", 40])'],hideOperatorForm:!0,seeAlso:["grid.push-rows","grid.shift-row","grid.pop-row"]},"pop-row":{category:"grid",description:"Pops the last row from the grid `g` and returns the new grid.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to pop a row from."}},variants:[{argumentNames:["g"]}],examples:['let { pop-row } = import("grid");\npop-row([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])'],seeAlso:["grid.shift-row","grid.push-rows","grid.unshift-rows"]},"shift-row":{category:"grid",description:"Shifts the first row from the grid `g` and returns the new grid.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to shift a row from."}},variants:[{argumentNames:["g"]}],examples:['let { shift-row } = import("grid");\nshift-row([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])'],seeAlso:["grid.pop-row","grid.push-rows","grid.unshift-rows"]},"push-cols":{category:"grid",description:"Pushes the specified columns into the grid `g` and returns the new grid.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to push columns into."},cols:{type:"array",rest:!0,description:"The columns to push into the grid."}},variants:[{argumentNames:["g","cols"]}],examples:['let { push-cols } = import("grid");\npush-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ["f", "m", "s"])'],hideOperatorForm:!0,seeAlso:["grid.unshift-cols","grid.pop-col","grid.shift-col","grid.concat-cols"]},"unshift-cols":{category:"grid",description:"Unshifts the specified columns into the grid `g` and returns the new grid.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to unshift columns into."},cols:{type:"array",rest:!0,description:"The columns to unshift into the grid."}},variants:[{argumentNames:["g","cols"]}],examples:['let { unshift-cols } = import("grid");\nunshift-cols([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n], ["f", "m", "s"])'],hideOperatorForm:!0,seeAlso:["grid.push-cols","grid.shift-col","grid.pop-col"]},"pop-col":{category:"grid",description:"Pops the last column from the grid `g` and returns the new grid.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to pop a column from."}},variants:[{argumentNames:["g"]}],examples:['let { pop-col } = import("grid");\npop-col([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])'],seeAlso:["grid.shift-col","grid.push-cols","grid.unshift-cols"]},"shift-col":{category:"grid",description:"Shifts the first column from the grid `g` and returns the new grid.",returns:{type:"grid"},args:{g:{type:"grid",description:"The grid to shift a column from."}},variants:[{argumentNames:["g"]}],examples:['let { shift-col } = import("grid");\nshift-col([\n  ["Albert", "father", 10],\n  ["Nina", "mother", 20],\n  ["Kian", "son", 30],\n])'],seeAlso:["grid.pop-col","grid.push-cols","grid.unshift-cols"]},"from-array":{category:"grid",description:"Creates a grid from a flat array with specified dimensions. The array is reshaped into the specified number of rows, and the number of columns is automatically calculated based on the total number of elements in the array.",returns:{type:"grid"},args:{a:{type:"array"},b:{type:"number"}},variants:[{argumentNames:["a","b"]}],examples:['let { from-array } = import("grid");\nfrom-array([1, 2, 3, 4], 2)','let { from-array } = import("grid");\nfrom-array([1, 2, 3, 4], 4)'],seeAlso:["grid.fill","grid.generate","grid.reshape"]}};function fromArray(e,t){const r=[],n=e.length/t;for(let o=0;o<t;o++){const t=o*n,a=t+n;r.push(e.slice(t,a))}return r}function transpose(e){const t=[];for(let r=0;r<e[0].length;r+=1){const n=[];for(let t=0;t<e.length;t+=1)n.push(e[t][r]);t.push(n)}return t}const gridFunctions={"every?":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertGrid(e,r),assertFunctionLike(t,r);const a=[];for(const t of e)for(const e of t)a.push(e);return everySequential(a,e=>o(t,[e],n,r))},arity:toFixedArity(2)},"some?":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertGrid(e,r),assertFunctionLike(t,r);const a=[];for(const t of e)for(const e of t)a.push(e);return someSequential(a,e=>o(t,[e],n,r))},arity:toFixedArity(2)},"every-row?":{evaluate:([e,t],r,n,{executeFunction:o})=>(assertGrid(e,r),assertFunctionLike(t,r),everySequential(Array.from(e),e=>o(t,[e],n,r))),arity:toFixedArity(2)},"some-row?":{evaluate:([e,t],r,n,{executeFunction:o})=>(assertGrid(e,r),assertFunctionLike(t,r),someSequential(Array.from(e),e=>o(t,[e],n,r))),arity:toFixedArity(2)},"every-col?":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertGrid(e,r),assertFunctionLike(t,r);const a=transpose(e);return everySequential(Array.from(a),e=>o(t,[e],n,r))},arity:toFixedArity(2)},"some-col?":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertGrid(e,r),assertFunctionLike(t,r);const a=transpose(e);return someSequential(Array.from(a),e=>o(t,[e],n,r))},arity:toFixedArity(2)},row:{evaluate:([e,t],r)=>(assertGrid(e,r),assertNumber(t,r,{integer:!0,nonNegative:!0,lt:e.length}),e[t]),arity:toFixedArity(2)},col:{evaluate:([e,t],r)=>(assertGrid(e,r),assertNumber(t,r,{integer:!0,nonNegative:!0,lt:e[0].length}),e.map(e=>e[t])),arity:toFixedArity(2)},shape:{evaluate:([e],t)=>(assertGrid(e,t),[e.length,e[0].length]),arity:toFixedArity(1)},fill:{evaluate:([e,t,r],n)=>{assertNumber(e,n,{integer:!0,positive:!0}),assertNumber(t,n,{integer:!0,positive:!0}),assertAny(r,n);const o=[];for(let n=0;n<e;n+=1){const e=[];for(let n=0;n<t;n+=1)e.push(r);o.push(e)}return o},arity:toFixedArity(3)},generate:{evaluate:([e,t,r],n,o,{executeFunction:a})=>(assertNumber(e,n,{integer:!0,positive:!0}),assertNumber(t,n,{integer:!0,positive:!0}),assertFunctionLike(r,n),mapSequential(Array.from({length:e}),(e,i)=>mapSequential(Array.from({length:t}),(e,t)=>chain(a(r,[i,t],o,n),e=>(assertAny(e,n),e))))),arity:toFixedArity(3)},reshape:{evaluate:([e,t],r)=>{assertGrid(e,r),assertNumber(t,r,{integer:!0,positive:!0});const n=e.flat();if(n.length%t!==0)throw new LitsError(`The number of elements in the grid must be divisible by rows, but got ${n.length} and ${t}`,r);const o=n.length/t,a=[];for(let e=0;e<t;e+=1){const t=[];for(let r=0;r<o;r+=1)t.push(n[e*o+r]);a.push(t)}return a},arity:toFixedArity(2)},transpose:{evaluate:([e],t)=>(assertGrid(e,t),transpose(e)),arity:toFixedArity(1)},"flip-h":{evaluate:([e],t)=>(assertGrid(e,t),e.map(e=>e.reverse())),arity:toFixedArity(1)},"flip-v":{evaluate:([e],t)=>(assertGrid(e,t),e.reverse()),arity:toFixedArity(1)},rotate:{evaluate:([e,t],r)=>{if(assertGrid(e,r),assertNumber(t,r,{integer:!0}),0===(t=(t%4+4)%4)||0===e.length)return e.map(e=>[...e]);const n=e.length,o=e[0].length;let a;switch(t){case 1:a=Array(o).fill(null).map(()=>Array(n).fill(null));for(let t=0;t<n;t++)for(let r=0;r<o;r++)a[r][n-1-t]=e[t][r];break;case 2:a=Array(n).fill(null).map(()=>Array(o).fill(null));for(let t=0;t<n;t++)for(let r=0;r<o;r++)a[n-1-t][o-1-r]=e[t][r];break;case 3:a=Array(o).fill(null).map(()=>Array(n).fill(null));for(let t=0;t<n;t++)for(let r=0;r<o;r++)a[o-1-r][t]=e[t][r]}return a},arity:toFixedArity(2)},"reverse-rows":{evaluate:([e],t)=>(assertGrid(e,t),e.reverse()),arity:toFixedArity(1)},"reverse-cols":{evaluate:([e],t)=>(assertGrid(e,t),e.map(e=>e.reverse())),arity:toFixedArity(1)},slice:{evaluate:([e,t,r],n)=>{if(assertGrid(e,n),assertVector(t,n),2!==t.length)throw new LitsError(`The start vector must have 2 elements, but got ${t.length}`,n);const[o,a]=t;if(assertNumber(o,n,{integer:!0,nonNegative:!0,lt:e.length}),assertNumber(a,n,{integer:!0,nonNegative:!0,lt:e[0].length}),r??=[e.length,e[0].length],assertVector(r,n),2!==r.length)throw new LitsError(`The end vector must have 2 elements, but got ${r.length}`,n);const[i,s]=r;assertNumber(i,n,{gt:o,lte:e.length}),assertNumber(s,n,{gt:a,lte:e[0].length});const c=[];for(let t=o;t<i;t+=1){const r=[];for(let n=a;n<s;n+=1)r.push(e[t][n]);c.push(r)}return c},arity:{min:2,max:3}},"slice-rows":{evaluate:([e,t,r],n)=>(assertGrid(e,n),void 0===r?(assertNumber(t,n,{integer:!0,lte:e.length,gte:-e.length}),t<0?e.slice(e.length+t):e.slice(t)):(assertNumber(t,n,{integer:!0,nonNegative:!0,lte:e.length}),assertNumber(r,n,{integer:!0}),assertNumber(r=r<0?e.length+r:r,n,{gt:t,lte:e.length}),e.slice(t,r))),arity:{min:2,max:3}},"slice-cols":{evaluate:([e,t,r],n)=>{assertGrid(e,n);const o=transpose(e);return void 0===r?(assertNumber(t,n,{integer:!0,lte:o.length,gte:-o.length}),transpose(t<0?o.slice(o.length+t):o.slice(t))):(assertNumber(t,n,{integer:!0,nonNegative:!0,lte:o.length}),assertNumber(r,n,{integer:!0}),assertNumber(r=r<0?o.length+r:r,n,{gt:t,lte:o.length}),transpose(o.slice(t,r)))},arity:{min:2,max:3}},"splice-rows":{evaluate:([e,t,r,...n],o)=>{assertGrid(e,o),assertNumber(t,o,{integer:!0,nonNegative:!0,lte:e.length}),assertNumber(r,o,{integer:!0,nonNegative:!0}),0!==n.length&&(assertGrid(n,o),n.every(t=>{if(assertArray(t,o),e[0].length!==t.length)throw new LitsError(`All rows must have the same length as the number of columns in grid, but got ${t.length}`,o);return!0}));const a=[];for(let r=0;r<t;r+=1)a.push(e[r]);n.length>0&&a.push(...n);for(let n=t+r;n<e.length;n+=1)a.push(e[n]);return a},arity:{min:3}},"splice-cols":{evaluate:([e,t,r,...n],o)=>{assertGrid(e,o);const a=transpose(e);assertNumber(t,o,{integer:!0,nonNegative:!0,lte:a.length}),assertNumber(r,o,{integer:!0,nonNegative:!0}),0!==n.length&&(assertGrid(n,o),n.every(e=>{if(assertArray(e,o),a[0].length!==e.length)throw new LitsError(`All rows must have the same length as the number of rows in grid, but got ${e.length}`,o);return!0}));const i=[];for(let e=0;e<t;e+=1)i.push(a[e]);i.push(...n);for(let e=t+r;e<a.length;e+=1)i.push(a[e]);return transpose(i)},arity:{min:3}},"concat-rows":{evaluate:(e,t)=>{assertArray(e,t),e.every(e=>assertGrid(e,t));const r=e[0][0].length;e.slice(1).every(e=>{if(e[0].length!==r)throw new LitsError(`All grids must have the same number of columns, but got ${r} and ${e[0].length}`,t);return!0});const n=[];return e.forEach(e=>{e.forEach(e=>{n.push(e)})}),n},arity:{min:1}},"concat-cols":{evaluate:(e,t)=>{assertArray(e,t),e.every(e=>assertGrid(e,t));const r=e[0].length;e.slice(1).every(e=>{if(e.length!==r)throw new LitsError(`All grids must have the same number of rows, but got ${r} and ${e.length}`,t);return!0});const n=[];for(let t=0;t<r;t+=1){const r=[];e.forEach(e=>{r.push(...e[t])}),n.push(r)}return n},arity:{min:1}},map:{evaluate:(e,t,r,{executeFunction:n})=>{const o=asFunctionLike(e.at(-1),t),a=e.slice(0,-1);assertGrid(a[0],t);const i=a[0].length,s=a[0][0].length;return a.slice(1).forEach(e=>{if(assertGrid(e,t),e.length!==i)throw new LitsError(`All grids must have the same number of rows, but got ${i} and ${e.length}`,t);if(e[0].length!==s)throw new LitsError(`All grids must have the same number of columns, but got ${s} and ${e[0].length}`,t)}),mapSequential(Array.from({length:i}),(e,i)=>mapSequential(Array.from({length:s}),(e,s)=>{const c=a.map(e=>e[i][s]);return chain(n(o,c,r,t),e=>asAny(e))}))},arity:{min:2}},mapi:{evaluate:([e,t],r,n,{executeFunction:o})=>{assertGrid(e,r),assertFunctionLike(t,r);const a=e.length,i=e[0].length;return mapSequential(Array.from({length:a}),(a,s)=>mapSequential(Array.from({length:i}),(a,i)=>chain(o(t,[e[s][i],s,i],n,r),e=>asAny(e))))},arity:toFixedArity(2)},reduce:{evaluate:([e,t,r],n,o,{executeFunction:a})=>{assertGrid(e,n),assertFunctionLike(t,n);const i=[];for(const t of e)for(const e of t)i.push(e);return reduceSequential(i,(e,r)=>a(t,[e,r],o,n),asAny(r))},arity:toFixedArity(3)},reducei:{evaluate:([e,t,r],n,o,{executeFunction:a})=>{assertGrid(e,n),assertFunctionLike(t,n);const i=[];for(let t=0;t<e.length;t+=1)for(let r=0;r<e[t].length;r+=1)i.push({cell:e[t][r],i:t,j:r});return reduceSequential(i,(e,{cell:r,i:i,j:s})=>a(t,[e,r,i,s],o,n),asAny(r))},arity:toFixedArity(3)},"push-rows":{evaluate:([e,...t],r)=>{if(assertGrid(e,r),assertGrid(t,r),e[0].length!==t[0].length)throw new LitsError(`All rows must have the same length as the number of columns in grid, but got ${e[0].length} and ${t[0].length}`,r);return[...e,...t]},arity:{min:2}},"unshift-rows":{evaluate:([e,...t],r)=>{if(assertGrid(e,r),assertGrid(t,r),e[0].length!==t[0].length)throw new LitsError(`All rows must have the same length as the number of columns in grid, but got ${e[0].length} and ${t[0].length}`,r);return[...t,...e]},arity:{min:2}},"pop-row":{evaluate:([e],t)=>(assertGrid(e,t),1===e.length?null:e.slice(0,-1)),arity:toFixedArity(1)},"shift-row":{evaluate:([e],t)=>(assertGrid(e,t),1===e.length?null:e.slice(1)),arity:toFixedArity(1)},"push-cols":{evaluate:([e,...t],r)=>{if(assertGrid(e,r),assertGrid(t,r),e.length!==t[0].length)throw new LitsError(`All columns must have the same length as the number of rows in grid, but got ${t.length}`,r);const n=[];for(let r=0;r<e.length;r+=1){const o=[];o.push(...e[r]),t.forEach(e=>{o.push(e[r])}),n.push(o)}return n},arity:{min:2}},"unshift-cols":{evaluate:([e,...t],r)=>{if(assertGrid(e,r),assertGrid(t,r),e.length!==t[0].length)throw new LitsError(`All columns must have the same length as the number of rows in grid, but got ${t.length}`,r);const n=[];for(let r=0;r<e.length;r+=1){const o=[];t.forEach(e=>{o.push(e[r])}),o.push(...e[r]),n.push(o)}return n},arity:{min:2}},"pop-col":{evaluate:([e],t)=>(assertGrid(e,t),1===e[0].length?null:e.map(e=>e.slice(0,-1))),arity:toFixedArity(1)},"shift-col":{evaluate:([e],t)=>(assertGrid(e,t),1===e[0].length?null:e.map(e=>e.slice(1))),arity:toFixedArity(1)},"from-array":{evaluate:([e,t],r)=>{if(assertArray(e,r),assertNumber(t,r,{integer:!0,positive:!0}),e.length%t!==0)throw new LitsError(`The number of elements in the array must be divisible by rows, but got ${e.length} and ${t}`,r);return fromArray(e,t)},arity:toFixedArity(2)}};for(const[e,t]of Object.entries(moduleDocs$5))gridFunctions[e]&&(gridFunctions[e].docs=t);const gridModule={name:"grid",functions:gridFunctions},moduleDocs$4={"random!":{category:"random",description:"Returns a random number between 0 and 1.",returns:{type:"number"},args:{},variants:[{argumentNames:[]}],examples:['let { random! } = import("random"); random!()'],seeAlso:["random.random-float!","random.random-int!","random.random-boolean!"]},"random-int!":{category:"random",description:"Returns a random integer between min and max (exclusive).",returns:{type:"integer"},args:{a:{type:"integer",description:"The minimum value."},b:{type:"integer",description:"The maximum value (exclusive)."}},variants:[{argumentNames:["a","b"]}],examples:['let { random-int! } = import("random"); random-int!(0, 10)','let { random-int! } = import("random"); random-int!(1, 100)'],seeAlso:["random.random-int-inclusive!","random.random-float!","random.random!"]},"random-int-inclusive!":{category:"random",description:"Returns a random integer between min and max (inclusive).",returns:{type:"integer"},args:{a:{type:"integer",description:"The minimum value."},b:{type:"integer",description:"The maximum value (inclusive)."}},variants:[{argumentNames:["a","b"]}],examples:['let { random-int-inclusive! } = import("random"); random-int-inclusive!(0, 10)'],seeAlso:["random.random-int!","random.random-float!"]},"random-float!":{category:"random",description:"Returns a random float between min and max.",returns:{type:"number"},args:{a:{type:"number",description:"The minimum value."},b:{type:"number",description:"The maximum value."}},variants:[{argumentNames:["a","b"]}],examples:['let { random-float! } = import("random"); random-float!(0, 10)','let { random-float! } = import("random"); random-float!(1, 100)'],seeAlso:["random.random!","random.random-int!","random.random-int-inclusive!"]},"random-boolean!":{category:"random",description:"Returns a random boolean.",returns:{type:"boolean"},args:{prob:{type:"number",description:"The probability of returning true (between 0 and 1)."}},variants:[{argumentNames:["prob"]}],examples:['let { random-boolean! } = import("random"); random-boolean!()','let { random-boolean! } = import("random"); random-boolean!(0.99)'],seeAlso:["random.random!"]},"random-item!":{category:"random",description:"Returns a random item from the array.",returns:{type:"any"},args:{a:{type:"array",description:"The array to sample from."}},variants:[{argumentNames:["a"]}],examples:['let { random-item! } = import("random"); random-item!([1, 2, 3, 4, 5])','let { random-item! } = import("random"); random-item!(["apple", "banana", "cherry"])'],seeAlso:["random.random-sample!","random.random-sample-unique!","random.random-char!"]},"random-sample-unique!":{category:"random",description:"Returns a random sample of n unique items from the array.",returns:{type:"array"},args:{a:{type:"array",description:"The array to sample from."},b:{type:"integer",description:"The number of items to sample."}},variants:[{argumentNames:["a","b"]}],examples:['let { random-sample-unique! } = import("random"); random-sample-unique!([1, 2, 3, 4, 5], 3)','let { random-sample-unique! } = import("random"); random-sample-unique!(["apple", "banana", "cherry"], 2)'],seeAlso:["random.random-sample!","random.random-item!","random.shuffle!"]},"random-sample!":{category:"random",description:"Returns a random sample of n items from the array.",returns:{type:"array"},args:{a:{type:"array",description:"The array to sample from."},b:{type:"integer",description:"The number of items to sample."}},variants:[{argumentNames:["a","b"]}],examples:['let { random-sample! } = import("random"); random-sample!([1, 2, 3, 4, 5], 3)','let { random-sample! } = import("random"); random-sample!(["apple", "banana", "cherry"], 10)'],seeAlso:["random.random-sample-unique!","random.random-item!","random.shuffle!"]},"shuffle!":{category:"random",description:"Returns a shuffled version of the array.",returns:{type:"array"},args:{a:{type:"array",description:"The array to shuffle."}},variants:[{argumentNames:["a"]}],examples:['let { shuffle! } = import("random"); shuffle!([1, 2, 3, 4, 5])','let { shuffle! } = import("random"); shuffle!(["apple", "banana", "cherry"])'],seeAlso:["random.random-sample!","random.random-sample-unique!"]},"random-normal!":{category:"random",description:"Returns a random number from a normal distribution with the given mean and standard deviation.",returns:{type:"number"},args:{mean:{type:"number",description:"The mean of the normal distribution."},stdDev:{type:"number",description:"The standard deviation of the normal distribution."}},variants:[{argumentNames:["mean","stdDev"]}],examples:['let { random-normal! } = import("random"); random-normal!(0, 1)','let { random-normal! } = import("random"); random-normal!(5, 2)'],seeAlso:["random.random-exponential!","random.random-binomial!","random.random-poisson!"],hideOperatorForm:!0},"random-exponential!":{category:"random",description:"Returns a random number from an exponential distribution with the given rate parameter.",returns:{type:"number"},args:{lambda:{type:"number",description:"The rate parameter of the exponential distribution."}},variants:[{argumentNames:["lambda"]}],examples:['let { random-exponential! } = import("random"); random-exponential!(1)','let { random-exponential! } = import("random"); random-exponential!(0.5)'],seeAlso:["random.random-normal!","random.random-poisson!","random.random-gamma!","random.random-pareto!"]},"random-binomial!":{category:"random",description:"Returns a random number from a binomial distribution with the given number of trials and probability of success.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number of trials."},p:{type:"number",description:"The probability of success on each trial."}},variants:[{argumentNames:["n","p"]}],examples:['let { random-binomial! } = import("random"); random-binomial!(10, 0.5)','let { random-binomial! } = import("random"); random-binomial!(20, 0.3)'],seeAlso:["random.random-normal!","random.random-poisson!"],hideOperatorForm:!0},"random-poisson!":{category:"random",description:"Returns a random number from a Poisson distribution with the given rate parameter.",returns:{type:"integer"},args:{lambda:{type:"number",description:"The rate parameter of the Poisson distribution."}},variants:[{argumentNames:["lambda"]}],examples:['let { random-poisson! } = import("random"); random-poisson!(1)','let { random-poisson! } = import("random"); random-poisson!(5)'],seeAlso:["random.random-binomial!","random.random-normal!","random.random-exponential!"]},"random-gamma!":{category:"random",description:"Returns a random number from a gamma distribution with the given shape and scale parameters.",returns:{type:"number"},args:{shape:{type:"number",description:"The shape parameter of the gamma distribution."},scale:{type:"number",description:"The scale parameter of the gamma distribution."}},variants:[{argumentNames:["shape","scale"]}],examples:['let { random-gamma! } = import("random"); random-gamma!(2, 2)','let { random-gamma! } = import("random"); random-gamma!(5, 1)'],seeAlso:["random.random-exponential!","random.random-pareto!"],hideOperatorForm:!0},"random-pareto!":{category:"random",description:"Returns a random number from a Pareto distribution with the given shape parameter.",returns:{type:"number"},args:{alpha:{type:"number",description:"The shape parameter of the Pareto distribution."}},variants:[{argumentNames:["alpha"]}],examples:['let { random-pareto! } = import("random"); random-pareto!(1)','let { random-pareto! } = import("random"); random-pareto!(2)'],seeAlso:["random.random-gamma!","random.random-exponential!"]},"uuid!":{category:"random",description:"Returns a random UUID v4 (Universally Unique Identifier).",returns:{type:"string"},args:{},variants:[{argumentNames:[]}],examples:['let { uuid! } = import("random"); uuid!()'],seeAlso:["random.random-id!","random.random-string!"]},"random-char!":{category:"random",description:"Returns a random character from the given string.",returns:{type:"string"},args:{charSet:{type:"string",description:"The string to sample from."}},variants:[{argumentNames:["charSet"]}],examples:['let { random-char! } = import("random"); random-char!("abcde")','let { random-char! } = import("random"); random-char!("ABCDEFGHIJKLMNOPQRSTUVWXYZ")'],seeAlso:["random.random-string!","random.random-item!"]},"random-string!":{category:"random",description:"Returns a random string of the given length from the given string.",returns:{type:"string"},args:{length:{type:"integer",description:"The length of the random string."},charSet:{type:"string",description:"The string to sample from."}},variants:[{argumentNames:["length","charSet"]}],examples:['let { random-string! } = import("random"); random-string!(10, "abcde")','let { random-string! } = import("random"); random-string!(5, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")'],seeAlso:["random.random-char!","random.random-id!","random.uuid!"],hideOperatorForm:!0},"random-id!":{category:"random",description:"Returns a random ID of the given length.",returns:{type:"string"},args:{length:{type:"integer",description:"The length of the random ID."}},variants:[{argumentNames:["length"]}],examples:['let { random-id! } = import("random"); random-id!(10)','let { random-id! } = import("random"); random-id!(5)'],seeAlso:["random.random-string!","random.uuid!"]},"random-color!":{category:"random",description:"Returns a random color in hex format.",returns:{type:"string"},args:{},variants:[{argumentNames:[]}],examples:['let { random-color! } = import("random"); random-color!()']}},randomFunctions={"random!":{evaluate:()=>Math.random(),arity:toFixedArity(0)},"random-int!":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0,gt:e}),Math.floor(Math.random()*(t-e))+e),arity:toFixedArity(2)},"random-int-inclusive!":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0,gte:e}),Math.floor(Math.random()*(t-e+1))+e),arity:toFixedArity(2)},"random-float!":{evaluate:([e,t],r)=>(assertNumber(e,r),assertNumber(t,r,{gt:e}),Math.random()*(t-e)+e),arity:toFixedArity(2)},"random-boolean!":{evaluate:([e],t)=>{const r=e??.5;return assertNumber(r,t,{gte:0,lte:1}),Math.random()<r},arity:{min:0,max:1}},"random-item!":{evaluate:([e],t)=>{assertArray(e,t);return asAny(e[Math.floor(Math.random()*e.length)])},arity:toFixedArity(1)},"random-sample!":{evaluate:([e,t],r)=>{if(assertArray(e,r),assertNumber(t,r,{integer:!0,nonNegative:!0}),0===e.length)throw new LitsError("Cannot sample from an empty array.",r);const n=[];for(let r=0;r<t;r++){const t=Math.floor(Math.random()*e.length);n.push(e[t])}return n},arity:toFixedArity(2)},"random-sample-unique!":{evaluate:([e,t],r)=>{if(assertArray(e,r),assertNumber(t,r,{integer:!0,nonNegative:!0,lte:e.length}),0===e.length)throw new LitsError("Cannot sample from an empty array.",r);const n=[],o=[...e];for(let e=0;e<t;e++){const e=Math.floor(Math.random()*o.length);n.push(o[e]),o.splice(e,1)}return n},arity:toFixedArity(2)},"shuffle!":{evaluate:([e],t)=>{assertArray(e,t);const r=[...e];for(let e=r.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[r[e],r[t]]=[r[t],r[e]]}return r},arity:toFixedArity(1)},"random-normal!":{evaluate:([e,t],r)=>{assertNumber(e,r),assertNumber(t,r,{gt:0});const n=Math.random(),o=Math.random();return Math.sqrt(-2*Math.log(n))*Math.cos(2*Math.PI*o)*t+e},arity:toFixedArity(2)},"random-exponential!":{evaluate:([e],t)=>{assertNumber(e,t,{gt:0});const r=Math.random();return-Math.log(r)/e},arity:toFixedArity(1)},"random-binomial!":{evaluate:([e,t],r)=>{assertNumber(e,r,{integer:!0,nonNegative:!0}),assertNumber(t,r,{gte:0,lte:1});let n=0;for(let r=0;r<e;r++)Math.random()<t&&n++;return n},arity:toFixedArity(2)},"random-poisson!":{evaluate:([e],t)=>{assertNumber(e,t,{gt:0});const r=Math.exp(-e);let n=0,o=1;do{n++,o*=Math.random()}while(o>r);return n-1},arity:toFixedArity(1)},"random-gamma!":{evaluate:([e,t],r)=>(assertNumber(e,r,{gt:0}),assertNumber(t,r,{gt:0}),randomGamma(e,t)),arity:toFixedArity(2)},"random-pareto!":{evaluate:([e],t)=>{assertNumber(e,t,{gt:0});return(1/Math.random())**(1/e)},arity:toFixedArity(1)},"uuid!":{evaluate:()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)}),arity:toFixedArity(0)},"random-char!":{evaluate:([e],t)=>{if(assertString(e,t),0===e.length)throw new LitsError("Character set cannot be empty.",t);return e[Math.floor(Math.random()*e.length)]},arity:toFixedArity(1)},"random-string!":{evaluate:([e,t],r)=>{if(assertNumber(e,r,{integer:!0,positive:!0}),assertString(t,r),0===t.length)throw new LitsError("Character set cannot be empty.",r);let n="";for(let r=0;r<e;r++){n+=t[Math.floor(Math.random()*t.length)]}return n},arity:toFixedArity(2)},"random-id!":{evaluate:([e],t)=>{assertNumber(e,t,{integer:!0,positive:!0});const r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";let n="";for(let t=0;t<e;t++){n+=r[Math.floor(62*Math.random())]}return n},arity:toFixedArity(1)},"random-color!":{evaluate:()=>`#${Math.floor(16777216*Math.random()).toString(16).padStart(6,"0")}`,arity:toFixedArity(0)}};function randomGamma(e,t=1){if(e<1){return randomGamma(e+1-1/3,t)*Math.random()**(1/e)}const r=e-1/3,n=1/Math.sqrt(9*r);let o,a,i;for(;;){do{o=randn(),a=1+n*o}while(a<=0);if(a*=a*a,i=Math.random(),i<1-.0331*o*o*o*o)return t*r*a;if(Math.log(i)<.5*o*o+r*(1-a+Math.log(a)))return t*r*a}}function randn(){let e=0,t=0;for(;0===e;)e=Math.random();for(;0===t;)t=Math.random();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}for(const[e,t]of Object.entries(moduleDocs$4))randomFunctions[e]&&(randomFunctions[e].docs=t);const randomModule={name:"random",functions:randomFunctions},moduleDocs$3={mean:{category:"vector",description:"Returns the **mean** of all elements in the `vector`.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **mean** of."}},variants:[{argumentNames:["vector"]}],examples:["mean([1, 2, 3])","mean([1, 2, -3])"],seeAlso:["mean","vector.moving-mean","vector.centered-moving-mean","vector.running-mean","vector.geometric-mean","vector.harmonic-mean","vector.median","vector.mode","vector.sum","vector.rms"]},"moving-mean":{category:"vector",description:"Returns the **moving mean** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving mean** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-mean } = import("vector");\nmoving-mean([1, 2, 3, 4, 5], 3)','let { moving-mean } = import("vector");\nmoving-mean([1, 2, 3, 4, 5], 5)'],seeAlso:["moving-fn","vector.mean","vector.centered-moving-mean","vector.running-mean"]},"centered-moving-mean":{category:"vector",description:"Returns the **centered moving mean** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving mean** of."},windowSize:{type:"integer",description:"The size of the centered moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-mean } = import("vector");\ncentered-moving-mean([1, 2, 3, 4, 5], 3)','let { centered-moving-mean } = import("vector");\ncentered-moving-mean([1, 2, 3, 4, 5], 3, 0, 10)','let { centered-moving-mean } = import("vector");\ncentered-moving-mean([1, 2, 3, 4, 5], 3, 10)'],seeAlso:["vector.mean","vector.moving-mean","vector.running-mean"]},"running-mean":{category:"vector",description:"Returns the **running mean** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running mean** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-mean } = import("vector");\nrunning-mean([1, 2, 3, 4, 5])'],seeAlso:["running-fn","vector.mean","vector.moving-mean","vector.centered-moving-mean"]},"geometric-mean":{category:"vector",description:"Returns the **geometric mean** of all elements in the `vector`.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **geometric mean** of."}},variants:[{argumentNames:["vector"]}],examples:['let { geometric-mean } = import("vector");\ngeometric-mean([1, 2, 3])','let { geometric-mean } = import("vector");\ngeometric-mean([1, 2, 9])'],seeAlso:["vector.moving-geometric-mean","vector.centered-moving-geometric-mean","vector.running-geometric-mean","vector.mean","vector.harmonic-mean"]},"moving-geometric-mean":{category:"vector",description:"Returns the **moving geometric mean** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving geometric mean** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-geometric-mean } = import("vector");\nmoving-geometric-mean([1, 2, 3, 4, 5], 3)','let { moving-geometric-mean } = import("vector");\nmoving-geometric-mean([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.geometric-mean","vector.centered-moving-geometric-mean","vector.running-geometric-mean"]},"centered-moving-geometric-mean":{category:"vector",description:"Returns the **centered moving geometric mean** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving geometric mean** of."},windowSize:{type:"integer",description:"The size of the centered moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-geometric-mean } = import("vector");\ncentered-moving-geometric-mean([1, 2, 3, 4, 5], 3)','let { centered-moving-geometric-mean } = import("vector");\ncentered-moving-geometric-mean([1, 2, 3, 4, 5], 3, 0, 10)','let { centered-moving-geometric-mean } = import("vector");\ncentered-moving-geometric-mean([1, 2, 3, 4, 5], 3, 10)'],seeAlso:["vector.geometric-mean","vector.moving-geometric-mean","vector.running-geometric-mean"]},"running-geometric-mean":{category:"vector",description:"Returns the **running geometric mean** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running geometric mean** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-geometric-mean } = import("vector");\nrunning-geometric-mean([1, 2, 3, 4, 5])'],seeAlso:["vector.geometric-mean","vector.moving-geometric-mean","vector.centered-moving-geometric-mean"]},"harmonic-mean":{category:"vector",description:"Returns the **harmonic mean** of all elements in the `vector`.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **harmonic mean** of."}},variants:[{argumentNames:["vector"]}],examples:['let { harmonic-mean } = import("vector");\nharmonic-mean([1, 2, 3])','let { harmonic-mean } = import("vector");\nharmonic-mean([1, 2, 9])'],seeAlso:["vector.moving-harmonic-mean","vector.centered-moving-harmonic-mean","vector.running-harmonic-mean","vector.mean","vector.geometric-mean"]},"moving-harmonic-mean":{category:"vector",description:"Returns the **moving harmonic mean** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving harmonic mean** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-harmonic-mean } = import("vector");\nmoving-harmonic-mean([1, 2, 3, 4, 5], 3)','let { moving-harmonic-mean } = import("vector");\nmoving-harmonic-mean([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.harmonic-mean","vector.centered-moving-harmonic-mean","vector.running-harmonic-mean"]},"centered-moving-harmonic-mean":{category:"vector",description:"Returns the **centered moving harmonic mean** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving harmonic mean** of."},windowSize:{type:"integer",description:"The size of the centered moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-harmonic-mean } = import("vector");\ncentered-moving-harmonic-mean([1, 2, 3, 4, 5], 3)','let { centered-moving-harmonic-mean } = import("vector");\ncentered-moving-harmonic-mean([1, 2, 3, 4, 5], 3, 0, 10)','let { centered-moving-harmonic-mean } = import("vector");\ncentered-moving-harmonic-mean([1, 2, 3, 4, 5], 3, 10)'],seeAlso:["vector.harmonic-mean","vector.moving-harmonic-mean","vector.running-harmonic-mean"]},"running-harmonic-mean":{category:"vector",description:"Returns the **running harmonic mean** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running harmonic mean** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-harmonic-mean } = import("vector");\nrunning-harmonic-mean([1, 2, 3, 4, 5])'],seeAlso:["vector.harmonic-mean","vector.moving-harmonic-mean","vector.centered-moving-harmonic-mean"]},median:{category:"vector",description:"Returns the median of all elements in the vector.",returns:{type:"number"},args:{vector:{type:"vector",description:"The vector to calculate the median of."}},variants:[{argumentNames:["vector"]}],examples:["median([1, 2, 3])","median([1, 2, -3])","median([1, 2, 3, 4])","median([1, 2, -3, 4])"],seeAlso:["median","vector.moving-median","vector.centered-moving-median","vector.running-median","vector.mean","vector.mode","vector.quartiles","vector.percentile","vector.iqr","vector.medad"]},"moving-median":{category:"vector",description:"Returns the **moving median** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving median** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-median } = import("vector");\nmoving-median([1, 2, 3, 4, 5], 3)','let { moving-median } = import("vector");\nmoving-median([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.median","vector.centered-moving-median","vector.running-median"]},"centered-moving-median":{category:"vector",description:"Returns the **centered moving median** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving median** of."},windowSize:{type:"integer",description:"The size of the centered moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-median } = import("vector");\ncentered-moving-median([1, 2, 3, 4, 5], 3)','let { centered-moving-median } = import("vector");\ncentered-moving-median([1, 2, 3, 4, 5], 3, 0, 10)','let { centered-moving-median } = import("vector");\ncentered-moving-median([1, 2, 3, 4, 5], 3, 10)'],seeAlso:["vector.median","vector.moving-median","vector.running-median"]},"running-median":{category:"vector",description:"Returns the **running median** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running median** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-median } = import("vector");\nrunning-median([1, 2, 3, 4, 5])'],seeAlso:["vector.median","vector.moving-median","vector.centered-moving-median"]},variance:{category:"vector",description:"Returns the **variance** of all elements in the `vector`.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **variance** of."}},variants:[{argumentNames:["vector"]}],examples:['let { variance } = import("vector");\nvariance([1, 2, 3])','let { variance } = import("vector");\nvariance([1, 2, -3])'],seeAlso:["linear-algebra.cov","vector.moving-variance","vector.centered-moving-variance","vector.running-variance","vector.stdev","vector.sample-variance","vector.mad"]},"moving-variance":{category:"vector",description:"Returns the **moving variance** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving variance** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-variance } = import("vector");\nmoving-variance([1, 2, 3, 4, 5], 3)','let { moving-variance } = import("vector");\nmoving-variance([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.variance","vector.centered-moving-variance","vector.running-variance"]},"centered-moving-variance":{category:"vector",description:"Returns the **centered moving variance** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving variance** of."},windowSize:{type:"integer",description:"The size of the centered moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-variance } = import("vector");\ncentered-moving-variance([1, 2, 3, 4, 5], 3)','let { centered-moving-variance } = import("vector");\ncentered-moving-variance([1, 2, 3, 4, 5], 3, 1)','let { centered-moving-variance } = import("vector");\ncentered-moving-variance([1, 2, 3, 4, 5], 3, 1, 5)','let { centered-moving-variance } = import("vector");\ncentered-moving-variance([1, 2, 3, 4, 5], 3, 0, 6)'],seeAlso:["vector.variance","vector.moving-variance","vector.running-variance"]},"running-variance":{category:"vector",description:"Returns the **running variance** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running variance** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-variance } = import("vector");\nrunning-variance([1, 2, 3, 4, 5])'],seeAlso:["vector.variance","vector.moving-variance","vector.centered-moving-variance"]},"sample-variance":{category:"vector",description:"Returns the sample variance of all elements in the vector.",returns:{type:"number"},args:{vector:{type:"vector",description:"Non emtpy vector to calculate the sample variance of."}},variants:[{argumentNames:["vector"]}],examples:['let { sample-variance } = import("vector");\nsample-variance([1, 2, 3])','let { sample-variance } = import("vector");\nsample-variance([1, 2, -3])','let { sample-variance } = import("vector");\nsample-variance([1, 2, 3, 4])','let { sample-variance } = import("vector");\nsample-variance([1, 2, -3, 4])','let { sample-variance } = import("vector");\nsample-variance([1, 2, 3, 40, 50])'],seeAlso:["vector.moving-sample-variance","vector.centered-moving-sample-variance","vector.running-sample-variance","vector.variance","vector.sample-stdev"]},"moving-sample-variance":{category:"vector",description:"Returns the **moving sample variance** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving sample variance** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-sample-variance } = import("vector");\nmoving-sample-variance([1, 2, 3, 4, 5], 3)','let { moving-sample-variance } = import("vector");\nmoving-sample-variance([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.sample-variance","vector.centered-moving-sample-variance","vector.running-sample-variance"]},"centered-moving-sample-variance":{category:"vector",description:"Returns the **centered moving sample variance** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving sample variance** of."},windowSize:{type:"integer",description:"The size of the centered moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-sample-variance } = import("vector");\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3)','let { centered-moving-sample-variance } = import("vector");\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3, 1)','let { centered-moving-sample-variance } = import("vector");\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3, 1, 5)','let { centered-moving-sample-variance } = import("vector");\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3, 0, 6)'],seeAlso:["vector.sample-variance","vector.moving-sample-variance","vector.running-sample-variance"]},"running-sample-variance":{category:"vector",description:"Returns the **running sample variance** of the `vector`.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running sample variance** of. First element in result is `null` since **sample variance** is not defined for a single element."}},variants:[{argumentNames:["vector"]}],examples:['let { running-sample-variance } = import("vector");\nrunning-sample-variance([1, 2, 3, 4, 5])'],seeAlso:["vector.sample-variance","vector.moving-sample-variance","vector.centered-moving-sample-variance"]},stdev:{category:"vector",description:"Returns the standard deviation of all elements in the vector.",returns:{type:"number"},args:{vector:{type:"vector",description:"Non emtpy vector to calculate the standard deviation of."}},variants:[{argumentNames:["vector"]}],examples:['let { stdev } = import("vector");\nstdev([1, 2, 3])','let { stdev } = import("vector");\nstdev([1, 2, -3])','let { stdev } = import("vector");\nstdev([1, 2, 3, 4])','let { stdev } = import("vector");\nstdev([1, 2, -3, 4])','let { stdev } = import("vector");\nstdev([1, 2, 3, 40, 50])'],seeAlso:["vector.moving-stdev","vector.centered-moving-stdev","vector.running-stdev","vector.variance","vector.sample-stdev","vector.rms","vector.mad"]},"moving-stdev":{category:"vector",description:"Returns the **moving standard deviation** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving standard deviation** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-stdev } = import("vector");\nmoving-stdev([1, 2, 3, 4, 5], 3)','let { moving-stdev } = import("vector");\nmoving-stdev([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.stdev","vector.centered-moving-stdev","vector.running-stdev"]},"centered-moving-stdev":{category:"vector",description:"Returns the **centered moving standard deviation** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving standard deviation** of."},windowSize:{type:"integer",description:"The size of the centered moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-stdev } = import("vector");\ncentered-moving-stdev([1, 2, 3, 4, 5], 3)','let { centered-moving-stdev } = import("vector");\ncentered-moving-stdev([1, 2, 3, 4, 5], 3, 1)','let { centered-moving-stdev } = import("vector");\ncentered-moving-stdev([1, 2, 3, 4, 5], 3, 1, 5)','let { centered-moving-stdev } = import("vector");\ncentered-moving-stdev([1, 2, 3, 4, 5], 3, 0, 6)'],seeAlso:["vector.stdev","vector.moving-stdev","vector.running-stdev"]},"running-stdev":{category:"vector",description:"Returns the **running standard deviation** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running standard deviation** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-stdev } = import("vector");\nrunning-stdev([1, 2, 3, 4, 5])'],seeAlso:["vector.stdev","vector.moving-stdev","vector.centered-moving-stdev"]},"sample-stdev":{category:"vector",description:"Returns the sample standard deviation of all elements in the vector.",returns:{type:"number"},args:{vector:{type:"vector",description:"Non emtpy vector to calculate the sample standard deviation of."}},variants:[{argumentNames:["vector"]}],examples:['let { sample-stdev } = import("vector");\nsample-stdev([1, 2, 3])','let { sample-stdev } = import("vector");\nsample-stdev([1, 2, -3])','let { sample-stdev } = import("vector");\nsample-stdev([1, 2, 3, 4])','let { sample-stdev } = import("vector");\nsample-stdev([1, 2, -3, 4])','let { sample-stdev } = import("vector");\nsample-stdev([1, 2, 3, 40, 50])'],seeAlso:["vector.moving-sample-stdev","vector.centered-moving-sample-stdev","vector.running-sample-stdev","vector.stdev","vector.sample-variance"]},"moving-sample-stdev":{category:"vector",description:"Returns the **moving sample standard deviation** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving sample standard deviation** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-sample-stdev } = import("vector");\nmoving-sample-stdev([1, 2, 3, 4, 5], 3)','let { moving-sample-stdev } = import("vector");\nmoving-sample-stdev([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.sample-stdev","vector.centered-moving-sample-stdev","vector.running-sample-stdev"]},"centered-moving-sample-stdev":{category:"vector",description:"Returns the **centered moving sample standard deviation** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving sample standard deviation** of."},windowSize:{type:"integer",description:"The size of the centered moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-sample-stdev } = import("vector");\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3)','let { centered-moving-sample-stdev } = import("vector");\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 1)','let { centered-moving-sample-stdev } = import("vector");\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 1, 5)','let { centered-moving-sample-stdev } = import("vector");\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 0, 6)'],seeAlso:["vector.sample-stdev","vector.moving-sample-stdev","vector.running-sample-stdev"]},"running-sample-stdev":{category:"vector",description:"Returns the **running sample standard deviation** of the `vector`.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running sample standard deviation** of. First element in result is `null` since **sample standard deviation** is not defined for a single element."}},variants:[{argumentNames:["vector"]}],examples:['let { running-sample-stdev } = import("vector");\nrunning-sample-stdev([1, 2, 3, 4, 5])'],seeAlso:["vector.sample-stdev","vector.moving-sample-stdev","vector.centered-moving-sample-stdev"]},iqr:{category:"vector",description:"Calculates the **interquartile range** of a `vector`. Returns the difference between the third and first quartiles.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **interquartile range** of. Minimum length is 4."}},variants:[{argumentNames:["vector"]}],examples:['let { iqr } = import("vector");\niqr([1, 2, 3, 4])','let { iqr } = import("vector");\niqr([5, 4, 3, 2, 1, 2, 3, 4, 5])','let { iqr } = import("vector");\niqr(range(1, 1000))','let { iqr, generate } = import("vector");\niqr(generate(1000, -> 1e6 / ($ + 1) ^ 2))','let { iqr, generate } = import("vector");\nlet { ln } = import("math");\niqr(generate(1000, -> ln($ + 1)))'],seeAlso:["vector.moving-iqr","vector.centered-moving-iqr","vector.running-iqr","vector.quartiles","vector.median","vector.mad","vector.medad","vector.outliers?","vector.outliers"]},"moving-iqr":{category:"vector",description:"Calculates the **moving interquartile range** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving interquartile range** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-iqr } = import("vector");\nmoving-iqr([1, 2, 4, 7, 11, 16], 4)','let { moving-iqr } = import("vector");\nmoving-iqr([1, 2, 4, 7, 11, 16], 5)','let { moving-iqr } = import("vector");\nmoving-iqr([1, 2, 4, 7, 11, 16], 6)'],seeAlso:["vector.iqr","vector.centered-moving-iqr","vector.running-iqr"]},"centered-moving-iqr":{category:"vector",description:"Calculates the **centered moving interquartile range** of a `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving interquartile range** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-iqr } = import("vector");\ncentered-moving-iqr([1, 2, 4, 7, 11, 16], 4)','let { centered-moving-iqr } = import("vector");\ncentered-moving-iqr([1, 2, 4, 7, 11, 16], 4, 0, 0)'],seeAlso:["vector.iqr","vector.moving-iqr","vector.running-iqr"]},"running-iqr":{category:"vector",description:"Calculates the **running interquartile range** of a `vector`. First three element in result is `null` since **running interquartile range** is not defined for less than four elements.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running interquartile range** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-iqr } = import("vector");\nrunning-iqr([1, 2, 3, 4, 5, 6])','let { running-iqr } = import("vector");\nrunning-iqr([-1, -2, -3, 1, 2, 3])'],seeAlso:["vector.iqr","vector.moving-iqr","vector.centered-moving-iqr"]},sum:{category:"vector",description:"Returns the sum of all elements in the vector.",returns:{type:"number"},args:{vector:{type:"vector",description:"The vector to sum."}},variants:[{argumentNames:["vector"]}],examples:["sum([1, 2, 3])","sum([1, 2, -3])"],seeAlso:["sum","vector.moving-sum","vector.centered-moving-sum","vector.running-sum","vector.prod","vector.cumsum","vector.mean"]},"moving-sum":{category:"vector",description:"Returns the **moving sum** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving sum** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-sum } = import("vector");\nmoving-sum([1, 2, 3, 4, 5], 3)','let { moving-sum } = import("vector");\nmoving-sum([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.sum","vector.centered-moving-sum","vector.running-sum"]},"centered-moving-sum":{category:"vector",description:"Returns the **centered moving sum** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving sum** of."},windowSize:{type:"integer",description:"The size of the centered moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-sum } = import("vector");\ncentered-moving-sum([1, 2, 3, 4, 5], 3)','let { centered-moving-sum } = import("vector");\ncentered-moving-sum([1, 2, 3, 4, 5], 3, 0, 0)','let { centered-moving-sum } = import("vector");\ncentered-moving-sum([1, 2, 3, 4, 5], 3, 10)'],seeAlso:["vector.sum","vector.moving-sum","vector.running-sum"]},"running-sum":{category:"vector",description:"Returns the **running sum** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running sum** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-sum } = import("vector");\nrunning-sum([1, 2, 3])','let { running-sum } = import("vector");\nrunning-sum([1, -2, -3])'],seeAlso:["vector.sum","vector.moving-sum","vector.centered-moving-sum","vector.cumsum"]},prod:{category:"vector",description:"Returns the **product** of all elements in the `vector`.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **product** of."}},variants:[{argumentNames:["vector"]}],examples:["prod([1, 2, 3])","prod([1, 2, -3])"],seeAlso:["prod","vector.moving-prod","vector.centered-moving-prod","vector.running-prod","vector.sum","vector.cumprod"]},"moving-prod":{category:"vector",description:"Returns the **moving product** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving product** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-prod } = import("vector");\nmoving-prod([1, 2, 3, 4, 5], 3)','let { moving-prod } = import("vector");\nmoving-prod([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.prod","vector.centered-moving-prod","vector.running-prod"]},"centered-moving-prod":{category:"vector",description:"Returns the **centered moving product** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving product** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-prod } = import("vector");\ncentered-moving-prod([1, 2, 3, 4, 5], 3)','let { centered-moving-prod } = import("vector");\ncentered-moving-prod([1, 2, 3, 4, 5], 3, 0, 0)'],seeAlso:["vector.prod","vector.moving-prod","vector.running-prod"]},"running-prod":{category:"vector",description:"Returns the **running product** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running product** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-prod } = import("vector");\nrunning-prod([1, 2, 3, 4, 5])','let { running-prod } = import("vector");\nrunning-prod([1, -2, -3])'],seeAlso:["vector.prod","vector.moving-prod","vector.centered-moving-prod","vector.cumprod"]},span:{category:"vector",description:"Returns the difference between the maximum and minimum values in a vector.",returns:{type:"number"},args:{vector:{type:"vector",description:"The vector to calculate the span of."}},variants:[{argumentNames:["vector"]}],examples:['let { span } = import("vector");\nspan([1, 2, 3])','let { span } = import("vector");\nspan([1, 1, 2, 3, 3])','let { span } = import("vector");\nspan([1, 2, -3])'],seeAlso:["vector.moving-span","vector.centered-moving-span","vector.running-span","min","max"]},"moving-span":{category:"vector",description:"Calculates the **moving span** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving span** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-span } = import("vector");\nmoving-span([1, 2, 4, 7, 11, 16], 4)','let { moving-span } = import("vector");\nmoving-span([1, 2, 4, 7, 11, 16], 5)','let { moving-span } = import("vector");\nmoving-span([1, 2, 4, 7, 11, 16], 6)'],seeAlso:["vector.span","vector.centered-moving-span","vector.running-span"]},"centered-moving-span":{category:"vector",description:"Calculates the **centered moving span** of a `vector` with a given window size. The result is padded with `leftPadding` on the left and right.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving span** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"The value to pad the result with on the left."},rightPadding:{type:"number",description:"The value to pad the result with on the right."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-span } = import("vector");\ncentered-moving-span([1, 2, 4, 7, 11, 16], 4)','let { centered-moving-span } = import("vector");\ncentered-moving-span([1, 2, 4, 7, 11, 16], 3, 0, 100)'],seeAlso:["vector.span","vector.moving-span","vector.running-span"]},"running-span":{category:"vector",description:"Calculates the **running span** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running span** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-span } = import("vector");\nrunning-span([1, 2, 4])'],seeAlso:["vector.span","vector.moving-span","vector.centered-moving-span"]},skewness:{category:"vector",description:"Calculates the **skewness** of a `vector`. Returns the third standardized moment.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **skewness** of. Minimum length is 3."}},variants:[{argumentNames:["vector"]}],examples:['let { skewness } = import("vector");\nskewness([1, 2, 3, 6, 20])','let { skewness } = import("vector");\nskewness([1, 2, 2, 3])'],seeAlso:["vector.moving-skewness","vector.centered-moving-skewness","vector.running-skewness","vector.kurtosis","vector.sample-skewness","vector.excess-kurtosis"]},"moving-skewness":{category:"vector",description:"Calculates the **moving skewness** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving skewness** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-skewness } = import("vector");\nmoving-skewness([1, 2, 4, 7, 11, 16], 4)','let { moving-skewness } = import("vector");\nmoving-skewness([1, 2, 4, 7, 11, 16], 5)'],seeAlso:["vector.skewness","vector.centered-moving-skewness","vector.running-skewness"]},"centered-moving-skewness":{category:"vector",description:"Calculates the **centered moving skewness** of a `vector` with a given window size and padding.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving skewness** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-skewness } = import("vector");\ncentered-moving-skewness([1, 2, 4, 7, 11, 16], 4)','let { centered-moving-skewness } = import("vector");\ncentered-moving-skewness([1, 2, 4, 7, 11, 16], 4, 0, 0)'],seeAlso:["vector.skewness","vector.moving-skewness","vector.running-skewness"]},"running-skewness":{category:"vector",description:"Calculates the **running skewness** of a `vector` with a given window size. First two element in result is `null` since **running skewness** is not defined for less than three elements.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running skewness** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-skewness } = import("vector");\nrunning-skewness([1, 2, 4, 7, 11])'],seeAlso:["vector.skewness","vector.moving-skewness","vector.centered-moving-skewness"]},"sample-skewness":{category:"vector",description:"Calculates the **sample skewness** of a `vector`. Returns the third standardized moment.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **sample skewness** of. Minimum length is 3."}},variants:[{argumentNames:["vector"]}],examples:['let { sample-skewness } = import("vector");\nsample-skewness([1, 2, 3, 6, 20])','let { sample-skewness } = import("vector");\nsample-skewness([1, 2, 2, 3])'],seeAlso:["vector.moving-sample-skewness","vector.centered-moving-sample-skewness","vector.running-sample-skewness","vector.skewness","vector.sample-kurtosis"]},"moving-sample-skewness":{category:"vector",description:"Calculates the **moving sample skewness** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving sample skewness** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-sample-skewness } = import("vector");\nmoving-sample-skewness([1, 2, 4, 7, 11, 16], 4)','let { moving-sample-skewness } = import("vector");\nmoving-sample-skewness([1, 2, 4, 7, 11, 16], 5)'],seeAlso:["vector.sample-skewness","vector.centered-moving-sample-skewness","vector.running-sample-skewness"]},"centered-moving-sample-skewness":{category:"vector",description:"Calculates the **centered moving sample skewness** of a `vector` with a given window size and padding.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving sample skewness** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-sample-skewness } = import("vector");\ncentered-moving-sample-skewness([1, 2, 4, 7, 11, 16], 4)','let { centered-moving-sample-skewness } = import("vector");\ncentered-moving-sample-skewness([1, 2, 4, 7, 11, 16], 3, 0, 100)'],seeAlso:["vector.sample-skewness","vector.moving-sample-skewness","vector.running-sample-skewness"]},"running-sample-skewness":{category:"vector",description:"Calculates the **running sample skewness** of a `vector` with a given window size. First two element in result is `null` since **running sample skewness** is not defined for less than three elements.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running sample skewness** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-sample-skewness } = import("vector");\nrunning-sample-skewness([1, 2, 4, 7, 11])'],seeAlso:["vector.sample-skewness","vector.moving-sample-skewness","vector.centered-moving-sample-skewness"]},"excess-kurtosis":{category:"vector",description:"Calculates the **excess kurtosis** of a `vector`. Returns the third standardized moment.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **excess kurtosis** of. Minimum length is 3."}},variants:[{argumentNames:["vector"]}],examples:['let { excess-kurtosis } = import("vector");\nexcess-kurtosis([1, 2, 3, 6, 20])','let { excess-kurtosis } = import("vector");\nexcess-kurtosis([1, 2, 2, 3])'],seeAlso:["vector.moving-excess-kurtosis","vector.centered-moving-excess-kurtosis","vector.running-excess-kurtosis","vector.kurtosis","vector.sample-excess-kurtosis","vector.skewness"]},"moving-excess-kurtosis":{category:"vector",description:"Calculates the **moving excess kurtosis** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving excess kurtosis** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-excess-kurtosis } = import("vector");\nmoving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)','let { moving-excess-kurtosis } = import("vector");\nmoving-excess-kurtosis([1, 2, 4, 7, 11, 16], 5)'],seeAlso:["vector.excess-kurtosis","vector.centered-moving-excess-kurtosis","vector.running-excess-kurtosis"]},"centered-moving-excess-kurtosis":{category:"vector",description:"Calculates the **centered moving excess kurtosis** of a `vector` with a given window size and padding.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving excess kurtosis** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-excess-kurtosis } = import("vector");\ncentered-moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)','let { centered-moving-excess-kurtosis } = import("vector");\ncentered-moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 0)'],seeAlso:["vector.excess-kurtosis","vector.moving-excess-kurtosis","vector.running-excess-kurtosis"]},"running-excess-kurtosis":{category:"vector",description:"Calculates the **running excess kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running excess kurtosis** is not defined for less than three elements.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running excess kurtosis** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-excess-kurtosis } = import("vector");\nrunning-excess-kurtosis([1, 2, 4, 7, 11])'],seeAlso:["vector.excess-kurtosis","vector.moving-excess-kurtosis","vector.centered-moving-excess-kurtosis"]},kurtosis:{category:"vector",description:"Calculates the **kurtosis** of a `vector`. Returns the third standardized moment.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **kurtosis** of. Minimum length is 3."}},variants:[{argumentNames:["vector"]}],examples:['let { kurtosis } = import("vector");\nkurtosis([1, 2, 3, 6, 20])','let { kurtosis } = import("vector");\nkurtosis([1, 2, 2, 3])'],seeAlso:["vector.moving-kurtosis","vector.centered-moving-kurtosis","vector.running-kurtosis","vector.excess-kurtosis","vector.sample-kurtosis","vector.skewness"]},"moving-kurtosis":{category:"vector",description:"Calculates the **moving kurtosis** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving kurtosis** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-kurtosis } = import("vector");\nmoving-kurtosis([1, 2, 4, 7, 11, 16], 4)','let { moving-kurtosis } = import("vector");\nmoving-kurtosis([1, 2, 4, 7, 11, 16], 5)'],seeAlso:["vector.kurtosis","vector.centered-moving-kurtosis","vector.running-kurtosis"]},"centered-moving-kurtosis":{category:"vector",description:"Calculates the **centered moving kurtosis** of a `vector` with a given window size and padding.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving kurtosis** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-kurtosis } = import("vector");\ncentered-moving-kurtosis([1, 2, 4, 7, 11, 16], 4)','let { centered-moving-kurtosis } = import("vector");\ncentered-moving-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 0)'],seeAlso:["vector.kurtosis","vector.moving-kurtosis","vector.running-kurtosis"]},"running-kurtosis":{category:"vector",description:"Calculates the **running kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running kurtosis** is not defined for less than three elements.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running kurtosis** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-kurtosis } = import("vector");\nrunning-kurtosis([1, 2, 4, 7, 11])'],seeAlso:["vector.kurtosis","vector.moving-kurtosis","vector.centered-moving-kurtosis"]},"sample-excess-kurtosis":{category:"vector",description:"Calculates the **sample excess kurtosis** of a `vector`. Returns the third standardized moment.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **sample excess kurtosis** of. Minimum length is 3."}},variants:[{argumentNames:["vector"]}],examples:['let { sample-excess-kurtosis } = import("vector");\nsample-excess-kurtosis([1, 2, 3, 6, 20])','let { sample-excess-kurtosis } = import("vector");\nsample-excess-kurtosis([1, 2, 2, 3])'],seeAlso:["vector.moving-sample-excess-kurtosis","vector.centered-moving-sample-excess-kurtosis","vector.running-sample-excess-kurtosis","vector.sample-kurtosis","vector.excess-kurtosis"]},"moving-sample-excess-kurtosis":{category:"vector",description:"Calculates the **moving sample excess kurtosis** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving sample excess kurtosis** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-sample-excess-kurtosis } = import("vector");\nmoving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)','let { moving-sample-excess-kurtosis } = import("vector");\nmoving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 5)'],seeAlso:["vector.sample-excess-kurtosis","vector.centered-moving-sample-excess-kurtosis","vector.running-sample-excess-kurtosis"]},"centered-moving-sample-excess-kurtosis":{category:"vector",description:"Calculates the **centered moving sample excess kurtosis** of a `vector` with a given window size and padding.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving sample excess kurtosis** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-sample-excess-kurtosis } = import("vector");\ncentered-moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)','let { centered-moving-sample-excess-kurtosis } = import("vector");\ncentered-moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 100)'],seeAlso:["vector.sample-excess-kurtosis","vector.moving-sample-excess-kurtosis","vector.running-sample-excess-kurtosis"]},"running-sample-excess-kurtosis":{category:"vector",description:"Calculates the **running sample excess kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running sample excess kurtosis** is not defined for less than three elements.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running sample excess kurtosis** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-sample-excess-kurtosis } = import("vector");\nrunning-sample-excess-kurtosis([1, 2, 4, 7, 11])'],seeAlso:["vector.sample-excess-kurtosis","vector.moving-sample-excess-kurtosis","vector.centered-moving-sample-excess-kurtosis"]},"sample-kurtosis":{category:"vector",description:"Calculates the **sample kurtosis** of a `vector`. Returns the third standardized moment.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **sample kurtosis** of. Minimum length is 3."}},variants:[{argumentNames:["vector"]}],examples:['let { sample-kurtosis } = import("vector");\nsample-kurtosis([1, 2, 3, 6, 20])','let { sample-kurtosis } = import("vector");\nsample-kurtosis([1, 2, 2, 3])'],seeAlso:["vector.moving-sample-kurtosis","vector.centered-moving-sample-kurtosis","vector.running-sample-kurtosis","vector.sample-excess-kurtosis","vector.kurtosis","vector.sample-skewness"]},"moving-sample-kurtosis":{category:"vector",description:"Calculates the **moving sample kurtosis** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving sample kurtosis** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-sample-kurtosis } = import("vector");\nmoving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4)','let { moving-sample-kurtosis } = import("vector");\nmoving-sample-kurtosis([1, 2, 4, 7, 11, 16], 5)'],seeAlso:["vector.sample-kurtosis","vector.centered-moving-sample-kurtosis","vector.running-sample-kurtosis"]},"centered-moving-sample-kurtosis":{category:"vector",description:"Calculates the **centered moving sample kurtosis** of a `vector` with a given window size and padding.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving sample kurtosis** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-sample-kurtosis } = import("vector");\ncentered-moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4)','let { centered-moving-sample-kurtosis } = import("vector");\ncentered-moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 100)'],seeAlso:["vector.sample-kurtosis","vector.moving-sample-kurtosis","vector.running-sample-kurtosis"]},"running-sample-kurtosis":{category:"vector",description:"Calculates the **running sample kurtosis** of a `vector` with a given window size. First two element in result is `null` since **running sample kurtosis** is not defined for less than three elements.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running sample kurtosis** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-sample-kurtosis } = import("vector");\nrunning-sample-kurtosis([1, 2, 4, 7, 11])'],seeAlso:["vector.sample-kurtosis","vector.moving-sample-kurtosis","vector.centered-moving-sample-kurtosis"]},rms:{category:"vector",description:"Calculates the **root mean square** of a `vector`. Returns the square root of the average of the squares of the elements.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **root mean square** of. Minimum length is 1."}},variants:[{argumentNames:["vector"]}],examples:['let { rms } = import("vector");\nrms([1, 2, 3, 4])','let { rms } = import("vector");\nrms([5, 4, 3, 2, 1])','let { rms } = import("vector");\nrms(range(1, 1000))','let { rms, generate } = import("vector");\nrms(generate(1000, -> 1e6 / ($ + 1) ^ 2))','let { rms, generate } = import("vector");\nlet { ln } = import("math");\nrms(generate(1000, -> ln($ + 1)))'],seeAlso:["vector.moving-rms","vector.centered-moving-rms","vector.running-rms","vector.mean","vector.stdev"]},"moving-rms":{category:"vector",description:"Calculates the **moving root mean square** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving root mean square** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-rms } = import("vector");\nmoving-rms([1, 2, 4, 7, 11, 16], 4)','let { moving-rms } = import("vector");\nmoving-rms([1, 2, 4, 7, 11, 16], 5)','let { moving-rms } = import("vector");\nmoving-rms([1, 2, 4, 7, 11, 16], 6)'],seeAlso:["vector.rms","vector.centered-moving-rms","vector.running-rms"]},"centered-moving-rms":{category:"vector",description:"Calculates the **centered moving root mean square** of a `vector` with a given window size and padding value.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving root mean square** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-rms } = import("vector");\ncentered-moving-rms([1, 2, 4, 7, 11, 16], 4)','let { centered-moving-rms } = import("vector");\ncentered-moving-rms([1, 2, 4, 7, 11, 16], 5, 0)','let { centered-moving-rms } = import("vector");\ncentered-moving-rms([1, 2, 4, 7, 11, 16], 6, 0, 0)'],seeAlso:["vector.rms","vector.moving-rms","vector.running-rms"]},"running-rms":{category:"vector",description:"Calculates the **running root mean square** of a `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running root mean square** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-rms } = import("vector");\nrunning-rms([1, 2, 3, 4, 5, 6])','let { running-rms } = import("vector");\nrunning-rms([1, -3, 2])','let { running-rms } = import("vector");\nrunning-rms([-1, -2, -3])','let { running-rms } = import("vector");\nrunning-rms([0])'],seeAlso:["vector.rms","vector.moving-rms","vector.centered-moving-rms"]},mad:{category:"vector",description:"Returns the **mean absolute deviation** of all elements in the `vector`.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **mean absolute deviation** of."}},variants:[{argumentNames:["vector"]}],examples:['let { mad } = import("vector");\nmad([1, 2, 3])','let { mad } = import("vector");\nmad([1, 2, -3])'],seeAlso:["vector.moving-mad","vector.centered-moving-mad","vector.running-mad","vector.medad","vector.stdev","vector.variance","vector.iqr"]},"moving-mad":{category:"vector",description:"Returns the **moving mean absolute deviation** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving mean absolute deviation** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-mad } = import("vector");\nmoving-mad([1, 2, 3, 4, 5], 3)','let { moving-mad } = import("vector");\nmoving-mad([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.mad","vector.centered-moving-mad","vector.running-mad"]},"centered-moving-mad":{category:"vector",description:"Returns the **centered moving mean absolute deviation** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving mean absolute deviation** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-mad } = import("vector");\ncentered-moving-mad([1, 2, 3, 4, 5], 3)','let { centered-moving-mad } = import("vector");\ncentered-moving-mad([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.mad","vector.moving-mad","vector.running-mad"]},"running-mad":{category:"vector",description:"Returns the **running mean absolute deviation** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running mean absolute deviation** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-mad } = import("vector");\nrunning-mad([1, 2, 3])','let { running-mad } = import("vector");\nrunning-mad([1, 2, -3])'],seeAlso:["vector.mad","vector.moving-mad","vector.centered-moving-mad"]},medad:{category:"vector",description:"Returns the **median absolute deviation** of all elements in the `vector`.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **median absolute deviation** of."}},variants:[{argumentNames:["vector"]}],examples:['let { medad } = import("vector");\nmedad([1, 2, 3])','let { medad } = import("vector");\nmedad([1, 2, -3])'],seeAlso:["vector.moving-medad","vector.centered-moving-medad","vector.running-medad","vector.mad","vector.median","vector.iqr"]},"moving-medad":{category:"vector",description:"Returns the **moving median absolute deviation** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving median absolute deviation** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-medad } = import("vector");\nmoving-medad([1, 2, 3, 4, 5], 3)','let { moving-medad } = import("vector");\nmoving-medad([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.medad","vector.centered-moving-medad","vector.running-medad"]},"centered-moving-medad":{category:"vector",description:"Returns the **centered moving median absolute deviation** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving median absolute deviation** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-medad } = import("vector");\ncentered-moving-medad([1, 2, 3, 4, 5], 3)','let { centered-moving-medad } = import("vector");\ncentered-moving-medad([1, 2, 3, 4, 5], 5)'],seeAlso:["vector.medad","vector.moving-medad","vector.running-medad"]},"running-medad":{category:"vector",description:"Returns the **running median absolute deviation** of the `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running median absolute deviation** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-medad } = import("vector");\nrunning-medad([1, 2, 3])','let { running-medad } = import("vector");\nrunning-medad([1, 2, -3])'],seeAlso:["vector.medad","vector.moving-medad","vector.centered-moving-medad"]},"gini-coefficient":{category:"vector",description:"Returns the **gini coefficient** of all elements in the `vector`.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **gini coefficient** of."}},variants:[{argumentNames:["vector"]}],examples:['let { gini-coefficient } = import("vector");\ngini-coefficient([1, 2, 3])','let { gini-coefficient } = import("vector");\ngini-coefficient([1, 1, 3])'],seeAlso:["vector.moving-gini-coefficient","vector.centered-moving-gini-coefficient","vector.running-gini-coefficient","vector.entropy"]},"moving-gini-coefficient":{category:"vector",description:"Returns the **moving gini coefficient** of the `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving gini coefficient** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-gini-coefficient } = import("vector");\nmoving-gini-coefficient([1, 2, 3], 2)','let { moving-gini-coefficient } = import("vector");\nmoving-gini-coefficient([1, 1, 3], 2)'],seeAlso:["vector.gini-coefficient","vector.centered-moving-gini-coefficient","vector.running-gini-coefficient"]},"centered-moving-gini-coefficient":{category:"vector",description:"Returns the **centered moving gini coefficient** of the `vector` with a given window size.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving gini coefficient** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-gini-coefficient } = import("vector");\ncentered-moving-gini-coefficient([1, 2, 3], 2)','let { centered-moving-gini-coefficient } = import("vector");\ncentered-moving-gini-coefficient([1, 1, 3], 2)'],seeAlso:["vector.gini-coefficient","vector.moving-gini-coefficient","vector.running-gini-coefficient"]},"running-gini-coefficient":{category:"vector",description:"Returns the **running gini coefficient** of the `vector`.",returns:{type:"array"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running gini coefficient** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-gini-coefficient } = import("vector");\nrunning-gini-coefficient([1, 2, 3])','let { running-gini-coefficient } = import("vector");\nrunning-gini-coefficient([1, 1, 3])'],seeAlso:["vector.gini-coefficient","vector.moving-gini-coefficient","vector.centered-moving-gini-coefficient"]},entropy:{category:"vector",description:"Calculates the **entropy** of a `vector`. The entropy is a measure of the uncertainty associated with a random variable.",returns:{type:"number"},args:{vector:{type:"vector",description:"The `vector` to calculate the **entropy** of. Minimum length is 1."}},variants:[{argumentNames:["vector"]}],examples:['let { entropy } = import("vector");\nentropy([1, 1, 2, 3, 3, 3])','let { entropy } = import("vector");\nentropy([1, 2, 3])','let { entropy } = import("vector");\nentropy([1, 2, 2, 3])','let { entropy } = import("vector");\nentropy([0])','let { entropy } = import("vector");\nentropy([1])','let { entropy } = import("vector");\nentropy([1, 2])'],seeAlso:["vector.moving-entropy","vector.centered-moving-entropy","vector.running-entropy","vector.gini-coefficient"]},"moving-entropy":{category:"vector",description:"Calculates the **moving entropy** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **moving entropy** of."},windowSize:{type:"integer",description:"The size of the moving window."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]}],examples:['let { moving-entropy } = import("vector");\nmoving-entropy([1, 1, 2, 3, 3, 3], 4)','let { moving-entropy } = import("vector");\nmoving-entropy([1, 1, 2, 3, 3, 3], 3)','let { moving-entropy } = import("vector");\nmoving-entropy([1, 2], 2)'],seeAlso:["vector.entropy","vector.centered-moving-entropy","vector.running-entropy"]},"centered-moving-entropy":{category:"vector",description:"Calculates the **centered moving entropy** of a `vector` with a given window size.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **centered moving entropy** of."},windowSize:{type:"integer",description:"The size of the moving window."},leftPadding:{type:"number",description:"Optional value to use for padding. Default is `null`."},rightPadding:{type:"number",description:"Optional value to use for right padding. Default is `null`."},a:{type:"vector"},b:{type:"integer"}},variants:[{argumentNames:["vector","windowSize"]},{argumentNames:["vector","windowSize","leftPadding"]},{argumentNames:["vector","windowSize","leftPadding","rightPadding"]}],examples:['let { centered-moving-entropy } = import("vector");\ncentered-moving-entropy([1, 1, 2, 3, 3, 3], 4)','let { centered-moving-entropy } = import("vector");\ncentered-moving-entropy([1, 1, 2, 3, 3, 3], 3)','let { centered-moving-entropy } = import("vector");\ncentered-moving-entropy([1, 2], 2)'],seeAlso:["vector.entropy","vector.moving-entropy","vector.running-entropy"]},"running-entropy":{category:"vector",description:"Calculates the **running entropy** of a `vector`.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The `vector` to calculate the **running entropy** of."}},variants:[{argumentNames:["vector"]}],examples:['let { running-entropy } = import("vector");\nrunning-entropy([1, 1, 2, 3, 3, 3])','let { running-entropy } = import("vector");\nrunning-entropy([1, 2])'],seeAlso:["vector.entropy","vector.moving-entropy","vector.centered-moving-entropy"]},"monotonic?":{category:"vector",description:"Checks if a vector is monotonic.",returns:{type:"boolean"},args:{vector:{type:"vector",description:"The vector to check."}},variants:[{argumentNames:["vector"]}],examples:['let { monotonic? } = import("vector");\nmonotonic?([1, 2, 3])','let { monotonic? } = import("vector");\nmonotonic?([1, 2, 2, 3])','let { monotonic? } = import("vector");\nmonotonic?([3, 2, 1])','let { monotonic? } = import("vector");\nmonotonic?([3, 2, 1, 1])','let { monotonic? } = import("vector");\nmonotonic?([3, 2, 1, 2])','let { monotonic? } = import("vector");\nmonotonic?([1])','let { monotonic? } = import("vector");\nmonotonic?([])'],seeAlso:["vector.strictly-monotonic?","vector.increasing?","vector.decreasing?"]},"strictly-monotonic?":{category:"vector",description:"Checks if a vector is strictly monotonic.",returns:{type:"boolean"},args:{vector:{type:"vector",description:"The vector to check."}},variants:[{argumentNames:["vector"]}],examples:['let { strictly-monotonic? } = import("vector");\nstrictly-monotonic?([1, 2, 3])','let { strictly-monotonic? } = import("vector");\nstrictly-monotonic?([1, 2, 2, 3])','let { strictly-monotonic? } = import("vector");\nstrictly-monotonic?([3, 2, 1])','let { strictly-monotonic? } = import("vector");\nstrictly-monotonic?([3, 2, 1, 1])','let { strictly-monotonic? } = import("vector");\nstrictly-monotonic?([3, 2, 1, 2])','let { strictly-monotonic? } = import("vector");\nstrictly-monotonic?([1])','let { strictly-monotonic? } = import("vector");\nstrictly-monotonic?([])'],seeAlso:["vector.monotonic?","vector.strictly-increasing?","vector.strictly-decreasing?"]},"increasing?":{category:"vector",description:"Checks if a vector is increasing.",returns:{type:"boolean"},args:{vector:{type:"vector",description:"The vector to check."}},variants:[{argumentNames:["vector"]}],examples:['let { increasing? } = import("vector");\nincreasing?([1, 2, 3])','let { increasing? } = import("vector");\nincreasing?([1, 2, 2, 3])','let { increasing? } = import("vector");\nincreasing?([3, 2, 1])','let { increasing? } = import("vector");\nincreasing?([3, 2, 1, 1])','let { increasing? } = import("vector");\nincreasing?([3, 2, 1, 2])','let { increasing? } = import("vector");\nincreasing?([1])','let { increasing? } = import("vector");\nincreasing?([])'],seeAlso:["vector.strictly-increasing?","vector.decreasing?","vector.strictly-decreasing?","vector.monotonic?"]},"decreasing?":{category:"vector",description:"Checks if a vector is decreasing.",returns:{type:"boolean"},args:{vector:{type:"vector",description:"The vector to check."}},variants:[{argumentNames:["vector"]}],examples:['let { decreasing? } = import("vector");\ndecreasing?([1, 2, 3])','let { decreasing? } = import("vector");\ndecreasing?([1, 2, 2, 3])','let { decreasing? } = import("vector");\ndecreasing?([3, 2, 1])','let { decreasing? } = import("vector");\ndecreasing?([3, 2, 1, 1])','let { decreasing? } = import("vector");\ndecreasing?([3, 2, 1, 2])','let { decreasing? } = import("vector");\ndecreasing?([1])','let { decreasing? } = import("vector");\ndecreasing?([])'],seeAlso:["vector.strictly-decreasing?","vector.increasing?","vector.strictly-increasing?","vector.monotonic?"]},"strictly-increasing?":{category:"vector",description:"Checks if a vector is strictly increasing.",returns:{type:"boolean"},args:{vector:{type:"vector",description:"The vector to check."}},variants:[{argumentNames:["vector"]}],examples:['let { strictly-increasing? } = import("vector");\nstrictly-increasing?([1, 2, 3])','let { strictly-increasing? } = import("vector");\nstrictly-increasing?([1, 2, 2, 3])','let { strictly-increasing? } = import("vector");\nstrictly-increasing?([3, 2, 1])','let { strictly-increasing? } = import("vector");\nstrictly-increasing?([3, 2, 1, 1])','let { strictly-increasing? } = import("vector");\nstrictly-increasing?([3, 2, 1, 2])','let { strictly-increasing? } = import("vector");\nstrictly-increasing?([1])','let { strictly-increasing? } = import("vector");\nstrictly-increasing?([])'],seeAlso:["vector.increasing?","vector.decreasing?","vector.strictly-decreasing?","vector.strictly-monotonic?"]},"strictly-decreasing?":{category:"vector",description:"Checks if a vector is strictly decreasing.",returns:{type:"boolean"},args:{vector:{type:"vector",description:"The vector to check."}},variants:[{argumentNames:["vector"]}],examples:['let { strictly-decreasing? } = import("vector");\nstrictly-decreasing?([1, 2, 3])','let { strictly-decreasing? } = import("vector");\nstrictly-decreasing?([1, 2, 2, 3])','let { strictly-decreasing? } = import("vector");\nstrictly-decreasing?([3, 2, 1])','let { strictly-decreasing? } = import("vector");\nstrictly-decreasing?([3, 2, 1, 1])','let { strictly-decreasing? } = import("vector");\nstrictly-decreasing?([3, 2, 1, 2])','let { strictly-decreasing? } = import("vector");\nstrictly-decreasing?([1])','let { strictly-decreasing? } = import("vector");\nstrictly-decreasing?([])'],seeAlso:["vector.increasing?","vector.strictly-increasing?","vector.decreasing?","vector.strictly-monotonic?"]},mode:{category:"vector",description:"Returns the mode of all elements in the vector.",returns:{type:"number"},args:{vector:{type:"vector",description:"The vector to calculate the mode of."}},variants:[{argumentNames:["vector"]}],examples:['let { mode } = import("vector");\nmode([1, 2, 3])','let { mode } = import("vector");\nmode([1, 2, -3, 1])','let { mode } = import("vector");\nmode([2, 2, 3, 3, 4])','let { mode } = import("vector");\nmode([2, 2, 3, 3])','let { mode } = import("vector");\nmode([1, 2, 3, 2, 1, 2])'],seeAlso:["vector.mean","vector.median"]},"min-index":{category:"vector",description:"Returns the index of the minimum value of all elements in the vector.",returns:{type:"integer"},args:{vector:{type:"vector",description:"Non emtpy vector to calculate the minimum index of."}},variants:[{argumentNames:["vector"]}],examples:['let { min-index } = import("vector");\nmin-index([1, 2, 3])','let { min-index } = import("vector");\nmin-index([1, 1, 2, 3, 3])','let { min-index } = import("vector");\nmin-index([1, 2, -3])','let { min-index } = import("vector");\nmin-index([1, 2, 3, 4])','let { min-index } = import("vector");\nmin-index([1, 2, -3, 4])'],seeAlso:["vector.max-index","min"]},"max-index":{category:"vector",description:"Returns the index of the maximum value of all elements in the vector.",returns:{type:"integer"},args:{vector:{type:"vector",description:"Non emtpy vector to calculate the maximum index of."}},variants:[{argumentNames:["vector"]}],examples:['let { max-index } = import("vector");\nmax-index([1, 2, 3])','let { max-index } = import("vector");\nmax-index([1, 1, 2, 3, 3])','let { max-index } = import("vector");\nmax-index([1, 2, -3])','let { max-index } = import("vector");\nmax-index([1, 2, 3, 4])','let { max-index } = import("vector");\nmax-index([1, 2, -3, 4])'],seeAlso:["vector.min-index","max"]},"sort-indices":{category:"vector",description:"Returns the indices of the elements in the vector sorted in ascending order.",returns:{type:"vector"},args:{vector:{type:"vector",description:"Non emtpy vector to calculate the sorted indices of."}},variants:[{argumentNames:["vector"]}],examples:['let { sort-indices } = import("vector");\nsort-indices([1, 2, 3])','let { sort-indices } = import("vector");\nsort-indices([1, 1, 2, 3, 3])','let { sort-indices } = import("vector");\nsort-indices([1, 2, -3])','let { sort-indices } = import("vector");\nsort-indices([1, 2, 3, 4])','let { sort-indices } = import("vector");\nsort-indices([1, 2, -3, 4])'],seeAlso:["sort"]},"count-values":{category:"vector",description:"Counts the number of occurrences of each value in the vector.",returns:{type:"number",array:!0},args:{vector:{type:"vector",description:"Vector to count the values of."}},variants:[{argumentNames:["vector"]}],examples:['let { count-values } = import("vector");\ncount-values([1, 2, 3])','let { count-values } = import("vector");\ncount-values([1, 1, 2, 3, 3])','let { count-values } = import("vector");\ncount-values([1, 2, -3])','let { count-values } = import("vector");\ncount-values([1, 2, 2, 1, 3, 2, 4, 2, 1, 2, 2, 1, 3, 2, 4])'],seeAlso:["sequence.frequencies","vector.bincount"]},linspace:{category:"vector",description:"Generates a vector of evenly spaced numbers between two values.",returns:{type:"number",array:!0},args:{start:{type:"number",description:"The starting value."},stop:{type:"number",description:"The ending value."},n:{type:"integer",description:"The number of values to generate."}},variants:[{argumentNames:["start","stop","n"]}],examples:['let { linspace } = import("vector");\nlinspace(0, 10, 6)','let { linspace } = import("vector");\nlinspace(10, 20, 25)'],seeAlso:["range","vector.ones","vector.zeros","vector.fill","vector.generate"]},ones:{category:"vector",description:"Generates a vector of ones.",returns:{type:"number",array:!0},args:{length:{type:"integer",description:"The length of the vector."}},variants:[{argumentNames:["length"]}],examples:['let { ones } = import("vector");\nones(5)','let { ones } = import("vector");\nones(10)','let { ones } = import("vector");\nones(0)'],seeAlso:["repeat","vector.zeros","vector.fill","vector.generate","vector.linspace"]},zeros:{category:"vector",description:"Generates a vector of zeros.",returns:{type:"number",array:!0},args:{length:{type:"integer",description:"The length of the vector."}},variants:[{argumentNames:["length"]}],examples:['let { zeros } = import("vector");\nzeros(5)','let { zeros } = import("vector");\nzeros(10)','let { zeros } = import("vector");\nzeros(0)'],seeAlso:["repeat","vector.ones","vector.fill","vector.generate","vector.linspace"]},fill:{category:"vector",description:"Generates a vector filled with a number.",returns:{type:"number",array:!0},args:{length:{type:"integer",description:"The length of the vector."},value:{type:"number",description:"The value to fill the vector with."},a:{type:"number"},b:{type:"integer"}},variants:[{argumentNames:["length","value"]}],examples:['let { fill } = import("vector");\nfill(5, PI)','let { fill } = import("vector");\nfill(10, -1)'],seeAlso:["repeat","vector.ones","vector.zeros","vector.generate","vector.linspace","grid.fill"]},generate:{category:"vector",description:"Generates a vector of numbers based on a function.",returns:{type:"number",array:!0},args:{length:{type:"integer",description:"The length of the vector."},func:{type:"function",description:"A function that takes an index and returns a number."},a:{type:"number"},b:{type:"integer"}},variants:[{argumentNames:["length","func"]}],examples:['let { generate } = import("vector");\ngenerate(5, -> $ * 2)','let { generate } = import("vector");\ngenerate(10, -> $ + 1)','let { generate } = import("vector");\ngenerate(0, -> $ + 1)'],seeAlso:["repeat","vector.ones","vector.zeros","vector.fill","vector.linspace","grid.generate"]},cumsum:{category:"vector",description:"Calculates the cumulative sum of a vector.",returns:{type:"number",array:!0},args:{vector:{type:"vector",description:"The vector to calculate the cumulative sum of."}},variants:[{argumentNames:["vector"]}],examples:['let { cumsum } = import("vector");\ncumsum([1, 2, 3])','let { cumsum } = import("vector");\ncumsum([1, 2, -3])','let { cumsum } = import("vector");\ncumsum([])'],seeAlso:["vector.cumprod","vector.sum","vector.running-sum"]},cumprod:{category:"vector",description:"Calculates the cumulative product of a vector.",returns:{type:"number",array:!0},args:{vector:{type:"vector",description:"The vector to calculate the cumulative product of."}},variants:[{argumentNames:["vector"]}],examples:['let { cumprod } = import("vector");\ncumprod([1, 2, 3])','let { cumprod } = import("vector");\ncumprod([1, 2, -3, 0, 10])','let { cumprod } = import("vector");\ncumprod([])'],seeAlso:["vector.cumsum","vector.prod","vector.running-prod"]},quartiles:{category:"vector",description:"Calculates the quartiles of a vector. Returns an array containing the first, second (median), and third quartiles.",returns:{type:"number",array:!0},args:{vector:{type:"vector",description:"The vector to calculate the quartiles of. Minimum length is 4."}},variants:[{argumentNames:["vector"]}],examples:['let { quartiles } = import("vector");\nquartiles([1, 2, 3, 4])','let { quartiles } = import("vector");\nquartiles([5, 4, 3, 2, 1, 2, 3, 4, 5])','let { quartiles } = import("vector");\nquartiles(range(1, 1000))','let { quartiles, generate } = import("vector");\nquartiles(generate(1000, -> 1e6 / ($ + 1) ^ 2))','let { quartiles, generate } = import("vector");\nlet { ln } = import("math");\nquartiles(generate(1000, -> ln($ + 1)))'],seeAlso:["vector.percentile","vector.quantile","vector.median","vector.iqr"]},percentile:{category:"vector",description:"Calculates the percentile of a vector. Returns the value at the specified percentile.",returns:{type:"number"},args:{vector:{type:"vector",description:"The non empty vector to calculate the percentile of."},percentile:{type:"number",description:"The percentile to calculate. Must be between 0 and 1."},a:{type:"number"},b:{type:"integer"}},variants:[{argumentNames:["vector","percentile"]}],examples:['let { percentile } = import("vector");\npercentile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 35)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 0)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 10)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 20)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 30)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 40)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 50)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 60)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 70)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 80)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 90)','let { percentile } = import("vector");\npercentile(range(100) ^ 0.5, 100)'],seeAlso:["vector.quantile","vector.quartiles","vector.median","vector.ecdf","vector.winsorize"]},quantile:{category:"vector",description:"Calculates the quantile of a vector. Returns the value at the specified quantile.",returns:{type:"number"},args:{vector:{type:"vector",description:"The non empty vector to calculate the quantile of."},quantile:{type:"number",description:"The quantile to calculate. Must be between 0 and 1."},a:{type:"number"},b:{type:"integer"}},variants:[{argumentNames:["vector","quantile"]}],examples:['let { quantile } = import("vector");\nquantile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0.35)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0.1)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0.2)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0.3)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0.4)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0.5)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0.6)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0.7)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0.8)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 0.9)','let { quantile } = import("vector");\nquantile(range(100) ^ 0.5, 1)'],seeAlso:["vector.percentile","vector.quartiles","vector.ecdf"]},histogram:{category:"vector",description:"Creates a histogram from a numeric `array` by dividing the data range into the specified number of bins. Returns an `array` of `[binStart, binEnd, count]` tuples representing each bin's range and the number of values within it. Handles empty arrays, identical values, and properly places maximum values in the last bin.",returns:{type:"array",array:!0},args:{vector:{type:"vector",description:"The numeric array to create a histogram from."},bins:{type:"integer",description:"The number of bins to divide the data range into."},a:{type:"number"},b:{type:"integer"}},variants:[{argumentNames:["vector","bins"]}],examples:['let { histogram } = import("vector");\nhistogram([1, 2, 2, 3, 2, 6, 4, 3, 2, 4, 1, 3, 2, 9], 3)','let { histogram } = import("vector");\nhistogram([1, 2, 3, 4, 5], 5)','let { histogram } = import("vector");\nhistogram([1, 2, 3, 4, 5], 10)','let { histogram } = import("vector");\nhistogram([1, 2, 3, 4, 5], 1)'],seeAlso:["vector.bincount","vector.ecdf"]},ecdf:{category:"vector",description:"Calculates the empirical cumulative distribution function value for a given threshold in a non empty dataset. Returns the proportion of values in the `array` that are less than or equal to the specified threshold.",returns:{type:"number"},args:{vector:{type:"vector",description:"The numeric array to calculate the ECDF from."},threshold:{type:"number",description:"The threshold value to calculate the ECDF for."},a:{type:"number"},b:{type:"integer"}},variants:[{argumentNames:["vector","threshold"]}],examples:['let { ecdf } = import("vector");\necdf([1, 2, 2, 3, 2, 6, 4, 3, 2, 4, 1, 3, 2, 9, 10, 12], 5)','let { ecdf } = import("vector");\necdf([1, 2, 3, 4, 5], 3)','let { ecdf } = import("vector");\necdf([1, 2, 3, 4, 5], 0)','let { ecdf } = import("vector");\necdf([1, 2, 3, 4, 5], 10)','let { ecdf } = import("vector");\necdf([1, 2, 3, 4, 5], 2)'],seeAlso:["vector.histogram","vector.percentile","vector.quantile"]},"outliers?":{category:"vector",description:"Checks if the `vector` contains outliers based on the interquartile range (IQR) method. Returns `true` if outliers are present, `false` otherwise.",returns:{type:"boolean"},args:{vector:{type:"vector",description:"The `vector` to check for outliers."}},variants:[{argumentNames:["vector"]}],examples:['let { outliers? } = import("vector");\noutliers?([1, 2, 3])','let { outliers? } = import("vector");\noutliers?([1, 2, -3])','let { outliers? } = import("vector");\noutliers?([1, 2, 3, 2, 4, 120])'],seeAlso:["vector.outliers","vector.winsorize","vector.iqr"]},outliers:{category:"vector",description:"Identifies outliers in the `vector` based on the interquartile range (IQR) method. Returns an array of outlier values.",returns:{type:"number",array:!0},args:{vector:{type:"vector",description:"The `vector` to check for outliers."}},variants:[{argumentNames:["vector"]}],examples:['let { outliers } = import("vector");\noutliers([1, 2, 3])','let { outliers } = import("vector");\noutliers([1, 2, -3])','let { outliers } = import("vector");\noutliers([1, 2, 3, 2, 4, 120])'],seeAlso:["vector.outliers?","vector.winsorize","vector.iqr"]},bincount:{category:"vector",description:"counts occurrences of each `integer` in a vector, returning an array where index `i` contains the count of value `i`, with optional **minimum size** and **weights parameters**.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The vector to count occurrences in."},minSize:{type:"integer",description:"Optional minimum size of the output array."},weights:{type:"number",array:!0,description:"Optional weights for each element in the vector."}},variants:[{argumentNames:["vector"]},{argumentNames:["vector","minSize"]},{argumentNames:["vector","minSize","weights"]}],examples:['let { bincount } = import("vector");\nbincount([1, 2, 3])','let { bincount } = import("vector");\nbincount([1, 2, 2, 3, 3])'],seeAlso:["vector.count-values","vector.histogram"],hideOperatorForm:!0},winsorize:{category:"vector",description:"Limits extreme values in a `vector` by replacing values below the **lower quantile** and above the **upper quantile** with the values at those quantiles. The function takes a `vector` of values and **quantile thresholds** (between 0 and 1), with the upper quantile. Winsorization reduces the influence of outliers while preserving the overall distribution shape, making statistical analyses more robust.",returns:{type:"vector"},args:{vector:{type:"vector",description:"The vector to winsorize."},"lower-quantile":{type:"number",description:"The lower quantile threshold (between 0 and 1)."},"upper-quantile":{type:"number",description:"Optional Upper quantile threshold (between 0 and 1). Defaults to `(1 - lower-quantile)` if `lower-quantile <= 0.5` otherwise `1`."}},variants:[{argumentNames:["vector","lower-quantile"]},{argumentNames:["vector","lower-quantile","upper-quantile"]}],examples:['let { winsorize } = import("vector");\nwinsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25)','let { winsorize } = import("vector");\nwinsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25, 0.75)','let { winsorize } = import("vector");\nwinsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25, 0.5)'],seeAlso:["vector.outliers","vector.outliers?","vector.percentile"],hideOperatorForm:!0},mse:{category:"vector",description:"Calculates the **Mean Squared Error (MSE)** between two vectors. Returns the average of the squared differences between corresponding elements.",returns:{type:"number"},args:{a:{type:"vector",description:"The first vector."},b:{type:"vector",description:"The second vector."}},variants:[{argumentNames:["a","b"]}],examples:['let { mse } = import("vector");\nmse([1, 2, 3], [1, 2, 3])','let { mse } = import("vector");\nmse([1, 2, 3], [4, 5, 6])','let { mse } = import("vector");\nmse([1, 2, 3], [2, 2, 2])','let { mse } = import("vector");\nmse([1, 2], [3, 3])','let { mse } = import("vector");\nmse([1], [3])'],seeAlso:["vector.rmse","vector.mae","vector.smape"]},rmse:{category:"vector",description:"Calculates the **Root Mean Squared Error (RMSE)** between two vectors. Returns the square root of the average of the squared differences between corresponding elements.",returns:{type:"number"},args:{a:{type:"vector",description:"The first vector."},b:{type:"vector",description:"The second vector."}},variants:[{argumentNames:["a","b"]}],examples:['let { rmse } = import("vector");\nrmse([1, 2, 3], [1, 2, 3])','let { rmse } = import("vector");\nrmse([1, 2, 3], [4, 5, 6])','let { rmse } = import("vector");\nrmse([1, 2, 3], [2, 2, 2])','let { rmse } = import("vector");\nrmse([1, 2], [3, 3])','let { rmse } = import("vector");\nrmse([1], [3])'],seeAlso:["vector.mse","vector.mae","vector.smape"]},mae:{category:"vector",description:"Calculates the **Mean Absolute Error (MAE)** between two vectors. Returns the average of the absolute differences between corresponding elements.",returns:{type:"number"},args:{a:{type:"vector",description:"The first vector."},b:{type:"vector",description:"The second vector."}},variants:[{argumentNames:["a","b"]}],examples:['let { mae } = import("vector");\nmae([1, 2, 3], [1, 2, 3])','let { mae } = import("vector");\nmae([1, 2, 3], [4, 5, 6])','let { mae } = import("vector");\nmae([1, 2, 3], [2, 2, 2])','let { mae } = import("vector");\nmae([1, 2], [3, 3])','let { mae } = import("vector");\nmae([1], [3])'],seeAlso:["vector.mse","vector.rmse","vector.smape"]},smape:{category:"vector",description:"Calculates the **Symmetric Mean Absolute Percentage Error (SMAPE)** between two vectors. Returns the average of the absolute percentage differences between corresponding elements.",returns:{type:"number"},args:{a:{type:"vector",description:"The first vector."},b:{type:"vector",description:"The second vector."}},variants:[{argumentNames:["a","b"]}],examples:['let { smape } = import("vector");\nsmape([1, 2, 3], [1, 2, 3])','let { smape } = import("vector");\nsmape([1, 2, 3], [4, 5, 6])','let { smape } = import("vector");\nsmape([1, 2, 3], [2, 2, 2])','let { smape } = import("vector");\nsmape([1, 2], [3, 3])','let { smape } = import("vector");\nsmape([1], [3])'],seeAlso:["vector.mse","vector.rmse","vector.mae"]}};function bincount(e,t=0,r){if(0===e.length)return Array.from({length:t},()=>0);const n=Math.max(...e),o=Math.max(n+1,t),a=Array.from({length:o},()=>0);for(let t=0;t<e.length;t++){const n=Math.floor(e[t]);n<o&&(a[n]+=r?r[t]:1)}return a}function calcHistogram(e,t){if(0===e.length){const e=[];for(let r=0;r<t;r++)e.push([0,0,0]);return e}const r=Math.min(...e),n=Math.max(...e);if(r===n){const n=[];for(let e=0;e<t;e++)n.push([r,r,0]);return n[0][2]=e.length,n}const o=(n-r)/t,a=[];for(let e=0;e<t;e++){const i=r+e*o,s=e===t-1?n:r+(e+1)*o;a.push([i,s,0])}for(const i of e)if(i===n)a[t-1][2]+=1;else{a[Math.min(Math.floor((i-r)/o),t-1)][2]+=1}return a}function mode(e){const t=new Map;for(const r of e)t.set(r,(t.get(r)||0)+1);let r=0;for(const e of t.values())e>r&&(r=e);if(1===r)return e;const n=[];for(const[e,o]of t.entries())o===r&&n.push(e);return n}function hasOutliers(e){return outliers(e).length>0}function outliers(e){if(e.length<=1)return[];const t=[...e].sort((e,t)=>e-t),r=Math.floor(.25*t.length),n=t.length%4==0?(t[r-1]+t[r])/2:t[r],o=Math.floor(.75*t.length),a=t.length%4==0?(t[o-1]+t[o])/2:t[o],i=a-n,s=n-1.5*i,c=a+1.5*i;return e.filter(e=>e<s||e>c)}function calcPercentile(e,t){const r=[...e].sort((e,t)=>e-t);if(0===t)return r[0];if(100===t)return r[r.length-1];const n=t/100*(r.length-1);if(Number.isInteger(n))return r[n];const o=Math.floor(n),a=Math.ceil(n),i=n-o;return r[o]*(1-i)+r[a]*i}function quartiles(e){const t=[...e].sort((e,t)=>e-t),r=t.length/2;let n;n=t.length%2==0?(t[r-1]+t[r])/2:t[Math.floor(r)];const o=t.slice(0,Math.floor(t.length/2)),a=t.slice(Math.ceil(t.length/2));let i,s;if(o.length%2==0){const e=o.length/2;i=(o[e-1]+o[e])/2}else i=o[Math.floor(o.length/2)];if(a.length%2==0){const e=a.length/2;s=(a[e-1]+a[e])/2}else s=a[Math.floor(a.length/2)];return[i,n,s]}function calcMean(e){if(0===e.length)return 0;return e.reduce((e,t)=>e+t,0)/e.length}const meanReductionFunction={mean:e=>calcMean(e)},geometricMeanReductionFunction={"geometric-mean":e=>{if(e.some(e=>e<0))throw new Error("Geometric mean is not defined for non-positive numbers");return Math.exp(e.reduce((e,t)=>e+Math.log(t),0)/e.length)}},harmonicMeanReductionFunction={"harmonic-mean":e=>e.length/e.reduce((e,t)=>e+1/t,0)};function calcMedian(e){const t=[...e].sort((e,t)=>e-t),r=Math.floor(t.length/2);return t.length%2==0?(t[r-1]+t[r])/2:t[r]}const medianReductionFunction={median:e=>calcMedian(e)},prodReductionFunction={prod:e=>e.reduce((e,t)=>e*t,1),padding:1,minLength:0},sumReductionFunction={sum:e=>e.reduce((e,t)=>e+t,0),minLength:0};function calcVariance(e,t){const r=t??calcMean(e);return e.reduce((e,t)=>e+(t-r)**2,0)/e.length}function calcSampleVariance(e,t){const r=calcMean(e);return e.reduce((e,t)=>e+(t-r)**2,0)/(e.length-1)}const varianceReductionFunction={variance:e=>calcVariance(e)},sampleVarianceReductionFunction={"sample-variance":e=>calcSampleVariance(e),minLength:2};function calcStdDev(e,t){const r=calcVariance(e,t);return Math.sqrt(r)}function calcSampleStdDev(e,t){const r=calcVariance(e,t);return Math.sqrt(r*(e.length/(e.length-1)))}const stdevReductionFunction={stdev:e=>calcStdDev(e)},sampleStdevReductionFunction={"sample-stdev":e=>calcSampleStdDev(e),minLength:2},iqrReductionFunction={iqr:e=>{const[t,,r]=quartiles(e);return r-t},minLength:4},spanReductionFunction={span:e=>0===e.length?0:Math.max(...e)-Math.min(...e),minLength:0};function skewness(e){const t=calcMean(e),r=calcStdDev(e);if(0===r)throw new Error("Standard deviation is zero, skewness is undefined");return e.reduce((e,r)=>e+(r-t)**3,0)/(e.length*r**3)}function sampleSkewness(e){const t=e.length,r=e.reduce((e,t)=>e+t,0)/t;let n=0,o=0;for(const t of e){const e=t-r;n+=e*e,o+=e*e*e}const a=n/(t-1),i=Math.sqrt(a);if(0===i)throw new Error("Cannot calculate sample skewness when standard deviation is 0");return t/((t-1)*(t-2))*o/i**3}const skewnessReductionFunction={skewness:e=>skewness(e),minLength:3},sampleSkewnessReductionFunction={"sample-skewness":e=>sampleSkewness(e),minLength:3};function kurtosis(e){const t=calcMean(e),r=calcStdDev(e);if(0===r)throw new Error("Standard deviation is zero, kurtosis is undefined");return e.reduce((e,r)=>e+(r-t)**4,0)/(e.length*r**4)}function excessKurtosis(e){return kurtosis(e)-3}function sampleKurtosis(e){const t=e.length,r=e.reduce((e,t)=>e+t,0)/t,n=e.reduce((e,t)=>e+(t-r)**2,0)/(t-1);if(0===n)throw new Error("Variance is zero, kurtosis is undefined");return t*(t+1)*e.reduce((e,t)=>e+(t-r)**4,0)/((t-1)*(t-2)*(t-3)*n**2)}function sampleExcessKurtosis(e){const t=e.length,r=e.reduce((e,t)=>e+t,0)/t,n=e.reduce((e,t)=>e+(t-r)**2,0)/(t-1);if(0===n)throw new Error("Variance is zero, kurtosis is undefined");return t*(t+1)*e.reduce((e,t)=>e+(t-r)**4,0)/((t-1)*(t-2)*(t-3)*n**2)-3*(t-1)*(t-1)/((t-2)*(t-3))}const kurtosisReductionFunction={kurtosis:e=>kurtosis(e),minLength:4},eccessKurtosisReductionFunction={"excess-kurtosis":e=>excessKurtosis(e),minLength:4},sampleKurtosisReductionFunction={"sample-kurtosis":e=>sampleKurtosis(e),minLength:4},sampleExcessKurtosisReductionFunction={"sample-excess-kurtosis":e=>sampleExcessKurtosis(e),minLength:4},rmsReductionFunction={rms:e=>Math.sqrt(e.reduce((e,t)=>e+t**2,0)/e.length)};function calcMad(e){const t=calcMedian(e);return e.reduce((e,r)=>e+Math.abs(r-t),0)/e.length}const madReductionFunction={mad:e=>calcMad(e)};function calcMedad(e){const t=calcMedian(e);return 1.4826*calcMedian(e.map(e=>Math.abs(e-t)))}const medadReductionFunction={medad:e=>calcMedad(e)},giniCoefficientReductionFunction={"gini-coefficient":e=>{if(e.some(e=>e<0))throw new Error("Gini coefficient is not defined for negative values");const t=[...e].sort((e,t)=>e-t),r=t.length,n=t.reduce((e,t)=>e+t,0);if(0===n)return 0;return 2*t.reduce((e,t,r)=>e+(r+1)*t,0)/(r*n)-(r+1)/r},minLength:1};function calculateEntropy(e){const t=new Map;for(const r of e)t.set(r,(t.get(r)||0)+1);const r=e.length;let n=0;for(const e of t.values()){const t=e/r;t>0&&(n-=t*Math.log2(t))}return n}const entropyReductionFunction={entropy:e=>calculateEntropy(e),minLength:1},reductionFunctionNormalExpressions={};function addReductionFunctions$1(e){for(const[t,r]of Object.entries(e)){if(reductionFunctionNormalExpressions[t])throw new Error(`Duplicate normal expression key found: ${t}`);if("minLength"!==t&&"padding"!==t&&"function"==typeof r){const n=r,o=t.replace(/^/,""),a=`moving-${o}`,i=`centered-moving-${o}`,s=`running-${o}`,c=e.minLength??1;assertNumber(c,void 0,{integer:!0,finite:!0,gte:0}),reductionFunctionNormalExpressions[t]=createReductionNormalExpression(n,c),reductionFunctionNormalExpressions[a]=createMovingNormalExpression(n,c),reductionFunctionNormalExpressions[i]=createCenteredMovingNormalExpression(n,c,e.padding??null),reductionFunctionNormalExpressions[s]=createRunningNormalExpression(n,c)}}}function createReductionNormalExpression(e,t){return{evaluate:([r],n)=>{if(assertVector(r,n),r.length<t)throw new LitsError(`Vector length must be at least ${t}`,n);try{return e(r)}catch(e){throw new LitsError(e,n)}},arity:toFixedArity(1)}}function createMovingNormalExpression(e,t){return{evaluate:([r,n],o)=>{if(assertVector(r,o),assertNumber(n,o,{integer:!0,finite:!0,gte:t,lte:r.length}),0===r.length)return[];try{if(n>=r.length)return[e(r)];const t=[];for(let o=0;o<r.length-n+1;o+=1)t.push(e(r.slice(o,o+n)));return t}catch(e){throw new LitsError(e,o)}},arity:toFixedArity(2)}}function createCenteredMovingNormalExpression(e,t,r){return{evaluate:([n,o,a,i],s)=>{if(assertVector(n,s),n.length<t)throw new LitsError(`Vector length must be at least ${t}`,s);if(assertNumber(o,s,{integer:!0,finite:!0,gte:t,lte:n.length}),null!==(a=a??r)&&assertNumber(a,s,{finite:!0}),null!==(i=i??r)&&assertNumber(i,s,{finite:!0}),0===n.length)return[];const c=Math.floor(o/2),l=[...Array(c).fill(a),...n,...Array(c).fill(i)],u="number"==typeof a?0:c,m=n.length-("number"==typeof i?0:o-c-1),p=[...Array(u).fill(null)];try{for(let t=u;t<m;t+=1)p.push(e(l.slice(t,t+o)))}catch(e){throw new LitsError(e,s)}return p.push(...Array(n.length-m).fill(null)),p},arity:{min:2,max:4}}}function createRunningNormalExpression(e,t){return{evaluate:([r],n)=>{if(assertVector(r,n),r.length<t)throw new LitsError(`Vector length must be at least ${t}`,n);if(0===r.length)return[];try{const n=Math.max(t-1,0),o=Array(n).fill(null);for(let t=n;t<r.length;t+=1)o.push(e(r.slice(0,t+1)));return o}catch(e){throw new LitsError(e,n)}},arity:toFixedArity(1)}}addReductionFunctions$1(meanReductionFunction),addReductionFunctions$1(geometricMeanReductionFunction),addReductionFunctions$1(harmonicMeanReductionFunction),addReductionFunctions$1(medianReductionFunction),addReductionFunctions$1(sumReductionFunction),addReductionFunctions$1(prodReductionFunction),addReductionFunctions$1(varianceReductionFunction),addReductionFunctions$1(sampleVarianceReductionFunction),addReductionFunctions$1(stdevReductionFunction),addReductionFunctions$1(sampleStdevReductionFunction),addReductionFunctions$1(iqrReductionFunction),addReductionFunctions$1(spanReductionFunction),addReductionFunctions$1(skewnessReductionFunction),addReductionFunctions$1(sampleSkewnessReductionFunction),addReductionFunctions$1(eccessKurtosisReductionFunction),addReductionFunctions$1(kurtosisReductionFunction),addReductionFunctions$1(sampleExcessKurtosisReductionFunction),addReductionFunctions$1(sampleKurtosisReductionFunction),addReductionFunctions$1(rmsReductionFunction),addReductionFunctions$1(madReductionFunction),addReductionFunctions$1(medadReductionFunction),addReductionFunctions$1(giniCoefficientReductionFunction),addReductionFunctions$1(entropyReductionFunction);const vectorFunctions={"monotonic?":{evaluate:([e],t)=>(assertVector(e,t),e.every((t,r)=>0===r||t>=e[r-1])||e.every((t,r)=>0===r||t<=e[r-1])),arity:toFixedArity(1)},"strictly-monotonic?":{evaluate:([e],t)=>(assertVector(e,t),e.every((t,r)=>0===r||t>e[r-1])||e.every((t,r)=>0===r||t<e[r-1])),arity:toFixedArity(1)},"increasing?":{evaluate:([e],t)=>(assertVector(e,t),e.every((t,r)=>0===r||t>=e[r-1])),arity:toFixedArity(1)},"decreasing?":{evaluate:([e],t)=>(assertVector(e,t),e.every((t,r)=>0===r||t<=e[r-1])),arity:toFixedArity(1)},"strictly-increasing?":{evaluate:([e],t)=>(assertVector(e,t),e.every((t,r)=>0===r||t>e[r-1])),arity:toFixedArity(1)},"strictly-decreasing?":{evaluate:([e],t)=>(assertVector(e,t),e.every((t,r)=>0===r||t<e[r-1])),arity:toFixedArity(1)},mode:{evaluate:([e],t)=>(assertNonEmptyVector(e,t),mode(e)),arity:toFixedArity(1)},"min-index":{evaluate:([e],t)=>(assertNonEmptyVector(e,t),e.reduce((t,r,n)=>r<e[t]?n:t,0)),arity:toFixedArity(1)},"max-index":{evaluate:([e],t)=>(assertNonEmptyVector(e,t),e.reduce((t,r,n)=>r>e[t]?n:t,0)),arity:toFixedArity(1)},"sort-indices":{evaluate:([e],t)=>(assertVector(e,t),[...e.keys()].sort((t,r)=>e[t]-e[r])),arity:toFixedArity(1)},"count-values":{evaluate:([e],t)=>{assertVector(e,t);const r=new Map;for(const t of e)r.set(t,(r.get(t)||0)+1);return[...r.entries()].sort((e,t)=>{const r=t[1]-e[1];return 0!==r?r:e[0]-t[0]})},arity:toFixedArity(1)},linspace:{evaluate:([e,t,r],n)=>{if(assertNumber(e,n,{finite:!0}),assertNumber(t,n,{finite:!0}),assertNumber(r,n,{integer:!0,nonNegative:!0}),0===r)return[];if(1===r)return[e];const o=(t-e)/(r-1);return Array.from({length:r},(t,r)=>e+r*o)},arity:toFixedArity(3)},ones:{evaluate:([e],t)=>(assertNumber(e,t,{integer:!0,nonNegative:!0}),Array.from({length:e},()=>1)),arity:toFixedArity(1)},zeros:{evaluate:([e],t)=>(assertNumber(e,t,{integer:!0,nonNegative:!0}),Array.from({length:e},()=>0)),arity:toFixedArity(1)},fill:{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0,nonNegative:!0}),Array.from({length:e},()=>t)),arity:toFixedArity(2)},generate:{evaluate:([e,t],r,n,{executeFunction:o})=>(assertNumber(e,r,{integer:!0,nonNegative:!0}),assertFunctionLike(t,r),mapSequential(Array.from({length:e}),(e,a)=>chain(o(t,[a],n,r),e=>(assertNumber(e,r,{finite:!0}),e)))),arity:toFixedArity(2)},cumsum:{evaluate:([e],t)=>(assertVector(e,t),e.reduce((e,t)=>{const r=e[e.length-1]??0;return e.push(r+t),e},[])),arity:toFixedArity(1)},cumprod:{evaluate:([e],t)=>(assertVector(e,t),e.reduce((e,t)=>{const r=e[e.length-1]??1;return e.push(r*t),e},[])),arity:toFixedArity(1)},quartiles:{evaluate:([e],t)=>{if(assertVector(e,t),e.length<4)throw new LitsError("Quartiles require at least four values",t);return quartiles(e)},arity:toFixedArity(1)},percentile:{evaluate:([e,t],r)=>(assertNonEmptyVector(e,r),assertNumber(t,r,{finite:!0,nonNegative:!0,lte:100}),calcPercentile(e,t)),arity:toFixedArity(2)},quantile:{evaluate:([e,t],r)=>(assertVector(e,r),assertNumber(t,r,{finite:!0,nonNegative:!0,lte:1}),calcPercentile(e,100*t)),arity:toFixedArity(2)},histogram:{evaluate:([e,t],r)=>(assertVector(e,r),assertNumber(t,r,{integer:!0,positive:!0}),calcHistogram(e,t)),arity:toFixedArity(2)},ecdf:{evaluate:([e,t],r)=>{assertNonEmptyVector(e,r),assertNumber(t,r,{finite:!0});const n=[...e].sort((e,t)=>e-t),o=n.findIndex(e=>e>t);return-1===o?1:o/n.length},arity:toFixedArity(2)},"outliers?":{evaluate:([e],t)=>(assertVector(e,t),hasOutliers(e)),arity:toFixedArity(1)},outliers:{evaluate:([e],t)=>(assertVector(e,t),outliers(e)),arity:toFixedArity(1)},bincount:{evaluate:(e,t)=>{const r=e[0];assertVector(r,t),r.forEach(e=>assertNumber(e,t,{finite:!0,integer:!0,nonNegative:!0}));const n=e[1]??0;assertNumber(n,t,{integer:!0,nonNegative:!0});const o=e[2]??void 0;if(void 0!==o){if(assertVector(o,t),o.length!==r.length)throw new LitsError("Weights vector must be the same length as the input vector",t);o.forEach(e=>assertNumber(e,t,{finite:!0}))}return bincount(r,n,o)},arity:{min:1,max:3}},winsorize:{evaluate:([e,t,r],n)=>{if(assertVector(e,n),assertNumber(t,n,{finite:!0,gte:0,lte:1}),r??=t>.5?1:1-t,assertNumber(r,n,{finite:!0,gte:t,lte:1}),0===e.length)return[];const o=[...e].sort((e,t)=>e-t),a=Math.max(0,Math.floor(t*e.length)),i=Math.min(e.length-1,Math.max(0,Math.floor(r*e.length)-1)),s=o[a],c=o[i];return e.map(e=>Math.max(s,Math.min(e,c)))},arity:{min:2,max:3}},mse:{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return e.reduce((e,r,n)=>e+(r-t[n])**2,0)/e.length},arity:toFixedArity(2)},rmse:{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return Math.sqrt(e.reduce((e,r,n)=>e+(r-t[n])**2,0)/e.length)},arity:toFixedArity(2)},mae:{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return e.reduce((e,r,n)=>e+Math.abs(r-t[n]),0)/e.length},arity:toFixedArity(2)},smape:{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return e.reduce((e,r,n)=>{const o=Math.abs(r-t[n]),a=(Math.abs(r)+Math.abs(t[n]))/2;return e+(0===a?0:o/a)},0)/e.length},arity:toFixedArity(2)}};function addReductionFunctions(e){for(const[t,r]of Object.entries(e)){if(vectorFunctions[t])throw new Error(`Duplicate normal expression key found: ${t}`);vectorFunctions[t]=r}}addReductionFunctions(reductionFunctionNormalExpressions);for(const[e,t]of Object.entries(moduleDocs$3))vectorFunctions[e]&&(vectorFunctions[e].docs=t);const vectorModule={name:"vector",functions:vectorFunctions},moduleDocs$2={reflect:{category:"linear-algebra",description:"Reflects a vector across a given axis.",returns:{type:"vector"},args:{a:{type:"vector",description:"Vector to reflect."},b:{type:"vector",description:"Axis of reflection."}},variants:[{argumentNames:["a","b"]}],examples:['let { reflect } = import("linear-algebra");\nreflect([1, 2], [0, 1])','let { reflect } = import("linear-algebra");\nreflect([1, 2, 3], [0, 0, 1])'],seeAlso:["linear-algebra.refract","linear-algebra.projection"]},refract:{category:"linear-algebra",description:"Refracts a vector across a given axis.",returns:{type:"vector"},args:{vector:{type:"vector",description:"Vector to refract."},axis:{type:"vector",description:"Axis of refraction."},eta:{type:"number",description:"Refraction index."}},variants:[{argumentNames:["vector","axis","eta"]}],examples:['let { refract } = import("linear-algebra");\nrefract([1, 2], [0, 1], 1.5)','let { refract } = import("linear-algebra");\nrefract([1, 2, 3], [0, 0, 1], 1.5)'],seeAlso:["linear-algebra.reflect"]},lerp:{category:"linear-algebra",description:"Performs linear interpolation between two vectors.",returns:{type:"vector"},args:{a:{type:"vector",description:"Start vector."},b:{type:"vector",description:"End vector."},t:{type:"number",description:"Interpolation factor (0 to 1)."}},variants:[{argumentNames:["a","b","t"]}],examples:['let { lerp } = import("linear-algebra");\nlerp([1, 2], [3, 4], 0.5)','let { lerp } = import("linear-algebra");\nlerp([1, 2], [3, 4], 2)','let { lerp } = import("linear-algebra");\nlerp([1, 2], [3, 4], -1)','let { lerp } = import("linear-algebra");\nlerp([1, 2, 3], [4, 5, 6], 0.25)'],seeAlso:["linear-algebra.projection"]},rotate2d:{category:"linear-algebra",description:"Rotates a 2D vector by a given angle in radians.",returns:{type:"vector"},args:{a:{type:"vector",description:"Vector to rotate."},b:{type:"number",description:"Angle in b."}},variants:[{argumentNames:["a","b"]}],examples:['let { rotate2d } = import("linear-algebra");\nrotate2d([1, 0], PI / 2)','let { rotate2d } = import("linear-algebra");\nrotate2d([0, 1], PI)'],seeAlso:["linear-algebra.rotate3d","linear-algebra.angle"]},rotate3d:{category:"linear-algebra",description:"Rotates a 3D vector around a given axis by a given angle in radians.",returns:{type:"vector"},args:{v:{type:"vector",description:"Vector to rotate."},axis:{type:"vector",description:"Axis of rotation."},radians:{type:"number",description:"Angle in radians."}},variants:[{argumentNames:["v","axis","radians"]}],examples:['let { rotate3d } = import("linear-algebra");\nrotate3d([1, 0, 0], [0, 1, 0], PI / 2)','let { rotate3d } = import("linear-algebra");\nrotate3d([0, 1, 0], [1, 0, 0], PI)'],seeAlso:["linear-algebra.rotate2d","linear-algebra.angle"]},dot:{category:"linear-algebra",description:"Calculates the dot product of two vectors. The result is a scalar.",returns:{type:"number"},args:{a:{type:"vector",description:"First vector."},b:{type:"vector",description:"Second vector."}},variants:[{argumentNames:["a","b"]}],examples:['let { dot } = import("linear-algebra");\ndot([1, 2], [3, 4])','let { dot } = import("linear-algebra");\ndot([1, 2, 3], [4, 5, 6])'],seeAlso:["linear-algebra.cross","linear-algebra.cosine-similarity","linear-algebra.angle","linear-algebra.projection","linear-algebra.orthogonal?"]},cross:{category:"linear-algebra",description:"Calculates the cross product of two 3D vectors. The result is a vector perpendicular to both input vectors.",returns:{type:"vector"},args:{a:{type:"vector",description:"First vector (3D)."},b:{type:"vector",description:"Second vector (3D)."}},variants:[{argumentNames:["a","b"]}],examples:['let { cross } = import("linear-algebra");\ncross([1, 2, 3], [4, 5, 6])','let { cross } = import("linear-algebra");\ncross([1, 0, 0], [0, 1, 0])','let { cross } = import("linear-algebra");\ncross([0, 0, 1], [1, 0, 0])','let { cross } = import("linear-algebra");\ncross([1, 2, 3], [0, 0, 0])','let { cross } = import("linear-algebra");\ncross([0, 0, 0], [1, 2, 3])'],seeAlso:["linear-algebra.dot"]},"normalize-minmax":{category:"linear-algebra",description:"Normalizes the vector using min-max normalization. The result is a vector with values between 0 and 1.",returns:{type:"number"},args:{v:{type:"vector",description:"Vector to normalize."}},variants:[{argumentNames:["v"]}],examples:['let { normalize-minmax } = import("linear-algebra");\nnormalize-minmax([1, 2, 3])','let { normalize-minmax } = import("linear-algebra");\nnormalize-minmax([1, 2, -3])','let { normalize-minmax } = import("linear-algebra");\nnormalize-minmax([1, 2, 3, 4])','let { normalize-minmax } = import("linear-algebra");\nnormalize-minmax([1, 2, -3, 4])','let { normalize-minmax } = import("linear-algebra");\nnormalize-minmax([1, 2, 3, 40, 50])'],seeAlso:["linear-algebra.normalize-zscore","linear-algebra.normalize-robust","linear-algebra.normalize-l1","linear-algebra.normalize-l2","linear-algebra.normalize-log"]},"normalize-zscore":{category:"linear-algebra",description:"Normalizes the vector using z-score normalization. The result is a vector with mean 0 and standard deviation 1.",returns:{type:"number"},args:{v:{type:"vector",description:"Vector to normalize."}},variants:[{argumentNames:["v"]}],examples:['let { normalize-zscore } = import("linear-algebra");\nnormalize-zscore([1, 2, 3])','let { normalize-zscore } = import("linear-algebra");\nnormalize-zscore([1, 2, -3])','let { normalize-zscore } = import("linear-algebra");\nnormalize-zscore([1, 2, 3, 4])','let { normalize-zscore } = import("linear-algebra");\nnormalize-zscore([1, 2, -3, 4])','let { normalize-zscore } = import("linear-algebra");\nnormalize-zscore([1, 2, 3, 40, 50])'],seeAlso:["linear-algebra.normalize-minmax","linear-algebra.normalize-robust","linear-algebra.normalize-l1","linear-algebra.normalize-l2","linear-algebra.normalize-log"]},"normalize-robust":{category:"linear-algebra",description:"Normalizes the vector using robust normalization. The result is a vector with median 0 and median absolute deviation 1.",returns:{type:"number"},args:{v:{type:"vector",description:"Vector to normalize."}},variants:[{argumentNames:["v"]}],examples:['let { normalize-robust } = import("linear-algebra");\nnormalize-robust([1, 2, 3])','let { normalize-robust } = import("linear-algebra");\nnormalize-robust([1, 2, -3])','let { normalize-robust } = import("linear-algebra");\nnormalize-robust([1, 2, 3, 4])','let { normalize-robust } = import("linear-algebra");\nnormalize-robust([1, 2, -3, 4])','let { normalize-robust } = import("linear-algebra");\nnormalize-robust([1, 2, 3, 40, 50])'],seeAlso:["linear-algebra.normalize-minmax","linear-algebra.normalize-zscore"]},"normalize-l1":{category:"linear-algebra",description:"Normalizes the vector using L1 normalization. The result is a vector with L1 norm equal to 1.",returns:{type:"number"},args:{v:{type:"vector",description:"Vector to normalize."}},variants:[{argumentNames:["v"]}],examples:['let { normalize-l1 } = import("linear-algebra");\nnormalize-l1([1, 2, 3])','let { normalize-l1 } = import("linear-algebra");\nnormalize-l1([1, 2, -3])','let { normalize-l1 } = import("linear-algebra");\nnormalize-l1([1, 2, 3, 4])','let { normalize-l1 } = import("linear-algebra");\nnormalize-l1([1, 2, -3, 4])','let { normalize-l1 } = import("linear-algebra");\nnormalize-l1([1, 2, 3, 40, 50])'],seeAlso:["linear-algebra.normalize-l2","linear-algebra.normalize-minmax","linear-algebra.manhattan-norm","linear-algebra.normalize-zscore"]},"normalize-l2":{category:"linear-algebra",description:"Normalizes the vector using L2 normalization. The result is a vector with L2 norm equal to 1.",returns:{type:"number"},args:{v:{type:"vector",description:"Vector to normalize."}},variants:[{argumentNames:["v"]}],examples:['let { normalize-l2 } = import("linear-algebra");\nnormalize-l2([1, 2, 3])','let { normalize-l2 } = import("linear-algebra");\nnormalize-l2([1, 2, 3])','let { normalize-l2 } = import("linear-algebra");\nnormalize-l2([1, 2, -3])','let { normalize-l2 } = import("linear-algebra");\nnormalize-l2([1, 2, 3, 4])','let { normalize-l2 } = import("linear-algebra");\nnormalize-l2([1, 2, -3, 4])','let { normalize-l2 } = import("linear-algebra");\nnormalize-l2([1, 2, 3, 40, 50])'],seeAlso:["linear-algebra.normalize-l1","linear-algebra.normalize-minmax","linear-algebra.euclidean-norm","linear-algebra.normalize-zscore"]},"normalize-log":{category:"linear-algebra",description:"Normalizes the vector using natural log normalization. The result is a vector with log-transformed values.",returns:{type:"number"},args:{v:{type:"vector",description:"Vector to normalize."}},variants:[{argumentNames:["v"]}],examples:['let { normalize-log } = import("linear-algebra");\nnormalize-log([1, 2, 3])','let { normalize-log } = import("linear-algebra");\nnormalize-log([1, 2, 3, 4])','let { normalize-log } = import("linear-algebra");\nnormalize-log([1, 2, 3, 40, 50])'],seeAlso:["linear-algebra.normalize-minmax","linear-algebra.normalize-zscore"]},angle:{category:"linear-algebra",description:"Calculates the **angle** between two vectors in radians.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { angle } = import("linear-algebra");\nangle([1, 0], [0, 1])','let { angle } = import("linear-algebra");\nangle([1, 0, 1], [0, 1, 0])'],seeAlso:["linear-algebra.dot","linear-algebra.collinear?","linear-algebra.orthogonal?","linear-algebra.rotate2d","linear-algebra.rotate3d","linear-algebra.parallel?","linear-algebra.cosine-similarity","linear-algebra.to-polar"]},projection:{category:"linear-algebra",description:"Calculates the **projection** of vector `a` onto vector `b`.",returns:{type:"vector"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { projection } = import("linear-algebra");\nprojection([1, 2], [3, 4])','let { projection } = import("linear-algebra");\nprojection([1, 2, 3], [4, 5, 6])'],seeAlso:["linear-algebra.dot","linear-algebra.reflect","linear-algebra.lerp"]},"collinear?":{category:"linear-algebra",description:"Checks if two vectors are **collinear**.",returns:{type:"boolean"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { collinear? } = import("linear-algebra");\ncollinear?([1, 2], [2, 4])','let { collinear? } = import("linear-algebra");\ncollinear?([1, 2], [-2, -4])','let { collinear? } = import("linear-algebra");\ncollinear?([1, 2, 3], [2, 4, 6])'],seeAlso:["linear-algebra.parallel?","linear-algebra.orthogonal?","linear-algebra.angle"]},"parallel?":{category:"linear-algebra",description:"Checks if two vectors are **parallel**.",returns:{type:"boolean"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { parallel? } = import("linear-algebra");\nparallel?([1, 2], [2, 4])','let { parallel? } = import("linear-algebra");\nparallel?([1, 2], [-2, -4])','let { parallel? } = import("linear-algebra");\nparallel?([1, 2, 3], [2, 4, 6])','let { parallel? } = import("linear-algebra");\nparallel?([1, 2], [3, 4])'],seeAlso:["linear-algebra.collinear?","linear-algebra.orthogonal?","linear-algebra.angle"]},"orthogonal?":{category:"linear-algebra",description:"Checks if two vectors are **orthogonal**.",returns:{type:"boolean"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { orthogonal? } = import("linear-algebra");\northogonal?([1, 0], [0, 1])','let { orthogonal? } = import("linear-algebra");\northogonal?([1, 0, 1], [0, 1, 0])','let { orthogonal? } = import("linear-algebra");\northogonal?([1, 2], [2, -1])'],seeAlso:["linear-algebra.collinear?","linear-algebra.parallel?","linear-algebra.dot","matrix.orthogonal?","linear-algebra.angle"]},"cosine-similarity":{category:"linear-algebra",description:"Calculates the **cosine similarity** between two vectors. The result is a value between -1 and 1.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { cosine-similarity } = import("linear-algebra");\ncosine-similarity([1, 2], [3, 4])','let { cosine-similarity } = import("linear-algebra");\ncosine-similarity([1, 2, 3], [4, 5, 6])','let { cosine-similarity } = import("linear-algebra");\ncosine-similarity([1, 0], [0, 1])'],seeAlso:["linear-algebra.dot","linear-algebra.angle","linear-algebra.euclidean-distance"]},"euclidean-distance":{category:"linear-algebra",description:"Calculates the **Euclidean distance** between two vectors. The result is a non-negative number.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { euclidean-distance } = import("linear-algebra");\neuclidean-distance([1, 2], [3, 4])','let { euclidean-distance } = import("linear-algebra");\neuclidean-distance([1, 2, 3], [4, 5, 6])','let { euclidean-distance } = import("linear-algebra");\neuclidean-distance([1, 0], [0, 1])'],seeAlso:["linear-algebra.manhattan-distance","linear-algebra.chebyshev-distance","linear-algebra.minkowski-distance","linear-algebra.euclidean-norm","linear-algebra.cosine-similarity","linear-algebra.hamming-distance"]},"euclidean-norm":{category:"linear-algebra",description:"Calculates the **Euclidean norm** (L2 norm) of a vector. The result is a non-negative number.",returns:{type:"number"},args:{v:{type:"vector",description:"Vector to calculate the norm for."}},variants:[{argumentNames:["v"]}],examples:['let { euclidean-norm } = import("linear-algebra");\neuclidean-norm([1, 2])','let { euclidean-norm } = import("linear-algebra");\neuclidean-norm([3, 4])','let { euclidean-norm } = import("linear-algebra");\neuclidean-norm([1, 2, 3])'],seeAlso:["linear-algebra.manhattan-norm","linear-algebra.chebyshev-norm","linear-algebra.minkowski-norm","linear-algebra.euclidean-distance","linear-algebra.normalize-l2","linear-algebra.hamming-norm"]},"manhattan-distance":{category:"linear-algebra",description:"Calculates the **Manhattan distance** between two vectors. The result is a non-negative number.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { manhattan-distance } = import("linear-algebra");\nmanhattan-distance([1, 2], [3, 4])','let { manhattan-distance } = import("linear-algebra");\nmanhattan-distance([1, 2, 3], [4, 5, 6])','let { manhattan-distance } = import("linear-algebra");\nmanhattan-distance([1, 0], [0, 1])'],seeAlso:["linear-algebra.euclidean-distance","linear-algebra.chebyshev-distance","linear-algebra.minkowski-distance","linear-algebra.manhattan-norm","linear-algebra.hamming-distance"]},"manhattan-norm":{category:"linear-algebra",description:"Calculates the **Manhattan norm** (L1 norm) of a vector. The result is a non-negative number.",returns:{type:"number"},args:{v:{type:"vector",description:"Vector to calculate the norm for."}},variants:[{argumentNames:["v"]}],examples:['let { manhattan-norm } = import("linear-algebra");\nmanhattan-norm([1, 2])','let { manhattan-norm } = import("linear-algebra");\nmanhattan-norm([3, 4])','let { manhattan-norm } = import("linear-algebra");\nmanhattan-norm([1, 2, 3])'],seeAlso:["linear-algebra.euclidean-norm","linear-algebra.chebyshev-norm","linear-algebra.minkowski-norm","linear-algebra.manhattan-distance","linear-algebra.normalize-l1","linear-algebra.hamming-norm"]},"hamming-distance":{category:"linear-algebra",description:"Calculates the **Hamming distance** between two vectors. The result is a non-negative integer.",returns:{type:"integer"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { hamming-distance } = import("linear-algebra");\nhamming-distance([1, 2], [3, 4])','let { hamming-distance } = import("linear-algebra");\nhamming-distance([1, 2, 3], [4, 5, 6])','let { hamming-distance } = import("linear-algebra");\nhamming-distance([1, 0], [0, 1])'],seeAlso:["linear-algebra.euclidean-distance","linear-algebra.manhattan-distance","linear-algebra.hamming-norm"]},"hamming-norm":{category:"linear-algebra",description:"Calculates the **Hamming norm** of a vector. The result is a non-negative integer.",returns:{type:"integer"},args:{v:{type:"vector",description:"Vector to calculate the norm for."}},variants:[{argumentNames:["v"]}],examples:['let { hamming-norm } = import("linear-algebra");\nhamming-norm([1, 2])','let { hamming-norm } = import("linear-algebra");\nhamming-norm([3, 4])','let { hamming-norm } = import("linear-algebra");\nhamming-norm([1, 2, 3])'],seeAlso:["linear-algebra.euclidean-norm","linear-algebra.manhattan-norm","linear-algebra.hamming-distance"]},"chebyshev-distance":{category:"linear-algebra",description:"Calculates the **Chebyshev distance** between two vectors. The result is a non-negative number.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { chebyshev-distance } = import("linear-algebra");\nchebyshev-distance([1, 2], [3, 4])','let { chebyshev-distance } = import("linear-algebra");\nchebyshev-distance([1, 2, 3], [4, 5, 6])','let { chebyshev-distance } = import("linear-algebra");\nchebyshev-distance([1, 0], [0, 1])'],seeAlso:["linear-algebra.euclidean-distance","linear-algebra.manhattan-distance","linear-algebra.minkowski-distance","linear-algebra.chebyshev-norm"]},"chebyshev-norm":{category:"linear-algebra",description:"Calculates the **Chebyshev norm** of a vector. The result is a non-negative number.",returns:{type:"number"},args:{v:{type:"vector",description:"Vector to calculate the norm for."}},variants:[{argumentNames:["v"]}],examples:['let { chebyshev-norm } = import("linear-algebra");\nchebyshev-norm([1, 2])','let { chebyshev-norm } = import("linear-algebra");\nchebyshev-norm([3, 4])','let { chebyshev-norm } = import("linear-algebra");\nchebyshev-norm([1, 2, 3])'],seeAlso:["linear-algebra.euclidean-norm","linear-algebra.manhattan-norm","linear-algebra.minkowski-norm","linear-algebra.chebyshev-distance"]},"minkowski-distance":{category:"linear-algebra",description:"Calculates the **Minkowski distance** between two vectors. The result is a non-negative number.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"},p:{type:"number",description:"Order of the norm (p)."}},variants:[{argumentNames:["a","b","p"]}],examples:['let { minkowski-distance } = import("linear-algebra");\nminkowski-distance([1, 2], [3, 4], 2)','let { minkowski-distance } = import("linear-algebra");\nminkowski-distance([1, 2, 3], [4, 5, 6], 3)','let { minkowski-distance } = import("linear-algebra");\nminkowski-distance([1, 0], [0, 1], 1)'],seeAlso:["linear-algebra.euclidean-distance","linear-algebra.manhattan-distance","linear-algebra.chebyshev-distance","linear-algebra.minkowski-norm"]},"minkowski-norm":{category:"linear-algebra",description:"Calculates the **Minkowski norm** of a vector. The result is a non-negative number.",returns:{type:"number"},args:{a:{type:"vector",description:"Vector to calculate the norm for."},b:{type:"number",description:"Order of the norm (p)."}},variants:[{argumentNames:["a","b"]}],examples:['let { minkowski-norm } = import("linear-algebra");\nminkowski-norm([1, 2], 2)','let { minkowski-norm } = import("linear-algebra");\nminkowski-norm([3, 4], 3)','let { minkowski-norm } = import("linear-algebra");\nminkowski-norm([1, 2, 3], 4)'],seeAlso:["linear-algebra.euclidean-norm","linear-algebra.manhattan-norm","linear-algebra.chebyshev-norm","linear-algebra.minkowski-distance"]},cov:{category:"linear-algebra",description:"Calculates the **covariance** between two vectors. The result is a number.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { cov } = import("linear-algebra");\ncov([1, 2], [3, 4])','let { cov } = import("linear-algebra");\ncov([1, 2, 3], [4, 5, 6])','let { cov } = import("linear-algebra");\ncov([1, 0], [0, 1])'],seeAlso:["linear-algebra.corr","linear-algebra.pearson-corr","vector.variance"]},corr:{category:"linear-algebra",description:"Calculates the **correlation** between two vectors. The result is a number between -1 and 1.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { corr } = import("linear-algebra");\ncorr([1, 2], [3, 4])','let { corr } = import("linear-algebra");\ncorr([1, 2, 3], [4, 5, 6])','let { corr } = import("linear-algebra");\ncorr([1, 0], [0, 1])'],seeAlso:["linear-algebra.cov","linear-algebra.pearson-corr","linear-algebra.spearman-corr","linear-algebra.kendall-tau","linear-algebra.autocorrelation","linear-algebra.cross-correlation"]},"spearman-corr":{category:"linear-algebra",description:"Calculates the **Spearman rank correlation** between two vectors. The result is a number between -1 and 1.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { spearman-corr } = import("linear-algebra");\nspearman-corr([1, 2], [3, 4])','let { spearman-corr } = import("linear-algebra");\nspearman-corr([1, 2, 3], [4, 5, 6])','let { spearman-corr } = import("linear-algebra");\nspearman-corr([1, 0], [0, 1])'],seeAlso:["linear-algebra.pearson-corr","linear-algebra.kendall-tau","linear-algebra.corr"]},"pearson-corr":{category:"linear-algebra",description:"Calculates the **Pearson correlation** between two vectors. The result is a number between -1 and 1.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { pearson-corr } = import("linear-algebra");\npearson-corr([1, 2], [3, 4])','let { pearson-corr } = import("linear-algebra");\npearson-corr([1, 2, 3], [4, 5, 6])','let { pearson-corr } = import("linear-algebra");\npearson-corr([1, 0], [0, 1])'],seeAlso:["linear-algebra.spearman-corr","linear-algebra.kendall-tau","linear-algebra.corr","linear-algebra.cov"]},"kendall-tau":{category:"linear-algebra",description:"Calculates the **Kendall Tau** rank correlation coefficient between two vectors. The result is a number between -1 and 1.",returns:{type:"number"},args:{a:{type:"vector"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { kendall-tau } = import("linear-algebra");\nkendall-tau([1, 2], [3, 4])','let { kendall-tau } = import("linear-algebra");\nkendall-tau([1, 2, 3], [4, 5, 6])','let { kendall-tau } = import("linear-algebra");\nkendall-tau([1, 0], [0, 1])'],seeAlso:["linear-algebra.spearman-corr","linear-algebra.pearson-corr","linear-algebra.corr"]},autocorrelation:{category:"linear-algebra",description:"Calculates the **autocorrelation** of a vector. The result is a vector of autocorrelation coefficients.",returns:{type:"vector"},args:{a:{type:"vector",description:"Vector to calculate the autocorrelation for."},b:{type:"integer",description:"Lag value for the autocorrelation."}},variants:[{argumentNames:["a","b"]}],examples:['let { autocorrelation } = import("linear-algebra");\nautocorrelation([1, 2, 3], -2)','let { autocorrelation } = import("linear-algebra");\nautocorrelation([1, 2, 3], -1)','let { autocorrelation } = import("linear-algebra");\nautocorrelation([1, 2, 3], 0)','let { autocorrelation } = import("linear-algebra");\nautocorrelation([1, 2, 3], 1)','let { autocorrelation } = import("linear-algebra");\nautocorrelation([1, 2, 3], 2)'],seeAlso:["linear-algebra.cross-correlation","linear-algebra.corr"]},"cross-correlation":{category:"linear-algebra",description:"Calculates the **cross-correlation** between two vectors. The result is a vector of cross-correlation coefficients.",returns:{type:"vector"},args:{a:{type:"vector"},b:{type:"vector"},lag:{type:"integer",description:"Lag value for the cross-correlation."}},variants:[{argumentNames:["a","b","lag"]}],examples:['let { cross-correlation } = import("linear-algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], -2)','let { cross-correlation } = import("linear-algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], -1)','let { cross-correlation } = import("linear-algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], 0)','let { cross-correlation } = import("linear-algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], 1)','let { cross-correlation } = import("linear-algebra");\ncross-correlation([1, 2, 3], [4, 5, 6], 2)'],seeAlso:["linear-algebra.autocorrelation","linear-algebra.corr"]},rref:{category:"linear-algebra",description:"Calculates the **Reduced Row Echelon Form** (RREF) of a matrix.",returns:{type:"matrix"},args:{m:{type:"matrix",description:"Matrix to calculate the RREF for."}},variants:[{argumentNames:["m"]}],examples:['let { rref } = import("linear-algebra");\nrref([[1, 2], [3, 4]])','let { rref } = import("linear-algebra");\nrref([[1, 2, 3], [4, 5, 6], [7, 8, 9]])','let { rref } = import("linear-algebra");\nrref([[1, 2, 3], [7, 8, 9], [4, 5, 7]])'],seeAlso:["linear-algebra.solve","matrix.rank"]},solve:{category:"linear-algebra",description:"Solves a system of linear equations represented by a matrix and a vector.",returns:{type:"vector"},args:{a:{type:"matrix"},b:{type:"vector"}},variants:[{argumentNames:["a","b"]}],examples:['let { solve } = import("linear-algebra");\nsolve([\n  [2, 1, -1, 1], \n  [4, 5, -3, 2], \n  [6, -2, 5, -3], \n  [8, 3, 2, 4]\n], [5, 10, 2, 17])','let { solve } = import("linear-algebra"); solve([[2, 0, 0], [3, 1, 0], [4, 5, 6]], [4, 5, 38])','let { solve } = import("linear-algebra"); solve([[2, 3], [1, -1]], [8, 2])'],seeAlso:["linear-algebra.rref","matrix.inv"]},"to-polar":{category:"linear-algebra",description:"Converts a 2D vector to polar coordinates.",returns:{type:"vector"},args:{vector:{type:"vector",description:"2D Vector to convert."}},variants:[{argumentNames:["vector"]}],examples:['let { to-polar } = import("linear-algebra");\nto-polar([1, 2])','let { to-polar } = import("linear-algebra");\nto-polar([3, 4])'],seeAlso:["linear-algebra.from-polar","linear-algebra.angle"]},"from-polar":{category:"linear-algebra",description:"Converts polar coordinates to a 2D vector.",returns:{type:"vector"},args:{polar:{type:"vector",description:"Polar coordinates to convert."}},variants:[{argumentNames:["polar"]}],examples:['let { from-polar } = import("linear-algebra");\nfrom-polar([1, PI / 4])','let { from-polar } = import("linear-algebra");\nfrom-polar([1, 0])','let { from-polar } = import("linear-algebra");\nfrom-polar([1, -PI / 2])'],seeAlso:["linear-algebra.to-polar"]}};function gaussJordanElimination(e){const t=e.map(e=>[...e]),r=t.length,n=t[0].length;let o=0,a=0;for(let e=0;e<n;e++){let i=-1;for(let n=a;n<r;n++)if(!approxZero(t[n][e])){i=n;break}if(-1===i)continue;o+=1,i!==a&&([t[i],t[a]]=[t[a],t[i]]);const s=t[a][e];for(let r=e;r<n;r++)t[a][r]/=s;for(let o=0;o<r;o++)if(o!==a&&!approxZero(t[o][e])){const r=t[o][e];for(let i=e;i<n;i++)t[o][i]-=r*t[a][i]}if(a++,a===r)break}return[t,o]}function solve(e,t){const r=e.length,n=e.map((e,r)=>[...e,t[r]]),[o]=gaussJordanElimination(n);for(let e=0;e<r;e+=1)if(approxZero(o[e][e]))return null;const a=Array.from({length:r},()=>0);for(let e=r-1;e>=0;e--){let t=0;for(let n=e+1;n<r;n++)t+=o[e][n]*a[n];a[e]=(o[e][r]-t)/o[e][e]}return a}function areVectorsCollinear(e,t){const r=e=>e.every(e=>approxZero(e));if(r(e)||r(t))return!0;let n=0;for(;n<e.length&&approxZero(e[n]);)n++;const o=t[n]/e[n];for(let r=0;r<e.length;r++)if(!approxZero(e[r])||!approxZero(t[r])){if(approxZero(e[r]))return!1;if(!approxEqual(t[r]/e[r],o))return!1}return!0}function areVectorsParallel(e,t){if(!areVectorsCollinear(e,t))return!1;for(let r=0;r<e.length;r++)if(!approxZero(e[r])&&!approxZero(t[r]))return Math.sign(e[r])===Math.sign(t[r]);return!0}function isZeroVector(e){return e.every(e=>approxZero(e))}function pearsonCorr(e,t){const r=calcMean(e),n=calcMean(t);let o=0,a=0,i=0;for(let s=0;s<e.length;s++){const c=e[s]-r,l=t[s]-n;o+=c*l,a+=c*c,i+=l*l}if(0===a||0===i)throw new Error("Cannot calculate Pearson correlation coefficient: one of the vectors has zero variance.");return o/(Math.sqrt(a)*Math.sqrt(i))}function calcFractionalRanks(e){const t=[...e.keys()].sort((t,r)=>e[t]-e[r]),r=Array.from({length:e.length}).fill(0);let n=1,o=0;for(;o<t.length;){const a=e[t[o]];let i=o;for(;i<t.length&&e[t[i]]===a;)i++;const s=n+(i-o-1)/2;for(let e=o;e<i;e++)r[t[e]]=s;n+=i-o,o=i}return r}function kendallTau(e,t,r=1e-10){let n=0,o=0,a=0,i=0;for(let s=0;s<e.length;s++)for(let c=s+1;c<e.length;c++){const l=e[s]-e[c],u=t[s]-t[c],m=Math.abs(l)<r,p=Math.abs(u)<r;m&&p||(m?a+=1:p?i+=1:l*u>0?n+=1:o+=1)}const s=n+o+a,c=n+o+i;if(0===s||0===c)throw new Error("Not enough data to calculate Kendall's Tau");return(n-o)/Math.sqrt(s*c)}function calcCovariance(e,t){const r=calcMean(e),n=calcMean(t);let o=0;for(let a=0;a<e.length;a++)o+=(e[a]-r)*(t[a]-n);return o/e.length}function calcCorrelation(e,t){const r=calcMean(e),n=calcMean(t),o=calcStdDev(e,r),a=calcStdDev(t,n);if(0===o||0===a)return 0===o&&0===a&&r===n?1:0;return calcCovariance(e,t)/(o*a)}function extractOverlappingSegments(e,t,r){const n=Math.abs(r),o=e.length-n;let a=[],i=[];return r>=0?(a=e.slice(0,o),i=t.slice(r,r+o)):(a=e.slice(n),i=t.slice(0,o)),[a,i]}function getUnit(e,t){if(0===e.length)return e;const r=Math.sqrt(e.reduce((e,t)=>e+t**2,0));if(approxZero(r))throw new LitsError("The vector must not be zero",t);return e.map(e=>e/r)}function dot(e,t){return e.reduce((e,r,n)=>e+r*t[n],0)}function subtract(e,t){return e.map((e,r)=>e-t[r])}function scale(e,t){return e.map(e=>e*t)}function length(e){return Math.sqrt(e.reduce((e,t)=>e+t**2,0))}const linearAlgebraNormalExpression={rotate2d:{evaluate:([e,t],r)=>{if(assert2dVector(e,r),isZeroVector(e))return e;assertNumber(t,r,{finite:!0});const n=Math.cos(t),o=Math.sin(t);return[e[0]*n-e[1]*o,e[0]*o+e[1]*n]},arity:toFixedArity(2)},rotate3d:{evaluate:([e,t,r],n)=>{if(assert3dVector(e,n),isZeroVector(e))return e;if(assertNumber(r,n,{finite:!0}),assert3dVector(t,n),isZeroVector(t))throw new LitsError("Rotation axis must not be zero",n);const o=Math.cos(r),a=Math.sin(r),[i,s,c]=getUnit(t,n),l=e[0]*i+e[1]*s+e[2]*c;return[l*i*(1-o)+e[0]*o+(-c*e[1]+s*e[2])*a,l*s*(1-o)+e[1]*o+(c*e[0]-i*e[2])*a,l*c*(1-o)+e[2]*o+(-s*e[0]+i*e[1])*a]},arity:toFixedArity(3)},reflect:{evaluate:([e,t],r)=>{if(assertVector(e,r),assertVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);if(isZeroVector(t))throw new LitsError("Reflection normal must not be zero",r);if(isZeroVector(e))return e;const n=getUnit(t,r);return subtract(e,scale(n,2*dot(e,n)))},arity:toFixedArity(2)},refract:{evaluate:([e,t,r],n)=>{if(assertVector(e,n),assertVector(t,n),assertNumber(r,n,{finite:!0,positive:!0}),e.length!==t.length)throw new LitsError("Vectors must be of the same length",n);if(isZeroVector(t))throw new LitsError("Refraction normal must not be zero",n);if(isZeroVector(e))return e;const o=getUnit(e,n),a=getUnit(t,n),i=dot(o,a),s=1-r*r*(1-i*i);if(s<0)return e;return subtract(scale(o,r),scale(a,r*i+Math.sqrt(s)))},arity:toFixedArity(3)},lerp:{evaluate:([e,t,r],n)=>{if(assertVector(e,n),assertVector(t,n),assertNumber(r,n,{finite:!0}),e.length!==t.length)throw new LitsError("Vectors must be of the same length",n);return e.map((e,n)=>e+(t[n]-e)*r)},arity:toFixedArity(3)},dot:{evaluate:([e,t],r)=>{if(assertVector(e,r),assertVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return dot(e,t)},arity:toFixedArity(2)},cross:{evaluate:([e,t],r)=>{if(assertVector(e,r),assertVector(t,r),3!==e.length||3!==t.length)throw new LitsError("Cross product is only defined for 3D vectors",r);return[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]]},arity:toFixedArity(2)},"normalize-minmax":{evaluate:([e],t)=>{if(assertVector(e,t),0===e.length)return[];const r=e.reduce((e,t)=>t<e?t:e,e[0]),n=e.reduce((e,t)=>t>e?t:e,e[0]);return r===n?e.map(()=>0):e.map(e=>(e-r)/(n-r))},arity:toFixedArity(1)},"normalize-robust":{evaluate:([e],t)=>{if(assertVector(e,t),0===e.length)return[];const r=calcMedian(e),n=calcMedad(e);return 0===n?e.map(e=>e-r):e.map(e=>(e-r)/n)},arity:toFixedArity(1)},"normalize-zscore":{evaluate:([e],t)=>{assertVector(e,t);const r=calcMean(e),n=calcStdDev(e);return 0===n?e.map(()=>0):e.map(e=>(e-r)/n)},arity:toFixedArity(1)},"normalize-l1":{evaluate:([e],t)=>{if(assertVector(e,t),0===e.length)return[];const r=e.reduce((e,t)=>e+Math.abs(t),0);return 0===r?e.map(()=>0):e.map(e=>e/r)},arity:toFixedArity(1)},"normalize-l2":{evaluate:([e],t)=>(assertVector(e,t),getUnit(e,t)),arity:toFixedArity(1)},"normalize-log":{evaluate:([e],t)=>{if(assertVector(e,t),0===e.length)return[];const r=Math.min(...e);if(r<=0)throw new LitsError("Log normalization requires all values to be positive",t);return e.map(e=>Math.log(e/r))},arity:toFixedArity(1)},angle:{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),isZeroVector(e)||isZeroVector(t))throw new LitsError("Cannot calculate angle with zero-length vector",r);if(e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);const n=e.reduce((e,r,n)=>e+r*t[n],0),o=Math.sqrt(e.reduce((e,t)=>e+t*t,0)),a=Math.sqrt(t.reduce((e,t)=>e+t*t,0));return Math.acos(n/(o*a))},arity:toFixedArity(2)},projection:{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),isZeroVector(t))throw new LitsError("Cannot project onto zero-length vector",r);if(e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);const n=e.reduce((e,r,n)=>e+r*t[n],0),o=Math.sqrt(t.reduce((e,t)=>e+t*t,0));return t.map(e=>n/o**2*e)},arity:toFixedArity(2)},"orthogonal?":{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return 0===e.reduce((e,r,n)=>e+r*t[n],0)},arity:toFixedArity(2)},"parallel?":{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return areVectorsParallel(e,t)},arity:toFixedArity(2)},"collinear?":{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return areVectorsCollinear(e,t)},arity:toFixedArity(2)},"cosine-similarity":{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),isZeroVector(e)||isZeroVector(t))throw new LitsError("Cannot calculate cosine similarity with zero-length vector",r);if(e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return e.reduce((e,r,n)=>e+r*t[n],0)/(Math.sqrt(e.reduce((e,t)=>e+t*t,0))*Math.sqrt(t.reduce((e,t)=>e+t*t,0)))},arity:toFixedArity(2)},"euclidean-distance":{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return Math.sqrt(e.reduce((e,r,n)=>e+(r-t[n])**2,0))},arity:toFixedArity(2)},"euclidean-norm":{evaluate:([e],t)=>(assertNonEmptyVector(e,t),length(e)),arity:toFixedArity(1)},"manhattan-distance":{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return e.reduce((e,r,n)=>e+Math.abs(r-t[n]),0)},arity:toFixedArity(2)},"manhattan-norm":{evaluate:([e],t)=>(assertNonEmptyVector(e,t),e.reduce((e,t)=>e+Math.abs(t),0)),arity:toFixedArity(1)},"hamming-distance":{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return e.reduce((e,r,n)=>e+(r!==t[n]?1:0),0)},arity:toFixedArity(2)},"hamming-norm":{evaluate:([e],t)=>(assertNonEmptyVector(e,t),e.reduce((e,t)=>e+(0!==t?1:0),0)),arity:toFixedArity(1)},"chebyshev-distance":{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return Math.max(...e.map((e,r)=>Math.abs(e-t[r])))},arity:toFixedArity(2)},"chebyshev-norm":{evaluate:([e],t)=>(assertNonEmptyVector(e,t),Math.max(...e.map(e=>Math.abs(e)))),arity:toFixedArity(1)},"minkowski-distance":{evaluate:([e,t,r],n)=>{if(assertNonEmptyVector(e,n),assertNonEmptyVector(t,n),assertNumber(r,n,{finite:!0,positive:!0}),e.length!==t.length)throw new LitsError("Vectors must be of the same length",n);return e.reduce((e,n,o)=>e+Math.abs(n-t[o])**r,0)**(1/r)},arity:toFixedArity(3)},"minkowski-norm":{evaluate:([e,t],r)=>(assertNonEmptyVector(e,r),assertNumber(t,r,{finite:!0,positive:!0}),e.reduce((e,r)=>e+Math.abs(r)**t,0)**(1/t)),arity:toFixedArity(2)},cov:{evaluate:([e,t],r)=>{if(assertNonEmptyVector(e,r),assertNonEmptyVector(t,r),e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);return 1===e.length?0:calcCovariance(e,t)},arity:toFixedArity(2)},corr:{evaluate:([e,t],r)=>{if(assertVector(e,r),assertVector(t,r),e.length<=1)throw new LitsError("Vectors must have at least 2 elements for corr",r);if(e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);const n=calcMean(e),o=calcMean(t);return e.reduce((e,r,a)=>e+(r-n)*(t[a]-o),0)/Math.sqrt(e.reduce((e,t)=>e+(t-n)**2,0)*t.reduce((e,t)=>e+(t-o)**2,0))},arity:toFixedArity(2)},"spearman-corr":{evaluate:([e,t],r)=>{if(assertVector(e,r),assertVector(t,r),e.length<=1)throw new LitsError("Vectors must have at least 2 elements for corr",r);if(e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);const n=calcFractionalRanks(e),o=calcFractionalRanks(t);try{return pearsonCorr(n,o)}catch(e){throw new LitsError(e,r)}},arity:toFixedArity(2)},"pearson-corr":{evaluate:([e,t],r)=>{if(assertVector(e,r),assertVector(t,r),e.length<=1)throw new LitsError("Vectors must have at least 2 elements for pearson-corr",r);if(e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);try{return pearsonCorr(e,t)}catch(e){throw new LitsError(e,r)}},arity:toFixedArity(2)},"kendall-tau":{evaluate:([e,t],r)=>{if(assertVector(e,r),assertVector(t,r),e.length<2)throw new LitsError("Vectors must have at least 2 elements for kendall-tau",r);if(e.length!==t.length)throw new LitsError("Vectors must be of the same length",r);try{return kendallTau(e,t)}catch(e){throw new LitsError(e,r)}},arity:toFixedArity(2)},autocorrelation:{evaluate:([e,t],r)=>{if(assertVector(e,r),e.length<2)throw new LitsError("Vector must have at least 2 elements for autocorrelation",r);if(assertNumber(t,r,{integer:!0,lt:e.length,gt:-e.length}),0===t)return 1;const n=Math.abs(t),o=calcMean(e);let a=0;const i=e.length;for(let r=0;r<i-n;r++){const i=t<0?r:r+n;a+=(e[t<0?r+n:r]-o)*(e[i]-o)}let s=0;for(let t=0;t<i;t++)s+=(e[t]-o)**2;return 0===s?0:a/s},arity:toFixedArity(2)},"cross-correlation":{evaluate:([e,t,r],n)=>{if(assertVector(e,n),assertVector(t,n),e.length<2)throw new LitsError("Vectors must have at least 2 elements",n);if(e.length!==t.length)throw new LitsError("Vectors must be of the same length",n);if(assertNumber(r,n,{integer:!0,lt:e.length,gt:-e.length}),0===r&&e.length===t.length&&e.every((e,r)=>e===t[r]))return 1;const[o,a]=extractOverlappingSegments(e,t,r);return calcCorrelation(o,a)},arity:toFixedArity(3)},rref:{evaluate:([e],t)=>{assertMatrix(e,t);const[r]=gaussJordanElimination(e);return r},arity:toFixedArity(1)},solve:{evaluate:([e,t],r)=>{if(assertSquareMatrix(e,r),assertVector(t,r),e.length!==t.length)throw new LitsError(`The number of rows in the matrix must be equal to the length of the vector, but got ${e.length} and ${t.length}`,r);return solve(e,t)},arity:toFixedArity(2)},"to-polar":{evaluate:([e],t)=>{if(assert2dVector(e,t),isZeroVector(e))return[0,0];return[Math.sqrt(e[0]**2+e[1]**2),Math.atan2(e[1],e[0])]},arity:toFixedArity(1)},"from-polar":{evaluate:([e],t)=>{assert2dVector(e,t);const[r,n]=e;return 0===r?[0,0]:[r*Math.cos(n),r*Math.sin(n)]},arity:toFixedArity(1)}};for(const[e,t]of Object.entries(moduleDocs$2))linearAlgebraNormalExpression[e]&&(linearAlgebraNormalExpression[e].docs=t);const linearAlgebraModule={name:"linear-algebra",functions:linearAlgebraNormalExpression},moduleDocs$1={mul:{category:"matrix",description:"Multiplies two `matrices` using standard `matrix` multiplication based on **dot products** of rows and columns.",returns:{type:"matrix"},args:{a:{type:"matrix"},b:{type:"matrix"}},variants:[{argumentNames:["a","b"]}],examples:['let { mul } = import("matrix");\nmul([[1, 2], [3, 4]], [[5, 6], [7, 8]])','let { mul } = import("matrix");\nmul([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]])'],seeAlso:["matrix.det","matrix.inv"]},det:{category:"matrix",description:"Calculates the **determinant** of a square matrix.",returns:{type:"number"},args:{m:{type:"matrix",description:"The `matrix` to calculate the determinant of."}},variants:[{argumentNames:["m"]}],examples:['let { det } = import("matrix");\ndet([[1, 2], [3, 4]])','let { det } = import("matrix");\ndet([[1, 2, 3], [4, 5, 6], [7, 8, 9]])'],seeAlso:["matrix.inv","matrix.cofactor","matrix.adj","matrix.trace","matrix.rank","matrix.invertible?","matrix.mul","matrix.minor"]},inv:{category:"matrix",description:"Calculates the **inverse** of a square matrix.",returns:{type:"matrix"},args:{m:{type:"matrix",description:"The `matrix` to calculate the inverse of."}},variants:[{argumentNames:["m"]}],examples:['let { inv } = import("matrix");\ninv([[1, 2], [3, 4]])','let { inv } = import("matrix");\ninv([[1, 2, 3], [4, 5, 7], [7, 8, 10]])'],seeAlso:["matrix.det","matrix.adj","matrix.invertible?","linear-algebra.solve","matrix.mul","matrix.orthogonal?"]},adj:{category:"matrix",description:"Calculates the **adjugate** of a square matrix.",returns:{type:"matrix"},args:{m:{type:"matrix",description:"The `matrix` to calculate the adjugate of."}},variants:[{argumentNames:["m"]}],examples:['let { adj } = import("matrix");\nadj([[1, 2], [3, 4]])','let { adj } = import("matrix");\nadj([[1, 2, 3], [4, 5, 6], [7, 8, 9]])','let { adj } = import("matrix");\nadj([[1, 2, 3], [7, 8, 9], [4, 5, 6]])'],seeAlso:["matrix.cofactor","matrix.det","matrix.inv"]},cofactor:{category:"matrix",description:"Calculates the **cofactor** of a square matrix.",returns:{type:"matrix"},args:{m:{type:"matrix",description:"The `matrix` to calculate the cofactor of."}},variants:[{argumentNames:["m"]}],examples:['let { cofactor } = import("matrix");\ncofactor([[1, 2], [3, 4]])','let { cofactor } = import("matrix");\ncofactor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])','let { cofactor } = import("matrix");\ncofactor([[1, 2, 3], [7, 8, 9], [4, 5, 6]])'],seeAlso:["matrix.adj","matrix.minor","matrix.det"]},minor:{category:"matrix",description:"Calculates the **minor** of a square matrix.",returns:{type:"matrix"},args:{m:{type:"matrix",description:"The `matrix` to calculate the minor of."},row:{type:"integer",description:"The row index of the element to calculate the minor for."},col:{type:"integer",description:"The column index of the element to calculate the minor for."}},variants:[{argumentNames:["m","row","col"]}],examples:['let { minor } = import("matrix");\nminor([[1, 2], [3, 4]], 0, 1)','let { minor } = import("matrix");\nminor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1, 1)'],seeAlso:["matrix.cofactor","matrix.det"]},trace:{category:"matrix",description:"Calculates the **trace** of a square matrix.",returns:{type:"number"},args:{m:{type:"matrix",description:"The `matrix` to calculate the trace of."}},variants:[{argumentNames:["m"]}],examples:['let { trace } = import("matrix");\ntrace([[1, 2], [3, 4]])','let { trace } = import("matrix");\ntrace([[1, 2, 3], [4, 5, 6], [7, 8, 9]])'],seeAlso:["matrix.det","matrix.diagonal?"]},"symmetric?":{category:"matrix",description:"Checks if a `matrix` is **symmetric**.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for symmetry."}},variants:[{argumentNames:["m"]}],examples:['let { symmetric? } = import("matrix");\nsymmetric?([[1, 2], [2, 1]])','let { symmetric? } = import("matrix");\nsymmetric?([[1, 2, 3], [2, 1, 4], [3, 4, 1]])'],seeAlso:["matrix.orthogonal?","matrix.diagonal?","matrix.square?","matrix.hilbert"]},"triangular?":{category:"matrix",description:"Checks if a `matrix` is **triangular**.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for triangularity."}},variants:[{argumentNames:["m"]}],examples:['let { triangular? } = import("matrix");\ntriangular?([[2, 0], [0, 1]])','let { triangular? } = import("matrix");\ntriangular?([[1, 2, 3], [0, 4, 5], [0, 0, 6]])'],seeAlso:["matrix.upper-triangular?","matrix.lower-triangular?","matrix.diagonal?","matrix.banded?"]},"upper-triangular?":{category:"matrix",description:"Checks if a `matrix` is **upper triangular**.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for upper triangularity."}},variants:[{argumentNames:["m"]}],examples:['let { upper-triangular? } = import("matrix");\nupper-triangular?([[1, 2], [0, 3]])','let { upper-triangular? } = import("matrix");\nupper-triangular?([[1, 2, 3], [0, 4, 5], [0, 0, 6]])'],seeAlso:["matrix.lower-triangular?","matrix.triangular?","matrix.diagonal?"]},"lower-triangular?":{category:"matrix",description:"Checks if a `matrix` is **lower triangular**.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for lower triangularity."}},variants:[{argumentNames:["m"]}],examples:['let { lower-triangular? } = import("matrix");\nlower-triangular?([[1, 0], [2, 3]])','let { lower-triangular? } = import("matrix");\nlower-triangular?([[1, 0, 0], [2, 3, 0], [4, 5, 6]])'],seeAlso:["matrix.upper-triangular?","matrix.triangular?","matrix.diagonal?"]},"diagonal?":{category:"matrix",description:"Checks if a `matrix` is **diagonal**.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for diagonal property."}},variants:[{argumentNames:["m"]}],examples:['let { diagonal? } = import("matrix");\ndiagonal?([[1, 0], [0, 2]])','let { diagonal? } = import("matrix");\ndiagonal?([[1, 0, 0], [0, 2, 0], [0, 0, 3]])','let { diagonal? } = import("matrix");\ndiagonal?([[1, 0, 0], [2, 2, 2], [0, 0, 3]])'],seeAlso:["matrix.identity?","matrix.symmetric?","matrix.triangular?","matrix.trace","matrix.upper-triangular?","matrix.lower-triangular?","matrix.band","matrix.banded?"]},"square?":{category:"matrix",description:"Checks if a `matrix` is **square**.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for square property."}},variants:[{argumentNames:["m"]}],examples:['let { square? } = import("matrix");\nsquare?([[1, 2], [3, 4]])','let { square? } = import("matrix");\nsquare?([[1, 2, 3], [4, 5, 6], [7, 8, 9]])','let { square? } = import("matrix");\nsquare?([[1, 2, 3], [4, 5, 6]])'],seeAlso:["matrix.symmetric?","matrix.identity?","matrix.invertible?"]},"orthogonal?":{category:"matrix",description:"Checks if a `matrix` is **orthogonal**.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for **orthogonality**."}},variants:[{argumentNames:["m"]}],examples:['let { orthogonal? } = import("matrix");\northogonal?([[1, 0], [0, 1]])','let { orthogonal? } = import("matrix");\northogonal?([[1, 0], [0, -1]])','let { orthogonal? } = import("matrix");\northogonal?([[1, 2], [3, 4]])'],seeAlso:["matrix.symmetric?","matrix.inv","matrix.identity?","linear-algebra.orthogonal?"]},"identity?":{category:"matrix",description:"Checks if a `matrix` is an **identity matrix**.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for identity property."}},variants:[{argumentNames:["m"]}],examples:['let { identity? } = import("matrix");\nidentity?([[1, 0], [0, 1]])','let { identity? } = import("matrix");\nidentity?([[1, 0, 0], [0, 1, 0], [0, 0, 1]])','let { identity? } = import("matrix");\nidentity?([[1, 0, 0], [0, 1, 0], [0, 0, 0]])'],seeAlso:["matrix.diagonal?","matrix.square?","matrix.orthogonal?"]},"invertible?":{category:"matrix",description:"Checks if a `matrix` is **invertible**.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for invertibility."}},variants:[{argumentNames:["m"]}],examples:['let { invertible? } = import("matrix");\ninvertible?([[1, 2], [3, 4]])','let { invertible? } = import("matrix");\ninvertible?([[1, 2, 3], [4, 5, 6], [7, 8, 9]])','let { invertible? } = import("matrix");\ninvertible?([[1, 2], [2, 4]])'],seeAlso:["matrix.det","matrix.inv","matrix.rank","matrix.square?"]},hilbert:{category:"matrix",description:"Generates a **Hilbert matrix** of size `n`.",returns:{type:"matrix"},args:{n:{type:"integer",description:"The size of the Hilbert matrix."}},variants:[{argumentNames:["n"]}],examples:['let { hilbert } = import("matrix");\nhilbert(3)','let { hilbert } = import("matrix");\nhilbert(4)'],seeAlso:["matrix.vandermonde","matrix.symmetric?"]},vandermonde:{category:"matrix",description:"Generates a **Vandermonde matrix** from a vector.",returns:{type:"matrix"},args:{v:{type:"vector",description:"The vector to generate the Vandermonde matrix from."}},variants:[{argumentNames:["v"]}],examples:['let { vandermonde } = import("matrix");\nvandermonde([1, 2, 3])','let { vandermonde } = import("matrix");\nvandermonde([1, 0, 1])'],seeAlso:["matrix.hilbert","matrix.band"]},band:{category:"matrix",description:"Generates a **banded matrix** of size `n` with lower band index `lband` and upper band index `uband`.",returns:{type:"matrix"},args:{n:{type:"integer",description:"The size of the banded matrix."},lband:{type:"integer",description:"The lower band index."},uband:{type:"integer",description:"The upper band index."}},variants:[{argumentNames:["n","lband","uband"]}],examples:['let { band } = import("matrix");\nband(3, 1, 1)','let { band } = import("matrix");\nband(4, 1, 2)'],seeAlso:["matrix.banded?","matrix.diagonal?","matrix.vandermonde"]},"banded?":{category:"matrix",description:"Checks if a `matrix` is **banded** with lower band index `lband` and upper band index `uband`.",returns:{type:"boolean"},args:{m:{type:"matrix",description:"The `matrix` to check for **banded** property."},lband:{type:"integer",description:"The lower band index."},uband:{type:"integer",description:"The upper band index."}},variants:[{argumentNames:["m","lband","uband"]}],examples:['let { banded? } = import("matrix");\nbanded?([\n  [1, 1, 1, 0],\n  [1, 1, 1, 1],\n  [1, 1, 1, 1],\n  [0, 1, 1, 1],\n], 2, 2)','let { banded? } = import("matrix");\nbanded?([\n  [1, 1, 1, 0],\n  [1, 1, 1, 1],\n  [1, 1, 1, 1],\n  [0, 1, 1, 1],\n], 1, 1)'],seeAlso:["matrix.band","matrix.triangular?","matrix.diagonal?"]},rank:{category:"matrix",description:"Calculates the **rank** of a matrix using **Gaussian elimination**.",returns:{type:"number"},args:{m:{type:"matrix",description:"The `matrix` to calculate the rank of."}},variants:[{argumentNames:["m"]}],examples:['let { rank } = import("matrix");\nrank([[1, 0, 0], [0, 1, 0], [0, 0, 1]])','let { rank } = import("matrix");\nrank([[1, 2, 3], [4, 5, 6], [7, 8, 9]])','let { rank } = import("matrix");\nrank([[2, 4, 6], [3, 6, 9], [4, 8, 12]])'],seeAlso:["matrix.det","matrix.invertible?","linear-algebra.rref"]},"frobenius-norm":{category:"matrix",description:"Calculates the **Frobenius norm** of a matrix.",returns:{type:"number"},args:{m:{type:"matrix",description:"The `matrix` to calculate the Frobenius norm of."}},variants:[{argumentNames:["m"]}],examples:['let { frobenius-norm } = import("matrix");\nfrobenius-norm([[1, 2], [3, 4]])','let { frobenius-norm } = import("matrix");\nfrobenius-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])'],seeAlso:["matrix.one-norm","matrix.inf-norm","matrix.max-norm"]},"one-norm":{category:"matrix",description:"Calculates the **one-norm** (column norm) of a matrix.",returns:{type:"number"},args:{m:{type:"matrix",description:"The `matrix` to calculate the one-norm of."}},variants:[{argumentNames:["m"]}],examples:['let { one-norm } = import("matrix");\none-norm([[1, 2], [3, 4]])','let { one-norm } = import("matrix");\none-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])'],seeAlso:["matrix.frobenius-norm","matrix.inf-norm","matrix.max-norm"]},"inf-norm":{category:"matrix",description:"Calculates the **infinity norm** of a matrix.",returns:{type:"number"},args:{m:{type:"matrix",description:"The `matrix` to calculate the infinity norm of."}},variants:[{argumentNames:["m"]}],examples:['let { inf-norm } = import("matrix");\ninf-norm([[1, 2], [3, 4]])','let { inf-norm } = import("matrix");\ninf-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])'],seeAlso:["matrix.frobenius-norm","matrix.one-norm","matrix.max-norm"]},"max-norm":{category:"matrix",description:"Calculates the **max norm** of a matrix.",returns:{type:"number"},args:{m:{type:"matrix",description:"The `matrix` to calculate the max norm of."}},variants:[{argumentNames:["m"]}],examples:['let { max-norm } = import("matrix");\nmax-norm([[1, 2], [3, 4]])','let { max-norm } = import("matrix");\nmax-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])'],seeAlso:["matrix.frobenius-norm","matrix.one-norm","matrix.inf-norm"]}};function determinant(e){const t=e.length,r=[];for(let n=0;n<t;n++)r[n]=[...e[n]];if(1===t)return r[0][0];if(2===t)return r[0][0]*r[1][1]-r[0][1]*r[1][0];let n=1;for(let e=0;e<t-1;e+=1){let o=e;for(let n=e+1;n<t;n+=1)Math.abs(r[n][e])>Math.abs(r[o][e])&&(o=n);if(approxZero(r[o][e]))return 0;o!==e&&([r[e],r[o]]=[r[o],r[e]],n=-n);for(let n=e+1;n<t;n+=1){const o=r[n][e]/r[e][e];for(let a=e;a<t;a++)r[n][a]-=o*r[e][a]}}let o=n;for(let e=0;e<t;e++)o*=r[e][e];return o}function minor(e,t,r){const n=e.length,o=[];for(let a=0;a<n;a++)if(a!==t){const t=[];for(let o=0;o<n;o++)o!==r&&t.push(e[a][o]);o.push(t)}return o}function adjugate(e){const t=e.length,r=[];for(let n=0;n<t;n++){r[n]=[];for(let o=0;o<t;o++){const t=(-1)**(n+o)*determinant(minor(e,o,n));r[n][o]=t}}return r}function band(e,t,r){const n=Array.from({length:e},()=>Array.from({length:e},()=>0));for(let o=0;o<e;o++)for(let a=Math.max(0,o-t);a<=Math.min(e-1,o+r);a++)n[o][a]=1;return n}function cofactor(e){const t=e.length,r=[];for(let n=0;n<t;n++){r[n]=[];for(let o=0;o<t;o++){const t=minor(e,n,o),a=(-1)**(n+o);r[n][o]=a*determinant(t)}}return r}function inverse(e){const t=e.length;if(1===t){const t=e[0][0];return approxZero(t)?null:[[1/t]]}const r=determinant(e);if(approxZero(r))return null;const n=adjugate(e),o=[];for(let e=0;e<t;e++){o[e]=[];for(let a=0;a<t;a++)o[e][a]=n[e][a]/r}return o}function isBanded(e,t,r){const n=e.length,o=e[0].length;for(let a=0;a<n;a++)for(let n=0;n<o;n++)if(0!==e[a][n]&&(a-n>t||n-a>r))return!1;return!0}function isSquare(e){return e.length===e[0].length}function isDiagonal(e){if(!isSquare(e))return!1;const t=e.length;for(let r=0;r<t;r+=1)for(let n=0;n<t;n+=1)if(r!==n&&0!==e[r][n])return!1;return!0}function isIdentity(e){if(!isSquare(e))return!1;const t=e.length;for(let r=0;r<t;r++)for(let n=0;n<t;n++)if(r===n){if(!approxEqual(e[r][n],1))return!1}else if(!approxZero(e[r][n]))return!1;return!0}function matrixMultiply(e,t){if(0===e.length||0===t.length||e[0].length!==t.length)throw new Error("Matrix dimensions do not match for multiplication");const r=e.length,n=e[0].length,o=t[0].length,a=Array(r).fill(0).map(()=>Array(o).fill(0));for(let i=0;i<r;i++)for(let r=0;r<n;r++){const n=e[i][r];for(let e=0;e<o;e++)a[i][e]+=n*t[r][e]}return a}function isOrthogonal(e){if(!isSquare(e))return!1;return isIdentity(matrixMultiply(e,transpose(e)))}function isSymetric(e){const t=e.length;if(!isSquare(e))return!1;for(let r=0;r<t;r+=1)for(let t=0;t<r;t+=1)if(e[r][t]!==e[t][r])return!1;return!0}function isTriangular(e){if(!isSquare(e))return!1;const t=e.length;let r=!0,n=!0;for(let o=0;o<t;o++)for(let a=0;a<t;a++){if(o>a&&0!==e[o][a]&&(r=!1,!n))return!1;o<a&&0!==e[o][a]&&(n=!1)}return r||n}function isTriangularUpper(e){if(!isSquare(e))return!1;const t=e.length;for(let r=0;r<t;r++)for(let t=0;t<r;t++)if(0!==e[r][t])return!1;return!0}function isTriangularLower(e){if(!isSquare(e))return!1;const t=e.length;if(!e.every(e=>e.length===t))return!1;for(let r=0;r<t;r++)for(let n=r+1;n<t;n++)if(0!==e[r][n])return!1;return!0}function norm1(e){const t=e.length,r=e[0].length;let n=0;for(let o=0;o<r;o+=1){let r=0;for(let n=0;n<t;n+=1)r+=Math.abs(e[n][o]);n=Math.max(n,r)}return n}function trace(e){return e.reduce((e,t,r)=>e+t[r],0)}const matrixNormalExpression={mul:{evaluate:([e,t],r)=>{assertMatrix(e,r),assertMatrix(t,r);try{return matrixMultiply(e,t)}catch(n){throw new LitsError(`The number of columns in the first matrix must be equal to the number of rows in the second matrix, but got ${e[0].length} and ${t.length}`,r)}},arity:toFixedArity(2)},det:{evaluate:([e],t)=>(assertSquareMatrix(e,t),determinant(e)),arity:toFixedArity(1)},inv:{evaluate:([e],t)=>{assertSquareMatrix(e,t);const r=inverse(e);if(null===r)throw new LitsError("The matrix must be invertible",t);return r},arity:toFixedArity(1)},adj:{evaluate:([e],t)=>(assertSquareMatrix(e,t),adjugate(e)),arity:toFixedArity(1)},cofactor:{evaluate:([e],t)=>(assertSquareMatrix(e,t),cofactor(e)),arity:toFixedArity(1)},minor:{evaluate:([e,t,r],n)=>(assertMatrix(e,n),assertNumber(t,n,{integer:!0,nonNegative:!0,lte:e.length}),assertNumber(r,n,{integer:!0,nonNegative:!0,lte:e[0].length}),minor(e,t,r)),arity:toFixedArity(3)},trace:{evaluate:([e],t)=>(assertSquareMatrix(e,t),trace(e)),arity:toFixedArity(1)},"symmetric?":{evaluate:([e],t)=>(assertMatrix(e,t),isSymetric(e)),arity:toFixedArity(1)},"triangular?":{evaluate:([e],t)=>(assertMatrix(e,t),isTriangular(e)),arity:toFixedArity(1)},"upper-triangular?":{evaluate:([e],t)=>(assertMatrix(e,t),isTriangularUpper(e)),arity:toFixedArity(1)},"lower-triangular?":{evaluate:([e],t)=>(assertMatrix(e,t),isTriangularLower(e)),arity:toFixedArity(1)},"diagonal?":{evaluate:([e],t)=>(assertMatrix(e,t),isDiagonal(e)),arity:toFixedArity(1)},"square?":{evaluate:([e],t)=>(assertMatrix(e,t),isSquare(e)),arity:toFixedArity(1)},"orthogonal?":{evaluate:([e],t)=>(assertMatrix(e,t),isOrthogonal(e)),arity:toFixedArity(1)},"identity?":{evaluate:([e],t)=>(assertMatrix(e,t),isIdentity(e)),arity:toFixedArity(1)},"invertible?":{evaluate:([e],t)=>(assertMatrix(e,t),!!isSquareMatrix(e)&&!approxZero(determinant(e))),arity:toFixedArity(1)},hilbert:{evaluate:([e],t)=>{assertNumber(e,t,{integer:!0,positive:!0});const r=[];for(let t=0;t<e;t+=1){const n=[];for(let r=0;r<e;r+=1)n.push(1/(t+r+1));r.push(n)}return r},arity:toFixedArity(1)},vandermonde:{evaluate:([e],t)=>{assertVector(e,t);const r=[];for(let t=0;t<e.length;t+=1){const n=[];for(let r=0;r<e.length;r+=1)n.push(e[t]**r);r.push(n)}return r},arity:toFixedArity(1)},band:{evaluate:([e,t,r],n)=>(assertNumber(e,n,{integer:!0,positive:!0}),assertNumber(t,n,{integer:!0,nonNegative:!0,lt:e}),assertNumber(r,n,{integer:!0,nonNegative:!0,lte:e}),band(e,t,r)),arity:toFixedArity(3)},"banded?":{evaluate:([e,t,r],n)=>{assertMatrix(e,n);const o=Math.max(e.length,e[0].length);return assertNumber(t,n,{integer:!0,nonNegative:!0,lt:o}),assertNumber(r,n,{integer:!0,nonNegative:!0,lt:o}),isBanded(e,t,r)},arity:toFixedArity(3)},rank:{evaluate:([e],t)=>{assertMatrix(e,t);const[,r]=gaussJordanElimination(e);return r},arity:toFixedArity(1)},"frobenius-norm":{evaluate:([e],t)=>(assertMatrix(e,t),Math.sqrt(e.reduce((e,t)=>e+t.reduce((e,t)=>e+t*t,0),0))),arity:toFixedArity(1)},"one-norm":{evaluate:([e],t)=>(assertMatrix(e,t),norm1(e)),arity:toFixedArity(1)},"inf-norm":{evaluate:([e],t)=>(assertMatrix(e,t),e.reduce((e,t)=>Math.max(e,t.reduce((e,t)=>e+Math.abs(t),0)),0)),arity:toFixedArity(1)},"max-norm":{evaluate:([e],t)=>(assertMatrix(e,t),e.reduce((e,t)=>{const r=t.reduce((e,t)=>Math.max(e,Math.abs(t)),0);return Math.max(e,r)},0)),arity:toFixedArity(1)}};for(const[e,t]of Object.entries(moduleDocs$1))matrixNormalExpression[e]&&(matrixNormalExpression[e].docs=t);const matrixModule={name:"matrix",functions:matrixNormalExpression},moduleDocs={"abundant-seq":{category:"number-theory",description:"Generates the abundant numbers up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { abundant-seq } = import("number-theory");\nabundant-seq(1)','let { abundant-seq } = import("number-theory");\nabundant-seq(5)'],seeAlso:["number-theory.abundant-nth","number-theory.abundant-take-while","number-theory.abundant?","number-theory.deficient-seq","number-theory.perfect-seq"]},"abundant-take-while":{category:"number-theory",description:"Generates the abundant numbers while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { abundant-take-while } = import("number-theory");\nabundant-take-while(-> $ < 100)'],seeAlso:["number-theory.abundant-seq","number-theory.abundant-nth","number-theory.abundant?"]},"abundant-nth":{category:"number-theory",description:"Generates the nth term of the abundant numbers.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the number in the sequence."}},variants:[{argumentNames:["n"]}],examples:['let { abundant-nth } = import("number-theory");\nabundant-nth(1)','let { abundant-nth } = import("number-theory");\nabundant-nth(5)'],seeAlso:["number-theory.abundant-seq","number-theory.abundant-take-while","number-theory.abundant?"]},"abundant?":{category:"number-theory",description:"Checks if a number is abundant.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { abundant? } = import("number-theory");\nabundant?(12)','let { abundant? } = import("number-theory");\nabundant?(15)'],seeAlso:["number-theory.abundant-seq","number-theory.abundant-nth","number-theory.deficient?","number-theory.perfect?","number-theory.sigma","number-theory.divisors","number-theory.abundant-take-while"]},"arithmetic-seq":{category:"number-theory",description:"Generates the arithmetic sequence for a given $start, $step, and $length.",returns:{type:"integer",array:!0},args:{start:{type:"number",description:"The starting term of the sequence."},step:{type:"number",description:"The common difference of the sequence."},length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["start","step","length"]}],examples:['let { arithmetic-seq } = import("number-theory");\narithmetic-seq(3, 2, 2)','let { arithmetic-seq } = import("number-theory");\narithmetic-seq(2, 3, 2)','let { arithmetic-seq } = import("number-theory");\narithmetic-seq(1, 2, 2)','let { arithmetic-seq } = import("number-theory");\narithmetic-seq(1, 1.5, 12)'],seeAlso:["number-theory.arithmetic-nth","number-theory.arithmetic-take-while","number-theory.arithmetic?","number-theory.geometric-seq"]},"arithmetic-take-while":{category:"number-theory",description:"Generates the arithmetic sequence while a condition is met.",returns:{type:"integer",array:!0},args:{start:{type:"number",description:"The starting term of the sequence."},step:{type:"number",description:"The common difference of the sequence."},takeWhile:{type:"function",description:"A function that takes a number and an index and returns a boolean."}},variants:[{argumentNames:["start","step","takeWhile"]}],examples:['let { arithmetic-take-while } = import("number-theory");\narithmetic-take-while(1, 0.25, -> $ < 3)'],seeAlso:["number-theory.arithmetic-seq","number-theory.arithmetic-nth","number-theory.arithmetic?"]},"arithmetic-nth":{category:"number-theory",description:"Generates the nth term of the arithmetic sequence.",returns:{type:"integer"},args:{start:{type:"number",description:"The starting term of the sequence."},step:{type:"number",description:"The common difference of the sequence."},n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["start","step","n"]}],examples:['let { arithmetic-nth } = import("number-theory");\narithmetic-nth(3, 2, 2)','let { arithmetic-nth } = import("number-theory");\narithmetic-nth(2, 3, 2)','let { arithmetic-nth } = import("number-theory");\narithmetic-nth(1, 2, 2)','let { arithmetic-nth } = import("number-theory");\narithmetic-nth(1, 1.5, 12)'],seeAlso:["number-theory.arithmetic-seq","number-theory.arithmetic-take-while","number-theory.arithmetic?"]},"arithmetic?":{category:"number-theory",description:"Checks if a number is part of the arithmetic sequence.",returns:{type:"boolean"},args:{start:{type:"number",description:"The starting term of the sequence."},step:{type:"number",description:"The common difference of the sequence."},n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["start","step","n"]}],examples:['let { arithmetic? } = import("number-theory");\narithmetic?(3, 2, 2)','let { arithmetic? } = import("number-theory");\narithmetic?(2, 3, 2)','let { arithmetic? } = import("number-theory");\narithmetic?(1, 2, 2)','let { arithmetic? } = import("number-theory");\narithmetic?(1, 1.5, 12)'],seeAlso:["number-theory.arithmetic-seq","number-theory.arithmetic-nth","number-theory.geometric?","number-theory.arithmetic-take-while"]},"bell-seq":{category:"number-theory",description:"Generates the Bell sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If not provided, the default is 22 (the maximum length of the pre-calculated bell numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { bell-seq } = import("number-theory");\nbell-seq(5)','let { bell-seq } = import("number-theory");\nbell-seq(10)','let { bell-seq } = import("number-theory");\nbell-seq()'],seeAlso:["number-theory.bell-nth","number-theory.bell-take-while","number-theory.bell?","number-theory.catalan-seq","number-theory.stirling-second","number-theory.stirling-first"]},"bell-take-while":{category:"number-theory",description:"Generates the Bell sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { bell-take-while } = import("number-theory");\nbell-take-while(-> $ < 1000)'],seeAlso:["number-theory.bell-seq","number-theory.bell-nth","number-theory.bell?"]},"bell-nth":{category:"number-theory",description:"Generates the nth term of the Bell sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { bell-nth } = import("number-theory");\nbell-nth(5)','let { bell-nth } = import("number-theory");\nbell-nth(10)'],seeAlso:["number-theory.bell-seq","number-theory.bell-take-while","number-theory.bell?"]},"bell?":{category:"number-theory",description:"Checks if a number is in the Bell sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { bell? } = import("number-theory");\nbell?(1)','let { bell? } = import("number-theory");\nbell?(27644437)','let { bell? } = import("number-theory");\nbell?(27644436)'],seeAlso:["number-theory.bell-seq","number-theory.bell-nth","number-theory.catalan?","number-theory.bell-take-while"]},"bernoulli-seq":{category:"number-theory",description:"Generates the Bernoulli sequence up to a specified length.",returns:{type:"number",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { bernoulli-seq } = import("number-theory");\nbernoulli-seq(5)','let { bernoulli-seq } = import("number-theory");\nbernoulli-seq(10)'],seeAlso:["number-theory.bernoulli-nth","number-theory.bernoulli-take-while"]},"bernoulli-take-while":{category:"number-theory",description:"Generates the Bernoulli sequence while a condition is met.",returns:{type:"number",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { bernoulli-take-while } = import("number-theory");\nbernoulli-take-while(-> abs($) < 100)'],seeAlso:["number-theory.bernoulli-seq","number-theory.bernoulli-nth"]},"bernoulli-nth":{category:"number-theory",description:"Generates the nth term of the Bernoulli sequence.",returns:{type:"number"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { bernoulli-nth } = import("number-theory");\nbernoulli-nth(5)','let { bernoulli-nth } = import("number-theory");\nbernoulli-nth(10)','let { bernoulli-nth } = import("number-theory");\nbernoulli-nth(23)'],seeAlso:["number-theory.bernoulli-seq","number-theory.bernoulli-take-while"]},"catalan-seq":{category:"number-theory",description:"Generates the Catalan sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If not provided, the default is 30 (the maximum length of the pre-calculated catalan numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { catalan-seq } = import("number-theory");\ncatalan-seq(5)','let { catalan-seq } = import("number-theory");\ncatalan-seq(10)','let { catalan-seq } = import("number-theory");\ncatalan-seq()'],seeAlso:["number-theory.catalan-nth","number-theory.catalan-take-while","number-theory.catalan?","number-theory.bell-seq"]},"catalan-take-while":{category:"number-theory",description:"Generates the Catalan sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { catalan-take-while } = import("number-theory");\ncatalan-take-while(-> $ < 1000)'],seeAlso:["number-theory.catalan-seq","number-theory.catalan-nth","number-theory.catalan?"]},"catalan-nth":{category:"number-theory",description:"Generates the nth term of the Catalan sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { catalan-nth } = import("number-theory");\ncatalan-nth(5)','let { catalan-nth } = import("number-theory");\ncatalan-nth(10)'],seeAlso:["number-theory.catalan-seq","number-theory.catalan-take-while","number-theory.catalan?"]},"catalan?":{category:"number-theory",description:"Determines if a number is in the Catalan sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { catalan? } = import("number-theory");\ncatalan?(5)','let { catalan? } = import("number-theory");\ncatalan?(10)'],seeAlso:["number-theory.catalan-seq","number-theory.catalan-nth","number-theory.bell?","number-theory.catalan-take-while"]},"collatz-seq":{category:"number-theory",description:"Generates the collatz sequence starting from a given integer.",returns:{type:"integer",array:!0},args:{start:{type:"integer",description:"The starting integer for the collatz sequence."}},variants:[{argumentNames:["start"]}],examples:['let { collatz-seq } = import("number-theory");\ncollatz-seq(3)','let { collatz-seq } = import("number-theory");\ncollatz-seq(11)'],seeAlso:["number-theory.juggler-seq"]},"composite-seq":{category:"number-theory",description:"Generates the composite sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { composite-seq } = import("number-theory");\ncomposite-seq(1)','let { composite-seq } = import("number-theory");\ncomposite-seq(2)','let { composite-seq } = import("number-theory");\ncomposite-seq(10)'],seeAlso:["number-theory.composite-nth","number-theory.composite-take-while","number-theory.composite?","number-theory.prime-seq"]},"composite-take-while":{category:"number-theory",description:"Generates the composite sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { composite-take-while } = import("number-theory");\ncomposite-take-while(-> $ < 50)'],seeAlso:["number-theory.composite-seq","number-theory.composite-nth","number-theory.composite?"]},"composite-nth":{category:"number-theory",description:"Generates the nth term of the composite sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the composite number to retrieve."}},variants:[{argumentNames:["n"]}],examples:['let { composite-nth } = import("number-theory");\ncomposite-nth(1)','let { composite-nth } = import("number-theory");\ncomposite-nth(2)','let { composite-nth } = import("number-theory");\ncomposite-nth(10)'],seeAlso:["number-theory.composite-seq","number-theory.composite-take-while","number-theory.composite?"]},"composite?":{category:"number-theory",description:"Determines if a number is composite.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { composite? } = import("number-theory");\ncomposite?(4)','let { composite? } = import("number-theory");\ncomposite?(5)','let { composite? } = import("number-theory");\ncomposite?(11)'],seeAlso:["number-theory.composite-seq","number-theory.composite-nth","number-theory.prime?","number-theory.prime-factors","number-theory.composite-take-while"]},"deficient-seq":{category:"number-theory",description:"Generates the deficient numbers up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { deficient-seq } = import("number-theory");\ndeficient-seq(1)','let { deficient-seq } = import("number-theory");\ndeficient-seq(5)'],seeAlso:["number-theory.deficient-nth","number-theory.deficient-take-while","number-theory.deficient?","number-theory.abundant-seq","number-theory.perfect-seq"]},"deficient-take-while":{category:"number-theory",description:"Generates the deficient numbers while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { deficient-take-while } = import("number-theory");\ndeficient-take-while(-> $ < 100)'],seeAlso:["number-theory.deficient-seq","number-theory.deficient-nth","number-theory.deficient?"]},"deficient-nth":{category:"number-theory",description:"Generates the nth term of the deficient numbers.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the number in the sequence."}},variants:[{argumentNames:["n"]}],examples:['let { deficient-nth } = import("number-theory");\ndeficient-nth(5)','let { deficient-nth } = import("number-theory");\ndeficient-nth(12)'],seeAlso:["number-theory.deficient-seq","number-theory.deficient-take-while","number-theory.deficient?"]},"deficient?":{category:"number-theory",description:"Checks if a number is deficient.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { deficient? } = import("number-theory");\ndeficient?(12)','let { deficient? } = import("number-theory");\ndeficient?(15)'],seeAlso:["number-theory.deficient-seq","number-theory.deficient-nth","number-theory.abundant?","number-theory.perfect?","number-theory.sigma","number-theory.divisors","number-theory.deficient-take-while"]},"factorial-seq":{category:"number-theory",description:"Generates the factorial sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If not provided, the default is 19 (the maximum length of the pre-calculated factorial numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { factorial-seq } = import("number-theory");\nfactorial-seq(1)','let { factorial-seq } = import("number-theory");\nfactorial-seq(2)','let { factorial-seq } = import("number-theory");\nfactorial-seq(3)','let { factorial-seq } = import("number-theory");\nfactorial-seq(4)','let { factorial-seq } = import("number-theory");\nfactorial-seq(5)','let { factorial-seq } = import("number-theory");\nfactorial-seq(10)'],seeAlso:["number-theory.factorial-nth","number-theory.factorial-take-while","number-theory.factorial?","number-theory.factorial"]},"factorial-take-while":{category:"number-theory",description:"Generates the factorial sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { factorial-take-while } = import("number-theory");\nfactorial-take-while(-> $ < 1000)'],seeAlso:["number-theory.factorial-seq","number-theory.factorial-nth","number-theory.factorial?"]},"factorial-nth":{category:"number-theory",description:"Generates the nth term of the factorial sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { factorial-nth } = import("number-theory");\nfactorial-nth(1)','let { factorial-nth } = import("number-theory");\nfactorial-nth(2)','let { factorial-nth } = import("number-theory");\nfactorial-nth(3)','let { factorial-nth } = import("number-theory");\nfactorial-nth(4)','let { factorial-nth } = import("number-theory");\nfactorial-nth(5)','let { factorial-nth } = import("number-theory");\nfactorial-nth(10)'],seeAlso:["number-theory.factorial-seq","number-theory.factorial-take-while","number-theory.factorial?","number-theory.factorial"]},"factorial?":{category:"number-theory",description:"Checks if a number is in the factorial sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { factorial? } = import("number-theory");\nfactorial?(1)','let { factorial? } = import("number-theory");\nfactorial?(2)','let { factorial? } = import("number-theory");\nfactorial?(3)','let { factorial? } = import("number-theory");\nfactorial?(4)','let { factorial? } = import("number-theory");\nfactorial?(5)','let { factorial? } = import("number-theory");\nfactorial?(6)','let { factorial? } = import("number-theory");\nfactorial?(7)','let { factorial? } = import("number-theory");\nfactorial?(8)','let { factorial? } = import("number-theory");\nfactorial?(9)','let { factorial? } = import("number-theory");\nfactorial?(3628800)'],seeAlso:["number-theory.factorial-seq","number-theory.factorial-nth","number-theory.factorial","number-theory.factorial-take-while"]},"fibonacci-seq":{category:"number-theory",description:"Generates the fibonacci sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If not provided, the default is 79 (the maximum length of the pre-calculated Fibonacci numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { fibonacci-seq } = import("number-theory");\nfibonacci-seq(1)','let { fibonacci-seq } = import("number-theory");\nfibonacci-seq(2)','let { fibonacci-seq } = import("number-theory");\nfibonacci-seq()'],seeAlso:["number-theory.fibonacci-nth","number-theory.fibonacci-take-while","number-theory.fibonacci?","number-theory.lucas-seq","number-theory.tribonacci-seq","number-theory.pell-seq","number-theory.padovan-seq"]},"fibonacci-take-while":{category:"number-theory",description:"Generates the fibonacci sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { fibonacci-take-while } = import("number-theory");\nfibonacci-take-while(-> $ < 100)'],seeAlso:["number-theory.fibonacci-seq","number-theory.fibonacci-nth","number-theory.fibonacci?"]},"fibonacci-nth":{category:"number-theory",description:"Generates the nth term of the fibonacci sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { fibonacci-nth } = import("number-theory");\nfibonacci-nth(5)','let { fibonacci-nth } = import("number-theory");\nfibonacci-nth(50)'],seeAlso:["number-theory.fibonacci-seq","number-theory.fibonacci-take-while","number-theory.fibonacci?"]},"fibonacci?":{category:"number-theory",description:"Determines if a number is in the fibonacci sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { fibonacci? } = import("number-theory");\nfibonacci?(0)','let { fibonacci? } = import("number-theory");\nfibonacci?(1)','let { fibonacci? } = import("number-theory");\nfibonacci?(2)','let { fibonacci? } = import("number-theory");\nfibonacci?(3)','let { fibonacci? } = import("number-theory");\nfibonacci?(4)','let { fibonacci? } = import("number-theory");\nfibonacci?(5)','let { fibonacci? } = import("number-theory");\nfibonacci?(6)','let { fibonacci? } = import("number-theory");\nfibonacci?(7)','let { fibonacci? } = import("number-theory");\nfibonacci?(8)','let { fibonacci? } = import("number-theory");\nfibonacci?(9)'],seeAlso:["number-theory.fibonacci-seq","number-theory.fibonacci-nth","number-theory.lucas?","number-theory.fibonacci-take-while","number-theory.tribonacci?","number-theory.padovan?","number-theory.pell?"]},"geometric-seq":{category:"number-theory",description:"Generates the geometric sequence for a given $start, $ratio, and $length.",returns:{type:"integer",array:!0},args:{start:{type:"number",description:"The starting term of the sequence."},ratio:{type:"number",description:"The common ratio of the sequence."},length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["start","ratio","length"]}],examples:['let { geometric-seq } = import("number-theory");\ngeometric-seq(3, 2, 2)','let { geometric-seq } = import("number-theory");\ngeometric-seq(2, 3, 2)','let { geometric-seq } = import("number-theory");\ngeometric-seq(1, 2, 2)','let { geometric-seq } = import("number-theory");\ngeometric-seq(1, 1.5, 12)'],seeAlso:["number-theory.geometric-nth","number-theory.geometric-take-while","number-theory.geometric?","number-theory.arithmetic-seq"]},"geometric-take-while":{category:"number-theory",description:"Generates the geometric sequence while a condition is met.",returns:{type:"integer",array:!0},args:{start:{type:"number",description:"The starting term of the sequence."},ratio:{type:"number",description:"The common ratio of the sequence."},takeWhile:{type:"function",description:"A function that takes a number and an index and returns a boolean."}},variants:[{argumentNames:["start","ratio","takeWhile"]}],examples:['let { geometric-take-while } = import("number-theory");\ngeometric-take-while(1, 1.5, -> $ < 10)'],seeAlso:["number-theory.geometric-seq","number-theory.geometric-nth","number-theory.geometric?"]},"geometric-nth":{category:"number-theory",description:"Generates the nth term of the geometric sequence.",returns:{type:"integer"},args:{start:{type:"number",description:"The starting term of the sequence."},ratio:{type:"number",description:"The common ratio of the sequence."},n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["start","ratio","n"]}],examples:['let { geometric-nth } = import("number-theory");\ngeometric-nth(3, 2, 2)','let { geometric-nth } = import("number-theory");\ngeometric-nth(2, 3, 2)','let { geometric-nth } = import("number-theory");\ngeometric-nth(1, 2, 2)','let { geometric-nth } = import("number-theory");\ngeometric-nth(1, 1.5, 4)'],seeAlso:["number-theory.geometric-seq","number-theory.geometric-take-while","number-theory.geometric?"]},"geometric?":{category:"number-theory",description:"Checks if a number is in the geometric sequence.",returns:{type:"boolean"},args:{start:{type:"number",description:"The starting term of the sequence."},ratio:{type:"number",description:"The common ratio of the sequence."},n:{type:"number",description:"The number to check."}},variants:[{argumentNames:["start","ratio","n"]}],examples:['let { geometric? } = import("number-theory");\ngeometric?(1, 2, 1)','let { geometric? } = import("number-theory");\ngeometric?(2, 3, 2)','let { geometric? } = import("number-theory");\ngeometric?(3, 2, 2)','let { geometric? } = import("number-theory");\ngeometric?(1, 1.5, 2.25)','let { geometric? } = import("number-theory");\ngeometric?(1, 1.5, -4)'],seeAlso:["number-theory.geometric-seq","number-theory.geometric-nth","number-theory.arithmetic?","number-theory.geometric-take-while"]},"golomb-seq":{category:"number-theory",description:"Generates the Golomb sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { golomb-seq } = import("number-theory");\ngolomb-seq(5)','let { golomb-seq } = import("number-theory");\ngolomb-seq(20)'],seeAlso:["number-theory.golomb-nth","number-theory.golomb-take-while","number-theory.golomb?","number-theory.recaman-seq"]},"golomb-take-while":{category:"number-theory",description:"Generates the Golomb sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { golomb-take-while } = import("number-theory");\ngolomb-take-while(-> $ <= 10)'],seeAlso:["number-theory.golomb-seq","number-theory.golomb-nth","number-theory.golomb?"]},"golomb-nth":{category:"number-theory",description:"Generates the nth term of the Golomb sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { golomb-nth } = import("number-theory");\ngolomb-nth(5)','let { golomb-nth } = import("number-theory");\ngolomb-nth(1000)'],seeAlso:["number-theory.golomb-seq","number-theory.golomb-take-while","number-theory.golomb?"]},"golomb?":{category:"number-theory",description:"Checks if a number is in the Golomb sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { golomb? } = import("number-theory");\ngolomb?(1)','let { golomb? } = import("number-theory");\ngolomb?(2)','let { golomb? } = import("number-theory");\ngolomb?(3345)','let { golomb? } = import("number-theory");\ngolomb?(67867864)'],seeAlso:["number-theory.golomb-seq","number-theory.golomb-nth","number-theory.golomb-take-while"]},"happy-seq":{category:"number-theory",description:"Generates the happy sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If not provided, the default is 20 (the maximum length of the pre-calculated happy numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { happy-seq } = import("number-theory");\nhappy-seq(1)','let { happy-seq } = import("number-theory");\nhappy-seq(2)','let { happy-seq } = import("number-theory");\nhappy-seq(20)'],seeAlso:["number-theory.happy-nth","number-theory.happy-take-while","number-theory.happy?","number-theory.lucky-seq"]},"happy-take-while":{category:"number-theory",description:"Generates the happy sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { happy-take-while } = import("number-theory");\nhappy-take-while(-> $ < 100)'],seeAlso:["number-theory.happy-seq","number-theory.happy-nth","number-theory.happy?"]},"happy-nth":{category:"number-theory",description:"Generates the nth term of the happy sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the happy number to return."}},variants:[{argumentNames:["n"]}],examples:['let { happy-nth } = import("number-theory");\nhappy-nth(1)','let { happy-nth } = import("number-theory");\nhappy-nth(2)','let { happy-nth } = import("number-theory");\nhappy-nth(20)'],seeAlso:["number-theory.happy-seq","number-theory.happy-take-while","number-theory.happy?"]},"happy?":{category:"number-theory",description:"Determines if a number is a happy number.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { happy? } = import("number-theory");\nhappy?(1)','let { happy? } = import("number-theory");\nhappy?(2)','let { happy? } = import("number-theory");\nhappy?(100)'],seeAlso:["number-theory.happy-seq","number-theory.happy-nth","number-theory.happy-take-while"]},"juggler-seq":{category:"number-theory",description:"Generates the Juggler sequence starting from a given integer.",returns:{type:"integer",array:!0},args:{start:{type:"integer",description:"The starting integer for the Juggler sequence."}},variants:[{argumentNames:["start"]}],examples:['let { juggler-seq } = import("number-theory");\njuggler-seq(3)','let { juggler-seq } = import("number-theory");\njuggler-seq(5)'],seeAlso:["number-theory.collatz-seq"]},"look-and-say-seq":{category:"number-theory",description:"Generates the Look-and-Say sequence up to a specified length.",returns:{type:"string",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { look-and-say-seq } = import("number-theory");\nlook-and-say-seq(5)'],seeAlso:["number-theory.look-and-say-nth","number-theory.look-and-say-take-while","number-theory.look-and-say?"]},"look-and-say-take-while":{category:"number-theory",description:"Generates the Look-and-Say sequence while a condition is met.",returns:{type:"string",array:!0},args:{takeWhile:{type:"function",description:"A function that takes a string and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { look-and-say-take-while } = import("number-theory");\nlook-and-say-take-while((term, index) -> count(term) < 10)','let { look-and-say-take-while } = import("number-theory");\nlook-and-say-take-while(-> $2 <= 10)'],seeAlso:["number-theory.look-and-say-seq","number-theory.look-and-say-nth","number-theory.look-and-say?"]},"look-and-say-nth":{category:"number-theory",description:"Generates the nth term of the Look-and-Say sequence.",returns:{type:"string"},args:{n:{type:"integer",description:"The index of the term in the sequence."}},variants:[{argumentNames:["n"]}],examples:['let { look-and-say-nth } = import("number-theory");\nlook-and-say-nth(5)'],seeAlso:["number-theory.look-and-say-seq","number-theory.look-and-say-take-while","number-theory.look-and-say?"]},"look-and-say?":{category:"number-theory",description:"Checks if a string is a valid Look-and-Say term.",returns:{type:"boolean"},args:{term:{type:"string",description:"The term to check."}},variants:[{argumentNames:["term"]}],examples:['let { look-and-say? } = import("number-theory");\nlook-and-say?("111221")','let { look-and-say? } = import("number-theory");\nlook-and-say?("123")'],seeAlso:["number-theory.look-and-say-seq","number-theory.look-and-say-nth","number-theory.look-and-say-take-while"]},"lucas-seq":{category:"number-theory",description:"Generates the lucas sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If not provided, the default is 77 (the maximum length of the pre-calculated Lucas numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { lucas-seq } = import("number-theory");\nlucas-seq(1)','let { lucas-seq } = import("number-theory");\nlucas-seq(2)','let { lucas-seq } = import("number-theory");\nlucas-seq()'],seeAlso:["number-theory.lucas-nth","number-theory.lucas-take-while","number-theory.lucas?","number-theory.fibonacci-seq"]},"lucas-take-while":{category:"number-theory",description:"Generates the lucas sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { lucas-take-while } = import("number-theory");\nlucas-take-while(-> $ < 100)'],seeAlso:["number-theory.lucas-seq","number-theory.lucas-nth","number-theory.lucas?"]},"lucas-nth":{category:"number-theory",description:"Generates the nth term of the lucas sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { lucas-nth } = import("number-theory");\nlucas-nth(1)','let { lucas-nth } = import("number-theory");\nlucas-nth(2)','let { lucas-nth } = import("number-theory");\nlucas-nth(10)'],seeAlso:["number-theory.lucas-seq","number-theory.lucas-take-while","number-theory.lucas?"]},"lucas?":{category:"number-theory",description:"Determines if a number is in the lucas sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { lucas? } = import("number-theory");\nlucas?(1)','let { lucas? } = import("number-theory");\nlucas?(2)','let { lucas? } = import("number-theory");\nlucas?(10)'],seeAlso:["number-theory.lucas-seq","number-theory.lucas-nth","number-theory.fibonacci?","number-theory.lucas-take-while"]},"lucky-seq":{category:"number-theory",description:"Generates the lucky sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { lucky-seq } = import("number-theory");\nlucky-seq(1)','let { lucky-seq } = import("number-theory");\nlucky-seq(2)','let { lucky-seq } = import("number-theory");\nlucky-seq(20)'],seeAlso:["number-theory.lucky-nth","number-theory.lucky-take-while","number-theory.lucky?","number-theory.happy-seq","number-theory.prime-seq"]},"lucky-take-while":{category:"number-theory",description:"Generates the lucky sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { lucky-take-while } = import("number-theory");\nlucky-take-while(-> $ < 100)'],seeAlso:["number-theory.lucky-seq","number-theory.lucky-nth","number-theory.lucky?"]},"lucky-nth":{category:"number-theory",description:"Generates the nth term of the lucky sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The position in the sequence."}},variants:[{argumentNames:["n"]}],examples:['let { lucky-nth } = import("number-theory");\nlucky-nth(1)','let { lucky-nth } = import("number-theory");\nlucky-nth(2)','let { lucky-nth } = import("number-theory");\nlucky-nth(20)'],seeAlso:["number-theory.lucky-seq","number-theory.lucky-take-while","number-theory.lucky?"]},"lucky?":{category:"number-theory",description:"Checks if a number is a lucky number.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { lucky? } = import("number-theory");\nlucky?(4)','let { lucky? } = import("number-theory");\nlucky?(7)','let { lucky? } = import("number-theory");\nlucky?(33)'],seeAlso:["number-theory.lucky-seq","number-theory.lucky-nth","number-theory.prime?","number-theory.lucky-take-while"]},"mersenne-seq":{category:"number-theory",description:"Generates the Mersenne sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If not provided, the default is 9 (the maximum length of the pre-calculated mersenne numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { mersenne-seq } = import("number-theory");\nmersenne-seq(1)','let { mersenne-seq } = import("number-theory");\nmersenne-seq(5)','let { mersenne-seq } = import("number-theory");\nmersenne-seq()'],seeAlso:["number-theory.mersenne-nth","number-theory.mersenne-take-while","number-theory.mersenne?","number-theory.prime-seq"]},"mersenne-take-while":{category:"number-theory",description:"Generates the Mersenne sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { mersenne-take-while } = import("number-theory");\nmersenne-take-while(-> $ < 1000)'],seeAlso:["number-theory.mersenne-seq","number-theory.mersenne-nth","number-theory.mersenne?"]},"mersenne-nth":{category:"number-theory",description:"Generates the nth term of the Mersenne sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { mersenne-nth } = import("number-theory");\nmersenne-nth(1)','let { mersenne-nth } = import("number-theory");\nmersenne-nth(5)'],seeAlso:["number-theory.mersenne-seq","number-theory.mersenne-take-while","number-theory.mersenne?"]},"mersenne?":{category:"number-theory",description:"Checks if a number is in the Mersenne sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { mersenne? } = import("number-theory");\nmersenne?(3)','let { mersenne? } = import("number-theory");\nmersenne?(4)','let { mersenne? } = import("number-theory");\nmersenne?(7)'],seeAlso:["number-theory.mersenne-seq","number-theory.mersenne-nth","number-theory.prime?","number-theory.mersenne-take-while"]},"padovan-seq":{category:"number-theory",description:"Generates the Padovan sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { padovan-seq } = import("number-theory");\npadovan-seq(5)','let { padovan-seq } = import("number-theory");\npadovan-seq(10)','let { padovan-seq } = import("number-theory");\npadovan-seq(20)'],seeAlso:["number-theory.padovan-nth","number-theory.padovan-take-while","number-theory.padovan?","number-theory.fibonacci-seq"]},"padovan-take-while":{category:"number-theory",description:"Generates the Padovan sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { padovan-take-while } = import("number-theory");\npadovan-take-while(-> $ < 1000)'],seeAlso:["number-theory.padovan-seq","number-theory.padovan-nth","number-theory.padovan?"]},"padovan-nth":{category:"number-theory",description:"Generates the nth term of the Padovan sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { padovan-nth } = import("number-theory");\npadovan-nth(5)','let { padovan-nth } = import("number-theory");\npadovan-nth(10)','let { padovan-nth } = import("number-theory");\npadovan-nth(20)'],seeAlso:["number-theory.padovan-seq","number-theory.padovan-take-while","number-theory.padovan?"]},"padovan?":{category:"number-theory",description:"Checks if a number is in the Padovan sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { padovan? } = import("number-theory");\npadovan?(1)','let { padovan? } = import("number-theory");\npadovan?(265)','let { padovan? } = import("number-theory");\npadovan?(6)'],seeAlso:["number-theory.padovan-seq","number-theory.padovan-nth","number-theory.fibonacci?","number-theory.padovan-take-while"]},"partition-seq":{category:"number-theory",description:"Generates the partition numbers up to a specified length. If no length is provided, it defaults to 299 (the maximum length of the pre-calculated partition numbers).",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { partition-seq } = import("number-theory");\npartition-seq(1)','let { partition-seq } = import("number-theory");\npartition-seq(10)','let { partition-seq } = import("number-theory");\npartition-seq()'],seeAlso:["number-theory.partition-nth","number-theory.partition-take-while","number-theory.partition?","number-theory.partitions","number-theory.count-partitions"]},"partition-take-while":{category:"number-theory",description:"Generates the partition numbers while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { partition-take-while } = import("number-theory");\npartition-take-while(-> $ < 1000)'],seeAlso:["number-theory.partition-seq","number-theory.partition-nth","number-theory.partition?"]},"partition-nth":{category:"number-theory",description:"Generates the nth term of the partition numbers.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the partition number to generate."}},variants:[{argumentNames:["n"]}],examples:['let { partition-nth } = import("number-theory");\npartition-nth(1)','let { partition-nth } = import("number-theory");\npartition-nth(5)'],seeAlso:["number-theory.partition-seq","number-theory.partition-take-while","number-theory.partition?"]},"partition?":{category:"number-theory",description:"Checks if a number is in the partition numbers.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { partition? } = import("number-theory");\npartition?(0)','let { partition? } = import("number-theory");\npartition?(1)','let { partition? } = import("number-theory");\npartition?(2)','let { partition? } = import("number-theory");\npartition?(3)','let { partition? } = import("number-theory");\npartition?(4)','let { partition? } = import("number-theory");\npartition?(5)'],seeAlso:["number-theory.partition-seq","number-theory.partition-nth","number-theory.partitions","number-theory.partition-take-while"]},"pell-seq":{category:"number-theory",description:"Generates the Pell sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If not provided, the default is 42 (the maximum length of the pre-calculated Pell numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { pell-seq } = import("number-theory");\npell-seq(5)','let { pell-seq } = import("number-theory");\npell-seq(10)','let { pell-seq } = import("number-theory");\npell-seq()'],seeAlso:["number-theory.pell-nth","number-theory.pell-take-while","number-theory.pell?","number-theory.fibonacci-seq"]},"pell-take-while":{category:"number-theory",description:"Generates the Pell sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { pell-take-while } = import("number-theory");\npell-take-while(-> $ < 1000)'],seeAlso:["number-theory.pell-seq","number-theory.pell-nth","number-theory.pell?"]},"pell-nth":{category:"number-theory",description:"Generates the nth term of the Pell sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { pell-nth } = import("number-theory");\npell-nth(5)','let { pell-nth } = import("number-theory");\npell-nth(10)','let { pell-nth } = import("number-theory");\npell-nth(20)'],seeAlso:["number-theory.pell-seq","number-theory.pell-take-while","number-theory.pell?"]},"pell?":{category:"number-theory",description:"Checks if a number is a Pell number.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { pell? } = import("number-theory");\npell?(1)','let { pell? } = import("number-theory");\npell?(470832)','let { pell? } = import("number-theory");\npell?(10)'],seeAlso:["number-theory.pell-seq","number-theory.pell-nth","number-theory.fibonacci?","number-theory.pell-take-while"]},"perfect-seq":{category:"number-theory",description:"Generates the perfect numbers up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If no length is provided, it defaults to 7 (the maximum length of the pre-calculated perfect numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { perfect-seq } = import("number-theory");\nperfect-seq(1)','let { perfect-seq } = import("number-theory");\nperfect-seq(5)','let { perfect-seq } = import("number-theory");\nperfect-seq()'],seeAlso:["number-theory.perfect-nth","number-theory.perfect-take-while","number-theory.perfect?","number-theory.abundant-seq","number-theory.deficient-seq","number-theory.amicable?"]},"perfect-take-while":{category:"number-theory",description:"Generates the perfect numbers while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { perfect-take-while } = import("number-theory");\nperfect-take-while(-> $ < 1000)'],seeAlso:["number-theory.perfect-seq","number-theory.perfect-nth","number-theory.perfect?"]},"perfect-nth":{category:"number-theory",description:"Generates the nth term of the perfect numbers.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the perfect number to generate."}},variants:[{argumentNames:["n"]}],examples:['let { perfect-nth } = import("number-theory");\nperfect-nth(1)','let { perfect-nth } = import("number-theory");\nperfect-nth(5)'],seeAlso:["number-theory.perfect-seq","number-theory.perfect-take-while","number-theory.perfect?"]},"perfect?":{category:"number-theory",description:"Checks if a number is in the perfect numbers.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { perfect? } = import("number-theory");\nperfect?(0)','let { perfect? } = import("number-theory");\nperfect?(1)','let { perfect? } = import("number-theory");\nperfect?(2)','let { perfect? } = import("number-theory");\nperfect?(3)','let { perfect? } = import("number-theory");\nperfect?(4)','let { perfect? } = import("number-theory");\nperfect?(5)','let { perfect? } = import("number-theory");\nperfect?(6)','let { perfect? } = import("number-theory");\nperfect?(7)','let { perfect? } = import("number-theory");\nperfect?(8)','let { perfect? } = import("number-theory");\nperfect?(9)'],seeAlso:["number-theory.perfect-seq","number-theory.perfect-nth","number-theory.abundant?","number-theory.deficient?","number-theory.sigma","number-theory.perfect-take-while","number-theory.amicable?","number-theory.proper-divisors"]},"perfect-square-seq":{category:"number-theory",description:"Generates the perfect square numbers up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { perfect-square-seq } = import("number-theory");\nperfect-square-seq(5)','let { perfect-square-seq } = import("number-theory");\nperfect-square-seq(20)'],seeAlso:["number-theory.perfect-square-nth","number-theory.perfect-square-take-while","number-theory.perfect-square?","number-theory.perfect-cube-seq","number-theory.perfect-power-seq","number-theory.polygonal-seq"]},"perfect-square-take-while":{category:"number-theory",description:"Generates the perfect square numbers while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { perfect-square-take-while } = import("number-theory");\nperfect-square-take-while(-> $ <= 100)'],seeAlso:["number-theory.perfect-square-seq","number-theory.perfect-square-nth","number-theory.perfect-square?"]},"perfect-square-nth":{category:"number-theory",description:"Generates the nth term of the perfect square numbers.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { perfect-square-nth } = import("number-theory");\nperfect-square-nth(1)','let { perfect-square-nth } = import("number-theory");\nperfect-square-nth(5)'],seeAlso:["number-theory.perfect-square-seq","number-theory.perfect-square-take-while","number-theory.perfect-square?"]},"perfect-square?":{category:"number-theory",description:"Checks if a number is a perfect square.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { perfect-square? } = import("number-theory");\nperfect-square?(16)','let { perfect-square? } = import("number-theory");\nperfect-square?(20)'],seeAlso:["number-theory.perfect-square-seq","number-theory.perfect-square-nth","number-theory.perfect-cube?","number-theory.perfect-power?","number-theory.perfect-square-take-while","number-theory.perfect-power","number-theory.polygonal?"]},"perfect-cube-seq":{category:"number-theory",description:"Generates the perfect cube numbers up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { perfect-cube-seq } = import("number-theory");\nperfect-cube-seq(5)','let { perfect-cube-seq } = import("number-theory");\nperfect-cube-seq(20)'],seeAlso:["number-theory.perfect-cube-nth","number-theory.perfect-cube-take-while","number-theory.perfect-cube?","number-theory.perfect-square-seq","number-theory.perfect-power-seq"]},"perfect-cube-take-while":{category:"number-theory",description:"Generates the perfect cube numbers while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { perfect-cube-take-while } = import("number-theory");\nperfect-cube-take-while(-> $ <= 100)'],seeAlso:["number-theory.perfect-cube-seq","number-theory.perfect-cube-nth","number-theory.perfect-cube?"]},"perfect-cube-nth":{category:"number-theory",description:"Generates the nth term of the perfect cube numbers.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { perfect-cube-nth } = import("number-theory");\nperfect-cube-nth(1)','let { perfect-cube-nth } = import("number-theory");\nperfect-cube-nth(5)'],seeAlso:["number-theory.perfect-cube-seq","number-theory.perfect-cube-take-while","number-theory.perfect-cube?"]},"perfect-cube?":{category:"number-theory",description:"Checks if a number is in the perfect cube numbers.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { perfect-cube? } = import("number-theory");\nperfect-cube?(7)','let { perfect-cube? } = import("number-theory");\nperfect-cube?(8)','let { perfect-cube? } = import("number-theory");\nperfect-cube?(9)'],seeAlso:["number-theory.perfect-cube-seq","number-theory.perfect-cube-nth","number-theory.perfect-square?","number-theory.perfect-power?","number-theory.perfect-cube-take-while","number-theory.perfect-power"]},"perfect-power-seq":{category:"number-theory",description:"Generates the perfect power numbers up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { perfect-power-seq } = import("number-theory");\nperfect-power-seq(5)','let { perfect-power-seq } = import("number-theory");\nperfect-power-seq(20)'],seeAlso:["number-theory.perfect-power-nth","number-theory.perfect-power-take-while","number-theory.perfect-power?","number-theory.perfect-power","number-theory.perfect-square-seq","number-theory.perfect-cube-seq"]},"perfect-power-take-while":{category:"number-theory",description:"Generates the perfect power numbers while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { perfect-power-take-while } = import("number-theory");\nperfect-power-take-while(-> $ <= 100)'],seeAlso:["number-theory.perfect-power-seq","number-theory.perfect-power-nth","number-theory.perfect-power?"]},"perfect-power-nth":{category:"number-theory",description:"Generates the nth term of the perfect power numbers.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { perfect-power-nth } = import("number-theory");\nperfect-power-nth(3)','let { perfect-power-nth } = import("number-theory");\nperfect-power-nth(15)'],seeAlso:["number-theory.perfect-power-seq","number-theory.perfect-power-take-while","number-theory.perfect-power?"]},"perfect-power?":{category:"number-theory",description:"Checks if a number is in the perfect power numbers.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { perfect-power? } = import("number-theory");\nperfect-power?(7)','let { perfect-power? } = import("number-theory");\nperfect-power?(8)','let { perfect-power? } = import("number-theory");\nperfect-power?(9)','let { perfect-power? } = import("number-theory");\nperfect-power?(10)'],seeAlso:["number-theory.perfect-power-seq","number-theory.perfect-power-nth","number-theory.perfect-power","number-theory.perfect-square?","number-theory.perfect-cube?","number-theory.perfect-power-take-while"]},"polygonal-seq":{category:"number-theory",description:"Generates the polygonal sequence for a given number of sides and length.",returns:{type:"integer",array:!0},args:{sides:{type:"integer",description:"The number of sides of the polygon."},length:{type:"integer",description:"The length of the sequence to generate."},a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["sides","length"]}],examples:['let { polygonal-seq } = import("number-theory");\npolygonal-seq(3, 2)','let { polygonal-seq } = import("number-theory");\npolygonal-seq(4, 2)','let { polygonal-seq } = import("number-theory");\npolygonal-seq(5, 3)','let { polygonal-seq } = import("number-theory");\npolygonal-seq(6, 5)','let { polygonal-seq } = import("number-theory");\npolygonal-seq(100, 10)'],seeAlso:["number-theory.polygonal-nth","number-theory.polygonal-take-while","number-theory.polygonal?","number-theory.perfect-square-seq"]},"polygonal-take-while":{category:"number-theory",description:"Generates the polygonal sequence while a condition is met.",returns:{type:"integer",array:!0},args:{sides:{type:"integer",description:"The number of sides of the polygon."},takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."},a:{type:"integer"},b:{type:"function"}},variants:[{argumentNames:["sides","takeWhile"]}],examples:['let { polygonal-take-while } = import("number-theory");\npolygonal-take-while(15, -> $ < 1000)'],seeAlso:["number-theory.polygonal-seq","number-theory.polygonal-nth","number-theory.polygonal?"]},"polygonal-nth":{category:"number-theory",description:"Generates the nth term of the polygonal sequence.",returns:{type:"integer"},args:{sides:{type:"integer",description:"The number of sides of the polygon."},n:{type:"integer",description:"The index of the term to generate."},a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["sides","n"]}],examples:['let { polygonal-nth } = import("number-theory");\npolygonal-nth(3, 9)','let { polygonal-nth } = import("number-theory");\npolygonal-nth(4, 5)','let { polygonal-nth } = import("number-theory");\npolygonal-nth(5, 5)'],seeAlso:["number-theory.polygonal-seq","number-theory.polygonal-take-while","number-theory.polygonal?"]},"polygonal?":{category:"number-theory",description:"Checks if a number is in the polygonal sequence.",returns:{type:"boolean"},args:{sides:{type:"integer",description:"The number of sides of the polygon."},n:{type:"integer",description:"The number to check."},a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["sides","n"]}],examples:['let { polygonal? } = import("number-theory");\npolygonal?(3, 10)','let { polygonal? } = import("number-theory");\npolygonal?(3, 9)','let { polygonal? } = import("number-theory");\npolygonal?(4, 10000)','let { polygonal? } = import("number-theory");\npolygonal?(4, 1000)','let { polygonal? } = import("number-theory");\npolygonal?(6, 45)'],seeAlso:["number-theory.polygonal-seq","number-theory.polygonal-nth","number-theory.perfect-square?","number-theory.polygonal-take-while"]},"prime-seq":{category:"number-theory",description:"Generates the prime sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { prime-seq } = import("number-theory");\nprime-seq(1)','let { prime-seq } = import("number-theory");\nprime-seq(2)','let { prime-seq } = import("number-theory");\nprime-seq(10)'],seeAlso:["number-theory.prime-nth","number-theory.prime-take-while","number-theory.prime?","number-theory.composite-seq","number-theory.mersenne-seq","number-theory.lucky-seq"]},"prime-take-while":{category:"number-theory",description:"Generates the prime sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { prime-take-while } = import("number-theory");\nprime-take-while(-> $ < 50)'],seeAlso:["number-theory.prime-seq","number-theory.prime-nth","number-theory.prime?"]},"prime-nth":{category:"number-theory",description:"Generates the nth term of the prime sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { prime-nth } = import("number-theory");\nprime-nth(1)','let { prime-nth } = import("number-theory");\nprime-nth(2)','let { prime-nth } = import("number-theory");\nprime-nth(10)'],seeAlso:["number-theory.prime-seq","number-theory.prime-take-while","number-theory.prime?"]},"prime?":{category:"number-theory",description:"Determines if a number is prime.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { prime? } = import("number-theory");\nprime?(1)','let { prime? } = import("number-theory");\nprime?(2)','let { prime? } = import("number-theory");\nprime?(3)','let { prime? } = import("number-theory");\nprime?(4)','let { prime? } = import("number-theory");\nprime?(997)','let { prime? } = import("number-theory");\nprime?(1001)'],seeAlso:["number-theory.prime-seq","number-theory.prime-nth","number-theory.composite?","number-theory.prime-factors","number-theory.mersenne?","number-theory.prime-take-while","number-theory.lucky?"]},"recaman-seq":{category:"number-theory",description:"Generates the Recaman sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { recaman-seq } = import("number-theory");\nrecaman-seq(5)','let { recaman-seq } = import("number-theory");\nrecaman-seq(10)','let { recaman-seq } = import("number-theory");\nrecaman-seq(20)'],seeAlso:["number-theory.recaman-nth","number-theory.recaman-take-while","number-theory.recaman?","number-theory.golomb-seq"]},"recaman-take-while":{category:"number-theory",description:"Generates the Recaman sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { recaman-take-while } = import("number-theory");\nrecaman-take-while(-> $ < 10)'],seeAlso:["number-theory.recaman-seq","number-theory.recaman-nth","number-theory.recaman?"]},"recaman-nth":{category:"number-theory",description:"Generates the nth term of the Recaman sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { recaman-nth } = import("number-theory");\nrecaman-nth(5)','let { recaman-nth } = import("number-theory");\nrecaman-nth(10)','let { recaman-nth } = import("number-theory");\nrecaman-nth(20)'],seeAlso:["number-theory.recaman-seq","number-theory.recaman-take-while","number-theory.recaman?"]},"recaman?":{category:"number-theory",description:"Checks if a number is in the Recaman sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { recaman? } = import("number-theory");\nrecaman?(5)','let { recaman? } = import("number-theory");\nrecaman?(10)','let { recaman? } = import("number-theory");\nrecaman?(20)'],seeAlso:["number-theory.recaman-seq","number-theory.recaman-nth","number-theory.recaman-take-while"]},"sylvester-seq":{category:"number-theory",description:"Generates the Sylvester sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate. If not provided, the default is 6 (the maximum length of the pre-calculated Sylvester numbers)."}},variants:[{argumentNames:["length"]},{argumentNames:[]}],examples:['let { sylvester-seq } = import("number-theory");\nsylvester-seq(5)','let { sylvester-seq } = import("number-theory");\nsylvester-seq()','let { sylvester-seq } = import("number-theory");\nsylvester-seq()'],seeAlso:["number-theory.sylvester-nth","number-theory.sylvester-take-while","number-theory.sylvester?"]},"sylvester-take-while":{category:"number-theory",description:"Generates the Sylvester sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { sylvester-take-while } = import("number-theory");\nsylvester-take-while(-> $ < 100000)'],seeAlso:["number-theory.sylvester-seq","number-theory.sylvester-nth","number-theory.sylvester?"]},"sylvester-nth":{category:"number-theory",description:"Generates the nth term of the Sylvester sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { sylvester-nth } = import("number-theory");\nsylvester-nth(1)','let { sylvester-nth } = import("number-theory");\nsylvester-nth(5)'],seeAlso:["number-theory.sylvester-seq","number-theory.sylvester-take-while","number-theory.sylvester?"]},"sylvester?":{category:"number-theory",description:"Checks if a number is in the Sylvester sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { sylvester? } = import("number-theory");\nsylvester?(2)','let { sylvester? } = import("number-theory");\nsylvester?(3)','let { sylvester? } = import("number-theory");\nsylvester?(6)'],seeAlso:["number-theory.sylvester-seq","number-theory.sylvester-nth","number-theory.sylvester-take-while"]},"thue-morse-seq":{category:"number-theory",description:"Generates the Thue-Morse sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { thue-morse-seq } = import("number-theory");\nthue-morse-seq(5)','let { thue-morse-seq } = import("number-theory");\nthue-morse-seq(10)','let { thue-morse-seq } = import("number-theory");\nthue-morse-seq(20)'],seeAlso:["number-theory.thue-morse-nth","number-theory.thue-morse-take-while","number-theory.thue-morse?"]},"thue-morse-take-while":{category:"number-theory",description:"Generates the Thue-Morse sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { thue-morse-take-while } = import("number-theory");\nthue-morse-take-while(-> $2 < 10)'],seeAlso:["number-theory.thue-morse-seq","number-theory.thue-morse-nth","number-theory.thue-morse?"]},"thue-morse-nth":{category:"number-theory",description:"Generates the nth term of the Thue-Morse sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term in the sequence."}},variants:[{argumentNames:["n"]}],examples:['let { thue-morse-nth } = import("number-theory");\nthue-morse-nth(5)','let { thue-morse-nth } = import("number-theory");\nthue-morse-nth(10)','let { thue-morse-nth } = import("number-theory");\nthue-morse-nth(20)'],seeAlso:["number-theory.thue-morse-seq","number-theory.thue-morse-take-while","number-theory.thue-morse?"]},"thue-morse?":{category:"number-theory",description:"Checks if a number is part of the Thue-Morse sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { thue-morse? } = import("number-theory");\nthue-morse?(1)','let { thue-morse? } = import("number-theory");\nthue-morse?(2)'],seeAlso:["number-theory.thue-morse-seq","number-theory.thue-morse-nth","number-theory.thue-morse-take-while"]},"tribonacci-seq":{category:"number-theory",description:"Generates the tribonacci sequence up to a specified length.",returns:{type:"integer",array:!0},args:{length:{type:"integer",description:"The length of the sequence to generate."}},variants:[{argumentNames:["length"]}],examples:['let { tribonacci-seq } = import("number-theory");\ntribonacci-seq(1)','let { tribonacci-seq } = import("number-theory");\ntribonacci-seq(2)','let { tribonacci-seq } = import("number-theory");\ntribonacci-seq(10)'],seeAlso:["number-theory.tribonacci-nth","number-theory.tribonacci-take-while","number-theory.tribonacci?","number-theory.fibonacci-seq"]},"tribonacci-take-while":{category:"number-theory",description:"Generates the tribonacci sequence while a condition is met.",returns:{type:"integer",array:!0},args:{takeWhile:{type:"function",description:"A function that takes an integer and an index and returns a boolean."}},variants:[{argumentNames:["takeWhile"]}],examples:['let { tribonacci-take-while } = import("number-theory");\ntribonacci-take-while(-> $ < 100)'],seeAlso:["number-theory.tribonacci-seq","number-theory.tribonacci-nth","number-theory.tribonacci?"]},"tribonacci-nth":{category:"number-theory",description:"Generates the nth term of the tribonacci sequence.",returns:{type:"integer"},args:{n:{type:"integer",description:"The index of the term to generate."}},variants:[{argumentNames:["n"]}],examples:['let { tribonacci-nth } = import("number-theory");\ntribonacci-nth(1)','let { tribonacci-nth } = import("number-theory");\ntribonacci-nth(2)','let { tribonacci-nth } = import("number-theory");\ntribonacci-nth(10)'],seeAlso:["number-theory.tribonacci-seq","number-theory.tribonacci-take-while","number-theory.tribonacci?"]},"tribonacci?":{category:"number-theory",description:"Determines if a number is in the tribonacci sequence.",returns:{type:"boolean"},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { tribonacci? } = import("number-theory");\ntribonacci?(0)','let { tribonacci? } = import("number-theory");\ntribonacci?(1)','let { tribonacci? } = import("number-theory");\ntribonacci?(2)','let { tribonacci? } = import("number-theory");\ntribonacci?(3)','let { tribonacci? } = import("number-theory");\ntribonacci?(4)','let { tribonacci? } = import("number-theory");\ntribonacci?(5)','let { tribonacci? } = import("number-theory");\ntribonacci?(6)','let { tribonacci? } = import("number-theory");\ntribonacci?(7)','let { tribonacci? } = import("number-theory");\ntribonacci?(8)','let { tribonacci? } = import("number-theory");\ntribonacci?(9)','let { tribonacci? } = import("number-theory");\ntribonacci?(10)'],seeAlso:["number-theory.tribonacci-seq","number-theory.tribonacci-nth","number-theory.fibonacci?","number-theory.tribonacci-take-while"]},"count-combinations":{category:"number-theory",description:"Calculates the number of combinations of n items taken k at a time.",returns:{type:"integer"},args:{a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],examples:['let { count-combinations } = import("number-theory");\ncount-combinations(5, 3)','let { count-combinations } = import("number-theory");\ncount-combinations(10, 2)'],seeAlso:["number-theory.combinations","number-theory.count-permutations","number-theory.factorial","number-theory.multinomial","number-theory.stirling-second","number-theory.count-partitions","number-theory.count-power-set"]},combinations:{category:"number-theory",description:"Generates all possible combinations of a specified size from a collection.",returns:{type:"array",array:!0},args:{set:{type:"array",array:!0,description:"The input collection to generate combinations from."},n:{type:"integer",description:"The size of each combination."},a:{type:"array"},b:{type:"integer"}},variants:[{argumentNames:["set","n"]}],examples:['let { combinations } = import("number-theory");\ncombinations([1, 2, 3], 2)','let { combinations } = import("number-theory");\ncombinations(["a", "b", "c"], 2)','let { combinations } = import("number-theory");\ncombinations([1, 2, 3], 0)','let { combinations } = import("number-theory");\ncombinations([1, 2, 3], 1)','let { combinations } = import("number-theory");\ncombinations([1, 2, 3], 3)'],seeAlso:["number-theory.count-combinations","number-theory.permutations","number-theory.power-set","number-theory.cartesian-product","number-theory.partitions"]},"count-derangements":{category:"number-theory",description:"Calculates the number of derangements (permutations where no element appears in its original position) of n items.",returns:{type:"integer"},args:{n:{type:"integer",description:"The total number of items."}},variants:[{argumentNames:["n"]}],examples:['let { count-derangements } = import("number-theory");\ncount-derangements(4)','let { count-derangements } = import("number-theory");\ncount-derangements(5)'],seeAlso:["number-theory.derangements","number-theory.count-permutations","number-theory.factorial"]},derangements:{category:"number-theory",description:"Generates all derangements (permutations where no element appears in its original position) of a set.",returns:{type:"array",array:!0},args:{set:{type:"array",array:!0,description:"The input collection to generate derangements from."}},variants:[{argumentNames:["set"]}],examples:['let { derangements } = import("number-theory");\nderangements([1, 2, 3, 4])','let { derangements } = import("number-theory");\nderangements(["a", "b", "c"])'],seeAlso:["number-theory.count-derangements","number-theory.permutations"]},divisors:{category:"number-theory",description:"Returns the divisors of a number.",returns:{type:"integer",array:!0},args:{n:{type:"integer",description:"The number to find divisors for."}},variants:[{argumentNames:["n"]}],examples:['let { divisors } = import("number-theory");\ndivisors(12)','let { divisors } = import("number-theory");\ndivisors(100)','let { divisors } = import("number-theory");\ndivisors(37)'],seeAlso:["number-theory.count-divisors","number-theory.proper-divisors","number-theory.sigma","number-theory.prime-factors","number-theory.divisible-by?","number-theory.lcm","number-theory.abundant?","number-theory.deficient?","number-theory.count-proper-divisors"]},"count-divisors":{category:"number-theory",description:"Returns the number of divisors of a number.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to count divisors for."}},variants:[{argumentNames:["n"]}],examples:['let { count-divisors } = import("number-theory");\ncount-divisors(12)','let { count-divisors } = import("number-theory");\ncount-divisors(100)','let { count-divisors } = import("number-theory");\ncount-divisors(37)'],seeAlso:["number-theory.divisors","number-theory.count-proper-divisors","number-theory.sigma"]},"proper-divisors":{category:"number-theory",description:"Returns the proper divisors of a number.",returns:{type:"integer",array:!0},args:{n:{type:"integer",description:"The number to find proper divisors for."}},variants:[{argumentNames:["n"]}],examples:['let { proper-divisors } = import("number-theory");\nproper-divisors(12)','let { proper-divisors } = import("number-theory");\nproper-divisors(100)','let { proper-divisors } = import("number-theory");\nproper-divisors(37)'],seeAlso:["number-theory.count-proper-divisors","number-theory.divisors","number-theory.amicable?","number-theory.perfect?"]},"count-proper-divisors":{category:"number-theory",description:"Returns the number of proper divisors of a number.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to count proper divisors for."}},variants:[{argumentNames:["n"]}],examples:['let { count-proper-divisors } = import("number-theory");\ncount-proper-divisors(12)','let { count-proper-divisors } = import("number-theory");\ncount-proper-divisors(100)','let { count-proper-divisors } = import("number-theory");\ncount-proper-divisors(37)'],seeAlso:["number-theory.proper-divisors","number-theory.count-divisors","number-theory.divisors"]},factorial:{category:"number-theory",description:"Calculates the factorial of a number.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to calculate the factorial for."}},variants:[{argumentNames:["n"]}],examples:['let { factorial } = import("number-theory");\nfactorial(5)','let { factorial } = import("number-theory");\nfactorial(0)','let { factorial } = import("number-theory");\nfactorial(10)','let { factorial } = import("number-theory");\nfactorial(20)'],seeAlso:["number-theory.factorial-seq","number-theory.factorial-nth","number-theory.factorial?","number-theory.count-combinations","number-theory.count-permutations","number-theory.multinomial","number-theory.count-derangements"]},partitions:{category:"number-theory",description:"Generates all partitions of a number.",returns:{type:"array",array:!0},args:{n:{type:"integer",description:"The number to partition."}},variants:[{argumentNames:["n"]}],examples:['let { partitions } = import("number-theory");\npartitions(4)','let { partitions } = import("number-theory");\npartitions(8)'],seeAlso:["number-theory.count-partitions","number-theory.partition-seq","number-theory.combinations","number-theory.partition?"]},"count-partitions":{category:"number-theory",description:"Returns the number of partitions of a number.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to count partitions for."}},variants:[{argumentNames:["n"]}],examples:['let { count-partitions } = import("number-theory");\ncount-partitions(4)','let { count-partitions } = import("number-theory");\ncount-partitions(8)','let { count-partitions } = import("number-theory");\ncount-partitions(15)'],seeAlso:["number-theory.partitions","number-theory.partition-seq","number-theory.count-combinations"]},permutations:{category:"number-theory",description:"Generates all permutations of a collection.",returns:{type:"array",array:!0},args:{set:{type:"array",array:!0,description:"The input collection to generate permutations from."}},variants:[{argumentNames:["set"]}],examples:['let { permutations } = import("number-theory");\npermutations([1, 2, 3])','let { permutations } = import("number-theory");\npermutations(["a", "b", "c"])','let { permutations } = import("number-theory");\npermutations([1, 2, 3, 4])','let { permutations } = import("number-theory");\npermutations([1, 2])','let { permutations } = import("number-theory");\npermutations([1])','let { permutations } = import("number-theory");\npermutations([])'],seeAlso:["number-theory.count-permutations","number-theory.combinations","number-theory.derangements","number-theory.cartesian-product"]},"count-permutations":{category:"number-theory",description:"Returns the number of permutations of n items taken k at a time.",returns:{type:"integer"},args:{a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],examples:['let { count-permutations } = import("number-theory");\ncount-permutations(5, 3)','let { count-permutations } = import("number-theory");\ncount-permutations(10, 2)','let { count-permutations } = import("number-theory");\ncount-permutations(10, 10)','let { count-permutations } = import("number-theory");\ncount-permutations(10, 0)','let { count-permutations } = import("number-theory");\ncount-permutations(10, 1)'],seeAlso:["number-theory.permutations","number-theory.count-combinations","number-theory.factorial","number-theory.multinomial","number-theory.stirling-first","number-theory.count-derangements"]},"power-set":{category:"number-theory",description:"Generates the power set of a collection.",returns:{type:"array",array:!0},args:{set:{type:"any",array:!0,description:"The input collection to generate the power set from."}},variants:[{argumentNames:["set"]}],examples:['let { power-set } = import("number-theory");\npower-set(["a", "b", "c"])','let { power-set } = import("number-theory");\npower-set([1, 2])','let { power-set } = import("number-theory");\npower-set([1])','let { power-set } = import("number-theory");\npower-set([])'],seeAlso:["number-theory.count-power-set","number-theory.combinations","number-theory.cartesian-product"]},"count-power-set":{category:"number-theory",description:"Returns the number of subsets of a set.",returns:{type:"integer"},args:{n:{type:"integer",description:"The size of the set."}},variants:[{argumentNames:["n"]}],examples:['let { count-power-set } = import("number-theory");\ncount-power-set(3)','let { count-power-set } = import("number-theory");\ncount-power-set(5)','let { count-power-set } = import("number-theory");\ncount-power-set(10)'],seeAlso:["number-theory.power-set","number-theory.count-combinations"]},"prime-factors":{category:"number-theory",description:"Returns the prime factors of a number.",returns:{type:"integer",array:!0},args:{n:{type:"integer",description:"The number to factor."}},variants:[{argumentNames:["n"]}],examples:['let { prime-factors } = import("number-theory");\nprime-factors(12)','let { prime-factors } = import("number-theory");\nprime-factors(100)','let { prime-factors } = import("number-theory");\nprime-factors(37)'],seeAlso:["number-theory.count-prime-factors","number-theory.distinct-prime-factors","number-theory.prime?","number-theory.divisors","number-theory.euler-totient","number-theory.mobius","number-theory.composite?","number-theory.count-distinct-prime-factors"]},"count-prime-factors":{category:"number-theory",description:"Returns the number of prime factors of a number.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to count prime factors for."}},variants:[{argumentNames:["n"]}],examples:['let { count-prime-factors } = import("number-theory");\ncount-prime-factors(12)','let { count-prime-factors } = import("number-theory");\ncount-prime-factors(100)','let { count-prime-factors } = import("number-theory");\ncount-prime-factors(37)'],seeAlso:["number-theory.prime-factors","number-theory.distinct-prime-factors","number-theory.count-distinct-prime-factors"]},"distinct-prime-factors":{category:"number-theory",description:"Returns the distinct prime factors of a number.",returns:{type:"integer",array:!0},args:{n:{type:"integer",description:"The number to find distinct prime factors for."}},variants:[{argumentNames:["n"]}],examples:['let { distinct-prime-factors } = import("number-theory");\ndistinct-prime-factors(12)','let { distinct-prime-factors } = import("number-theory");\ndistinct-prime-factors(100)','let { distinct-prime-factors } = import("number-theory");\ndistinct-prime-factors(37)'],seeAlso:["number-theory.prime-factors","number-theory.count-distinct-prime-factors","number-theory.count-prime-factors"]},"count-distinct-prime-factors":{category:"number-theory",description:"Returns the number of distinct prime factors of a number.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to count distinct prime factors for."}},variants:[{argumentNames:["n"]}],examples:['let { count-distinct-prime-factors } = import("number-theory");\ncount-distinct-prime-factors(12)','let { count-distinct-prime-factors } = import("number-theory");\ncount-distinct-prime-factors(100)','let { count-distinct-prime-factors } = import("number-theory");\ncount-distinct-prime-factors(37)'],seeAlso:["number-theory.distinct-prime-factors","number-theory.prime-factors","number-theory.count-prime-factors"]},"coprime?":{category:"number-theory",description:"Checks if two numbers are coprime (i.e., their GCD is 1).",returns:{type:"boolean"},args:{a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],examples:['let { coprime? } = import("number-theory");\ncoprime?(12, 8)','let { coprime? } = import("number-theory");\ncoprime?(12, 5)','let { coprime? } = import("number-theory");\ncoprime?(37, 1)','let { coprime? } = import("number-theory");\ncoprime?(0, 0)','let { coprime? } = import("number-theory");\ncoprime?(0, 5)','let { coprime? } = import("number-theory");\ncoprime?(5, 0)','let { coprime? } = import("number-theory");\ncoprime?(1, 0)','let { coprime? } = import("number-theory");\ncoprime?(0, 1)','let { coprime? } = import("number-theory");\ncoprime?(1, 1)','let { coprime? } = import("number-theory");\ncoprime?(2, 3)'],seeAlso:["number-theory.gcd","number-theory.euler-totient","number-theory.divisible-by?","number-theory.lcm","number-theory.carmichael-lambda"]},"divisible-by?":{category:"number-theory",description:"Checks if a number is divisible by another number.",returns:{type:"boolean"},args:{a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],examples:['let { divisible-by? } = import("number-theory");\ndivisible-by?(12, 4)','let { divisible-by? } = import("number-theory");\ndivisible-by?(12, 5)','let { divisible-by? } = import("number-theory");\ndivisible-by?(37, 1)','let { divisible-by? } = import("number-theory");\ndivisible-by?(0, 0)','let { divisible-by? } = import("number-theory");\ndivisible-by?(0, 5)','let { divisible-by? } = import("number-theory");\ndivisible-by?(5, 0)'],seeAlso:["number-theory.divisors","number-theory.gcd","number-theory.coprime?"]},gcd:{category:"number-theory",description:"Calculates the greatest common divisor (GCD) of two numbers.",returns:{type:"integer"},args:{a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],examples:['let { gcd } = import("number-theory");\ngcd(100, 25)','let { gcd } = import("number-theory");\ngcd(37, 1)','let { gcd } = import("number-theory");\ngcd(0, 0)','let { gcd } = import("number-theory");\ngcd(0, 5)','let { gcd } = import("number-theory");\ngcd(5, 0)'],seeAlso:["number-theory.lcm","number-theory.extended-gcd","number-theory.coprime?","number-theory.divisible-by?"]},lcm:{category:"number-theory",description:"Calculates the least common multiple (LCM) of two numbers.",returns:{type:"integer"},args:{a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],examples:['let { lcm } = import("number-theory");\nlcm(100, 25)','let { lcm } = import("number-theory");\nlcm(37, 1)','let { lcm } = import("number-theory");\nlcm(0, 5)','let { lcm } = import("number-theory");\nlcm(5, 0)'],seeAlso:["number-theory.gcd","number-theory.divisors","number-theory.coprime?"]},multinomial:{category:"number-theory",description:"Calculates the multinomial coefficient from of a list of numbers representing the sizes of each group.",returns:{type:"integer"},args:{args:{type:"integer",rest:!0,description:"The numbers representing the sizes of each group."}},variants:[{argumentNames:["args"]}],examples:['let { multinomial } = import("number-theory");\nmultinomial(5, 2, 3)','let { multinomial } = import("number-theory");\nmultinomial(10, 2, 3, 5)'],seeAlso:["number-theory.count-combinations","number-theory.factorial","number-theory.count-permutations"],hideOperatorForm:!0},"amicable?":{category:"number-theory",description:"Checks if two numbers are amicable (i.e., the sum of the proper divisors of each number equals the other number).",returns:{type:"boolean"},args:{a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],examples:['let { amicable? } = import("number-theory");\namicable?(220, 284)','let { amicable? } = import("number-theory");\namicable?(1184, 1210)','let { amicable? } = import("number-theory");\namicable?(2620, 2924)','let { amicable? } = import("number-theory");\namicable?(5020, 5564)','let { amicable? } = import("number-theory");\namicable?(6232, 6368)'],seeAlso:["number-theory.proper-divisors","number-theory.perfect?","number-theory.sigma","number-theory.perfect-seq"]},"euler-totient":{category:"number-theory",description:"Calculates the Euler's totient function (φ(n)) of a number, which counts the integers up to n that are coprime to n.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to calculate the totient for."}},variants:[{argumentNames:["n"]}],examples:['let { euler-totient } = import("number-theory");\neuler-totient(1)','let { euler-totient } = import("number-theory");\neuler-totient(2)','let { euler-totient } = import("number-theory");\neuler-totient(10)','let { euler-totient } = import("number-theory");\neuler-totient(20)'],seeAlso:["number-theory.coprime?","number-theory.carmichael-lambda","number-theory.mobius","number-theory.prime-factors","number-theory.mertens"]},mobius:{category:"number-theory",description:"Calculates the Möbius function (μ(n)) of a number, which is used in number theory.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to calculate the Möbius function for."}},variants:[{argumentNames:["n"]}],examples:['let { mobius } = import("number-theory");\nmobius(1)','let { mobius } = import("number-theory");\nmobius(2)','let { mobius } = import("number-theory");\nmobius(3)','let { mobius } = import("number-theory");\nmobius(4)','let { mobius } = import("number-theory");\nmobius(6)','let { mobius } = import("number-theory");\nmobius(12)','let { mobius } = import("number-theory");\nmobius(30)'],seeAlso:["number-theory.mertens","number-theory.euler-totient","number-theory.prime-factors"]},mertens:{category:"number-theory",description:"Calculates the Mertens function (M(n)) of a number, which is the sum of the Möbius function up to n.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to calculate the Mertens function for."}},variants:[{argumentNames:["n"]}],examples:['let { mobius } = import("number-theory");\nmobius(1)','let { mobius } = import("number-theory");\nmobius(2)','let { mobius } = import("number-theory");\nmobius(3)','let { mobius } = import("number-theory");\nmobius(4)','let { mobius } = import("number-theory");\nmobius(6)','let { mobius } = import("number-theory");\nmobius(12)','let { mobius } = import("number-theory");\nmobius(30)'],seeAlso:["number-theory.mobius","number-theory.euler-totient"]},sigma:{category:"number-theory",description:"Calculates the sum of divisors function (σ(n)) of a number, which is the sum of all positive divisors of n.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to calculate the sum of divisors for."}},variants:[{argumentNames:["n"]}],examples:['let { sigma } = import("number-theory");\nsigma(1)','let { sigma } = import("number-theory");\nsigma(2)','let { sigma } = import("number-theory");\nsigma(3)','let { sigma } = import("number-theory");\nsigma(4)','let { sigma } = import("number-theory");\nsigma(6)','let { sigma } = import("number-theory");\nsigma(12)','let { sigma } = import("number-theory");\nsigma(30)'],seeAlso:["number-theory.divisors","number-theory.perfect?","number-theory.abundant?","number-theory.deficient?","number-theory.amicable?","number-theory.count-divisors"]},"carmichael-lambda":{category:"number-theory",description:"Calculates the Carmichael function (λ(n)) of a number, which is the smallest positive integer m such that a^m ≡ 1 (mod n) for all integers a coprime to n.",returns:{type:"integer"},args:{n:{type:"integer",description:"The number to calculate the Carmichael function for."}},variants:[{argumentNames:["n"]}],examples:['let { carmichael-lambda } = import("number-theory");\ncarmichael-lambda(1)','let { carmichael-lambda } = import("number-theory");\ncarmichael-lambda(2)','let { carmichael-lambda } = import("number-theory");\ncarmichael-lambda(3)','let { carmichael-lambda } = import("number-theory");\ncarmichael-lambda(4)','let { carmichael-lambda } = import("number-theory");\ncarmichael-lambda(6)','let { carmichael-lambda } = import("number-theory");\ncarmichael-lambda(12)','let { carmichael-lambda } = import("number-theory");\ncarmichael-lambda(30)'],seeAlso:["number-theory.euler-totient","number-theory.mod-exp","number-theory.coprime?"]},"cartesian-product":{category:"number-theory",description:"Calculates the Cartesian product of two or more sets.",returns:{type:"array",array:!0},args:{sets:{type:"array",array:!0,description:"The input collections to calculate the Cartesian product from."},a:{type:"array"},b:{type:"array"}},variants:[{argumentNames:["sets"]}],examples:['let { cartesian-product } = import("number-theory");\ncartesian-product([1, 2], ["a", "b"])','let { cartesian-product } = import("number-theory");\ncartesian-product([1, 2], ["a", "b"], [true, false])','let { cartesian-product } = import("number-theory");\ncartesian-product([1, 2, 3], ["x", "y", "z"])'],seeAlso:["number-theory.combinations","number-theory.power-set","number-theory.permutations"]},"perfect-power":{category:"number-theory",description:"Returns a tuple of the base and exponent if the number is a perfect power, otherwise returns null.",returns:{type:"array",array:!0},args:{n:{type:"integer",description:"The number to check."}},variants:[{argumentNames:["n"]}],examples:['let { perfect-power } = import("number-theory");\nperfect-power(1)','let { perfect-power } = import("number-theory");\nperfect-power(2)','let { perfect-power } = import("number-theory");\nperfect-power(4)','let { perfect-power } = import("number-theory");\nperfect-power(8)','let { perfect-power } = import("number-theory");\nperfect-power(9)','let { perfect-power } = import("number-theory");\nperfect-power(16)','let { perfect-power } = import("number-theory");\nperfect-power(19)'],seeAlso:["number-theory.perfect-power?","number-theory.perfect-power-seq","number-theory.perfect-square?","number-theory.perfect-cube?"]},"mod-exp":{category:"number-theory",description:"Calculates the modular exponentiation of a base raised to an exponent modulo a modulus.",returns:{type:"integer"},args:{base:{type:"integer"},exponent:{type:"integer"},modulus:{type:"integer"}},variants:[{argumentNames:["base","exponent","modulus"]}],examples:['let { mod-exp } = import("number-theory");\nmod-exp(2, 3, 5)','let { mod-exp } = import("number-theory");\nmod-exp(3, 4, 7)','let { mod-exp } = import("number-theory");\nmod-exp(5, 6, 11)','let { mod-exp } = import("number-theory");\nmod-exp(7, 8, 13)'],seeAlso:["number-theory.mod-inv","number-theory.carmichael-lambda","number-theory.chinese-remainder"]},"mod-inv":{category:"number-theory",description:"Calculates the modular multiplicative inverse of a number modulo another number.",returns:{type:"integer"},args:{a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["a","m"]}],examples:['let { mod-inv } = import("number-theory");\nmod-inv(3, 11)','let { mod-inv } = import("number-theory");\nmod-inv(10, 17)','let { mod-inv } = import("number-theory");\nmod-inv(5, 13)','let { mod-inv } = import("number-theory");\nmod-inv(7, 19)'],seeAlso:["number-theory.mod-exp","number-theory.extended-gcd","number-theory.chinese-remainder"]},"extended-gcd":{category:"number-theory",description:"Calculates the extended greatest common divisor (GCD) of two numbers, returning the GCD and the coefficients of Bézout's identity.",returns:{type:"integer",array:!0},args:{a:{type:"integer"},b:{type:"integer"}},variants:[{argumentNames:["a","b"]}],examples:['let { extended-gcd } = import("number-theory");\nextended-gcd(30, 12)','let { extended-gcd } = import("number-theory");\nextended-gcd(56, 98)','let { extended-gcd } = import("number-theory");\nextended-gcd(101, 10)','let { extended-gcd } = import("number-theory");\nextended-gcd(17, 13)'],seeAlso:["number-theory.gcd","number-theory.mod-inv","number-theory.chinese-remainder"]},"chinese-remainder":{category:"number-theory",description:"Solves a system of simultaneous congruences using the Chinese Remainder Theorem.",returns:{type:"integer"},args:{remainders:{type:"integer",array:!0,description:"The remainders of the congruences."},moduli:{type:"integer",array:!0,description:"The moduli of the congruences."},a:{type:"array"},b:{type:"array"}},variants:[{argumentNames:["remainders","moduli"]}],examples:['let { chinese-remainder } = import("number-theory");\nchinese-remainder([2, 3], [3, 5])','let { chinese-remainder } = import("number-theory");\nchinese-remainder([1, 2], [3, 4])','let { chinese-remainder } = import("number-theory");\nchinese-remainder([0, 1], [2, 3])','let { chinese-remainder } = import("number-theory");\nchinese-remainder([1, 2, 3], [4, 5, 7])'],seeAlso:["number-theory.mod-exp","number-theory.mod-inv","number-theory.extended-gcd"]},"stirling-first":{category:"number-theory",description:"Calculates the Stirling numbers of the first kind, which count the number of permutations of n elements with k cycles.",returns:{type:"integer"},args:{a:{type:"integer",description:"The number of elements."},b:{type:"integer",description:"The number of cycles."}},variants:[{argumentNames:["a","b"]}],examples:['let { stirling-first } = import("number-theory");\nstirling-first(5, 2)','let { stirling-first } = import("number-theory");\nstirling-first(4, 3)','let { stirling-first } = import("number-theory");\nstirling-first(6, 1)','let { stirling-first } = import("number-theory");\nstirling-first(7, 4)','let { stirling-first } = import("number-theory");\nstirling-first(8, 5)'],seeAlso:["number-theory.stirling-second","number-theory.bell-seq","number-theory.count-permutations"]},"stirling-second":{category:"number-theory",description:"Calculates the Stirling numbers of the second kind, which count the number of ways to partition n elements into k non-empty subsets.",returns:{type:"integer"},args:{a:{type:"integer",description:"The number of elements."},b:{type:"integer",description:"The number of subsets."}},variants:[{argumentNames:["a","b"]}],examples:['let { stirling-second } = import("number-theory");\nstirling-second(5, 2)','let { stirling-second } = import("number-theory");\nstirling-second(4, 3)','let { stirling-second } = import("number-theory");\nstirling-second(6, 1)','let { stirling-second } = import("number-theory");\nstirling-second(7, 4)','let { stirling-second } = import("number-theory");\nstirling-second(8, 5)'],seeAlso:["number-theory.stirling-first","number-theory.bell-seq","number-theory.count-combinations"]}};function binomialCoefficient(e,t){if(0===t||t===e)return 1;let r=1;for(let n=0;n<t;n++)r*=(e-n)/(n+1);return r}function combinations(e,t){if(1===t)return e.map(e=>[e]);const r=[];for(let n=0;n<=e.length-t;n++){const o=e[n],a=combinations(e.slice(n+1),t-1);for(const e of a)r.push([o,...e])}return r}const combinationsNormalExpressions={combinations:{evaluate:([e,t],r)=>(assertArray(e,r),assertNumber(t,r,{integer:!0,nonNegative:!0,lte:e.length}),0===t?[[]]:combinations(e,t)),arity:toFixedArity(2)},"count-combinations":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0,nonNegative:!0}),assertNumber(t,r,{integer:!0,nonNegative:!0,lte:e}),binomialCoefficient(e,t)),arity:toFixedArity(2)}};function getAllDerangements(e){const t=e.length,r=[],n=Array.from({length:t},()=>!1),o=Array.from({length:t});return function a(i){if(i!==t)for(let r=0;r<t;r++)n[r]||r===i||(n[r]=!0,o[i]=e[r],a(i+1),n[r]=!1);else r.push([...o])}(0),r}function countDerangements(e){if(1===e)return 0;let t=1,r=0,n=0;for(let o=2;o<=e;o++)n=(o-1)*(t+r),t=r,r=n;return n}const derangementsNormalExpressions={derangements:{evaluate:([e],t)=>(assertArray(e,t),getAllDerangements(e)),arity:toFixedArity(1)},"count-derangements":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0,integer:!0,positive:!0}),countDerangements(e)),arity:toFixedArity(1)}};function calcUnsortedDivisors(e){const t=[];for(let r=1;r<=Math.sqrt(e);r++)e%r===0&&(t.push(r),r!==e/r&&t.push(e/r));return t}function getDivisors(e){return calcUnsortedDivisors(e).sort((e,t)=>e-t)}function getProperDivisors(e){return getDivisors(e).slice(0,-1)}const divisorsNormalExpressions={divisors:{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0,integer:!0,positive:!0}),getDivisors(e)),arity:toFixedArity(1)},"count-divisors":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0,integer:!0,positive:!0}),calcUnsortedDivisors(e).length),arity:toFixedArity(1)},"proper-divisors":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0,integer:!0,positive:!0}),getProperDivisors(e)),arity:toFixedArity(1)},"count-proper-divisors":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0,integer:!0,positive:!0}),calcUnsortedDivisors(e).length-1),arity:toFixedArity(1)}},factorialNumbers=[1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87178291200,1307674368e3,20922789888e3,355687428096e3,6402373705728e3];function factorialOf(e){if(e<0)throw new Error("Factorial is not defined for negative numbers");if(0===e||1===e)return 1;if(e<=18)return factorialNumbers[e];let t=factorialNumbers[18];for(let r=19;r<=e;r++)t*=r;return t}const factorialNormalExpressions={factorial:{evaluate:([e],t)=>(assertNumber(e,t,{integer:!0,nonNegative:!0,lte:170}),factorialOf(e)),arity:toFixedArity(1)}},partitionNumbers=[1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1255,1575,1958,2436,3010,3718,4565,5604,6842,8349,10143,12310,14883,17977,21637,26015,31185,37338,44583,53174,63261,75175,89134,105558,124754,147273,173525,204226,239943,281589,329931,386155,451276,526823,614154,715220,831820,966467,1121505,1300156,1505499,1741630,2012558,2323520,2679689,3087735,3554345,4087968,4697205,5392783,6185689,7089500,8118264,9289091,10619863,12132164,13848650,15796476,18004327,20506255,23338469,26543660,30167357,34262962,38887673,44108109,49995925,56634173,64112359,72533807,82010177,92669720,104651419,118114304,133230930,150198136,169229875,190569292,214481126,241265379,271248950,304801365,342325709,384276336,431149389,483502844,541946240,607163746,679903203,761002156,851376628,952050665,1064144451,1188908248,1327710076,1482074143,1653668665,1844349560,2056148051,2291320912,2552338241,2841940500,3163127352,3519222692,3913864295,4351078600,4835271870,5371315400,5964539504,6620830889,7346629512,8149040695,9035836076,10015581680,11097645016,12292341831,13610949895,15065878135,16670689208,18440293320,20390982757,22540654445,24908858009,27517052599,30388671978,33549419497,37027355200,40853235313,45060624582,49686288421,54770336324,60356673280,66493182097,73232243759,80630964769,88751778802,97662728555,107438159466,118159068427,129913904637,142798995930,156919475295,172389800255,189334822579,207890420102,228204732751,250438925115,274768617130,301384802048,330495499613,362326859895,397125074750,435157697830,476715857290,522115831195,571701605655,625846753120,684957390936,749474411781,819876908323,896684817527,980462880430,0xf98dace281,1171432692373,1280011042268,1398341745571,1527273599625,1667727404093,1820701100652,1987276856363,2168627105469,2366022741845,2580840212973,2814570987591,3068829878530,3345365983698,3646072432125,3972999029388,4328363658647,4714566886083,5134205287973,5590088317495,6085253859260,6622987708040,7206841706490,7840656226137,8528581302375,9275102575355,0x92c1cc50847,0x9f8afdf968b,0xad6918d4f36,0xbc72dde1287,0xccc0de0d1d7,0xde6da02b061,0xf195c5ba10a,18028182516671,19573856161145,21248279009367,23061871173849,25025873760111,27152408925615,29454549941750,31946390696157,34643126322519,37561133582570,40718063627362,44132934884255,47826239745920,51820051838712,56138148670947,60806135438329,65851585970275,71304185514919,77195892663512,83561103925871,90436839668817,97862933703585,0x604ca1b434ad,0x682ca0bc6d4e,0x70ad06a4328b,0x79da3e8e4df8,0x83c1a359c63d,0x8e7190d8114a,0x99f976fff202,0xa669edb53a4a,0xb3d4caca1bc8,0xc24d38b78151,0xd1e7cfd30909,0xe2bab064772f,0xf4dd9f8523e3,290726957916112,313891991306665,338854264248680,365749566870782,394723676655357,425933084409356,459545750448675,495741934760846,534715062908609,576672674947168,621837416509615,670448123060170,722760953690372,779050629562167,839611730366814,904760108316360,974834369944625,0x3bb262854d36d,0x404dafd2efa2e,0x4541ae2536f6d,0x4a94ddd83ba57,0x504e363fd1eca,0x56752ddfc97e7,0x5d11c356f6b53,0x642c86bff69f5,0x6bcea3db036a0,0x7401ecbfdbd63,0x7cd0e571c49d4,0x8646d010a1b6f,0x906fba0855202,0x9b5889f52508f,0xa70f0ea631153,0xb3a20ef033ec5,0xc1215ac210755,0xcf9ddd28cfa8d,0xdf29afbd9f60e,0xefd82f26a7157,4534253126900886,4872038056472084,5234371069753672,5622992691950605,6039763882095515,6486674127079088,6965850144195831,7479565078510584,8030248384943040,8620496275465025];function partitions(e){if(e<=0)return[[]];if(1===e)return[[1]];const t=[];return function e(r,n,o){if(0!==r)for(let t=Math.min(n,r);t>=1;t--)o.push(t),e(r-t,t,o),o.pop();else t.push([...o])}(e,e,[]),t}const partitionsNormalExpressions={partitions:{evaluate:([e],t)=>(assertNumber(e,t,{integer:!0,nonNegative:!0}),partitions(e)),arity:toFixedArity(1)},"count-partitions":{evaluate:([e],t)=>{if(assertNumber(e,t,{integer:!0,nonNegative:!0}),0===e)return 1;if(e>partitionNumbers.length)throw new LitsError(`n is too large. The maximum value is ${partitionNumbers.length-1}.`,t);return partitionNumbers[e-1]},arity:toFixedArity(1)}};function permutations(e){if(0===e.length)return[[]];const t=[];for(let r=0;r<e.length;r++){const n=e[r],o=permutations([...e.slice(0,r),...e.slice(r+1)]);for(const e of o)t.push([n,...e])}return t}const permutationsNormalExpressions={permutations:{evaluate:([e],t)=>(assertArray(e,t),permutations(e)),arity:toFixedArity(1)},"count-permutations":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0,nonNegative:!0}),assertNumber(t,r,{integer:!0,nonNegative:!0,lte:e}),factorialOf(e)/factorialOf(e-t)),arity:toFixedArity(2)}};function powerSet(e){const t=[[]];for(const r of e){const e=t.map(e=>[...e,r]);t.push(...e)}return t}const powerSetNormalExpressions={"power-set":{evaluate:([e],t)=>(assertArray(e,t),powerSet(e)),arity:toFixedArity(1)},"count-power-set":{evaluate:([e],t)=>(assertNumber(e,t,{integer:!0,nonNegative:!0}),e>=53?1/0:2**e),arity:toFixedArity(1)}};function primeFactors(e){if(1===e)return[];const t=[];let r=2;for(;e>1;)e%r===0?(t.push(r),e/=r):r++;return t}const primeFactorsNormalExpressions={"prime-factors":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0,integer:!0,positive:!0}),primeFactors(e)),arity:toFixedArity(1)},"distinct-prime-factors":{evaluate:([e],t)=>{assertNumber(e,t,{finite:!0,integer:!0,positive:!0});const r=primeFactors(e),n=new Set(r);return Array.from(n)},arity:toFixedArity(1)},"count-prime-factors":{evaluate:([e],t)=>(assertNumber(e,t,{finite:!0,integer:!0,positive:!0}),primeFactors(e).length),arity:toFixedArity(1)},"count-distinct-prime-factors":{evaluate:([e],t)=>{assertNumber(e,t,{finite:!0,integer:!0,positive:!0});const r=primeFactors(e);return new Set(r).size},arity:toFixedArity(1)}};function isAbundant(e){return getProperDivisors(e).reduce((e,t)=>e+t,0)>e}const abundantSequence={"abundant-seq":e=>{const t=[];let r=2;for(;t.length<e;)isAbundant(r)&&t.push(r),r+=1;return t},"abundant?":e=>isAbundant(e),"abundant-take-while":e=>{const t=[];return function r(n){return isAbundant(n)?chain(e(n,t.length),e=>e?(t.push(n),r(n+1)):t):r(n+1)}(2)}};function isInArithmeticSequence(e,t,r){if(0===t)return approxEqual(r,e);const n=(r-e)/t;if(n<0)return!1;const o=Math.round(n),a=e+t*o;return approxEqual(n,o)&&approxEqual(a,r)}const arithmeticNormalExpressions={"arithmetic-seq":{evaluate:([e,t,r],n)=>(assertNumber(e,n,{finite:!0}),assertNumber(t,n,{finite:!0}),assertNumber(r,n,{integer:!0,positive:!0}),Array.from({length:r},(r,n)=>e+n*t)),arity:toFixedArity(3)},"arithmetic-take-while":{evaluate:([e,t,r],n,o,{executeFunction:a})=>{assertNumber(e,n,{finite:!0}),assertNumber(t,n,{finite:!0}),assertFunctionLike(r,n);const i=e,s=t,c=r,l=[];return function e(t){const r=i+t*s;return chain(a(c,[r,t],o,n),n=>n?(l.push(r),e(t+1)):l)}(0)},arity:toFixedArity(3)},"arithmetic-nth":{evaluate:([e,t,r],n)=>(assertNumber(e,n,{finite:!0}),assertNumber(t,n,{finite:!0}),assertNumber(r,n,{integer:!0,positive:!0}),e+(r-1)*t),arity:toFixedArity(3)},"arithmetic?":{evaluate:([e,t,r],n)=>(assertNumber(r,n),assertNumber(e,n,{finite:!0}),assertNumber(t,n,{finite:!0}),isInArithmeticSequence(e,t,r)),arity:toFixedArity(3)}},bellNumbers=[1,2,5,15,52,203,877,4140,21147,115975,678570,4213597,27644437,190899322,1382958545,10480142147,82864869804,682076806159,5832742205057,51724158235372,474869816156751,4506715738447323];function getBernoulliSeq(e){const t=[1];for(let r=1;r<e;r+=1){let e=0;for(let n=0;n<r;n+=1)e+=binomialCoefficient(r+1,n)*t[n];t[r]=r>1&&r%2==1?0:-e/(r+1)}return t}function generateBernoulli(e){const t=[1];return function r(n){let o=0;for(let e=0;e<n;e++)o+=binomialCoefficient(n+1,e)*t[e];const a=n>1&&n%2==1?0:-o/(n+1);return chain(e(a,n),e=>e?(t.push(a),r(n+1)):t)}(1)}const bernoulliNormalExpressions={"bernoulli-seq":{evaluate:([e],t)=>(assertNumber(e,t,{integer:!0,positive:!0}),getBernoulliSeq(e)),arity:toFixedArity(1)},"bernoulli-nth":{evaluate:([e],t)=>{assertNumber(e,t,{integer:!0,positive:!0});return getBernoulliSeq(e)[e-1]},arity:toFixedArity(1)},"bernoulli-take-while":{evaluate:([e],t,r,{executeFunction:n})=>{assertFunctionLike(e,t);const o=e;return generateBernoulli((e,t)=>chain(n(o,[e,t],r),e=>!!e))},arity:toFixedArity(1)}},catalanNumbers=[1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190,6564120420,24466267020,91482563640,343059613650,1289904147324,4861946401452,18367353072152,69533550916004,0xefe09af96cd8,0x38f88b34d6a68,0xd8db5c347b610],collatzSequence={"collatz-seq":e=>{let t=e;const r=[t];for(;1!==t;)t%2==0?t/=2:t=3*t+1,r.push(t);return r},noNth:!0};function isPrime(e){if(e<=1)return!1;if(e<=3)return!0;if(e%2==0||e%3==0)return!1;for(let t=5;t*t<=e;t+=6)if(e%t===0||e%(t+2)===0)return!1;return!0}const primeSequence={"prime-seq":e=>{const t=[];let r=2;for(;t.length<e;)isPrime(r)&&t.push(r),r+=1;return t},"prime?":e=>isPrime(e),"prime-take-while":e=>{const t=[];return function r(n){return isPrime(n)?chain(e(n,t.length),e=>e?(t.push(n),r(n+1)):t):r(n+1)}(2)}};function isComposite(e){return!(e<=1)&&!isPrime(e)}const compositeSequence={"composite-seq":e=>{const t=[];let r=2;for(;t.length<e;)isComposite(r)&&t.push(r),r+=1;return t},"composite?":e=>isComposite(e),"composite-take-while":e=>{const t=[];return function r(n){return isComposite(n)?chain(e(n,t.length),e=>e?(t.push(n),r(n+1)):t):r(n+1)}(4)}};function isDeficient(e){return getProperDivisors(e).reduce((e,t)=>e+t,0)<e}const deficientSequence={"deficient-seq":e=>{const t=[];let r=1;for(;t.length<e;)isDeficient(r)&&t.push(r),r+=1;return t},"deficient?":e=>isDeficient(e),"deficient-take-while":e=>{const t=[];return function r(n){return isDeficient(n)?chain(e(n,t.length),e=>e?(t.push(n),r(n+1)):t):r(n+1)}(1)}},fibonacciNumbers=[0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,225851433717,365435296162,591286729879,956722026041,1548008755920,2504730781961,4052739537881,6557470319842,0x9a661ca20bb,0xf9d297a859d,27777890035288,44945570212853,72723460248141,0x6b04f4c2fe42,0xad2934c6d08f,308061521170129,498454011879264,806515533049393,0x4a2dce62b0d91,0x780626e057bc2,0xc233f54308953,5527939700884757,8944394323791464];function isInGeometricSequence(e,t,r){if(approxEqual(e,0))return approxEqual(r,0);if(approxEqual(t,1))return approxEqual(r,e);if(approxEqual(t,0))return approxEqual(r,0)||approxEqual(r,e);if(approxEqual(r,e))return!0;if(approxEqual(t,-1))return approxEqual(r,e)||approxEqual(r,-e);if(t<0){const n=Math.log(Math.abs(r/e))/Math.log(Math.abs(t)),o=Math.round(n);if(!approxEqual(o,n)||o<0)return!1;const a=o%2==0?Math.sign(e):Math.sign(e)*Math.sign(t);return Math.sign(r)===a}if(t>1&&r<e||t<1&&r>e)return!1;const n=Math.log(r/e)/Math.log(t),o=Math.round(n);if(!approxEqual(o,n)||o<0)return!1;return approxEqual(e*t**o,r)}const geometricNormalExpressions={"geometric-seq":{evaluate:([e,t,r],n)=>(assertNumber(e,n,{finite:!0}),assertNumber(t,n,{finite:!0}),assertNumber(r,n,{integer:!0,positive:!0}),Array.from({length:r},(r,n)=>e*t**n)),arity:toFixedArity(3)},"geometric-take-while":{evaluate:([e,t,r],n,o,{executeFunction:a})=>{assertNumber(e,n,{finite:!0}),assertNumber(t,n,{finite:!0}),assertFunctionLike(r,n);const i=e,s=t,c=r,l=[];return function e(t){const r=i*s**t;return chain(a(c,[r,t],o,n),n=>n?(l.push(r),e(t+1)):l)}(0)},arity:toFixedArity(3)},"geometric-nth":{evaluate:([e,t,r],n)=>(assertNumber(e,n,{finite:!0}),assertNumber(t,n,{finite:!0}),assertNumber(r,n,{integer:!0,positive:!0}),e*t**(r-1)),arity:toFixedArity(3)},"geometric?":{evaluate:([e,t,r],n)=>(assertNumber(r,n),assertNumber(e,n,{finite:!0}),assertNumber(t,n,{finite:!0}),isInGeometricSequence(e,t,r)),arity:toFixedArity(3)}};function getGolombSeq(e){const t=[0,1];for(let r=2;r<=e;r+=1)t.push(1+t[r-t[t[r-1]]]);return t.slice(1)}function generateGolombSeq(e){const t=[0,1];return chain(e(1,0),r=>{if(!r)return[];return function r(n){const o=1+t[n-t[t[n-1]]];return chain(e(o,n-1),e=>e?(t.push(o),r(n+1)):t.slice(1))}(2)})}const golombSequence={"golomb-seq":e=>getGolombSeq(e),"golomb?":()=>!0,"golomb-take-while":e=>generateGolombSeq(e)};function isHappyNumber(e){if(e<=0)return!1;const t=new Set;for(;1!==e&&!t.has(e);)t.add(e),e=getSumOfSquaredDigits(e);return 1===e}function getSumOfSquaredDigits(e){let t=0;for(;e>0;){const r=e%10;t+=r*r,e=Math.floor(e/10)}return t}const happySequence={"happy-seq":e=>{const t=[];for(let r=1;t.length<e;r++){let e=r;const n=new Set;for(;1!==e&&!n.has(e);)n.add(e),e=String(e).split("").reduce((e,t)=>e+Number(t)**2,0);1===e&&t.push(r)}return t},"happy?":e=>isHappyNumber(e),"happy-take-while":e=>{const t=[];return function r(n){return isHappyNumber(n)?chain(e(n,t.length),e=>e?(t.push(n),r(n+1)):t):r(n+1)}(1)}},jugglerSequence={"juggler-seq":e=>{let t=e;const r=[t];for(;t>1;)t=t%2==0?Math.floor(Math.sqrt(t)):Math.floor(t**1.5),r.push(t);return r},noNth:!0};function isLookAndSay(e){let t="1";if(t===e)return!0;for(;;){if(t=getNextLookAndSayTerm(t),t===e)return!0;if(t.length>e.length)return!1}}function getNextLookAndSayTerm(e){let t="",r=1;for(let n=0;n<e.length;n++)n+1<e.length&&e[n]===e[n+1]?r++:(t+=r.toString()+e[n],r=1);return t}const lookAndSaySequence={string:!0,"look-and-say-seq":e=>{const t=["1"];for(let r=1;r<e;r+=1){const e=t[r-1].replace(/(\d)\1*/g,e=>`${e.length}${e[0]}`);t[r]=e}return t},"look-and-say-take-while":e=>{const t=[];return chain(e("1",0),r=>{if(!r)return t;return t.push("1"),function r(n){const o=t[n-1].replace(/(\d)\1*/g,e=>`${e.length}${e[0]}`);return chain(e(o,n),e=>e?(t.push(o),r(n+1)):t)}(1)})},"look-and-say?":e=>isLookAndSay(e)},lucasNumbers=[2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127,24476,39603,64079,103682,167761,271443,439204,710647,1149851,1860498,3010349,4870847,7881196,12752043,20633239,33385282,54018521,87403803,141422324,228826127,370248451,599074578,969323029,1568397607,2537720636,4106118243,6643838879,10749957122,17393796001,28143753123,45537549124,73681302247,119218851371,192900153618,312119004989,505019158607,817138163596,1322157322203,2139295485799,3461452808002,5600748293801,9062201101803,0xd55fbe3dc94,23725150497407,38388099893011,62113250390418,0x5b67cb4878a5,0x93e5a9822a37,0xef4d74caa2dc,425730551631123,688846502588399,0x3f5b3b1643d02,0x66834447bacf1,0xa5de7f5dfe9f3,4721424167835364,7639424778862807];function generateLuckyNumbers(e){const t=[];for(let e=1;e<=2e3;e++)t.push(e);let r=[1];for(let e=1;e<t.length;e++)t[e]%2!=0&&r.push(t[e]);const n=[1];let o=1;return chain(e(1,0),t=>{if(!t)return[];let a=1;return function t(){const i=r[a];return chain(e(i,o),e=>{if(!e)return n;n.push(i),o++;const s=i,c=[];for(let e=0;e<r.length;e++)(e+1)%s!==0&&c.push(r[e]);if(r=c,a++,a>=r.length-5){let e=r[r.length-1]+2;for(;r.length<a+1e3;)r.push(e),e+=2}return t()})}()})}function getLuckyNumbers(e){const t=[];let r=1;const n=e*(e<100?20:30);for(;t.length<n;)t.push(r),r+=2;let o=1;for(;o<t.length&&o<e;){const e=t[o];let r=0;for(let n=0;n<t.length;n++)(n+1)%e!==0&&(t[r++]=t[n]);t.length=r,o<t.length&&o++}return t.slice(0,e)}const luckySequence={"lucky-seq":e=>getLuckyNumbers(e),"lucky?":e=>generateLuckyNumbers(t=>t<=e).includes(e),"lucky-take-while":e=>generateLuckyNumbers(e)},mersenneNumbers=[3,7,31,127,2047,8191,131071,524287,2147483647];function isPadovan(e){if(!Number.isInteger(e)||e<=0)return!1;if(1===e)return!0;const t=[1,1,1,2,2,3,4,5,7,9,12,16,21,28,37,49,65,86,114,151,200,265,351,465,616,816,1081,1432,1897,2513,3329,4410,5842,7739,10252,13581,17991,23833,31572,41824,55405,73396,97229];if(t.includes(e))return!0;if(e>t[t.length-1]&&e<=Number.MAX_SAFE_INTEGER){let r,n=t[t.length-3],o=t[t.length-2],a=t[t.length-1];for(;a<e;){if(r=n+o,n=o,o=a,a=r,a===e)return!0;if(!Number.isSafeInteger(a))return!1}}return!1}const padovanSequence={"padovan-seq":e=>{const t=[1,1,1];for(let r=3;r<e;r+=1)t[r]=t[r-2]+t[r-3];return t.slice(0,e)},"padovan?":e=>isPadovan(e),"padovan-take-while":e=>{const t=[];return chain(e(1,0),r=>r?(t.push(1),chain(e(1,1),r=>r?(t.push(1),chain(e(1,2),r=>{if(!r)return t;t.push(1);let n=1,o=1,a=1;return function r(i){const s=n+o;return n=o,o=a,a=s,chain(e(a,i),e=>e?(t.push(a),r(i+1)):t)}(4)})):t)):t)}},pellNumbers=[1,2,5,12,29,70,169,408,985,2378,5741,13860,33461,80782,195025,470832,1136689,2744210,6625109,15994428,38613965,93222358,225058681,543339720,1311738121,3166815962,7645370045,18457556052,44560482149,107578520350,259717522849,627013566048,1513744654945,3654502875938,8822750406821,21300003689580,51422757785981,0x70e8e1937766,299713796309065,723573111879672,0x634c28af7f039,0xefb9b143d586a],perfectNumbers=[6,28,496,8128,33550336,8589869056,137438691328],perfectCubeSequence={"perfect-cube-seq":e=>{const t=[];for(let r=1;r<=e;r++)t.push(r**3);return t},"perfect-cube?":e=>e>0&&Number.isInteger(Math.cbrt(e)),"perfect-cube-take-while":e=>{const t=[];return function r(n){const o=n**3;return chain(e(o,n),e=>e?(t.push(o),r(n+1)):t)}(1)}};function perfectPower(e){if(e<2)return 1===e?[1,2]:null;const t=Math.floor(Math.log2(e))+1;for(let r=2;r<=t;r++){const t=e**(1/r),n=Math.round(t);if(approxEqual(n**r,e))return[n,r]}return null}const perfectPowerSequence={"perfect-power-seq":e=>{const t=[];for(let r=1;t.length<e;r++)perfectPower(r)&&t.push(r);return t},"perfect-power?":e=>null!==perfectPower(e),"perfect-power-take-while":e=>{const t=[];return function r(n){return perfectPower(n)?chain(e(n,t.length),e=>e?(t.push(n),r(n+1)):t):r(n+1)}(1)}},perfectSquareSequence={"perfect-square-seq":e=>{const t=[];for(let r=1;r<=e;r++)t.push(r**2);return t},"perfect-square?":e=>e>0&&Number.isInteger(Math.sqrt(e)),"perfect-square-take-while":e=>{const t=[];return function r(n){const o=n**2;return chain(e(o,n),e=>e?(t.push(o),r(n+1)):t)}(1)}},poligonalNormalExpressions={"polygonal-seq":{evaluate:([e,t],r)=>{assertNumber(e,r,{integer:!0,gte:3}),assertNumber(t,r,{integer:!0,positive:!0});const n=[];for(let r=1;r<=t;r+=1)n[r-1]=(r*r*(e-2)-r*(e-4))/2;return n},arity:toFixedArity(2)},"polygonal-take-while":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertNumber(e,r,{integer:!0,gte:3}),assertFunctionLike(t,r);const a=e,i=t,s=[];return function e(t){const c=(t*t*(a-2)-t*(a-4))/2;return chain(o(i,[c,t],n,r),r=>r?(s.push(c),e(t+1)):s)}(1)},arity:toFixedArity(2)},"polygonal-nth":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0,gte:3}),assertNumber(t,r,{integer:!0,positive:!0}),(t*t*(e-2)-t*(e-4))/2),arity:toFixedArity(2)},"polygonal?":{evaluate:([e,t],r)=>{if(assertNumber(t,r,{integer:!0}),assertNumber(e,r,{integer:!0,gte:3}),t<=0)return!1;const n=e-2,o=e-4,a=8*n*t+o*o,i=Math.sqrt(a);if(!Number.isInteger(i))return!1;const s=i+o;if(s%(2*n)!=0)return!1;const c=s/(2*n);return Number.isInteger(c)&&c>0},arity:toFixedArity(2)}};function generateRecamanSequence(e){if(1===e)return[0];const t=[0],r=new Set([0]);for(let n=1;n<e;n++){let e=t[n-1]-n;(e<=0||r.has(e))&&(e=t[n-1]+n),t.push(e),r.add(e)}return t}const recamanSequence={"recaman-seq":e=>generateRecamanSequence(e),"recaman-take-while":e=>{const t=[],r=new Set([0]);return chain(e(0,0),n=>{if(!n)return t;return t.push(0),function n(o){let a=t[o-1]-o;return(a<=0||r.has(a))&&(a=t[o-1]+o),chain(e(a,o),e=>e?(t.push(a),r.add(a),n(o+1)):t)}(1)})},"recaman?":()=>!0},sylvesterNumbers=[2,6,42,1806,3263442,0x9afa8dc8416],thueMorseSequence={"thue-morse-seq":e=>{const t=[];for(let r=0;r<e;r+=1)t[r]=countSetBits(r)%2;return t},"thue-morse-take-while":e=>{const t=[];return function r(n){const o=countSetBits(n)%2;return chain(e(o,n),e=>e?(t.push(o),r(n+1)):t)}(0)},"thue-morse?":e=>1===e||0===e};function countSetBits(e){let t=0;for(;e;)t+=1&e,e>>=1;return t}const tribonacciNumbers=[0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,66012,121415,223317,410744,755476,1389537,2555757,4700770,8646064,15902591,29249425,53798080,98950096,181997601,334745777,615693474,1132436852,2082876103,3831006429,7046319384,12960201916,23837527729,43844049029,80641778674,148323355432,272809183135,501774317241,922906855808,1697490356184,3122171529233,5742568741225,0x99b36012952,19426970897100,35731770264967,65720971788709,0x6df08059d9f8,0xca35cf00a924,408933139743937,752145307699165,0x4ea34736b35c2,0x90a3317d5c260,4680045560037375,8607945812375585],sequenceNormalExpressions={};function addNormalExpressions$1(e){for(const[t,r]of Object.entries(e)){if(sequenceNormalExpressions[t])throw new Error(`Duplicate normal expression key found: ${t}`);sequenceNormalExpressions[t]=r}}function getFiniteNumberSequence(e,t){return{[`${e}-seq`]:createSeqNormalExpression(e=>t.slice(0,e),t.length),[`${e}-take-while`]:createTakeWhileNormalExpression(e=>function r(n){return n>=t.length?t.slice(0,n):chain(e(t[n],n),e=>e?r(n+1):t.slice(0,n))}(0),t.length),[`${e}-nth`]:createNthNormalExpression(()=>t,t.length),[`${e}?`]:createNumberPredNormalExpression(e=>t.includes(e))}}function addSequence(e){for(const[t,r]of Object.entries(e)){if(sequenceNormalExpressions[t])throw new Error(`Duplicate normal expression key found: ${t}`);t.endsWith("seq")?(sequenceNormalExpressions[t]=createSeqNormalExpression(r,e.maxLength),e.noNth||(sequenceNormalExpressions[t.replace(/seq$/,"nth")]=createNthNormalExpression(r,e.maxLength))):t.endsWith("take-while")?sequenceNormalExpressions[t]=createTakeWhileNormalExpression(r,e.maxLength):t.endsWith("?")&&(e.string?sequenceNormalExpressions[t]=createStringPredNormalExpression(r):sequenceNormalExpressions[t]=createNumberPredNormalExpression(r))}}function createSeqNormalExpression(e,t){return{evaluate:(r,n)=>{const o=r[0]??t;assertNumber(o,n,{integer:!0,positive:!0,lte:t});const a=e(o,n);if("number"==typeof a[0]&&a.some(e=>e>Number.MAX_SAFE_INTEGER))throw new LitsError("Result exceeds maximum safe integer",n);return a},arity:"number"==typeof t?{max:1}:toFixedArity(1)}}function createTakeWhileNormalExpression(e,t){return{evaluate:(t,r,n,{executeFunction:o})=>{const a=t[0];assertFunctionLike(a,r);const i=e((e,t)=>chain(o(a,[e,t],n),e=>!!e),r);return chain(i,e=>{if("number"==typeof e[0]&&e.some(e=>e>Number.MAX_SAFE_INTEGER))throw new LitsError("Result exceeds maximum safe integer",r);return e})},arity:"number"==typeof t?{max:1}:toFixedArity(1)}}function createNthNormalExpression(e,t){return{evaluate:(r,n)=>{const o=r[0];assertNumber(o,n,{integer:!0,positive:!0,lte:t});const a=e(o,n);if("number"==typeof a[0]&&a.some(e=>e>Number.MAX_SAFE_INTEGER))throw new LitsError("Result exceeds maximum safe integer",n);return a[o-1]},arity:toFixedArity(1)}}function createNumberPredNormalExpression(e){return{evaluate:(t,r)=>{const n=t[0];return assertNumber(n,r),e(n,r)},arity:toFixedArity(1)}}function createStringPredNormalExpression(e){return{evaluate:(t,r)=>{const n=t[0];return assertString(n,r),e(n,r)},arity:toFixedArity(1)}}function gcd(e,t){for(;0!==t;){const r=t;t=e%t,e=r}return Math.abs(e)}function lcm(e,t){return Math.floor(e*t/gcd(e,t))}function mobius(e){if(1===e)return 1;const t=primeFactors(e);return new Set(t).size!==t.length?0:t.length%2==0?1:-1}function modExp(e,t,r){if(1===r)return 0;let n=1;for(e%=r;t>0;)t%2==1&&(n=n*e%r),t>>=1,e=e*e%r;return n}function extendedGcd(e,t){if(0===t)return[e,1,0];const[r,n,o]=extendedGcd(t,e%t);return[r,o,n-Math.floor(e/t)*o]}function modInverse(e,t){const[r,n]=extendedGcd(e,t);if(1!==r)throw new Error(`Modular inverse does not exist (gcd(${e}, ${t}) = ${r})`);return(n%t+t)%t}function chineseRemainder(e,t){for(let e=0;e<t.length;e++)for(let r=e+1;r<t.length;r++){const n=extendedGcd(t[e],t[r])[0];if(1!==n)throw new Error(`Moduli must be pairwise coprime, but gcd(${t[e]}, ${t[r]}) = ${n}`)}const r=t.reduce((e,t)=>e*t,1);let n=0;for(let o=0;o<e.length;o++){const a=e[o],i=t[o],s=r/i;n=(n+a*s*modInverse(s,i))%r}return n}addSequence(abundantSequence),addSequence(collatzSequence),addSequence(compositeSequence),addSequence(deficientSequence),addSequence(golombSequence),addSequence(happySequence),addSequence(jugglerSequence),addSequence(lookAndSaySequence),addSequence(luckySequence),addSequence(padovanSequence),addSequence(perfectSquareSequence),addSequence(perfectCubeSequence),addSequence(perfectPowerSequence),addSequence(primeSequence),addSequence(recamanSequence),addSequence(thueMorseSequence),addNormalExpressions$1(getFiniteNumberSequence("tribonacci",tribonacciNumbers)),addNormalExpressions$1(getFiniteNumberSequence("catalan",catalanNumbers)),addNormalExpressions$1(getFiniteNumberSequence("factorial",factorialNumbers)),addNormalExpressions$1(getFiniteNumberSequence("fibonacci",fibonacciNumbers)),addNormalExpressions$1(getFiniteNumberSequence("lucas",lucasNumbers)),addNormalExpressions$1(getFiniteNumberSequence("mersenne",mersenneNumbers)),addNormalExpressions$1(getFiniteNumberSequence("partition",partitionNumbers)),addNormalExpressions$1(getFiniteNumberSequence("pell",pellNumbers)),addNormalExpressions$1(getFiniteNumberSequence("perfect",perfectNumbers)),addNormalExpressions$1(getFiniteNumberSequence("sylvester",sylvesterNumbers)),addNormalExpressions$1(getFiniteNumberSequence("bell",bellNumbers)),addNormalExpressions$1(arithmeticNormalExpressions),addNormalExpressions$1(bernoulliNormalExpressions),addNormalExpressions$1(geometricNormalExpressions),addNormalExpressions$1(poligonalNormalExpressions);const combinatoricalNormalExpression={"coprime?":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0}),1===gcd(e,t)),arity:toFixedArity(2)},"divisible-by?":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0}),0!==t&&e%t===0),arity:toFixedArity(2)},gcd:{evaluate:([e,t],r)=>(assertNumber(e,r),assertNumber(t,r),gcd(e,t)),arity:toFixedArity(2)},lcm:{evaluate:([e,t],r)=>(assertNumber(e,r),assertNumber(t,r),lcm(e,t)),arity:toFixedArity(2)},multinomial:{evaluate:([...e],t)=>{assertVector(e,t);return factorialOf(e.reduce((e,r)=>(assertNumber(r,t,{integer:!0,nonNegative:!0}),e+r),0))/e.reduce((e,t)=>e*factorialOf(t),1)},arity:{min:1}},"amicable?":{evaluate:([e,t],r)=>{assertNumber(e,r,{integer:!0,positive:!0}),assertNumber(t,r,{integer:!0,positive:!0});const n=getProperDivisors(e).reduce((e,t)=>e+t,0),o=getProperDivisors(t).reduce((e,t)=>e+t,0);return n===t&&o===e&&e!==t},arity:toFixedArity(2)},"euler-totient":{evaluate:([e],t)=>{assertNumber(e,t,{integer:!0,positive:!0});let r=e;for(let t=2;t*t<=e;t+=1)if(e%t===0){for(;e%t===0;)e/=t;r-=r/t}return e>1&&(r-=r/e),r},arity:toFixedArity(1)},mobius:{evaluate:([e],t)=>{if(assertNumber(e,t,{integer:!0,positive:!0}),1===e)return 1;const r=primeFactors(e);return new Set(r).size!==r.length?0:r.length%2==0?1:-1},arity:toFixedArity(1)},mertens:{evaluate:([e],t)=>{if(assertNumber(e,t,{integer:!0,positive:!0}),1===e)return 1;let r=0;for(let t=1;t<=e;t++){r+=mobius(t)}return r},arity:toFixedArity(1)},sigma:{evaluate:([e],t)=>(assertNumber(e,t,{integer:!0,positive:!0}),getDivisors(e).reduce((e,t)=>e+t,0)),arity:toFixedArity(1)},"carmichael-lambda":{evaluate:([e],t)=>{if(assertNumber(e,t,{integer:!0,positive:!0}),1===e)return 1;const r=primeFactors(e),n=new Map;for(const e of r)n.set(e,(n.get(e)||0)+1);const o=[];for(const[e,t]of n.entries())2===e?1===t?o.push(1):2===t?o.push(2):o.push(2**(t-2)):o.push((e-1)*e**(t-1));return o.reduce((e,t)=>lcm(e,t),1)},arity:toFixedArity(1)},"cartesian-product":{evaluate:(e,t)=>{e.forEach(e=>{assertArray(e,t)});return e.reduce((e,t)=>{const r=[];return e.forEach(e=>{t.forEach(t=>{r.push([...e,t])})}),r},[[]])},arity:{min:1}},"perfect-power":{evaluate:([e],t)=>{assertNumber(e,t,{integer:!0,positive:!0});return perfectPower(e)||null},arity:toFixedArity(1)},"mod-exp":{evaluate:([e,t,r],n)=>(assertNumber(e,n,{finite:!0}),assertNumber(t,n,{integer:!0,positive:!0}),assertNumber(r,n,{integer:!0,positive:!0}),modExp(e,t,r)),arity:toFixedArity(3)},"mod-inv":{evaluate:([e,t],r)=>{assertNumber(e,r,{integer:!0,positive:!0}),assertNumber(t,r,{integer:!0,positive:!0});try{return modInverse(e,t)}catch(e){throw new LitsError(e,r)}},arity:toFixedArity(2)},"extended-gcd":{evaluate:([e,t],r)=>(assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0}),extendedGcd(e,t)),arity:toFixedArity(2)},"chinese-remainder":{evaluate:([e,t],r)=>{if(assertVector(e,r),assertVector(t,r),e.length!==t.length)throw new LitsError("Remainders and moduli must have the same length.",r);try{return chineseRemainder(e,t)}catch(e){throw new LitsError(e.message,r)}},arity:toFixedArity(2)},"stirling-first":{evaluate:([e,t],r)=>{assertNumber(e,r,{integer:!0,positive:!0}),assertNumber(t,r,{integer:!0,positive:!0,lte:e});const n=Array.from({length:e+1},()=>Array(t+1).fill(0));n[0][0]=1;for(let r=1;r<=e;r++)for(let e=1;e<=Math.min(r,t);e++)n[r][e]=n[r-1][e-1]+(r-1)*n[r-1][e];return n[e][t]},arity:toFixedArity(2)},"stirling-second":{evaluate:([e,t],r)=>{if(assertNumber(e,r,{integer:!0,positive:!0}),assertNumber(t,r,{integer:!0,positive:!0,lte:e}),1===t)return 1;if(t===e)return 1;const n=Array.from({length:e+1},()=>Array(t+1).fill(0));n[0][0]=1;for(let r=1;r<=e;r++)for(let e=1;e<=Math.min(r,t);e++)n[r][e]=e*n[r-1][e]+n[r-1][e-1];return n[e][t]},arity:toFixedArity(2)}};function addSequences(e){for(const[t,r]of Object.entries(e)){if(combinatoricalNormalExpression[t])throw new Error(`Duplicate normal expression key found: ${t}`);combinatoricalNormalExpression[t]=r}}function addNormalExpressions(e){for(const[t,r]of Object.entries(e)){if(combinatoricalNormalExpression[t])throw new Error(`Duplicate normal expression key found: ${t}`);combinatoricalNormalExpression[t]=r}}addSequences(sequenceNormalExpressions),addNormalExpressions(factorialNormalExpressions),addNormalExpressions(divisorsNormalExpressions),addNormalExpressions(combinationsNormalExpressions),addNormalExpressions(permutationsNormalExpressions),addNormalExpressions(partitionsNormalExpressions),addNormalExpressions(primeFactorsNormalExpressions),addNormalExpressions(derangementsNormalExpressions),addNormalExpressions(powerSetNormalExpressions);for(const[e,t]of Object.entries(moduleDocs))combinatoricalNormalExpression[e]&&(combinatoricalNormalExpression[e].docs=t);const numberTheoryModule={name:"number-theory",functions:combinatoricalNormalExpression};function getNumberVectorOrMatrixOperation(e,t){if(isVector(e))return["vector",e];if(isMatrix(e))return["matrix",e];if(!isNumber(e))throw new LitsError("Invalid parameter type: "+typeof e,t);return["number",e]}function unaryMathOp(e){return([t],r)=>{const[n,o]=getNumberVectorOrMatrixOperation(t,r);return"number"===n?e(o):"vector"===n?o.map(t=>e(t)):o.map(t=>t.map(t=>e(t)))}}const mathUtilsFunctions={sin:{evaluate:unaryMathOp(e=>Math.sin(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `sin` function computes the sine of an angle (in radians), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the sine of each element while preserving the original structure.",seeAlso:["math.asin","math.sinh","math.cos","math.tan","math.to-rad"],examples:['let { sin } = import("math"); sin(0)','let { sin } = import("math"); sin(1)','let { sin } = import("math"); sin(PI)','let { sin } = import("math"); sin(-0.5)','let { sin } = import("math"); sin([1, 2, 3])','let { sin } = import("math"); sin([[1, 2], [3, 4]])']}},asin:{evaluate:unaryMathOp(e=>Math.asin(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `asin` function computes the arcsine (inverse sine) of a `number` in radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the arcsine of each element while preserving the original structure.",seeAlso:["math.sin","math.asinh","math.acos","math.atan"],examples:['let { asin } = import("math"); asin(0)','let { asin } = import("math"); asin(1)','let { asin } = import("math"); asin(-0.5)','let { asin } = import("math"); asin([1, 2, 3])','let { asin } = import("math"); asin([[1, 2], [3, 4]])']}},sinh:{evaluate:unaryMathOp(e=>Math.sinh(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `sinh` function computes the hyperbolic sine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the hyperbolic sine of each element while preserving the original structure.",seeAlso:["math.asinh","math.sin","math.cosh","math.tanh"],examples:['let { sinh } = import("math"); sinh(0)','let { sinh } = import("math"); sinh(1)','let { sinh } = import("math"); sinh(-0.5)','let { sinh } = import("math"); sinh([0.1, 0.2, 0.3])','let { sinh } = import("math"); sinh([[0.1, 0.2], [0.3, 0.4]])']}},asinh:{evaluate:unaryMathOp(e=>Math.asinh(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `asinh` function computes the inverse hyperbolic sine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the inverse hyperbolic sine of each element while preserving the original structure.",seeAlso:["math.sinh","math.asin","math.acosh","math.atanh"],examples:['let { asinh } = import("math"); asinh(10)','let { asinh } = import("math"); asinh(90)','let { asinh } = import("math"); asinh(50)','let { asinh } = import("math"); asinh([10, 20, 30])','let { asinh } = import("math"); asinh([[10, 20], [30, 40]])']}},cos:{evaluate:unaryMathOp(e=>Math.cos(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `cos` function computes the cosine of an angle (in radians), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the cosine of each element while preserving the original structure.",seeAlso:["math.acos","math.cosh","math.sin","math.tan","math.to-rad"],examples:['let { cos } = import("math"); cos(0)','let { cos } = import("math"); cos(1)','let { cos } = import("math"); cos(PI)','let { cos } = import("math"); cos(-0.5)','let { cos } = import("math"); cos([1, 2, 3])','let { cos } = import("math"); cos([[1, 2], [3, 4]])']}},acos:{evaluate:unaryMathOp(e=>Math.acos(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `acos` function computes the arccosine (inverse cosine) of a `number` in radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the arccosine of each element while preserving the original structure.",seeAlso:["math.cos","math.acosh","math.asin","math.atan"],examples:['let { acos } = import("math"); acos(0)','let { acos } = import("math"); acos(1)','let { acos } = import("math"); acos(-0.5)','let { acos } = import("math"); acos([0.1, 0.2, 0.3])','let { acos } = import("math"); acos([[0.1, 0.2], [0.3, 0.4]])']}},cosh:{evaluate:unaryMathOp(e=>Math.cosh(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `cosh` function computes the hyperbolic cosine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the hyperbolic cosine of each element while preserving the original structure.",seeAlso:["math.acosh","math.cos","math.sinh","math.tanh"],examples:['let { cosh } = import("math"); cosh(0)','let { cosh } = import("math"); cosh(1)','let { cosh } = import("math"); cosh(-0.5)','let { cosh } = import("math"); cosh([0.1, 0.2, 0.3])','let { cosh } = import("math"); cosh([[0.1, 0.2], [0.3, 0.4]])']}},acosh:{evaluate:unaryMathOp(e=>Math.acosh(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `acosh` function computes the inverse hyperbolic cosine of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the inverse hyperbolic cosine of each element while preserving the original structure.",seeAlso:["math.cosh","math.acos","math.asinh","math.atanh"],examples:['let { acosh } = import("math"); acosh(1)','let { acosh } = import("math"); acosh(2)','let { acosh } = import("math"); acosh(100)','let { acosh } = import("math"); acosh(50)','let { acosh } = import("math"); acosh([1, 2, 3])','let { acosh } = import("math"); acosh([[1, 2], [3, 4]])']}},tan:{evaluate:unaryMathOp(e=>Math.tan(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `tan` function computes the tangent of an angle (in radians), working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the tangent of each element while preserving the original structure.",seeAlso:["math.atan","math.tanh","math.sin","math.cos","math.to-rad"],examples:['let { tan } = import("math"); tan(0)','let { tan } = import("math"); tan(1)','let { tan } = import("math"); tan(PI)','let { tan } = import("math"); tan(-0.5)','let { tan } = import("math"); tan([1, 2, 3])','let { tan } = import("math"); tan([[1, 2], [3, 4]])']}},atan:{evaluate:unaryMathOp(e=>Math.atan(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `atan` function computes the arctangent (inverse tangent) of a `number` in radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the arctangent of each element while preserving the original structure.",seeAlso:["math.tan","math.atanh","math.asin","math.acos"],examples:['let { atan } = import("math"); atan(0)','let { atan } = import("math"); atan(1)','let { atan } = import("math"); atan(-0.5)','let { atan } = import("math"); atan([0.1, 0.2, 0.3])','let { atan } = import("math"); atan([[0.1, 0.2], [0.3, 0.4]])']}},tanh:{evaluate:unaryMathOp(e=>Math.tanh(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `tanh` function computes the hyperbolic tangent of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the hyperbolic tangent of each element while preserving the original structure.",seeAlso:["math.atanh","math.tan","math.sinh","math.cosh"],examples:['let { tanh } = import("math"); tanh(0)','let { tanh } = import("math"); tanh(1)','let { tanh } = import("math"); tanh(-0.5)','let { tanh } = import("math"); tanh(50)']}},atanh:{evaluate:unaryMathOp(e=>Math.atanh(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `atanh` function computes the inverse hyperbolic tangent of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the inverse hyperbolic tangent of each element while preserving the original structure.",seeAlso:["math.tanh","math.atan","math.asinh","math.acosh"],examples:['let { atanh } = import("math"); atanh(0)','let { atanh } = import("math"); atanh(0.9)','let { atanh } = import("math"); atanh(-0.5)','let { atanh } = import("math"); atanh([0.1, 0.2, 0.3])','let { atanh } = import("math"); atanh([[0.1, 0.2], [0.3, 0.4]])']}},ln:{evaluate:unaryMathOp(e=>Math.log(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `ln` function computes the natural logarithm (base `e`) of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the natural logarithm of each element while preserving the original structure.",seeAlso:["math.log2","math.log10","^"],examples:['let { ln } = import("math"); ln(0.01)','let { ln } = import("math"); ln(2.5)','let { ln } = import("math"); ln(E)','let { ln } = import("math"); ln([1, 2, 3])','let { ln } = import("math"); ln([[1, 2], [3, 4]])']}},log2:{evaluate:unaryMathOp(e=>Math.log2(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `log2` function computes the base `2` logarithm of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the base-2 logarithm of each element while preserving the original structure.",seeAlso:["math.ln","math.log10"],examples:['let { log2 } = import("math"); log2(0.01)','let { log2 } = import("math"); log2(2 ^ 12)','let { log2 } = import("math"); log2(2.5)','let { log2 } = import("math"); log2([1, 2, 3])','let { log2 } = import("math"); log2([[1, 2], [3, 4]])']}},log10:{evaluate:unaryMathOp(e=>Math.log10(e)),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `log10` function computes the base `10` logarithm of a `number`, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it returns the base-10 logarithm of each element while preserving the original structure.",seeAlso:["math.ln","math.log2"],examples:['let { log10 } = import("math"); log10(0.01)','let { log10 } = import("math"); log10(10 ^ 12)','let { log10 } = import("math"); log10(2.5)','let { log10 } = import("math"); log10([1, 2, 3])','let { log10 } = import("math"); log10([[1, 2], [3, 4]])']}},"to-rad":{evaluate:unaryMathOp(e=>e*Math.PI/180),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `to-rad` function converts an angle from degrees to radians, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it converts each element while preserving the original structure.",seeAlso:["math.to-deg","math.sin","math.cos","math.tan"],examples:['let { to-rad } = import("math"); to-rad(0)','let { to-rad } = import("math"); to-rad(90)','let { to-rad } = import("math"); to-rad(180)','let { to-rad } = import("math"); to-rad(360)','let { to-rad } = import("math"); to-rad([0, 90, 180])','let { to-rad } = import("math"); to-rad([[0, 90], [180, 360]])']}},"to-deg":{evaluate:unaryMathOp(e=>180*e/Math.PI),arity:toFixedArity(1),docs:{category:"math",returns:{type:["number","vector","matrix"]},args:{x:{type:["number","vector","matrix"]}},variants:[{argumentNames:["x"]}],description:"The `to-deg` function converts an angle from radians to degrees, working on `numbers` and element-wise on `vectors` and `matrices`. When applied to collections, it converts each element while preserving the original structure.",seeAlso:["math.to-rad"],examples:['let { to-deg } = import("math"); to-deg(0)','let { to-deg } = import("math"); to-deg(PI)','let { to-deg } = import("math"); to-deg(PI / 2)','let { to-deg } = import("math"); to-deg(3 * PI / 2)','let { to-deg } = import("math"); to-deg([0, PI, PI / 2])','let { to-deg } = import("math"); to-deg([[0, PI], [PI / 2, 3 * PI / 2]])']}}},mathUtilsModule={name:"math",functions:mathUtilsFunctions},functionalUtilsNormalExpression={juxt:{evaluate:(e,t)=>{e.forEach(e=>assertFunctionLike(e,t));const r=getCommonArityFromFunctions(e);if(null===r)throw new LitsError("All functions must accept the same number of arguments",t);return{[FUNCTION_SYMBOL]:!0,sourceCodeInfo:t,functionType:"Juxt",params:e,arity:r}},arity:{min:1},docs:{category:"functional",returns:{type:"function"},args:{a:{type:"function"},b:{type:"function"},fun:{type:"function"},fns:{type:"function",rest:!0}},variants:[{argumentNames:["fun"]},{argumentNames:["fun","fns"]}],description:"Takes one or many function and returns a function that is the juxtaposition of those functions.\nThe returned function takes a variable number of args,\nand returns a vector containing the result of applying each function to the args (left-to-right).",seeAlso:["comp"],examples:['let { juxt } = import("functional");\njuxt(+, *, min, max)(\n  3,\n  4,\n  6,\n)','let { juxt } = import("functional");\njuxt("a", "b")(\n  {\n    a: 1,\n    b: 2,\n    c: 3,\n    d: 4\n  }\n)','let { juxt } = import("functional");\njuxt(+, *, min, max) apply range(1, 11)']}},complement:{evaluate:([e],t)=>{const r=asFunctionLike(e,t);return{[FUNCTION_SYMBOL]:!0,sourceCodeInfo:t,functionType:"Complement",function:r,arity:getArityFromFunction(r)}},arity:toFixedArity(1),docs:{category:"functional",returns:{type:"function"},args:{fun:{type:"function"}},variants:[{argumentNames:["fun"]}],description:"Takes a function $fun and returns a new function that takes the same arguments as f, has the same effects, if any, and returns the opposite truth value.",seeAlso:["comp","functional.every-pred","functional.some-pred"],examples:['let { complement } = import("functional");\ncomplement(>)(1, 3)','let { complement } = import("functional");\ncomplement(<)(1, 3)','let { complement } = import("functional");\ncomplement(+)(1, 3)','let { complement } = import("functional");\ncomplement(+)(0, 0)']}},"every-pred":{evaluate:(e,t)=>({[FUNCTION_SYMBOL]:!0,sourceCodeInfo:t,functionType:"EveryPred",params:e,arity:{min:1,max:1}}),arity:{min:1},docs:{category:"functional",returns:{type:"function"},args:{fun:{type:"function"},fns:{type:"function",rest:!0}},variants:[{argumentNames:["fun"]},{argumentNames:["fun","fns"]}],description:"\nTakes a number of predicates and returns a function that returns `true` if all predicates\nreturn a truthy value against all of its arguments, else it returns `false`.",seeAlso:["functional.some-pred","functional.complement","collection.every?"],examples:['let { every-pred } = import("functional");\nevery-pred(string?, -> count($) > 3)(\n  "Albert",\n  "Mojir"\n)','let { every-pred } = import("functional");\n(string? every-pred -> count($) > 3)(\n  "Albert",\n  "M"\n)'],hideOperatorForm:!0}},"some-pred":{evaluate:(e,t)=>({[FUNCTION_SYMBOL]:!0,sourceCodeInfo:t,functionType:"SomePred",params:e,arity:{min:1,max:1}}),arity:{min:1},docs:{category:"functional",returns:{type:"function"},args:{fun:{type:"function"},fns:{type:"function",rest:!0}},variants:[{argumentNames:["fun"]},{argumentNames:["fun","fns"]}],description:"Takes a number of `predicates` and returns a function that returns `true` if at least one of the `predicates` return a truthy `true` value against at least one of its arguments, else it returns `false`.",seeAlso:["functional.every-pred","functional.complement","collection.any?"],examples:['let { some-pred } = import("functional");\nsome-pred(string?, -> count($) > 3)("Albert", "Mojir")','let { some-pred } = import("functional");\nsome-pred(string?, -> count($) > 3)("a", "M")','let { some-pred } = import("functional");\nsome-pred(string?, -> count($) > 3)("a", [1, 2, 3])','let { some-pred } = import("functional");\nsome-pred(string?, -> count($) > 3)([1, 2, 3], [2])'],hideOperatorForm:!0}},fnull:{evaluate:([e,...t],r)=>{const n=asFunctionLike(e,r);return{[FUNCTION_SYMBOL]:!0,sourceCodeInfo:r,functionType:"Fnull",function:n,params:t,arity:getArityFromFunction(n)}},arity:{min:2},docs:{category:"functional",returns:{type:"function"},args:{a:{type:"function"},b:{type:"any"},fun:{type:"function"},arg:{type:"any"},args:{type:"any",rest:!0}},variants:[{argumentNames:["fun","arg"]},{argumentNames:["fun","arg","args"]}],description:"Takes a function $fun, and returns a function that calls $fun, replacing a null argument to the corresponding argument.",seeAlso:["identity","constantly"],examples:['let { fnull } = import("functional");\nfnull(inc, 0)(1)','let { fnull } = import("functional");\nfnull(inc, 0)(null)','let { fnull } = import("functional");\n(inc fnull 0)(null)','let { fnull } = import("functional");\nfnull(+, 1, 2)(null, 0)','let { fnull } = import("functional");\nfnull(+, 1, 2)(0, null)','let { fnull } = import("functional");\nfnull(+, 1, 2)(null, null)','let { fnull } = import("functional");\nfnull(+, 1, 2)(null, null, 3, 4)']}}},functionalUtilsModule={name:"functional",functions:functionalUtilsNormalExpression},stringUtilsFunctions={"string-repeat":{evaluate:([e,t],r)=>(assertString(e,r),assertNumber(t,r,{integer:!0,nonNegative:!0}),e.repeat(t)),arity:toFixedArity(2),docs:{category:"string",returns:{type:"number"},args:{a:{type:"string"},b:{type:"integer"},s:{type:"string"},n:{type:"integer"}},variants:[{argumentNames:["s","n"]}],description:"Repeates $s $n times.",seeAlso:["str","repeat"],examples:['let { string-repeat } = import("string"); "*" string-repeat 10','let { string-repeat } = import("string"); string-repeat("*", 10)','let { string-repeat } = import("string"); string-repeat("***", 0)']}},"from-char-code":{evaluate:([e],t)=>{assertNumber(e,t,{finite:!0});const r=toNonNegativeInteger(e);try{return String.fromCodePoint(r)}catch(e){throw new LitsError(e,t)}},arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{code:{type:"number"}},variants:[{argumentNames:["code"]}],description:"Return character for code point $code.",seeAlso:["string.to-char-code"],examples:['let { from-char-code } = import("string"); from-char-code(65)','let { from-char-code } = import("string"); from-char-code(0)']}},"to-char-code":{evaluate:([e],t)=>(assertString(e,t,{nonEmpty:!0}),asNonUndefined(e.codePointAt(0),t)),arity:toFixedArity(1),docs:{category:"string",returns:{type:"number"},args:{c:{type:"string"}},variants:[{argumentNames:["c"]}],description:"Return code point for first character in $c.",seeAlso:["string.from-char-code"],examples:['let { to-char-code } = import("string"); to-char-code("A")','let { to-char-code } = import("string"); to-char-code("Albert")']}},"trim-left":{evaluate:([e],t)=>(assertString(e,t),e.replace(/^\s+/,"")),arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Returns a new string with leading whitespaces removed.",seeAlso:["trim","string.trim-right"],examples:['let { trim-left } = import("string"); trim-left("  Albert  ")','let { trim-left } = import("string"); trim-left("   ")','let { trim-left } = import("string"); trim-left("")']}},"trim-right":{evaluate:([e],t)=>(assertString(e,t),e.replace(/\s+$/,"")),arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Returns a new string with trailing whitespaces removed.",seeAlso:["trim","string.trim-left"],examples:['let { trim-right } = import("string"); trim-right("  Albert  ")','let { trim-right } = import("string"); trim-right("   ")','let { trim-right } = import("string"); trim-right("")']}},"split-lines":{evaluate:([e],t)=>(assertString(e,t),e.split(/\r\n|\n|\r/).filter(e=>""!==e)),arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Divides $s into an array of substrings, each representing a line.",seeAlso:["split"],examples:['let { split-lines } = import("string"); split-lines("Albert\nMojir\n")','let { split-lines } = import("string"); split-lines("Albert\n\nMojir")','let { split-lines } = import("string"); split-lines("Albert\nMojir\n\n")','let { split-lines } = import("string"); split-lines("")']}},"pad-left":{evaluate:([e,t,r],n)=>(assertString(e,n),assertNumber(t,n,{integer:!0}),void 0!==r&&assertString(r,n),e.padStart(t,r)),arity:{min:2,max:3},docs:{category:"string",returns:{type:"string"},args:{a:{type:"string"},b:{type:"integer"},s:{type:"string"},length:{type:"integer"},padString:{type:"string"}},variants:[{argumentNames:["s","length"]},{argumentNames:["s","length","padString"]}],description:"Pads from the start of $s with `padString` (multiple times, if needed) until the resulting string reaches the given $length.",seeAlso:["string.pad-right"],examples:['let { pad-left } = import("string"); "Albert" pad-left 20','let { pad-left } = import("string"); pad-left("Albert", 20)','let { pad-left } = import("string"); pad-left("Albert", 20, "-*-")','let { pad-left } = import("string"); pad-left("Albert", 5)','let { pad-left } = import("string"); pad-left("Albert", -1)']}},"pad-right":{evaluate:([e,t,r],n)=>(assertString(e,n),assertNumber(t,n,{integer:!0}),void 0!==r&&assertString(r,n),e.padEnd(t,r)),arity:{min:2,max:3},docs:{category:"string",returns:{type:"string"},args:{a:{type:"string"},b:{type:"integer"},s:{type:"string"},length:{type:"integer"},padString:{type:"string"}},variants:[{argumentNames:["s","length"]},{argumentNames:["s","length","padString"]}],description:"Pads from the start of $s with `padString` (multiple times, if needed) until the resulting string reaches the given `length`.",seeAlso:["string.pad-left"],examples:['let { pad-right } = import("string"); "Albert" pad-right 20','let { pad-right } = import("string"); pad-right("Albert", 20)','let { pad-right } = import("string"); pad-right("Albert", 20, "-*-")','let { pad-right } = import("string"); pad-right("Albert", 5)','let { pad-right } = import("string"); pad-right("Albert", -1)']}},template:{evaluate:([e,...t],r)=>{assertString(e,r),assertArray(t,r);const n=e.split("||||");if(n.length<=1)return applyPlaceholders(n[0],t,r);{const e=t[0];assertNumber(e,r,{integer:!0,nonNegative:!0});const o=[`${e}`,...t.slice(1)];if(2===n.length){return applyPlaceholders(n[1===e?0:1],o,r)}return applyPlaceholders(n[Math.min(e,n.length-1)],o,r)}},arity:{min:1,max:10},docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"},params:{type:"any",rest:!0}},variants:[{argumentNames:["s","params"]}],description:"Applies placeholders to a string. Support for basic pluralization - see examples. If pluralization is used, first placeholder must be a number.",seeAlso:["str"],examples:['let { template } = import("string"); template("Hi, $1 and $2", "Carl", "Larry")','let { template } = import("string"); template("Hi $1, $2, $3, $4, $5, $6, $7, $8 and $9", "A", "B", "C", "D", "E", "F", "G", "H", "I")','let { template } = import("string"); template("$1 book||||$1 books", 0)','let { template } = import("string"); template("$1 book||||$1 books", 1)','let { template } = import("string"); template("$1 book||||$1 books", 2)','let { template } = import("string"); template("No book||||$1 book||||$1 books", 0)','let { template } = import("string"); template("No book||||$1 book||||$1 books", 1)','let { template } = import("string"); template("No book||||$1 book||||$1 books", 10)','let { template } = import("string"); template("No book||||One book||||Two books||||Three books||||$1 books", 0)','let { template } = import("string"); template("No book||||One book||||Two books||||Three books||||$1 books", 1)','let { template } = import("string"); template("No book||||One book||||Two books||||Three books||||$1 books", 2)','let { template } = import("string"); template("No book||||One book||||Two books||||Three books||||$1 books", 3)','let { template } = import("string"); template("No book||||One book||||Two books||||Three books||||$1 books", 4)'],hideOperatorForm:!0}},"encode-base64":{evaluate:([e],t)=>(assertString(e,t),btoa(encodeURIComponent(e).replace(/%([0-9A-F]{2})/g,(e,t)=>String.fromCharCode(Number.parseInt(t,16))))),arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Returns a Base64 encoded string from $s.",seeAlso:["string.decode-base64"],examples:['let { encode-base64 } = import("string"); encode-base64("Albert")']}},"decode-base64":{evaluate:([e],t)=>{assertString(e,t);try{return decodeURIComponent(Array.prototype.map.call(atob(e),e=>`%${`00${e.charCodeAt(0).toString(16)}`.slice(-2)}`).join(""))}catch(e){throw new LitsError(e,t)}},arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{base64string:{type:"string"}},variants:[{argumentNames:["base64string"]}],description:"Returns a Base64 decoded string from $base64string.",seeAlso:["string.encode-base64"],examples:['let { decode-base64 } = import("string"); decode-base64("QWxiZXJ0IPCfkLs=")']}},"encode-uri-component":{evaluate:([e],t)=>(assertString(e,t),encodeURIComponent(e)),arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Returns an escaped `URI` string.",seeAlso:["string.decode-uri-component"],examples:['let { encode-uri-component } = import("string"); encode-uri-component("Hi everyone!?")']}},"decode-uri-component":{evaluate:([e],t)=>{assertString(e,t);try{return decodeURIComponent(e)}catch(e){throw new LitsError(e,t)}},arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Returns an un-escaped `URI` string.",seeAlso:["string.encode-uri-component"],examples:['let { decode-uri-component } = import("string"); decode-uri-component("Hi%20everyone!%3F%20%F0%9F%91%8D")']}},capitalize:{evaluate:([e],t)=>(assertString(e,t),e.charAt(0).toUpperCase()+e.slice(1).toLowerCase()),arity:toFixedArity(1),docs:{category:"string",returns:{type:"string"},args:{s:{type:"string"}},variants:[{argumentNames:["s"]}],description:"Returns $s with the first character converted to uppercase and the rest to lowercase.",seeAlso:["lower-case","upper-case"],examples:['let { capitalize } = import("string"); capitalize("albert")','let { capitalize } = import("string"); capitalize("ALBERT")','let { capitalize } = import("string"); capitalize("aLBERT")','let { capitalize } = import("string"); capitalize("")']}}},doubleDollarRegexp=/\$\$/g;function applyPlaceholders(e,t,r){for(let n=0;n<9;n+=1){const o=new RegExp(`(\\$\\$|[^$]|^)\\$${n+1}`,"g");if(o.test(e)){const a=asStringOrNumber(t[n],r);e=e.replace(o,`$1${a}`)}}return e=e.replace(doubleDollarRegexp,"$")}const stringUtilsModule={name:"string",functions:stringUtilsFunctions};function get(e,t){if(isObj(e)){if("string"==typeof t&&collHasKey(e,t))return toAny(e[t])}else if(isNumber(t,{nonNegative:!0,integer:!0})&&t>=0&&t<e.length)return toAny(e[t])}function assoc(e,t,r,n){if(assertColl(e,n),Array.isArray(e)||"string"==typeof e){if(assertNumber(t,n,{integer:!0}),assertNumber(t,n,{gte:0}),assertNumber(t,n,{lte:e.length}),"string"==typeof e)return assertString(r,n,{char:!0}),`${e.slice(0,t)}${r}${e.slice(t+1)}`;const o=[...e];return o[t]=r,o}assertString(t,n);const o={...e};return o[t]=r,o}function update(e,t,r,n,o,a,i){if(isObj(e)){assertString(t,i);const s={...e};return chain(a(r,[s[t],...n],o,i),e=>(s[t]=e,s))}{assertNumber(t,i);const s=toNonNegativeInteger(t);if(assertNumber(s,i,{lte:e.length}),Array.isArray(e))return chain(mapSequential(Array.from({length:e.length+(s===e.length?1:0)}),(t,c)=>s===c?a(r,[e[c],...n],o,i):e[c]),e=>e);{const t=e.split("");return chain(mapSequential(Array.from({length:t.length+(s===t.length?1:0)}),(e,c)=>s===c?chain(a(r,[t[c],...n],o,i),e=>asString(e,i,{char:!0})):t[c]),e=>e.join(""))}}}function cloneAndGetMeta(e,t,r){const n=cloneColl(e);return{coll:n,innerCollMeta:t.slice(0,t.length-1).reduce((e,t)=>{const n=e.coll;let o;return Array.isArray(n)?(assertNumber(t,r),o=asColl(n[t],r)):(assertObj(n,r),assertString(t,r),collHasKey(e.coll,t)||(n[t]={}),o=asColl(n[t],r)),{coll:o,parent:n}},{coll:n,parent:{}})}}const collectionUtilsFunctions={"get-in":{evaluate:(e,t)=>{let r=toAny(e[0]);const n=e[1]??[],o=toAny(e[2]);assertArray(n,t);for(const e of n){if(assertStringOrNumber(e,t),!isColl(r))return o;{const t=get(r,e);if(void 0===t)return o;r=t}}return r},arity:{min:2,max:3},docs:{category:"collection",returns:{type:"any"},args:{a:{type:"collection"},b:{type:"array"},"not-found":{type:"any"}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","not-found"]}],description:"Returns the value in a nested collection, where $b is an array of keys. Returns $not-found if the key is not present. If $not-found is not set, `null` is returned.",seeAlso:["get","collection.assoc-in","collection.update-in"],examples:['\nlet cu = import("collection");\ncu.get-in(\n  [[1, 2, 3], [4, { a: "Kalle" }, 6]],\n  [1, 1, "a", 0]\n)','\nlet cu = import("collection");\ncu.get-in(\n  [[1, 2, 3], [4, { a: "Kalle" }, 6]],\n  [1, 1, "b", 0]\n)','\nlet cu = import("collection");\ncu.get-in(\n  [[1, 2, 3], [4, { a: "Kalle" }, 6]],\n  [1, 1, "b", 0],\n  "Lisa"\n)']}},"assoc-in":{evaluate:([e,t,r],n)=>{if(assertColl(e,n),assertArray(t,n),assertAny(r,n),1===t.length)return assertStringOrNumber(t[0],n),assoc(e,t[0],r,n);const{coll:o,innerCollMeta:a}=cloneAndGetMeta(e,t,n),i=asStringOrNumber(t[t.length-1],n),s=asStringOrNumber(t[t.length-2],n);return Array.isArray(a.parent)?(assertNumber(s,n),a.parent[s]=assoc(a.coll,i,r,n)):(assertString(s,n),a.parent[s]=assoc(a.coll,i,r,n)),o},arity:toFixedArity(3),docs:{category:"collection",returns:{type:"collection"},args:{coll:{type:"collection"},ks:{type:["number","string"],array:!0},value:{type:"any"}},variants:[{argumentNames:["coll","ks","value"]}],description:"\nAssociates a value in the nested collection $coll, where $ks is an array of keys and $value is the new value.\n\nIf any levels do not exist, objects will be created - and the corresponding keys must be of type string.",seeAlso:["assoc","collection.get-in","collection.update-in"],examples:['\nlet cu = import("collection");\ncu.assoc-in(\n  {},\n  ["a", "b", "c"],\n  "Albert"\n)','\nlet cu = import("collection");\ncu.assoc-in(\n  [1, 2, [1, 2, 3]],\n  [2, 1],\n  "Albert"\n)','\nlet cu = import("collection");\ncu.assoc-in(\n  [1, 2, { name: "albert" }],\n  [2, "name", 0],\n  "A"\n)']}},update:{evaluate:([e,t,r,...n],o,a,{executeFunction:i})=>(assertColl(e,o),assertStringOrNumber(t,o),assertFunctionLike(r,o),update(e,t,r,n,a,i,o)),arity:{min:3},docs:{category:"collection",returns:{type:"collection"},args:{coll:{type:"collection"},key:{type:["string","number"]},fun:{type:"function"},"fun-args":{type:"any",rest:!0}},variants:[{argumentNames:["coll","value","fun"]},{argumentNames:["coll","value","fun","fun-args"]}],description:"\nUpdates a value in the $coll collection, where $key is a key. $fun is a function\nthat will take the old value and any supplied $fun-args and\nreturn the new value.\nIf the key does not exist, `null` is passed as the old value.",seeAlso:["collection.update-in","assoc"],examples:['\nlet cu = import("collection");\nlet x = { a: 1, b: 2 };\ncu.update(x, "a", inc)','\nlet cu = import("collection");\nlet x = { a: 1, b: 2 };\ncu.update(\n  x,\n  "c",\n  val -> null?(val) ? 0 : inc(val)\n)']}},"update-in":{evaluate:([e,t,r,...n],o,a,{executeFunction:i})=>{if(assertColl(e,o),assertArray(t,o),assertFunctionLike(r,o),1===t.length)return assertStringOrNumber(t[0],o),update(e,t[0],r,n,a,i,o);const{coll:s,innerCollMeta:c}=cloneAndGetMeta(e,t,o),l=asStringOrNumber(t[t.length-1],o),u=asStringOrNumber(t[t.length-2],o);return Array.isArray(c.parent)?(assertNumber(u,o),chain(update(c.coll,l,r,n,a,i,o),e=>(c.parent[u]=e,s))):(assertString(u,o),chain(update(c.coll,l,r,n,a,i,o),e=>(c.parent[u]=e,s)))},arity:{min:3},docs:{category:"collection",returns:{type:"collection"},args:{coll:{type:"collection"},ks:{type:"array"},fun:{type:"function"},"fun-args":{type:"any",rest:!0}},variants:[{argumentNames:["coll","ks","fun"]},{argumentNames:["coll","ks","fun","fun-args"]}],description:"Updates a value in the $coll collection, where $ks is an array of\nkeys and $fun is a function that will take the old value and\nany supplied $fun-args and return the new value. If any levels do not exist,\nobjects will be created - and the corresponding keys must be of type string.",seeAlso:["collection.update","collection.assoc-in","collection.get-in"],examples:['\nlet cu = import("collection");\ncu.update-in(\n  { a: [1, 2, 3] },\n  ["a", 1],\n  -> null?($) ? 0 : inc($)\n)','\nlet cu = import("collection");\ncu.update-in(\n  { a: { foo: "bar"} },\n  ["a", "foo"],\n  -> null?($) ? "?" : "!"\n)','\nlet cu = import("collection");\ncu.update-in(\n  { a: { foo: "bar"} },\n  ["a", "baz"],\n  -> null?($) ? "?" : "!"\n)','\nlet cu = import("collection");\ncu.update-in(\n  { a: [1, 2, 3] },\n  ["a", 1],\n  *,\n  10,\n  10,\n  10,\n)']}},filteri:{evaluate:([e,t],r,n,{executeFunction:o})=>(assertColl(e,r),assertFunctionLike(t,r),Array.isArray(e)?filterSequential(e,(e,a)=>o(t,[e,a],n,r)):"string"==typeof e?chain(filterSequential(e.split(""),(e,a)=>o(t,[e,a],n,r)),e=>e.join("")):chain(filterSequential(Object.entries(e),([e,a])=>o(t,[a,e],n,r)),e=>e.reduce((e,[t,r])=>(e[t]=r,e),{}))),arity:toFixedArity(2),docs:{category:"collection",returns:{type:"collection"},args:{a:{type:"collection"},b:{type:"function",description:"The function to call for each element in the collection. The function should take two arguments: the element itself and the index."}},variants:[{argumentNames:["a","b"]}],description:"Creates a new collection with all elements that pass the test implemented by $b. The function is called for each element in the collection, and it should take two arguments: the element itself and the index.",seeAlso:["filter","collection.mapi"],examples:['let cu = import("collection"); cu.filteri([1, 2, 3], (x, i) -> i % 2 == 0)','let cu = import("collection"); cu.filteri([1, 2, 3], (x, i) -> x % 2 == 0)','let cu = import("collection"); cu.filteri([1, 2, 3], (x, i) -> x + i > 3)']}},mapi:{evaluate:([e,t],r,n,{executeFunction:o})=>{if(assertColl(e,r),assertFunctionLike(t,r),Array.isArray(e))return mapSequential(e,(e,a)=>o(t,[e,a],n,r));if("string"==typeof e)return chain(mapSequential(e.split(""),(e,a)=>o(t,[e,a],n,r)),e=>e.join(""));return reduceSequential(Object.entries(e),(e,[a,i])=>chain(o(t,[i,a],n,r),t=>(e[a]=t,e)),{})},arity:toFixedArity(2),docs:{category:"collection",returns:{type:"collection"},args:{a:{type:"collection"},b:{type:"function",description:"The function to call for each element in the collection. The function should take two arguments: the element itself and the index."}},variants:[{argumentNames:["a","b"]}],description:"Creates a new collection populated with the results of calling $b on every element in $a. The function is called for each element in the collection, and it should take two arguments: the element itself and the index.",seeAlso:["map","collection.filteri"],examples:['let cu = import("collection"); cu.mapi([1, 2, 3], (x, i) -> x + i)','let cu = import("collection"); cu.mapi([1, 2, 3], (x, i) -> x * i)','let cu = import("collection"); cu.mapi([1, 2, 3], (x, i) -> x - i)','let cu = import("collection"); cu.mapi([1, 2, 3], (x, i) -> x / i)','let cu = import("collection"); cu.mapi([1, 2, 3], (x, i) -> x % inc(i))']}},reducei:{evaluate:([e,t,r],n,o,{executeFunction:a})=>(assertColl(e,n),assertFunctionLike(t,n),assertAny(r,n),"string"==typeof e?(assertString(r,n),0===e.length?r:reduceSequential(e.split("").map((e,t)=>({elem:e,index:t})),(e,{elem:r,index:i})=>a(t,[e,r,i],o,n),r)):Array.isArray(e)?0===e.length?r:reduceSequential(e.map((e,t)=>({elem:e,index:t})),(e,{elem:r,index:i})=>a(t,[e,r,i],o,n),r):0===Object.keys(e).length?r:reduceSequential(Object.entries(e),(e,[r,i])=>a(t,[e,i,r],o,n),r)),arity:toFixedArity(3),docs:{category:"collection",returns:{type:"any"},args:{coll:{type:"collection"},fun:{type:"function",description:"The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index."},initial:{type:"any",description:"The initial value to use as the accumulator."}},variants:[{argumentNames:["coll","fun","initial"]}],description:"Runs $fun function on each element of the $coll, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.",seeAlso:["reduce","collection.reducei-right","collection.reductionsi"],examples:['let cu = import("collection"); cu.reducei([1, 2, 3], (acc, x, i) -> acc + x + i, 0)','let cu = import("collection"); cu.reducei("Albert", (acc, x, i) -> acc ++ x ++ i, "")','let cu = import("collection"); cu.reducei({ a: 1, b: 2 }, -> $1 ++ $3, "")']}},"reduce-right":{evaluate:([e,t,r],n,o,{executeFunction:a})=>(assertColl(e,n),assertFunctionLike(t,n),assertAny(r,n),"string"==typeof e?0===e.length?r:reduceSequential(Array.from(e.split("")).reverse(),(e,r)=>a(t,[e,r],o,n),r):Array.isArray(e)?0===e.length?r:reduceSequential(Array.from(e).reverse(),(e,r)=>a(t,[e,r],o,n),r):0===Object.keys(e).length?r:reduceSequential(Object.entries(e).reverse(),(e,[,r])=>a(t,[e,r],o,n),r)),arity:toFixedArity(3),docs:{category:"collection",returns:{type:"any"},args:{fun:{type:"function"},coll:{type:"collection"},initial:{type:"any"}},variants:[{argumentNames:["coll","fun","initial"]}],description:"Runs $fun function on each element of the $coll (starting from the last item), passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value.",seeAlso:["reduce","collection.reducei-right"],examples:['let cu = import("collection"); cu.reduce-right(["A", "B", "C"], str, "")','let cu = import("collection"); cu.reduce-right({ a: 1, b: 2 }, +, 0)']}},"reducei-right":{evaluate:([e,t,r],n,o,{executeFunction:a})=>(assertColl(e,n),assertFunctionLike(t,n),assertAny(r,n),"string"==typeof e?0===e.length?r:reduceSequential(Array.from(e.split("")).reverse().map((e,t,r)=>({elem:e,index:r.length-1-t})),(e,{elem:r,index:i})=>a(t,[e,r,i],o,n),r):Array.isArray(e)?0===e.length?r:reduceSequential(Array.from(e).reverse().map((e,t,r)=>({elem:e,index:r.length-1-t})),(e,{elem:r,index:i})=>a(t,[e,r,i],o,n),r):0===Object.keys(e).length?r:reduceSequential(Object.entries(e).reverse(),(e,[r,i])=>a(t,[e,i,r],o,n),r)),arity:toFixedArity(3),docs:{category:"collection",returns:{type:"any"},args:{coll:{type:"collection"},fun:{type:"function",description:"The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index."},initial:{type:"any",description:"The initial value to use as the accumulator."}},variants:[{argumentNames:["coll","fun","initial"]}],description:"Runs $fun function on each element of the $coll (starting from the last item), passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.",seeAlso:["collection.reducei","collection.reduce-right"],examples:['let cu = import("collection"); cu.reducei-right([1, 2, 3], (acc, x, i) -> acc + x + i, 0)','let cu = import("collection"); cu.reducei-right("Albert", (acc, x, i) -> acc ++ x ++ i, "")','let cu = import("collection"); cu.reducei-right({ a: 1, b: 2 }, -> $1 ++ $3, "")']}},reductions:{evaluate:([e,t,r],n,o,{executeFunction:a})=>{assertColl(e,n),assertFunctionLike(t,n),assertAny(r,n),assertAny(r,n);const i="string"==typeof e?(assertString(r,n),0===e.length?[]:e.split("")):Array.isArray(e)?0===e.length?[]:Array.from(e):0===Object.keys(e).length?[]:Object.entries(e).map(([,e])=>e);if(0===i.length)return[r];const s=[r];return chain(reduceSequential(i,(e,r)=>chain(a(t,[e,r],o,n),e=>(s.push(e),e)),r),()=>s)},arity:toFixedArity(3),docs:{category:"collection",returns:{type:"any",array:!0},args:{fun:{type:"function"},coll:{type:"collection"},initial:{type:"any"}},variants:[{argumentNames:["coll","fun","initial"]}],description:"Returns an array of the intermediate values of the reduction (see `reduce`) of $coll by $fun.",seeAlso:["reduce","collection.reductionsi"],examples:['let cu = import("collection"); cu.reductions([1, 2, 3], +, 0)','let cu = import("collection"); cu.reductions([1, 2, 3], +, 10)','let cu = import("collection"); cu.reductions([], +, 0)','let cu = import("collection"); cu.reductions({ a: 1, b: 2 }, +, 0)','\nlet cu = import("collection");\ncu.reductions(\n  [1, 2, 3, 4, 5, 6, 7, 8, 9],\n  (result, value) -> result + (even?(value) ? value : 0),\n  0\n)']}},reductionsi:{evaluate:([e,t,r],n,o,{executeFunction:a})=>{assertColl(e,n),assertFunctionLike(t,n),assertAny(r,n),assertAny(r,n);const i=(e,t)=>({elem:e,key:t}),s="string"==typeof e?(assertString(r,n),0===e.length?[]:e.split("").map((e,t)=>i(e,t))):Array.isArray(e)?0===e.length?[]:e.map((e,t)=>i(e,t)):0===Object.keys(e).length?[]:Object.entries(e).map(([e,t])=>i(t,e));if(0===s.length)return[r];const c=[r];return chain(reduceSequential(s,(e,{elem:r,key:i})=>chain(a(t,[e,r,i],o,n),e=>(c.push(e),e)),r),()=>c)},arity:toFixedArity(3),docs:{category:"collection",returns:{type:"any",array:!0},args:{coll:{type:"collection"},fun:{type:"function",description:"The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index."},initial:{type:"any",description:"The initial value to use as the accumulator."}},variants:[{argumentNames:["coll","fun","initial"]}],description:"Returns an array of the intermediate values of the reduction (see `reduce`) of $coll by $fun. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.",seeAlso:["collection.reductions","collection.reducei"],examples:['let cu = import("collection"); cu.reductionsi([1, 2, 3], (acc, x, i) -> acc + x + i, 0)','let cu = import("collection"); cu.reductionsi("Albert", (acc, x, i) -> acc ++ x ++ i, "")','let cu = import("collection"); cu.reductionsi({ a: 1, b: 2 }, -> $1 ++ $3, "")']}},"not-empty":{evaluate:([e],t)=>null===e?null:(assertColl(e,t),"string"==typeof e||Array.isArray(e)?e.length>0?e:null:Object.keys(e).length>0?e:null),arity:toFixedArity(1),docs:{category:"collection",returns:{type:"boolean"},args:{coll:{type:["collection","null"]}},variants:[{argumentNames:["coll"]}],description:"Returns `null` if $coll is empty or `null`, otherwise $coll.",seeAlso:["empty?","not-empty?"],examples:['let cu = import("collection"); cu.not-empty([])','let cu = import("collection"); cu.not-empty([1, 2, 3])','let cu = import("collection"); cu.not-empty({})','let cu = import("collection"); cu.not-empty({ a: 2 })','let cu = import("collection"); cu.not-empty("")','let cu = import("collection"); cu.not-empty("Albert")','let cu = import("collection"); cu.not-empty(null)']}},"every?":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertColl(e,r),assertFunctionLike(t,r);return everySequential(Array.isArray(e)?e:"string"==typeof e?e.split(""):Object.entries(e),e=>o(t,[e],n,r))},arity:toFixedArity(2),docs:{category:"collection",returns:{type:"boolean"},args:{a:{type:"collection"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],description:"Returns `true` if all entries in $a pass the test implemented by $b, otherwise returns `false`.",seeAlso:["collection.any?","collection.not-every?","collection.not-any?","functional.every-pred","grid.every?"],examples:['let cu = import("collection"); cu.every?([1, 2, 3], number?)','let cu = import("collection"); cu.every?([1, 2, 3], even?)','\nlet cu = import("collection");\ncu.every?(\n  ["Albert", "Mojir", 160, [1, 2]],\n  string?,\n)','\nlet cu = import("collection");\ncu.every?(\n  [50, 100, 150, 200],\n  -> $ > 10,\n)','let cu = import("collection"); cu.every?([], number?)','let cu = import("collection"); cu.every?("", number?)','let cu = import("collection"); cu.every?({}, number?)','\nlet cu = import("collection");\ncu.every?(\n  { a: 2, b: 4},\n  -> even?(second($))\n)','\nlet cu = import("collection");\ncu.every?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)']}},"any?":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertFunctionLike(t,r),assertColl(e,r);return someSequential(Array.isArray(e)?e:"string"==typeof e?e.split(""):Object.entries(e),e=>o(t,[e],n,r))},arity:toFixedArity(2),docs:{category:"collection",returns:{type:"boolean"},args:{a:{type:"collection"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],description:"Returns `true` if any element in $a pass the test implemented by $b, otherwise returns `false`.",seeAlso:["collection.every?","collection.not-any?","collection.not-every?","functional.some-pred","some","grid.some?"],examples:['\nlet cu = import("collection");\ncu.any?(\n  ["Albert", "Mojir", 160, [1, 2]],\n  string?\n)','\nlet cu = import("collection");\ncu.any?(\n  [50, 100, 150, 200],\n  x -> x > 10\n)','let cu = import("collection"); cu.any?([], number?)','let cu = import("collection"); cu.any?("", number?)','let cu = import("collection"); cu.any?({}, number?)','\nlet cu = import("collection");\ncu.any?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)','\nlet cu = import("collection");\ncu.any?(\n  { a: 1, b: 3 },\n  -> even?(second($))\n)']}},"not-any?":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertFunctionLike(t,r),assertColl(e,r);return chain(someSequential(Array.isArray(e)?e:"string"==typeof e?e.split(""):Object.entries(e),e=>o(t,[e],n,r)),e=>!e)},arity:toFixedArity(2),docs:{category:"collection",returns:{type:"boolean"},args:{a:{type:"collection"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],description:"Returns `false` if any element in $a pass the test implemented by $b, otherwise returns `true`.",seeAlso:["collection.any?","collection.every?","collection.not-every?"],examples:['\nlet cu = import("collection");\ncu.not-any?(\n  ["Albert", "Mojir", 160, [1, 2]],\n  string?\n)','\nlet cu = import("collection");\ncu.not-any?(\n  [50, 100, 150, 200],\n  x -> x > 10\n)','let cu = import("collection"); cu.not-any?([], number?)','let cu = import("collection"); cu.not-any?("", number?)','let cu = import("collection"); cu.not-any?({}, number?)','\nlet cu = import("collection");\ncu.not-any?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)','\nlet cu = import("collection");\ncu.not-any?(\n  { a: 1, b: 3 },\n  -> even?(second($))\n)']}},"not-every?":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertFunctionLike(t,r),assertColl(e,r);return chain(everySequential(Array.isArray(e)?e:"string"==typeof e?e.split(""):Object.entries(e),e=>o(t,[e],n,r)),e=>!e)},arity:toFixedArity(2),docs:{category:"collection",returns:{type:"boolean"},args:{a:{type:"collection"},b:{type:"function"}},variants:[{argumentNames:["a","b"]}],description:"Returns `true` if at least one element in $a does not pass the test implemented by $b, otherwise returns `false`.",seeAlso:["collection.every?","collection.any?","collection.not-any?"],examples:['\nlet cu = import("collection");\ncu.not-every?(\n  ["Albert", "Mojir", 160, [1, 2]],\n  string?\n)','\nlet cu = import("collection");\ncu.not-every?(\n  [50, 100, 150, 200],\n  x -> x > 10\n)','let cu = import("collection"); cu.not-every?([], number?)','let cu = import("collection"); cu.not-every?("", number?)','let cu = import("collection"); cu.not-every?({}, number?)','\nlet cu = import("collection");\ncu.not-every?(\n  { a: 2, b: 4 },\n  -> even?(second($))\n)','\nlet cu = import("collection");\ncu.not-every?(\n  { a: 2, b: 3 },\n  -> even?(second($))\n)']}}},collectionUtilsModule={name:"collection",functions:collectionUtilsFunctions},sequenceUtilsFunctions={position:{evaluate:([e,t],r,n,{executeFunction:o})=>{if(assertFunctionLike(t,r),null===e)return null;assertSeq(e,r);return chain(findIndexSequential("string"==typeof e?e.split(""):e,e=>o(t,[e],n,r)),e=>-1!==e?e:null)},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:["number","null"]},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:["sequence","null"]},fun:{type:"function"}},variants:[{argumentNames:["seq","fun"]}],description:"Returns the index of the first elements that passes the test implemented by $fun. If no element was found, `null` is returned.",seeAlso:["index-of","some","find"],examples:['\nlet su = import("sequence");\nsu.position(\n  ["Albert", "Mojir", 160, [1, 2]],\n  string?\n)','\nlet su = import("sequence");\nsu.position(\n  [5, 10, 15, 20],\n  -> $ > 10\n)','\nlet su = import("sequence");\nsu.position(\n  [5, 10, 15, 20],\n  -> $ > 100\n)','\nlet su = import("sequence");\nsu.position(\n  null,\n  -> $ > 100\n)']}},"last-index-of":{evaluate:([e,t],r)=>{if(assertAny(t,r),null===e)return null;if(assertSeq(e,r),"string"==typeof e){assertString(t,r);const n=e.lastIndexOf(t);return-1!==n?n:null}{const n=e.findLastIndex(e=>deepEqual(asAny(e,r),t),r);return-1!==n?n:null}},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:["number","null"]},args:{a:{type:"sequence"},b:{type:"any"},seq:{type:["sequence","null"]},x:{type:"any"}},variants:[{argumentNames:["seq","x"]}],description:"Returns the last index of $x in $seq. If element is not present in $seq `null` is returned.",seeAlso:["index-of"],examples:['let su = import("sequence"); su.last-index-of([[1], [2], [1], [2]], [1])','let su = import("sequence"); su.last-index-of(["Albert", "Mojir", 160, [1, 2]], "Mojir")','let su = import("sequence"); su.last-index-of([5, 10, 15, 20, 15], 15)','let su = import("sequence"); su.last-index-of([5, 10, 15, 20], 1)','let su = import("sequence"); su.last-index-of(null, 1)']}},shift:{evaluate:([e],t)=>{if(assertSeq(e,t),"string"==typeof e)return e.substring(1);const r=[...e];return r.shift(),r},arity:toFixedArity(1),docs:{category:"sequence",returns:{type:["sequence","null"]},args:{seq:{type:"sequence"}},variants:[{argumentNames:["seq"]}],description:"Returns a copy of $seq with first element removed. If $seq is empty `null` is returned.",seeAlso:["sequence.unshift","pop","rest"],examples:['let su = import("sequence"); su.shift([1, 2, 3])','let su = import("sequence"); su.shift([])']}},splice:{evaluate:(e,t)=>{const[r,n,o,...a]=e;assertSeq(r,t),assertNumber(n,t,{integer:!0}),assertNumber(o,t,{integer:!0,nonNegative:!0});const i=n<0?r.length+n:n;return Array.isArray(r)?[...r.slice(0,i),...a,...r.slice(i+o)]:(a.forEach(e=>assertString(e,t)),`${r.substring(0,i)}${a.join("")}${r.substring(i+o)}`)},arity:{min:3},docs:{category:"sequence",returns:{type:"sequence"},args:{seq:{type:"sequence",rest:!0},start:{type:"integer"},deleteCount:{type:"integer"},items:{type:"any",rest:!0}},variants:[{argumentNames:["seq","start","deleteCount"]},{argumentNames:["seq","start","deleteCount","items"]}],description:"Returns a a spliced array. Removes $deleteCount elements from $seq starting at $start and replaces them with $items. If $start is negative, it is counting from the end of the array.",seeAlso:["slice","sequence.remove-at"],examples:['let su = import("sequence"); su.splice([1, 2, 3, 4, 5], 2, 2, "x")','let su = import("sequence"); su.splice([1, 2, 3, 4, 5], -2, 1, "x")','let su = import("sequence"); su.splice("Albert", 2, 2, "fo")']}},"sort-by":{evaluate:(e,t,r,{executeFunction:n})=>{const[o,a]=e,i=2===e.length;assertSeq(o,t),assertFunctionLike(a,t);const s=i?null:e[2],c="string"==typeof o,l=c?o.split(""):[...o];return chain(mapSequential(l,e=>n(a,[e],r,t)),e=>{if(i){const r=l.map((t,r)=>({elem:t,key:e[r]}));r.sort((e,r)=>(assertStringOrNumber(e.key,t),assertStringOrNumber(r.key,t),compare(e.key,r.key,t)));const n=r.map(e=>e.elem);return c?n.join(""):n}{assertFunctionLike(s,t);const o=l.map((t,r)=>({elem:t,key:e[r]}));o.sort((e,o)=>{const a=n(s,[e.key,o.key],r,t);if(a instanceof Promise)throw new TypeError("Async functions cannot be used as sort-by comparators");return assertNumber(a,t,{finite:!0}),a});const a=o.map(e=>e.elem);return c?a.join(""):a}})},arity:{min:2,max:3},docs:{category:"sequence",returns:{type:"any",rest:!0},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:"sequence"},keyfn:{type:"function"},comparer:{type:"function"}},variants:[{argumentNames:["seq","keyfn"]},{argumentNames:["seq","keyfn","comparer"]}],description:"Returns a sorted sequence of the items in $seq, where the sort order is determined by comparing `(keyfn item)`. If no $comparer is supplied, uses builtin `compare`.",seeAlso:["sort","compare"],examples:['let su = import("sequence"); su.sort-by(["Albert", "Mojir", "Nina"], count)','let su = import("sequence"); su.sort-by(["Albert", "Mojir", "Nina"], count)','let su = import("sequence"); su.sort-by("Albert", lower-case, -> $2 compare $1)']}},unshift:{evaluate:([e,...t],r)=>{if(assertSeq(e,r),"string"==typeof e)return assertCharArray(t,r),[...t,e].join("");const n=[...e];return n.unshift(...t),n},arity:{min:2},docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"any"},seq:{type:"sequence"},values:{type:"any",rest:!0}},variants:[{argumentNames:["seq","values"]}],description:"Returns copy of $seq with $values added to the beginning.",seeAlso:["push","sequence.shift","++"],examples:['let su = import("sequence"); su.unshift([1, 2, 3], 4)','let su = import("sequence"); su.unshift([1, 2, 3], 4)','let su = import("sequence"); su.unshift([1, 2, 3], 4, 5, 6)','\nlet su = import("sequence");\nlet l = [1, 2, 3];\nsu.unshift(l, 4);\nl']}},distinct:{evaluate:([e],t)=>{if(assertSeq(e,t),Array.isArray(e)){const r=[];for(const n of e)assertAny(n,t),r.some(e=>deepEqual(e,n,t))||r.push(n);return r}return Array.from(new Set(e.split(""))).join("")},arity:toFixedArity(1),docs:{category:"sequence",returns:{type:"sequence"},args:{seq:{type:"sequence"}},variants:[{argumentNames:["seq"]}],description:"Returns a copy of $seq with no duplicates.",seeAlso:["sequence.frequencies"],examples:['let su = import("sequence"); su.distinct([[1], [2], [3], [1], [3], [5]])','let su = import("sequence"); su.distinct([1, 2, 3, 1, 3, 5])','let su = import("sequence"); su.distinct("Albert Mojir")','let su = import("sequence"); su.distinct([])','let su = import("sequence"); su.distinct("")']}},remove:{evaluate:([e,t],r,n,{executeFunction:o})=>{assertFunctionLike(t,r),assertSeq(e,r);return chain(filterSequential(Array.isArray(e)?e:e.split(""),e=>chain(o(t,[e],n,r),e=>!e)),t=>"string"==typeof e?t.join(""):t)},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:"sequence"},fun:{type:"function"}},variants:[{argumentNames:["seq","fun"]}],description:"Returns a new sequence of items in $seq for witch `pred(item)` returns a falsy value.",seeAlso:["filter","sequence.remove-at"],examples:['let su = import("sequence"); su.remove([1, 2, 3, 1, 3, 5], odd?)','let su = import("sequence"); su.remove([1, 2, 3, 1, 3, 5], even?)','let su = import("sequence"); su.remove("Albert Mojir", -> "aoueiyAOUEIY" contains? $)']}},"remove-at":{evaluate:([e,t],r)=>{assertNumber(t,r,{integer:!0}),assertSeq(e,r);const n=t<0?e.length+t:t;return n<0||n>=e.length?e:Array.isArray(e)?e.filter((e,t)=>t!==n):`${e.substring(0,n)}${e.substring(n+1)}`},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"integer"},seq:{type:"sequence"},n:{type:"number"}},variants:[{argumentNames:["seq","n"]}],description:"Returns a new sequence of all items in $seq except item at position $n. If $n is negative, it is counting from the end of the sequence.",seeAlso:["sequence.remove","sequence.splice"],examples:['let su = import("sequence"); su.remove-at([1, 2, 3, 1, 3, 5], 2)','let su = import("sequence"); su.remove-at("Albert", -2)','let su = import("sequence"); su.remove-at([1, 2, 3, 1, 3, 5], 0)','let su = import("sequence"); su.remove-at([1, 2, 3, 1, 3, 5], -1)','let su = import("sequence"); su.remove-at("Albert Mojir", 6)']}},"split-at":{evaluate:([e,t],r)=>{assertNumber(t,r,{integer:!0}),assertSeq(e,r);const n=t<0?e.length+t:t;return[e.slice(0,n),e.slice(n)]},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"integer"},seq:{type:"sequence"},n:{type:"number"}},variants:[{argumentNames:["seq","n"]}],description:"Returns a pair of sequence `[take(pos input), drop(pos input)]`.",seeAlso:["sequence.split-with","take","drop"],examples:['let su = import("sequence"); su.split-at([1, 2, 3, 4, 5], 2)','let su = import("sequence"); su.split-at("Albert", -2)','let su = import("sequence"); su.split-at([1, 2, 3, 4, 5], -2)','let su = import("sequence"); su.split-at("Albert", 2)']}},"split-with":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertFunctionLike(t,r),assertSeq(e,r);const a=Array.isArray(e);return chain(findIndexSequential(a?e:e.split(""),e=>chain(o(t,[e],n,r),e=>!e)),t=>-1===t?[e,a?[]:""]:[e.slice(0,t),e.slice(t)])},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:"sequence"},fun:{type:"function"}},variants:[{argumentNames:["seq","fun"]}],description:"Returns a pair of sequences `[take-while(input, fun), drop-while(input, fun)]`.",seeAlso:["sequence.split-at","take-while","drop-while"],examples:['let su = import("sequence"); su.split-with([1, 2, 3, 4, 5], odd?)','let su = import("sequence"); su.split-with([1, 2, 3, 4, 5], -> $ > 3)','let su = import("sequence"); su.split-with("Albert", -> $ <= "o")']}},frequencies:{evaluate:([e],t)=>{assertSeq(e,t);return("string"==typeof e?e.split(""):e).reduce((e,r)=>(assertString(r,t),collHasKey(e,r)?e[r]=e[r]+1:e[r]=1,e),{})},arity:toFixedArity(1),docs:{category:"sequence",returns:{type:"object"},args:{seq:{type:"sequence"}},variants:[{argumentNames:["seq"]}],description:"Returns an object from distinct items in $seq to the number of times they appear. Note that all items in $seq must be valid object keys i.e. strings.",seeAlso:["sequence.group-by","sequence.distinct","vector.count-values"],examples:['let su = import("sequence"); su.frequencies(["Albert", "Mojir", "Nina", "Mojir"])','let su = import("sequence"); su.frequencies("Pneumonoultramicroscopicsilicovolcanoconiosis")']}},"group-by":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertFunctionLike(t,r),assertSeq(e,r);return reduceSequential(Array.isArray(e)?e:e.split(""),(e,a)=>chain(o(t,[a],n,r),t=>(assertString(t,r),collHasKey(e,t)||(e[t]=[]),e[t].push(a),e)),{})},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"object"},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:"sequence"},fun:{type:"function"}},variants:[{argumentNames:["seq","fun"]}],description:"Returns an object of the elements of $seq keyed by the result of $fun on each element. The value at each key will be an array of the corresponding elements.",seeAlso:["sequence.frequencies","sequence.partition-by"],examples:['let su = import("sequence"); su.group-by([{ name: "Albert" }, { name: "Albert" }, { name: "Mojir" }], "name")','let su = import("sequence"); su.group-by([{name: "Albert"}, {name: "Albert"}, {name: "Mojir"}], "name")','let su = import("sequence"); su.group-by("Albert Mojir", -> "aoueiAOUEI" contains? $ ? "vowel" : "other")']}},partition:{evaluate:(e,t)=>{const r=asSeq(e[0],t),n=toNonNegativeInteger(asNumber(e[1],t));return partitionHelper(n,e.length>=3?toNonNegativeInteger(asNumber(e[2],t)):n,r,4===e.length?null===e[3]?[]:asArray(e[3],t):void 0,t)},arity:{min:2,max:4},docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"number"},seq:{type:"sequence"},n:{type:"number"},step:{type:"number"},pad:{type:"array"}},variants:[{argumentNames:["seq","n"]},{argumentNames:["seq","n","step"]},{argumentNames:["seq","n","step","pad"]}],description:"Returns an array of sequences of $n items each, at offsets $step apart. If $step is not supplied, defaults to $n. If a $pad array is supplied, use its elements as necessary to complete last partition upto $n items. In case there are not enough padding elements, return a partition with less than $n items.",seeAlso:["sequence.partition-all","sequence.partition-by"],examples:['let su = import("sequence"); su.partition(range(20), 4)','let su = import("sequence"); su.partition(range(20), 4)','let su = import("sequence"); su.partition(range(22), 4)','let su = import("sequence"); su.partition(range(20), 4, 6)','let su = import("sequence"); su.partition(range(20), 4, 3)','let su = import("sequence"); su.partition(range(20), 3, 6, ["a"])','let su = import("sequence"); su.partition(range(20), 4, 6, ["a"])','let su = import("sequence"); su.partition(range(20), 4, 6, ["a", "b", "c", "d"])','let su = import("sequence"); su.partition(["a", "b", "c", "d", "e", "f"], 3, 1)','let su = import("sequence"); su.partition([1, 2, 3, 4], 10)','let su = import("sequence"); su.partition([1, 2, 3, 4], 10, 10)','let su = import("sequence"); su.partition([1, 2, 3, 4], 10, 10, [])','let su = import("sequence"); su.partition([1, 2, 3, 4], 10, 10, null)','let su = import("sequence"); su.partition("superfragilistic", 5)','let su = import("sequence"); su.partition("superfragilistic", 5, 5, null)','let su = import("sequence"); let foo = [5, 6, 7, 8]; su.partition(foo, 2, 1, foo)']}},"partition-all":{evaluate:(e,t)=>{const r=asSeq(e[0],t),n=toNonNegativeInteger(asNumber(e[1],t));return partitionHelper(n,3===e.length?toNonNegativeInteger(asNumber(e[2],t)):n,r,[],t)},arity:{min:2,max:3},docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"number"},seq:{type:"sequence"},n:{type:"number"},step:{type:"number"}},variants:[{argumentNames:["seq","n"]},{argumentNames:["seq","n","step"]}],description:"Returns an array of sequences like partition, but may include partitions with fewer than n items at the end.",seeAlso:["sequence.partition","sequence.partition-by"],examples:['let su = import("sequence"); su.partition-all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4)','let su = import("sequence"); su.partition-all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4)','let su = import("sequence"); su.partition([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4)','let su = import("sequence"); su.partition-all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 2, 4)']}},"partition-by":{evaluate:([e,t],r,n,{executeFunction:o})=>{assertFunctionLike(t,r),assertSeq(e,r);const a="string"==typeof e;return chain(reduceSequential(a?e.split(""):e,(e,a)=>chain(o(t,[a],n,r),t=>(t!==e.oldValue&&(e.result.push([]),e.oldValue=t),e.result[e.result.length-1].push(a),e)),{result:[],oldValue:void 0}),({result:e})=>a?e.map(e=>e.join("")):e)},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"function"},seq:{type:"sequence"},fun:{type:"function"}},variants:[{argumentNames:["seq","fun"]}],description:"Applies $fun to each value in $seq, splitting it each time $fun returns a new value. Returns an array of sequences.",seeAlso:["sequence.partition","sequence.partition-all","sequence.group-by"],examples:['let su = import("sequence"); su.partition-by([1, 2, 3, 4, 5], odd?)','let su = import("sequence"); su.partition-by([1, 2, 3, 4, 5], -> $ == 3)','let su = import("sequence"); su.partition-by([1, 1, 1, 2, 2, 3, 3], odd?)','let su = import("sequence"); su.partition-by("Leeeeeerrroyyy", identity)']}},"ends-with?":{evaluate:([e,t],r)=>(assertSeq(e,r),"string"==typeof e?(assertString(t,r),e.endsWith(t)):deepEqual(asAny(e.at(-1),r),asAny(t,r),r)),arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"boolean"},args:{a:{type:"sequence"},b:{type:"sequence"},seq:{type:"sequence"},suffix:{type:"sequence"}},variants:[{argumentNames:["seq","suffix"]}],description:"Returns `true` if $seq ends with $suffix, otherwise `false`.",seeAlso:["sequence.starts-with?"],examples:['let su = import("sequence"); su.ends-with?([[1], [2], [3], [4], [5]], [5])','let su = import("sequence"); su.ends-with?([[1], [2], [3], [4], [5]], 5)','let su = import("sequence"); su.ends-with?([1, 2, 3, 4, 5], 5)','let su = import("sequence"); su.ends-with?([1, 2, 3, 4, 5], [5])','let su = import("sequence"); su.ends-with?("Albert", "rt")','let su = import("sequence"); su.ends-with?("Albert", "RT")']}},"starts-with?":{evaluate:([e,t],r)=>(assertSeq(e,r),"string"==typeof e?(assertString(t,r),e.startsWith(t)):deepEqual(asAny(e[0],r),asAny(t,r),r)),arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"boolean"},args:{a:{type:"sequence"},b:{type:"sequence"},seq:{type:"sequence"},prefix:{type:"sequence"}},variants:[{argumentNames:["seq","prefix"]}],description:"Returns `true` if $seq starts with $prefix, otherwise `false`.",seeAlso:["sequence.ends-with?"],examples:['let su = import("sequence"); su.starts-with?([[1], [2], [3], [4], [5]], [1])','let su = import("sequence"); su.starts-with?([1, 2, 3, 4, 5], 1)','let su = import("sequence"); su.starts-with?([1, 2, 3, 4, 5], [1])','let su = import("sequence"); su.starts-with?("Albert", "Al")','let su = import("sequence"); su.starts-with?("Albert", "al")']}},interleave:{evaluate:([...e],t)=>{const r="string"==typeof e[0],n=r?e.map(e=>(assertString(e,t),e.split(""))):e.map(e=>(assertArray(e,t),e)),o=Math.min(...n.map(e=>e.length)),a=[];for(let e=0;e<o;e+=1)for(const t of n)e<t.length&&a.push(t[e]);return r?a.join(""):a},arity:{min:1},docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"sequence"},seqs:{type:"sequence",rest:!0}},variants:[{argumentNames:["seqs"]}],description:"Returns a sequence of the first item from each of the $seqs, then the second item from each of the $seqs, until all items from the shortest seq are exhausted.",seeAlso:["sequence.interpose","zipmap"],examples:['let su = import("sequence"); su.interleave([1, 2, 3], [4, 5, 6])','let su = import("sequence"); su.interleave("Albert", ".,.,.,")','let su = import("sequence"); su.interleave([1, 2, 3], [4, 5, 6])','let su = import("sequence"); su.interleave([1, 2, 3], [4, 5, 6], [7, 8, 9])','let su = import("sequence"); su.interleave([1, 2, 3], [4, 5, 6], [7, 8])','let su = import("sequence"); su.interleave([1, 2, 3], [4, 5, 6], [7])','let su = import("sequence"); su.interleave([1, 2, 3], [4, 5, 6], [])','let su = import("sequence"); su.interleave([1, 2, 3], [])','let su = import("sequence"); su.interleave([])']}},interpose:{evaluate:([e,t],r)=>{if(assertSeq(e,r),"string"==typeof e)return assertString(t,r),e.split("").join(t);if(0===e.length)return[];const n=[];for(let r=0;r<e.length-1;r+=1)n.push(e[r],t);return n.push(e[e.length-1]),n},arity:toFixedArity(2),docs:{category:"sequence",returns:{type:"sequence"},args:{a:{type:"sequence"},b:{type:"any"},seq:{type:"sequence"},separator:{type:"any"}},variants:[{argumentNames:["seq","separator"]}],description:"Returns a sequence of the elements of $seq separated by $separator. If $seq is a string, the separator must be a string.",seeAlso:["sequence.interleave","join"],examples:['let su = import("sequence"); su.interpose("Albert", "-")','let su = import("sequence"); su.interpose([1, 2, 3, 4, 5], "a")','let su = import("sequence"); su.interpose(["Albert", "Mojir", "Nina"], ", ")','let su = import("sequence"); su.interpose("Albert", ".")']}}};function partitionHelper(e,t,r,n,o){assertNumber(t,o,{positive:!0});const a="string"==typeof r,i=[];let s=0;e:for(;s<r.length;){const o=[];for(let a=s;a<s+e;a+=1)if(a>=r.length){const e=a-r.length;if(!n){s+=t;continue e}if(e>=n.length)break;o.push(n[e])}else o.push(r[a]);i.push(o),s+=t}return a?i.map(e=>e.join("")):i}const sequenceUtilsModule={name:"sequence",functions:sequenceUtilsFunctions};function getOperatorArgs(e,t){return{a:{type:e},b:{type:t}}}const bitwiseUtilsNormalExpression={"bit-not":{evaluate:([e],t)=>(assertNumber(e,t,{integer:!0}),~e),arity:toFixedArity(1),docs:{category:"bitwise",returns:{type:"integer"},args:{a:{type:"integer"}},variants:[{argumentNames:["a"]}],description:"Returns bitwise `not` of $a.",seeAlso:["&","|","xor","bitwise.bit-and-not"],examples:['let { bit-not } = import("bitwise");\nbit-not(0)','let { bit-not } = import("bitwise");\nbit-not(255)']}},"bit-and-not":{evaluate:([e,...t],r)=>(assertNumber(e,r,{integer:!0}),t.reduce((e,t)=>(assertNumber(t,r,{integer:!0}),e&~t),e)),arity:{min:2},docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs("integer","integer"),c:{type:"integer",rest:!0}},variants:[{argumentNames:["a","b"]},{argumentNames:["a","b","c"]}],description:"Returns bitwise `and` with complement.",seeAlso:["&","|","xor","bitwise.bit-not"],examples:['let { bit-and-not } = import("bitwise");\n0b0011 bit-and-not 0b0110','let { bit-and-not } = import("bitwise");\nbit-and-not(0b0011, 0b0110)','let { bit-and-not } = import("bitwise");\nbit-and-not(0b0011, 0b0110, 0b1001)']}},"bit-flip":{evaluate:([e,t],r)=>{assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0,nonNegative:!0});return e^1<<t},arity:toFixedArity(2),docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs("integer","integer")},variants:[{argumentNames:["a","b"]}],description:"Flips bit number $b.",seeAlso:["bitwise.bit-set","bitwise.bit-clear","bitwise.bit-test"],examples:['let { bit-flip } = import("bitwise");\n0b0011 bit-flip 1','let { bit-flip } = import("bitwise");\nbit-flip(0b0011, 1)','let { bit-flip } = import("bitwise");\nbit-flip(0b1100, 1)']}},"bit-set":{evaluate:([e,t],r)=>{assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0,nonNegative:!0});return e|1<<t},arity:toFixedArity(2),docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs("integer","integer")},variants:[{argumentNames:["a","b"]}],description:"Sets bit number $b.",seeAlso:["bitwise.bit-flip","bitwise.bit-clear","bitwise.bit-test"],examples:['let { bit-set } = import("bitwise");\n0b0010 bit-set 1','let { bit-set } = import("bitwise");\nbit-set(0b0011, 1)','let { bit-set } = import("bitwise");\nbit-set(0b1100, 1)']}},"bit-clear":{evaluate:([e,t],r)=>{assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0,nonNegative:!0});return e&~(1<<t)},arity:toFixedArity(2),docs:{category:"bitwise",returns:{type:"integer"},args:{...getOperatorArgs("integer","integer")},variants:[{argumentNames:["a","b"]}],description:"Clears bit number $b.",seeAlso:["bitwise.bit-flip","bitwise.bit-set","bitwise.bit-test"],examples:['let { bit-clear } = import("bitwise");\n0b0011 bit-clear 1','let { bit-clear } = import("bitwise");\nbit-clear(0b0011, 1)','let { bit-clear } = import("bitwise");\nbit-clear(0b1100, 1)']}},"bit-test":{evaluate:([e,t],r)=>{assertNumber(e,r,{integer:!0}),assertNumber(t,r,{integer:!0,nonNegative:!0});return!!(e&1<<t)},arity:toFixedArity(2),docs:{category:"bitwise",returns:{type:"boolean"},args:{...getOperatorArgs("integer","integer")},variants:[{argumentNames:["a","b"]}],description:"Checks if bit number $b is set.",seeAlso:["bitwise.bit-flip","bitwise.bit-set","bitwise.bit-clear"],examples:['let { bit-test } = import("bitwise");\n0b0011 bit-test 1','let { bit-test } = import("bitwise");\nbit-test(0b0011, 1)','let { bit-test } = import("bitwise");\nbit-test(0b1100, 1)']}}},bitwiseUtilsModule={name:"bitwise",functions:bitwiseUtilsNormalExpression},allBuiltinModules=[assertModule,gridModule,randomModule,vectorModule,linearAlgebraModule,matrixModule,numberTheoryModule,mathUtilsModule,functionalUtilsModule,stringUtilsModule,collectionUtilsModule,sequenceUtilsModule,bitwiseUtilsModule];function isFunctionDocs(e){return"args"in e&&"variants"in e}const datatype={"-type-number":{datatype:!0,title:"number",category:"datatype",description:"A `number`",examples:["42","3.14"]},"-type-string":{datatype:!0,title:"string",category:"datatype",description:"A `string`",examples:['"hello"','""']},"-type-object":{datatype:!0,title:"object",category:"datatype",description:"An `object`, a collection of key-value pairs where keys are `strings`",examples:["{}","{ a: 1, b: 2}"]},"-type-array":{datatype:!0,title:"array",category:"datatype",description:"An `array`",examples:["[]","[1, 2, 3]",'["a", null, true]']},"-type-vector":{datatype:!0,title:"vector",category:"datatype",description:"An `array` of `numbers`",examples:["[]","[1, 2, 3]"]},"-type-matrix":{datatype:!0,title:"matrix",category:"datatype",description:"A `matrix`, a two-dimensional `array` with `numbers` where each row has the same number of columns. A `matrix` is also a `grid`.",examples:["[[]]","[[1, 2], [3, 4]]","[[1, 2], [3, 4], [5, 6]]"]},"-type-grid":{datatype:!0,title:"grid",category:"datatype",description:"A `grid`, a two-dimensional `array` where each row has the same number of columns",examples:["[[]]","[[1, 2], [3, 4]]",'[["a", "b"], [3, 4], [5, 6]]']},"-type-boolean":{datatype:!0,title:"boolean",category:"datatype",description:"A `boolean`",examples:["true","false"]},"-type-function":{datatype:!0,title:"function",category:"datatype",description:"A `function`",examples:["x -> x + 1","(a, b, c) -> (a + b) * c","() -> 42","-> $1 + $2"]},"-type-integer":{datatype:!0,title:"integer",category:"datatype",description:"An `integer`",examples:["42","-42"]},"-type-any":{datatype:!0,title:"any",category:"datatype",description:"`Any` value",examples:["42",'"hello"',"true","null"]},"-type-null":{datatype:!0,title:"null",category:"datatype",description:"The value `null`",examples:["null"]},"-type-collection":{datatype:!0,title:"collection",category:"datatype",description:"A collection, an `object`, an `array` or a `string`",examples:["{ foo: 42 }","[1, 2, 3]",'"hello"']},"-type-sequence":{datatype:!0,title:"sequence",category:"datatype",description:"A sequence, an `array` or a `string`",examples:["[1, 2, 3]",'"hello"']},"-type-regexp":{datatype:!0,title:"regexp",category:"datatype",description:"A regular expression",examples:['regexp("^\\\\s*(.*)$")','#"albert"ig']},"-type-never":{datatype:!0,title:"never",category:"datatype",description:"A value that can never be created",examples:['\n// throw("error") will never return a value\ntry throw("error") catch "never" end']}},shorthand={"-short-regexp":{shorthand:!0,title:'#"pattern"',category:"shorthand",description:"Shorthand for `regexp(pattern)`. Only difference is that escaping is not needed.",examples:['#"^\\s*(.*)$"','#"albert"ig'],seeAlso:["regexp","match","replace","replace-all"]},"-short-fn":{shorthand:!0,title:"-> expression",category:"shorthand",description:"\nShorthand for `(args, ...) -> expression`.\n`$1, $2, $3, ...` are shorthand for the first, second, third, ... argument.\n\nYou can reference the first argument using either `$1` or `$`.\nHowever, please note that `$1` and `$` are mutually exclusive and cannot be used simultaneously.\nE.g. `#(* $ $1)` is not valid.",examples:["-> $1 + $2","(-> $ * $)(9)"]}};function docsToReference(e){const t={};for(const[r,n]of Object.entries(e)){const e=n.docs;if(!e)throw new Error(`Missing docs for expression "${r}"`);t[r]={title:r,category:e.category,description:e.description,returns:e.returns,args:e.args,variants:e.variants,examples:e.examples,...e.seeAlso?{seeAlso:e.seeAlso}:{},...e.hideOperatorForm?{noOperatorDocumentation:!0}:{}}}return t}function moduledDocsToReference(e,t){const r={};for(const[n,o]of Object.entries(t)){const t=o.docs;if(!t)throw new Error(`Missing docs for ${e}.${n}`);const a=`${e}.${n}`;r[a]={title:a,category:t.category,description:t.description,returns:t.returns,args:t.args,variants:t.variants,examples:t.examples,...t.seeAlso?{seeAlso:t.seeAlso}:{},...t.hideOperatorForm?{noOperatorDocumentation:!0}:{}}}return r}const bitwiseReference=docsToReference(bitwiseNormalExpression),arrayRef=docsToReference(arrayNormalExpression),collectionRef=docsToReference(collectionNormalExpression),functionalRef=docsToReference(functionalNormalExpression),mathRef=docsToReference(mathNormalExpression),emptyRef={},metaRef=docsToReference(getMetaNormalExpression(emptyRef)),miscRef=docsToReference(miscNormalExpression),objectRef=docsToReference(objectNormalExpression),predicatesRef=docsToReference(predicatesNormalExpression),regexpRef=docsToReference(regexpNormalExpression),sequenceRef=docsToReference(sequenceNormalExpression),stringRef=docsToReference(stringNormalExpression),vectorRef=docsToReference(vectorNormalExpression);function specialExpressionDocsToReference(){const e={};for(const[t,r]of Object.entries(specialExpressionTypes)){const n=specialExpressions[r],o=n?.docs;o&&(isFunctionDocs(o)?e[t]={title:t,category:o.category,description:o.description,returns:o.returns,args:o.args,variants:o.variants,examples:o.examples,...o.seeAlso?{seeAlso:o.seeAlso}:{},...o.hideOperatorForm?{noOperatorDocumentation:!0}:{}}:e[t]={title:t,category:o.category,description:o.description,customVariants:o.customVariants,...o.details?{details:o.details}:{},...o.returns?{returns:o.returns}:{},examples:o.examples,...o.seeAlso?{seeAlso:o.seeAlso}:{}})}return e}const specialExpressionsReference=specialExpressionDocsToReference();function isFunctionReference(e){return"returns"in e&&"args"in e&&"variants"in e}const normalExpressionReference={...bitwiseReference,...collectionRef,...arrayRef,...sequenceRef,...mathRef,...functionalRef,...metaRef,...miscRef,...objectRef,...predicatesRef,...regexpRef,...stringRef,...vectorRef},moduleReference={...moduledDocsToReference(assertModule.name,assertModule.functions),...moduledDocsToReference(gridModule.name,gridModule.functions),...moduledDocsToReference(randomModule.name,randomModule.functions),...moduledDocsToReference(vectorModule.name,vectorModule.functions),...moduledDocsToReference(linearAlgebraModule.name,linearAlgebraModule.functions),...moduledDocsToReference(matrixModule.name,matrixModule.functions),...moduledDocsToReference(numberTheoryModule.name,numberTheoryModule.functions),...moduledDocsToReference(stringUtilsModule.name,stringUtilsModule.functions),...moduledDocsToReference(collectionUtilsModule.name,collectionUtilsModule.functions),...moduledDocsToReference(sequenceUtilsModule.name,sequenceUtilsModule.functions),...moduledDocsToReference(mathUtilsModule.name,mathUtilsModule.functions),...moduledDocsToReference(functionalUtilsModule.name,functionalUtilsModule.functions),...moduledDocsToReference(bitwiseUtilsModule.name,bitwiseUtilsModule.functions)};Object.entries(normalExpressionReference).forEach(([e,t])=>{if(!normalExpressions[e])throw new Error(`Missing normal expression ${e} in normalExpressions`);const r=normalExpressions[e].arity;!t.noOperatorDocumentation&&canBeOperator(r)&&(t._isOperator=!0,isSymbolicOperator(e)&&(t._prefereOperator=!0))}),Object.entries(specialExpressionsReference).forEach(([e,t])=>{if(isFunctionReference(t)){const r=specialExpressions[specialExpressionTypes[e]]?.arity;r&&canBeOperator(r)&&(t._isOperator=!0)}});const functionReference={...normalExpressionReference,...specialExpressionsReference},apiReference=sortByCategory({...functionReference,...shorthand,...datatype}),allReference=sortByCategory({...apiReference,...moduleReference});function sortByCategory(e){return Object.fromEntries(Object.entries(e).sort(([e,t],[r,n])=>{const o="special-expression"===t.category?"":t.category,a="special-expression"===n.category?"":n.category;return o!==a?o.localeCompare(a):e.localeCompare(r)}))}Object.values(allReference).forEach(e=>{e.title=e.title.replace(/"/g,"&quot;")}),setNormalExpressionReference(normalExpressionReference);const getLits=(()=>{const e=new Lits({debug:!0,modules:allBuiltinModules}),t=new Lits({debug:!1,modules:allBuiltinModules});return r=>r||getState("debug")?e:t})(),elements={wrapper:document.getElementById("wrapper"),playground:document.getElementById("playground"),sidebar:document.getElementById("sidebar"),mainPanel:document.getElementById("main-panel"),contextPanel:document.getElementById("context-panel"),litsPanel:document.getElementById("lits-panel"),outputPanel:document.getElementById("output-panel"),moreMenu:document.getElementById("more-menu"),addContextMenu:document.getElementById("add-context-menu"),newContextName:document.getElementById("new-context-name"),newContextValue:document.getElementById("new-context-value"),newContextError:document.getElementById("new-context-error"),contextTextArea:document.getElementById("context-textarea"),outputResult:document.getElementById("output-result"),litsTextArea:document.getElementById("lits-textarea"),resizePlayground:document.getElementById("resize-playground"),resizeDevider1:document.getElementById("resize-divider-1"),resizeDevider2:document.getElementById("resize-divider-2"),toggleDebugMenuLabel:document.getElementById("toggle-debug-menu-label"),litsPanelDebugInfo:document.getElementById("lits-panel-debug-info"),contextUndoButton:document.getElementById("context-undo-button"),contextRedoButton:document.getElementById("context-redo-button"),litsCodeUndoButton:document.getElementById("lits-code-undo-button"),litsCodeRedoButton:document.getElementById("lits-code-redo-button"),contextTitle:document.getElementById("context-title"),litsCodeTitle:document.getElementById("lits-code-title"),litsCodeTitleString:document.getElementById("lits-code-title-string")};let moveParams=null,autoCompleter=null,ignoreSelectionChange=!1;function calculateDimensions(){return{windowHeight:window.innerHeight,windowWidth:window.innerWidth}}function openMoreMenu(){elements.moreMenu.style.display="block"}function closeMoreMenu(){elements.moreMenu.style.display="none"}const expandedModules=new Set;function toggleModuleCategory(e){const t=e.replace(/\s+/g,"-"),r=document.getElementById(`ns-chevron-${t}`),n=document.getElementById(`ns-content-${t}`);r&&n&&(expandedModules.has(e)?(expandedModules.delete(e),n.style.display="none",r.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M10 6L8.59 7.41L13.17 12l-4.58 4.59L10 18l6-6z"/></svg>'):(expandedModules.add(e),n.style.display="flex",r.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6l-6-6z"/></svg>'))}function openAddContextMenu(){elements.newContextName.value=getState("new-context-name"),elements.newContextValue.value=getState("new-context-value"),elements.addContextMenu.style.display="block",elements.newContextName.focus()}function closeAddContextMenu(){elements.addContextMenu.style.display="none",elements.newContextError.style.display="none",elements.newContextError.textContent="",elements.newContextName.value="",elements.newContextValue.value=""}function share(){addOutputSeparator(),appendOutput("Sharable link:","comment");const e=`${location.origin}${location.pathname}?state=${encodeState()}`,t=document.createElement("a");t.textContent=e,t.className="share-link",t.href=e,addOutputElement(t)}function onDocumentClick(e){const t=e.target;t?.closest("#more-menu")||"block"!==elements.moreMenu.style.display||closeMoreMenu(),t?.closest("#add-context-menu")||"block"!==elements.addContextMenu.style.display||closeAddContextMenu()}const layout=throttle(()=>{const{windowWidth:e,windowHeight:t}=calculateDimensions(),r=Math.min(getState("playground-height"),t),n=e*getState("resize-divider-1-percent")/100,o=e*(100-getState("resize-divider-2-percent"))/100,a=e-n-o;elements.playground.style.height=`${r}px`,elements.contextPanel.style.width=`${n}px`,elements.litsPanel.style.width=`${a}px`,elements.outputPanel.style.width=`${o}px`,elements.sidebar.style.bottom=`${r}px`,elements.mainPanel.style.bottom=`${r}px`,elements.wrapper.style.display="block"}),undoContextHistory=throttle(()=>{ignoreSelectionChange=!0,undoContext()&&(applyState(),focusContext()),setTimeout(()=>ignoreSelectionChange=!1)}),redoContextHistory=throttle(()=>{ignoreSelectionChange=!0,redoContext()&&(applyState(),focusContext()),setTimeout(()=>ignoreSelectionChange=!1)}),undoLitsCodeHistory=throttle(()=>{ignoreSelectionChange=!0,undoLitsCode()&&(applyState(),focusLitsCode()),setTimeout(()=>ignoreSelectionChange=!1)}),redoLitsCodeHistory=throttle(()=>{ignoreSelectionChange=!0,redoLitsCode()&&(applyState(),focusLitsCode()),setTimeout(()=>ignoreSelectionChange=!1)});function resetPlayground(){clearAllStates(),resetContext(),resetLitsCode(),resetOutput(),Search.closeSearch(),Search.clearSearch(),layout(),updateCSS()}function resetContext(){elements.contextTextArea.value="",clearState("context","context-scroll-top","context-selection-start","context-selection-end"),focusContext()}function setContext(e,t,r){elements.contextTextArea.value=e,t?saveState({context:e,"context-selection-start":elements.contextTextArea.selectionStart,"context-selection-end":elements.contextTextArea.selectionEnd},!0):saveState({context:e},!1),"top"===r?elements.contextTextArea.scrollTo(0,0):"bottom"===r&&elements.contextTextArea.scrollTo({top:elements.contextTextArea.scrollHeight,behavior:"smooth"})}function getParsedContext(){try{return asUnknownRecord(JSON.parse(getState("context")))}catch(e){return{}}}function addContextEntry(){const e=elements.newContextName.value;if(""===e)return elements.newContextError.textContent="Name is required",elements.newContextError.style.display="block",void elements.newContextName.focus();const t=elements.newContextValue.value;try{const r=JSON.parse(t),n=getParsedContext(),o=Object.assign({},n.bindings);o[e]=r,n.bindings=o,setContext(JSON.stringify(n,null,2),!0),closeAddContextMenu()}catch(e){elements.newContextError.textContent="Invalid JSON",elements.newContextError.style.display="block",elements.newContextValue.focus()}clearState("new-context-name"),clearState("new-context-value")}function addSampleContext(){const e=getParsedContext();e.bindings=Object.assign({"a-number":42,"a-string":"foo bar","an-array":["foo","bar",1,2,!0,!1,null],"an-object":{name:"John Doe",age:42,married:!0,children:["Alice","Bob"],address:{street:"123 Main St",city:"Springfield",state:"IL",zip:"62701"}},"matrix-a":[[1,2,3],[4,5,6]],"matrix-b":[[7,8],[9,10],[11,12]],"matrix-c":[[3,0,2],[2,0,-2],[0,1,1]]},e.bindings),e.fnBindings=Object.assign({"prompt!":"(title) => prompt(title)"},e.fnBindings),setContext(JSON.stringify(e,null,2),!0)}function resetLitsCode(){elements.litsTextArea.value="",clearState("lits-code","lits-code-scroll-top","lits-code-selection-start","lits-code-selection-end"),focusLitsCode()}function setLitsCode(e,t,r){elements.litsTextArea.value=e,t?saveState({"lits-code":e,"lits-code-selection-start":elements.litsTextArea.selectionStart,"lits-code-selection-end":elements.litsTextArea.selectionEnd},!0):saveState({"lits-code":e},!1),"top"===r?elements.litsTextArea.scrollTo(0,0):"bottom"===r&&elements.litsTextArea.scrollTo({top:elements.litsTextArea.scrollHeight,behavior:"smooth"})}function appendLitsCode(e){const t=getState("lits-code").trimEnd();setLitsCode(t?`${t}\n\n${e}`:e.trim(),!0,"bottom")}function resetOutput(){elements.outputResult.innerHTML="",clearState("output")}function hasOutput(){return""!==getState("output").trim()}function setOutput(e,t){elements.outputResult.innerHTML=e,saveState({output:e},t)}function appendOutput(e,t){const r=document.createElement("span");r.className=t,r.textContent=`${e}`,addOutputElement(r)}function addOutputSeparator(){if(hasOutput()){const e=document.createElement("div");e.className="separator",addOutputElement(e)}}function addOutputElement(e){elements.outputResult.appendChild(e),elements.outputResult.scrollTop=elements.outputResult.scrollHeight,saveState({output:elements.outputResult.innerHTML})}function getDataFromUrl(){const e=new URLSearchParams(window.location.search),t=e.get("state");t&&(addOutputSeparator(),applyEncodedState(t)?appendOutput(`Data parsed from url parameter state: ${t}`,"comment"):appendOutput(`Invalid url parameter state: ${t}`,"error"),e.delete("state"),history.replaceState(null,"",`${location.pathname}${e.toString()?"?":""}${e.toString()}`))}function keydownHandler(e,t){const r=e.target,n=r.selectionStart,o=r.selectionEnd,a=r.value.lastIndexOf("\n",n-1),i=(n-a-1)%2==0;if((!["Shift","Control","Meta","Alt","Escape"].includes(e.key)&&"Space"!==e.code||"Space"===e.code&&!e.altKey)&&(autoCompleter=null),"Space"===e.code&&e.altKey){e.preventDefault(),autoCompleter||(autoCompleter=getLits().getAutoCompleter(r.value,n,getLitsParamsFromContext()));const o=e.shiftKey?autoCompleter.getPreviousSuggestion():autoCompleter.getNextSuggestion();return void(o&&(r.value=o.program,r.selectionStart=r.selectionEnd=o.position,t()))}switch(e.code){case"Tab":e.preventDefault(),e.shiftKey||(r.value=r.value.substring(0,n)+(i?"  ":" ")+r.value.substring(o),r.selectionStart=r.selectionEnd=n+(i?2:1),t());break;case"Escape":e.preventDefault(),autoCompleter&&(r.value=autoCompleter.originalProgram,r.selectionStart=r.selectionEnd=autoCompleter.originalPosition,autoCompleter=null,t());break;case"Backspace":i&&n===o&&"  "===r.value.substring(n-2,n+2)&&(e.preventDefault(),r.value=r.value.substring(0,n-2)+r.value.substring(o),r.selectionStart=r.selectionEnd=n-2,t());break;case"Enter":{e.preventDefault();const i=r.value.substring(a+1,n).replace(/^( *).*/,"$1").length;r.value=`${r.value.substring(0,n)}\n${" ".repeat(i)}${r.value.substring(o)}`,r.selectionStart=r.selectionEnd=n+1+i,t();break}case"Delete":i&&n===o&&"  "===r.value.substring(n,n+2)&&(e.preventDefault(),r.value=r.value.substring(0,n)+r.value.substring(o+2),r.selectionStart=r.selectionEnd=n,t())}}function truncateCode(e){const t=getLits().tokenize(e,{minify:!0}).tokens.map(e=>"Whitespace"===e[0]?" ":e[1]).join("").trim();return t.length<=100?t:`${t.substring(0,97)}...`}async function run(){addOutputSeparator();const e=getSelectedLitsCode(),t=e.code||getState("lits-code");appendOutput(`${e.code?"Run selection":"Run"}: ${truncateCode(t)}`,"comment");const r=getLitsParamsFromContext(),n=hijackConsole();try{const e=await getLits().async.run(t,r);appendOutput(stringifyValue(e,!1),"result")}catch(e){appendOutput(e,"error")}finally{n.releaseConsole(),focusLitsCode()}}function analyze(){addOutputSeparator();const e=getSelectedLitsCode(),t=e.code||getState("lits-code");appendOutput(`${e.code?"Analyze selection":"Analyze"}: ${truncateCode(t)}`,"comment");const r=getLitsParamsFromContext(),n=hijackConsole();try{const e=[...getLits("debug").getUndefinedSymbols(t,r)].join(", ");appendOutput(`${`Unresolved symbols: ${e||"-"}`}`,"analyze")}catch(e){appendOutput(e,"error")}finally{n.releaseConsole(),focusLitsCode()}}function parse(){addOutputSeparator();const e=getSelectedLitsCode(),t=e.code||getState("lits-code");appendOutput(`${e.code?"Parse selection":"Parse"}${getState("debug")?" (debug):":":"} ${truncateCode(t)}`,"comment");const r=hijackConsole();try{const e=getLits().tokenize(t),n=getLits().parse(e);appendOutput(JSON.stringify(n,null,2),"parse"),r.releaseConsole(),console.log(n)}catch(e){appendOutput(e,"error"),r.releaseConsole()}finally{focusLitsCode()}}function tokenize(){addOutputSeparator();const e=getSelectedLitsCode(),t=e.code||getState("lits-code");appendOutput(`${e.code?"Tokenize selection":"Tokenize"}${getState("debug")?" (debug):":":"} ${truncateCode(t)}`,"comment");const r=hijackConsole();try{const e=getLits().tokenize(t);appendOutput(JSON.stringify(e,null,2),"tokenize"),r.releaseConsole(),console.log(e)}catch(e){return appendOutput(e,"error"),void r.releaseConsole()}finally{focusLitsCode()}}function format(){addOutputSeparator();const e=getSelectedLitsCode(),t=e.code||getState("lits-code");appendOutput(`${e.code?"Format selection":"Format"}: ${truncateCode(t)}`,"comment"),setLitsCode(t,!0),e.code?saveState({"focused-panel":"lits-code","lits-code-selection-start":e.selectionStart,"lits-code-selection-end":e.selectionStart+t.length}):saveState({"focused-panel":"lits-code","lits-code-selection-start":e.selectionStart,"lits-code-selection-end":e.selectionEnd}),applyState()}function toggleDebug(){const e=!getState("debug");saveState({debug:e}),updateCSS(),addOutputSeparator(),appendOutput("Debug mode toggled "+(e?"ON":"OFF"),"comment"),focusLitsCode()}function focusContext(){elements.contextTextArea.focus()}function focusLitsCode(){elements.litsTextArea.focus()}function getLitsParamsFromContext(){const contextString=getState("context");try{const parsedContext=contextString.trim().length>0?JSON.parse(contextString):{},parsedFnBindings=asUnknownRecord(parsedContext.fnBindings??{}),bindings=asUnknownRecord(parsedContext.bindings??{}),fnBindings=Object.entries(parsedFnBindings).reduce((acc,[key,value])=>{if("string"!=typeof value)throw console.log(key,value),new TypeError(`Invalid fnBinding value. "${key}" should be a javascript function string`);const fn=eval(value);if("function"!=typeof fn)throw new TypeError(`Invalid fnBinding value. "${key}" should be a javascript function`);return acc[key]={fn:fn},acc},{});return{bindings:{...bindings,...fnBindings}}}catch(e){return appendOutput(`Error: ${e.message}\nCould not parse context:\n${contextString}`,"error"),{}}}function getSelectedLitsCode(){const e=getState("lits-code-selection-start"),t=getState("lits-code-selection-end");return{leadingCode:elements.litsTextArea.value.substring(0,e),trailingCode:elements.litsTextArea.value.substring(t),code:elements.litsTextArea.value.substring(e,t),selectionStart:e,selectionEnd:t}}function applyState(e=!1){const t=getState("context-selection-start"),r=getState("context-selection-end"),n=getState("lits-code-selection-start"),o=getState("lits-code-selection-end");setOutput(getState("output"),!1),getDataFromUrl(),setContext(getState("context"),!1),elements.contextTextArea.selectionStart=t,elements.contextTextArea.selectionEnd=r,setLitsCode(getState("lits-code"),!1,e?"top":void 0),elements.litsTextArea.selectionStart=n,elements.litsTextArea.selectionEnd=o,updateCSS(),layout(),setTimeout(()=>{"context"===getState("focused-panel")?focusContext():"lits-code"===getState("focused-panel")&&focusLitsCode(),elements.contextTextArea.scrollTop=getState("context-scroll-top"),elements.litsTextArea.scrollTop=getState("lits-code-scroll-top"),elements.outputResult.scrollTop=getState("output-scroll-top")},0)}function updateCSS(){const e=getState("debug");elements.toggleDebugMenuLabel.textContent=e?"Debug: ON":"Debug: OFF",elements.litsPanelDebugInfo.style.display=e?"flex":"none",elements.litsCodeTitle.style.color="lits-code"===getState("focused-panel")?"white":"",elements.litsCodeTitleString.textContent="Lits Code",elements.contextTitle.style.color="context"===getState("focused-panel")?"white":""}function showPage(e,t,r="push"){setTimeout(()=>{inactivateAll(),Search.closeSearch();const n=document.getElementById(e),o=`${e&&"index"!==e?e:"home-page"}_link`,a=document.getElementById(o);if(e&&"index"!==e&&"example-page"!==e||elements.mainPanel.scrollTo({top:0}),n){if(n.classList.add("active-content"),a){a.classList.add("active-sidebar-entry");const e=a.closest('[id^="ns-content-"]');if(e&&e instanceof HTMLElement&&"none"===e.style.display){toggleModuleCategory(e.id.replace("ns-content-","").replace(/-/g," "))}"none"!==t&&a.scrollIntoView({block:"center",behavior:t})}"index"===e?history.replaceState(null,"Lits",window.location.pathname+window.location.search):"replace"===r?history.replaceState(null,"",`#${e}`):"none"!==r&&history.pushState(null,"",`#${e}`)}else showPage("index",t,"replace")},0)}function inactivateAll(){let e=document.getElementsByClassName("active-content");for(;e[0];)e[0].classList.remove("active-content");for(e=document.getElementsByClassName("active-sidebar-entry");e[0];)e[0].classList.remove("active-sidebar-entry")}function addToPlayground(e,t){appendLitsCode(`// Example - ${e}\n\n${decodeURIComponent(atob(t))};\n`),saveState({"focused-panel":"lits-code"}),applyState()}function setPlayground(e,t){const r=JSON.parse(decodeURIComponent(atob(t)));setContext(r.context?JSON.stringify(r.context,(e,t)=>void 0===t?null:t,2):"",!0,"top");const n=r.code?r.code:"",o=Math.max(e.length+10,40),a=Math.floor((o-e.length)/2),i=Math.ceil((o-e.length)/2);setLitsCode(`\n/*${"*".repeat(o)}**\n *${" ".repeat(a)}${e}${" ".repeat(i)} *\n *${"*".repeat(o)}**/\n\n${n}\n`.trimStart(),!0,"top"),saveState({"focused-panel":"lits-code"}),applyState()}function hijackConsole(){const e=console.log;console.log=function(...e){appendOutput(e.map(e=>stringifyValue(e)).join(" "),"output")};const t=console.warn;console.warn=function(...e){t.apply(console,e),appendOutput(e[0],"warn")};const r=console.error;return console.warn=function(...e){r.apply(console,e),appendOutput(e[0],"error")},{releaseConsole:()=>{console.log=e,console.warn=t}}}return window.onload=function(){elements.contextUndoButton.classList.add("disabled"),elements.contextRedoButton.classList.add("disabled"),elements.litsCodeUndoButton.classList.add("disabled"),elements.litsCodeRedoButton.classList.add("disabled"),setContextHistoryListener(e=>{e.canUndo?elements.contextUndoButton.classList.remove("disabled"):elements.contextUndoButton.classList.add("disabled"),e.canRedo?elements.contextRedoButton.classList.remove("disabled"):elements.contextRedoButton.classList.add("disabled")}),setLitsCodeHistoryListener(e=>{e.canUndo?elements.litsCodeUndoButton.classList.remove("disabled"):elements.litsCodeUndoButton.classList.add("disabled"),e.canRedo?elements.litsCodeRedoButton.classList.remove("disabled"):elements.litsCodeRedoButton.classList.add("disabled")}),document.addEventListener("click",onDocumentClick,!0),elements.resizePlayground.onmousedown=e=>{moveParams={id:"playground",startMoveY:e.clientY,heightBeforeMove:getState("playground-height")}},elements.resizeDevider1.onmousedown=e=>{moveParams={id:"resize-divider-1",startMoveX:e.clientX,percentBeforeMove:getState("resize-divider-1-percent")}},elements.resizeDevider2.onmousedown=e=>{moveParams={id:"resize-divider-2",startMoveX:e.clientX,percentBeforeMove:getState("resize-divider-2-percent")}},window.onresize=layout,window.onmouseup=()=>{document.body.classList.remove("no-select"),moveParams=null},window.onmousemove=e=>{const{windowHeight:t,windowWidth:r}=calculateDimensions();if(null!==moveParams)if(document.body.classList.add("no-select"),"playground"===moveParams.id){let r=moveParams.heightBeforeMove+moveParams.startMoveY-e.clientY;r<30&&(r=30),r>t&&(r=t),saveState({"playground-height":r}),layout()}else if("resize-divider-1"===moveParams.id){let t=moveParams.percentBeforeMove+(e.clientX-moveParams.startMoveX)/r*100;t<10&&(t=10),t>getState("resize-divider-2-percent")-10&&(t=getState("resize-divider-2-percent")-10),saveState({"resize-divider-1-percent":t}),layout()}else if("resize-divider-2"===moveParams.id){let t=moveParams.percentBeforeMove+(e.clientX-moveParams.startMoveX)/r*100;t<getState("resize-divider-1-percent")+10&&(t=getState("resize-divider-1-percent")+10),t>90&&(t=90),saveState({"resize-divider-2-percent":t}),layout()}},window.addEventListener("keydown",e=>{if(!Search.handleKeyDown(e)){if(e.ctrlKey)switch(e.key){case"r":e.preventDefault(),run();break;case"a":e.preventDefault(),analyze();break;case"t":e.preventDefault(),tokenize();break;case"p":e.preventDefault(),parse();break;case"f":e.preventDefault(),format();break;case"d":e.preventDefault(),toggleDebug();break;case"1":e.preventDefault(),focusContext();break;case"2":e.preventDefault(),focusLitsCode()}"Escape"===e.key&&(closeMoreMenu(),closeAddContextMenu(),e.preventDefault()),(isMac()&&e.metaKey||!isMac&&e.ctrlKey)&&!e.shiftKey&&"z"===e.key&&(e.preventDefault(),document.activeElement===elements.contextTextArea?undoContextHistory():document.activeElement===elements.litsTextArea&&undoLitsCodeHistory()),(isMac()&&e.metaKey||!isMac&&e.ctrlKey)&&e.shiftKey&&"z"===e.key&&(e.preventDefault(),document.activeElement===elements.contextTextArea?redoContextHistory():document.activeElement===elements.litsTextArea&&redoLitsCodeHistory())}}),elements.contextTextArea.addEventListener("keydown",e=>{keydownHandler(e,()=>setContext(elements.contextTextArea.value,!0))}),elements.contextTextArea.addEventListener("input",()=>{setContext(elements.contextTextArea.value,!0)}),elements.contextTextArea.addEventListener("scroll",()=>{saveState({"context-scroll-top":elements.contextTextArea.scrollTop})}),elements.contextTextArea.addEventListener("selectionchange",()=>{ignoreSelectionChange||saveState({"context-selection-start":elements.contextTextArea.selectionStart,"context-selection-end":elements.contextTextArea.selectionEnd})}),elements.contextTextArea.addEventListener("focusin",()=>{saveState({"focused-panel":"context"}),updateCSS()}),elements.contextTextArea.addEventListener("focusout",()=>{saveState({"focused-panel":null}),updateCSS()}),elements.litsTextArea.addEventListener("keydown",e=>{keydownHandler(e,()=>setLitsCode(elements.litsTextArea.value,!0))}),elements.litsTextArea.addEventListener("input",()=>{setLitsCode(elements.litsTextArea.value,!0)}),elements.litsTextArea.addEventListener("scroll",()=>{saveState({"lits-code-scroll-top":elements.litsTextArea.scrollTop})}),elements.litsTextArea.addEventListener("selectionchange",()=>{ignoreSelectionChange||saveState({"lits-code-selection-start":elements.litsTextArea.selectionStart,"lits-code-selection-end":elements.litsTextArea.selectionEnd})}),elements.litsTextArea.addEventListener("focusin",()=>{saveState({"focused-panel":"lits-code"}),updateCSS()}),elements.litsTextArea.addEventListener("focusout",()=>{saveState({"focused-panel":null}),updateCSS()}),elements.outputResult.addEventListener("scroll",()=>{saveState({"output-scroll-top":elements.outputResult.scrollTop})}),elements.newContextName.addEventListener("input",()=>{saveState({"new-context-name":elements.newContextName.value})}),elements.newContextValue.addEventListener("input",()=>{saveState({"new-context-value":elements.newContextValue.value})}),applyState(!0);showPage(location.hash.substring(1)||"index","instant","replace"),Search.onClose(()=>{applyState()})},window.addEventListener("popstate",()=>{showPage(location.hash.substring(1)||"index","instant","none")}),exports.Search=Search,exports.addContextEntry=addContextEntry,exports.addSampleContext=addSampleContext,exports.addToPlayground=addToPlayground,exports.analyze=analyze,exports.closeAddContextMenu=closeAddContextMenu,exports.closeMoreMenu=closeMoreMenu,exports.focusContext=focusContext,exports.focusLitsCode=focusLitsCode,exports.format=format,exports.openAddContextMenu=openAddContextMenu,exports.openMoreMenu=openMoreMenu,exports.parse=parse,exports.redoContextHistory=redoContextHistory,exports.redoLitsCodeHistory=redoLitsCodeHistory,exports.resetContext=resetContext,exports.resetLitsCode=resetLitsCode,exports.resetOutput=resetOutput,exports.resetPlayground=resetPlayground,exports.run=run,exports.setPlayground=setPlayground,exports.share=share,exports.showPage=showPage,exports.toggleDebug=toggleDebug,exports.toggleModuleCategory=toggleModuleCategory,exports.tokenize=tokenize,exports.undoContextHistory=undoContextHistory,exports.undoLitsCodeHistory=undoLitsCodeHistory,exports}({});
