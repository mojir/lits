import { describe, expect, it } from 'vitest'
import { Lits } from '../../../../../Lits/Lits'
import { LitsError } from '../../../../../errors'

const lits = new Lits()
describe('number theory', () => {
  describe('n:coprime?', () => {
    it('should return true if two numbers are coprime', () => {
      expect(lits.run('n:coprime?(1, 1)')).toEqual(true)
      expect(lits.run('n:coprime?(2, 3)')).toEqual(true)
      expect(lits.run('n:coprime?(4, 6)')).toEqual(false)
      expect(lits.run('n:coprime?(8, 12)')).toEqual(false)
      expect(lits.run('n:coprime?(10, 15)')).toEqual(false)
      expect(lits.run('n:coprime?(100, 200)')).toEqual(false)
    })
  })
  describe('n:divisible-by?', () => {
    it('should return true if divisible by', () => {
      expect(lits.run('n:divisible-by?(2, 1)')).toEqual(true)
      expect(lits.run('n:divisible-by?(7, 2)')).toEqual(false)
      expect(lits.run('n:divisible-by?(6, 3)')).toEqual(true)
      expect(lits.run('n:divisible-by?(8, 4)')).toEqual(true)
      expect(lits.run('n:divisible-by?(9, 3)')).toEqual(true)
      expect(lits.run('n:divisible-by?(10, 5)')).toEqual(true)
      expect(lits.run('n:divisible-by?(11, 5)')).toEqual(false)
      expect(lits.run('n:divisible-by?(11, 0)')).toEqual(false)
      expect(() => lits.run('n:divisible-by?(2.5, 0.5)')).toThrow()
    })
  })
  describe('n:gcd', () => {
    it('should return the gcd of two numbers', () => {
      expect(lits.run('n:gcd(1, 1)')).toEqual(1)
      expect(lits.run('n:gcd(2, 3)')).toEqual(1)
      expect(lits.run('n:gcd(4, 6)')).toEqual(2)
      expect(lits.run('n:gcd(8, 12)')).toEqual(4)
      expect(lits.run('n:gcd(10, 15)')).toEqual(5)
      expect(lits.run('n:gcd(100, 200)')).toEqual(100)
    })
  })
  describe('n:lcm', () => {
    it('should return the lcm of two numbers', () => {
      expect(lits.run('n:lcm(1, 1)')).toEqual(1)
      expect(lits.run('n:lcm(2, 3)')).toEqual(6)
      expect(lits.run('n:lcm(4, 6)')).toEqual(12)
      expect(lits.run('n:lcm(8, 12)')).toEqual(24)
      expect(lits.run('n:lcm(10, 15)')).toEqual(30)
      expect(lits.run('n:lcm(100, 200)')).toEqual(200)
    })
  })
  describe('n:multinomial', () => {
    it('should return the multinomial coefficient of a list of numbers', () => {
      // Basic cases
      expect(lits.run('n:multinomial(1)')).toEqual(1)
      expect(lits.run('n:multinomial(1, 1)')).toEqual(2)
      expect(lits.run('n:multinomial(1, 1, 1)')).toEqual(6)
      expect(lits.run('n:multinomial(2, 3)')).toEqual(10)
      expect(lits.run('n:multinomial(2, 1, 3)')).toEqual(60)

      // Larger numbers
      expect(lits.run('n:multinomial(4, 2, 1)')).toEqual(105)
      expect(lits.run('n:multinomial(5, 5)')).toEqual(252)
      expect(lits.run('n:multinomial(10, 5)')).toEqual(3003)
      expect(lits.run('n:multinomial(3, 4, 5, 6)')).toEqual(514594080)

      // Edge cases
      expect(lits.run('n:multinomial(0, 0)')).toEqual(1) // 0!/0!0! = 1
      expect(lits.run('n:multinomial(0, 0, 0)')).toEqual(1)
      expect(lits.run('n:multinomial(0, 5)')).toEqual(1) // 5!/5!0! = 1
      expect(lits.run('n:multinomial(5, 0)')).toEqual(1) // 5!/5!0! = 1

      // One parameter case
      expect(lits.run('n:multinomial(0)')).toEqual(1)
      expect(lits.run('n:multinomial(5)')).toEqual(1) // 5!/5! = 1

      // Mixed cases
      expect(lits.run('n:multinomial(1, 0, 1)')).toEqual(2)
      expect(lits.run('n:multinomial(2, 0, 2)')).toEqual(6)
    })
  })

  describe('n:amicable?', () => {
    it('should return true if two numbers are amicable', () => {
      expect(lits.run('n:amicable?(220, 284)')).toEqual(true)
      expect(lits.run('n:amicable?(1184, 1210)')).toEqual(true)
      expect(lits.run('n:amicable?(2620, 2924)')).toEqual(true)
      expect(lits.run('n:amicable?(5020, 5564)')).toEqual(true)
      expect(lits.run('n:amicable?(6232, 6368)')).toEqual(true)
      expect(lits.run('n:amicable?(1210, 1184)')).toEqual(true)
      expect(lits.run('n:amicable?(284, 220)')).toEqual(true)
      expect(lits.run('n:amicable?(6, 28)')).toEqual(false)
      expect(lits.run('n:amicable?(12, 28)')).toEqual(false)
      expect(lits.run('n:amicable?(28, 6)')).toEqual(false)
      expect(lits.run('n:amicable?(220, 220)')).toEqual(false)
      expect(lits.run('n:amicable?(1, 1)')).toEqual(false)
      expect(lits.run('n:amicable?(2, 2)')).toEqual(false)
      expect(() => lits.run('n:amicable?(0, 0)')).toThrow()
    })
  })

  describe('n:euler-totient', () => {
    it('should return the euler totient of a number', () => {
      expect(lits.run('n:euler-totient(1)')).toEqual(1)
      expect(lits.run('n:euler-totient(2)')).toEqual(1)
      expect(lits.run('n:euler-totient(3)')).toEqual(2)
      expect(lits.run('n:euler-totient(4)')).toEqual(2)
      expect(lits.run('n:euler-totient(5)')).toEqual(4)
      expect(lits.run('n:euler-totient(6)')).toEqual(2)
      expect(lits.run('n:euler-totient(7)')).toEqual(6)
      expect(lits.run('n:euler-totient(8)')).toEqual(4)
      expect(lits.run('n:euler-totient(9)')).toEqual(6)
      expect(lits.run('n:euler-totient(10)')).toEqual(4)
      expect(lits.run('n:euler-totient(11)')).toEqual(10)
      expect(lits.run('n:euler-totient(12)')).toEqual(4)
      expect(lits.run('n:euler-totient(13)')).toEqual(12)
      expect(lits.run('n:euler-totient(14)')).toEqual(6)
      expect(lits.run('n:euler-totient(15)')).toEqual(8)
      expect(lits.run('n:euler-totient(16)')).toEqual(8)
      expect(lits.run('n:euler-totient(17)')).toEqual(16)
      expect(lits.run('n:euler-totient(18)')).toEqual(6)
      expect(lits.run('n:euler-totient(19)')).toEqual(18)
      expect(lits.run('n:euler-totient(20)')).toEqual(8)
    })
  })

  describe('n:mobius', () => {
    it('should return the mobius function of a number', () => {
      expect(lits.run('n:mobius(1)')).toEqual(1)
      expect(lits.run('n:mobius(2)')).toEqual(-1)
      expect(lits.run('n:mobius(3)')).toEqual(-1)
      expect(lits.run('n:mobius(4)')).toEqual(0)
      expect(lits.run('n:mobius(5)')).toEqual(-1)
      expect(lits.run('n:mobius(6)')).toEqual(1)
      expect(lits.run('n:mobius(7)')).toEqual(-1)
      expect(lits.run('n:mobius(8)')).toEqual(0)
      expect(lits.run('n:mobius(9)')).toEqual(0)
      expect(lits.run('n:mobius(10)')).toEqual(1)
      expect(lits.run('n:mobius(11)')).toEqual(-1)
      expect(lits.run('n:mobius(12)')).toEqual(0)
      expect(lits.run('n:mobius(13)')).toEqual(-1)
      expect(lits.run('n:mobius(14)')).toEqual(1)
      expect(lits.run('n:mobius(15)')).toEqual(1)
      expect(lits.run('n:mobius(16)')).toEqual(0)
      expect(lits.run('n:mobius(17)')).toEqual(-1)
      expect(lits.run('n:mobius(18)')).toEqual(0)
      expect(lits.run('n:mobius(19)')).toEqual(-1)
      expect(lits.run('n:mobius(20)')).toEqual(0)
      expect(lits.run('n:mobius(21)')).toEqual(1)
      expect(lits.run('n:mobius(22)')).toEqual(1)
      expect(lits.run('n:mobius(23)')).toEqual(-1)
      expect(lits.run('n:mobius(24)')).toEqual(0)
      expect(lits.run('n:mobius(25)')).toEqual(0)
      expect(lits.run('n:mobius(30)')).toEqual(-1)
      expect(lits.run('n:möbius(42)')).toEqual(-1)
      expect(lits.run('n:möbius(60)')).toEqual(0)
      expect(lits.run('n:möbius(75)')).toEqual(0)
      expect(lits.run('n:möbius(98)')).toEqual(0)
      expect(lits.run('n:möbius(105)')).toEqual(-1)
      expect(lits.run('n:möbius(210)')).toEqual(1)
      expect(lits.run('n:möbius(997)')).toEqual(-1)
      expect(lits.run('n:möbius(999)')).toEqual(0)
      expect(lits.run('n:möbius(1000)')).toEqual(0)
      expect(lits.run('n:möbius(2310)')).toEqual(-1)
      expect(lits.run('n:möbius(30030)')).toEqual(1)
    })
  })
  describe('n:mertens', () => {
    it('should return the mertens function of a number', () => {
      expect(lits.run('n:mertens(1)')).toEqual(1)
      expect(lits.run('n:mertens(2)')).toEqual(0)
      expect(lits.run('n:mertens(3)')).toEqual(-1)
      expect(lits.run('n:mertens(4)')).toEqual(-1)
      expect(lits.run('n:mertens(5)')).toEqual(-2)
      expect(lits.run('n:mertens(6)')).toEqual(-1)
      expect(lits.run('n:mertens(7)')).toEqual(-2)
      expect(lits.run('n:mertens(8)')).toEqual(-2)
      expect(lits.run('n:mertens(9)')).toEqual(-2)
      expect(lits.run('n:mertens(10)')).toEqual(-1)
      expect(lits.run('n:mertens(11)')).toEqual(-2)
      expect(lits.run('n:mertens(12)')).toEqual(-2)
      expect(lits.run('n:mertens(13)')).toEqual(-3)
      expect(lits.run('n:mertens(14)')).toEqual(-2)
      expect(lits.run('n:mertens(15)')).toEqual(-1)
      expect(lits.run('n:mertens(16)')).toEqual(-1)
      expect(lits.run('n:mertens(17)')).toEqual(-2)
      expect(lits.run('n:mertens(18)')).toEqual(-2)
      expect(lits.run('n:mertens(19)')).toEqual(-3)
      expect(lits.run('n:mertens(20)')).toEqual(-3)
      expect(lits.run('n:mertens(21)')).toEqual(-2)
      expect(lits.run('n:mertens(22)')).toEqual(-1)
      expect(lits.run('n:mertens(23)')).toEqual(-2)
      expect(lits.run('n:mertens(24)')).toEqual(-2)
      expect(lits.run('n:mertens(25)')).toEqual(-2)
      expect(lits.run('n:mertens(30)')).toEqual(-3)
      expect(lits.run('n:mertens(42)')).toEqual(-2)
      expect(lits.run('n:mertens(60)')).toEqual(-1)
      expect(lits.run('n:mertens(75)')).toEqual(-3)
      expect(lits.run('n:mertens(98)')).toEqual(1)
    })
  })
  describe('n:sigma', () => {
    it('should return the sigma function of a number', () => {
      expect(lits.run('n:sigma(1)')).toEqual(1)
      expect(lits.run('n:sigma(2)')).toEqual(3)
      expect(lits.run('n:sigma(3)')).toEqual(4)
      expect(lits.run('n:sigma(4)')).toEqual(7)
      expect(lits.run('n:sigma(5)')).toEqual(6)
      expect(lits.run('n:sigma(6)')).toEqual(12)
      expect(lits.run('n:sigma(7)')).toEqual(8)
      expect(lits.run('n:sigma(8)')).toEqual(15)
      expect(lits.run('n:sigma(9)')).toEqual(13)
      expect(lits.run('n:sigma(10)')).toEqual(18)
      expect(lits.run('n:sigma(11)')).toEqual(12)
      expect(lits.run('n:sigma(12)')).toEqual(28)
      expect(lits.run('n:sigma(13)')).toEqual(14)
      expect(lits.run('n:sigma(14)')).toEqual(24)
      expect(lits.run('n:sigma(15)')).toEqual(24)
      expect(lits.run('n:sigma(16)')).toEqual(31)
      expect(lits.run('n:sigma(17)')).toEqual(18)
      expect(lits.run('n:sigma(18)')).toEqual(39)
      expect(lits.run('n:sigma(19)')).toEqual(20)
      expect(lits.run('n:sigma(20)')).toEqual(42)
    })
  })
  describe('n:carmichael-lambda', () => {
    it('should return the carmichael lambda of a number', () => {
      expect(lits.run('n:carmichael-lambda(1)')).toEqual(1)
      expect(lits.run('n:carmichael-lambda(2)')).toEqual(1)
      expect(lits.run('n:carmichael-lambda(3)')).toEqual(2)
      expect(lits.run('n:carmichael-lambda(4)')).toEqual(2)
      expect(lits.run('n:carmichael-lambda(5)')).toEqual(4)
      expect(lits.run('n:carmichael-lambda(6)')).toEqual(2)
      expect(lits.run('n:carmichael-lambda(7)')).toEqual(6)
      expect(lits.run('n:carmichael-lambda(8)')).toEqual(2)
      expect(lits.run('n:carmichael-lambda(9)')).toEqual(6)
      expect(lits.run('n:carmichael-lambda(10)')).toEqual(4)
      expect(lits.run('n:carmichael-lambda(11)')).toEqual(10)
      expect(lits.run('n:carmichael-lambda(12)')).toEqual(2)
      expect(lits.run('n:carmichael-lambda(13)')).toEqual(12)
      expect(lits.run('n:carmichael-lambda(14)')).toEqual(6)
      expect(lits.run('n:carmichael-lambda(15)')).toEqual(4)
      expect(lits.run('n:carmichael-lambda(16)')).toEqual(4)
      expect(lits.run('n:carmichael-lambda(17)')).toEqual(16)
    })
  })
  describe('cartesian-product', () => {
    it('should return the cartesian product of two or many lists', () => {
      expect(lits.run('n:cartesian-product([1, 2], [3, 4])')).toEqual([[1, 3], [1, 4], [2, 3], [2, 4]])
      expect(lits.run('n:cartesian-product([1, 2], [])')).toEqual([])
      expect(lits.run('n:cartesian-product([], [3, 4])')).toEqual([])
      expect(lits.run('n:cartesian-product([], [])')).toEqual([])
      expect(lits.run('n:cartesian-product([1, 2], [3, 4], [5, 6])')).toEqual([[1, 3, 5], [1, 3, 6], [1, 4, 5], [1, 4, 6], [2, 3, 5], [2, 3, 6], [2, 4, 5], [2, 4, 6]])
    })
  })
  describe('n:perfect-power', () => {
    it('should return tuple representing powers from number', () => {
      expect(lits.run('n:perfect-power(1)')).toEqual([1, 2])
      expect(lits.run('n:perfect-power(2)')).toEqual(null)
      expect(lits.run('n:perfect-power(4)')).toEqual([2, 2])
      expect(lits.run('n:perfect-power(8)')).toEqual([2, 3])
      expect(lits.run('n:perfect-power(9)')).toEqual([3, 2])
      expect(lits.run('n:perfect-power(16)')).toEqual([4, 2])
      expect(lits.run('n:perfect-power(27)')).toEqual([3, 3])
      expect(lits.run('n:perfect-power(32)')).toEqual([2, 5])
      expect(lits.run('n:perfect-power(64)')).toEqual([8, 2])
      expect(lits.run('n:perfect-power(81)')).toEqual([9, 2])
      expect(lits.run('n:perfect-power(100)')).toEqual([10, 2])
      expect(lits.run('n:perfect-power(121)')).toEqual([11, 2])
      expect(lits.run('n:perfect-power(125)')).toEqual([5, 3])
      expect(lits.run('n:perfect-power(128)')).toEqual([2, 7])
      expect(lits.run('n:perfect-power(729)')).toEqual([27, 2])
      expect(lits.run('n:perfect-power(1000)')).toEqual([10, 3])
      expect(lits.run('n:perfect-power(1024)')).toEqual([32, 2])
      expect(lits.run('n:perfect-power(1331)')).toEqual([11, 3])
      expect(lits.run('n:perfect-power(4096)')).toEqual([64, 2])
      expect(lits.run('n:perfect-power(6561)')).toEqual([81, 2])
    })
  })
  describe('n:mod-exp', () => {
    it('should return the modular exponentiation of a number', () => {
      expect(lits.run('n:mod-exp(2, 3, 1)')).toEqual(0)
      expect(lits.run('n:mod-exp(2, 3, 5)')).toEqual(3)
      expect(lits.run('n:mod-exp(3, 4, 7)')).toEqual(4)
      expect(lits.run('n:mod-exp(5, 6, 11)')).toEqual(5)
      expect(lits.run('n:mod-exp(7, 8, 13)')).toEqual(3)
      expect(lits.run('n:mod-exp(9, 10, 17)')).toEqual(13)
      expect(lits.run('n:mod-exp(11, 12, 19)')).toEqual(1)
      expect(lits.run('n:mod-exp(13, 14, 23)')).toEqual(12)
      expect(lits.run('n:mod-exp(15, 16, 29)')).toEqual(7)
      expect(lits.run('n:mod-exp(4, 13, 497)')).toEqual(445)
    })
  })
  describe('n:mod-inv', () => {
    it('should return the modular inverse of a number', () => {
      expect(lits.run('n:mod-inv(2, 3)')).toEqual(2)
      expect(lits.run('n:mod-inv(3, 7)')).toEqual(5)
      expect(lits.run('n:mod-inv(4, 11)')).toEqual(3)
      expect(lits.run('n:mod-inv(5, 13)')).toEqual(8)
      expect(lits.run('n:mod-inv(6, 17)')).toEqual(3)
      expect(lits.run('n:mod-inv(7, 19)')).toEqual(11)
      expect(lits.run('n:mod-inv(8, 23)')).toEqual(3)
      expect(lits.run('n:mod-inv(9, 29)')).toEqual(13)
      expect(() => lits.run('n:mod-inv(4, 6)')).toThrow()
    })
  })
  describe('extended-gcd', () => {
    it('should return the extended gcd of two numbers', () => {
      expect(lits.run('n:extended-gcd(1, 1)')).toEqual([1, 0, 1])
      expect(lits.run('n:extended-gcd(2, 3)')).toEqual([1, -1, 1])
      expect(lits.run('n:extended-gcd(4, 6)')).toEqual([2, -1, 1])
      expect(lits.run('n:extended-gcd(8, 12)')).toEqual([4, -1, 1])
      expect(lits.run('n:extended-gcd(10, 15)')).toEqual([5, -1, 1])
      expect(lits.run('n:extended-gcd(100, 200)')).toEqual([100, 1, 0])
    })
  })
  describe('n:chinese-remainder', () => {
    it('should return the chinese remainder of a list of numbers', () => {
      expect(lits.run('n:chinese-remainder([2, 3], [3, 5])')).toEqual(8)
      expect(lits.run('n:chinese-remainder([2, 3], [3, 5])')).toEqual(8)
      expect(lits.run('n:chinese-remainder([1, 2, 3], [2, 3, 5])')).toEqual(23)
      expect(() => lits.run('n:chinese-remainder([1, 2, 4], [2, 3, 6])')).toThrow(LitsError)
      expect(() => lits.run('n:chinese-remainder([1, 2], [2, 3, 5])')).toThrow()
    })
  })
  describe('n:stirling-first', () => {
    it('should return the stirling number of the first kind', () => {
      expect(lits.run('n:stirling-first(1, 1)')).toEqual(1)
      expect(lits.run('n:stirling-first(2, 1)')).toEqual(1)
      expect(lits.run('n:stirling-first(2, 2)')).toEqual(1)
      expect(lits.run('n:stirling-first(3, 1)')).toEqual(2)
      expect(lits.run('n:stirling-first(3, 2)')).toEqual(3)
      expect(lits.run('n:stirling-first(3, 3)')).toEqual(1)
      expect(lits.run('n:stirling-first(4, 1)')).toEqual(6)
      expect(lits.run('n:stirling-first(4, 2)')).toEqual(11)
      expect(lits.run('n:stirling-first(4, 3)')).toEqual(6)
      expect(lits.run('n:stirling-first(4, 4)')).toEqual(1)
      expect(() => lits.run('n:stirling-first(4, 5)')).toThrow()
      expect(() => lits.run('n:stirling-first(4, 0)')).toThrow()
      expect(() => lits.run('n:stirling-first(0, 0)')).toThrow()
    })
  })
  describe('n:stirling-second', () => {
    it('should return the stirling number of the second kind', () => {
      expect(lits.run('n:stirling-second(1, 1)')).toEqual(1)
      expect(lits.run('n:stirling-second(2, 1)')).toEqual(1)
      expect(lits.run('n:stirling-second(2, 2)')).toEqual(1)
      expect(lits.run('n:stirling-second(3, 1)')).toEqual(1)
      expect(lits.run('n:stirling-second(3, 2)')).toEqual(3)
      expect(lits.run('n:stirling-second(3, 3)')).toEqual(1)
      expect(lits.run('n:stirling-second(4, 1)')).toEqual(1)
      expect(lits.run('n:stirling-second(4, 2)')).toEqual(7)
      expect(lits.run('n:stirling-second(4, 3)')).toEqual(6)
      expect(lits.run('n:stirling-second(4, 4)')).toEqual(1)
      expect(() => lits.run('n:stirling-first(4, 5)')).toThrow()
      expect(() => lits.run('n:stirling-first(4, 0)')).toThrow()
      expect(() => lits.run('n:stirling-first(0, 0)')).toThrow()
    })
  })
})
