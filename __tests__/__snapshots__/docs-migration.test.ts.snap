// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`reference output stability > allReference snapshot is stable 1`] = `
"{
  "<<": {
    "title": "<<",
    "category": "Bitwise",
    "description": "Shifts $a arithmetically left by $b bit positions.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "1 << 10",
      "<<(1, 10)",
      "<<(-4, 2)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  ">>": {
    "title": ">>",
    "category": "Bitwise",
    "description": "Shifts $a arithmetically right by $b bit positions.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "2048 >> 10",
      ">>(2048, 10)",
      ">>>(-16, 2)",
      ">>(4, 10)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  ">>>": {
    "title": ">>>",
    "category": "Bitwise",
    "description": "Shifts $a arithmetically right by $b bit positions without sign extension.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "-16 >>> 2",
      ">>>(2048, 10)",
      ">>>(-16, 2)",
      ">>>(4, 10)",
      ">>>(-1, 10)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "bit-not": {
    "title": "bit-not",
    "category": "Bitwise",
    "description": "Returns bitwise \`not\` of $a.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a"
        ]
      }
    ],
    "examples": [
      "bit-not(0)",
      "bit-not(255)"
    ]
  },
  "&": {
    "title": "&",
    "category": "Bitwise",
    "description": "Returns bitwise \`and\` of all arguments.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      },
      "c": {
        "type": "integer",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "c"
        ]
      }
    ],
    "examples": [
      "0b0011 & 0b0110",
      "&(0b0011, 0b0110)",
      "&(0b0011, 0b0110, 0b1001)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "bit-and-not": {
    "title": "bit-and-not",
    "category": "Bitwise",
    "description": "Returns bitwise \`and\` with complement.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      },
      "c": {
        "type": "integer",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "c"
        ]
      }
    ],
    "examples": [
      "0b0011 bit-and-not 0b0110",
      "bit-and-not(0b0011, 0b0110)",
      "bit-and-not(0b0011, 0b0110, 0b1001)"
    ],
    "_isOperator": true
  },
  "|": {
    "title": "|",
    "category": "Bitwise",
    "description": "Returns bitwise \`or\` of all arguments.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      },
      "c": {
        "type": "integer",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "c"
        ]
      }
    ],
    "examples": [
      "0b0011 | 0b0110",
      "|(0b0011, 0b0110)",
      "|(0b1000, 0b0100, 0b0010)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "xor": {
    "title": "xor",
    "category": "Bitwise",
    "description": "Returns bitwise \`xor\` of all arguments.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      },
      "c": {
        "type": "integer",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "c"
        ]
      }
    ],
    "examples": [
      "0b0011 xor 0b0110",
      "xor(0b0011, 0b0110)",
      "xor(0b11110000, 0b00111100, 0b10101010)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "bit-flip": {
    "title": "bit-flip",
    "category": "Bitwise",
    "description": "Flips bit number $b.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "0b0011 bit-flip 1",
      "bit-flip(0b0011, 1)",
      "bit-flip(0b1100, 1)"
    ],
    "_isOperator": true
  },
  "bit-set": {
    "title": "bit-set",
    "category": "Bitwise",
    "description": "Sets bit number $b.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "0b0010 bit-set 1",
      "bit-set(0b0011, 1)",
      "bit-set(0b1100, 1)"
    ],
    "_isOperator": true
  },
  "bit-clear": {
    "title": "bit-clear",
    "category": "Bitwise",
    "description": "Clears bit number $b.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "0b0011 bit-clear 1",
      "bit-clear(0b0011, 1)",
      "bit-clear(0b1100, 1)"
    ],
    "_isOperator": true
  },
  "bit-test": {
    "title": "bit-test",
    "category": "Bitwise",
    "description": "Checks if bit number $b is set.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "0b0011 bit-test 1",
      "bit-test(0b0011, 1)",
      "bit-test(0b1100, 1)"
    ],
    "_isOperator": true
  },
  "filter": {
    "title": "filter",
    "category": "Collection",
    "description": "Creates a new collection with all elements that pass the test implemented by $fun.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "function"
      },
      "coll": {
        "type": "collection"
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "fun"
        ]
      }
    ],
    "examples": [
      "\\nfilter(\\n  [\\"Albert\\", \\"Mojir\\", 160, [1, 2]],\\n  string?\\n)",
      "\\nfilter(\\n  [5, 10, 15, 20],\\n  -> $ > 10\\n)",
      "\\nfilter(\\n  { a: 1, b: 2 },\\n  odd?\\n)"
    ],
    "_isOperator": true
  },
  "filteri": {
    "title": "filteri",
    "category": "Collection",
    "description": "Creates a new collection with all elements that pass the test implemented by $b. The function is called for each element in the collection, and it should take two arguments: the element itself and the index.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "function",
        "description": "The function to call for each element in the collection. The function should take two arguments: the element itself and the index."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "filteri([1, 2, 3], (x, i) -> i % 2 == 0)",
      "filteri([1, 2, 3], (x, i) -> x % 2 == 0)",
      "filteri([1, 2, 3], (x, i) -> x + i > 3)"
    ],
    "_isOperator": true
  },
  "map": {
    "title": "map",
    "category": "Collection",
    "description": "Creates a new collection populated with the results of calling $fun on every element in $colls.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "function"
      },
      "colls": {
        "type": "collection",
        "rest": true,
        "description": "At least one."
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "colls",
          "fun"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3] map -",
      "[1, 2, 3] map -> -($)",
      "map([\\"Albert\\", \\"Mojir\\", 42], str)",
      "map([1, 2, 3], inc)",
      "map([1, 2, 3], [1, 10, 100], *)",
      "map({ a: 1, b: 2 }, inc)",
      "map({ a: 1, b: 2 }, { a: 10, b: 20 }, +)"
    ],
    "_isOperator": true
  },
  "mapi": {
    "title": "mapi",
    "category": "Collection",
    "description": "Creates a new collection populated with the results of calling $b on every element in $a. The function is called for each element in the collection, and it should take two arguments: the element itself and the index.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "function",
        "description": "The function to call for each element in the collection. The function should take two arguments: the element itself and the index."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "mapi([1, 2, 3], (x, i) -> x + i)",
      "mapi([1, 2, 3], (x, i) -> x * i)",
      "mapi([1, 2, 3], (x, i) -> x - i)",
      "mapi([1, 2, 3], (x, i) -> x / i)",
      "mapi([1, 2, 3], (x, i) -> x % inc(i))"
    ],
    "_isOperator": true
  },
  "reduce": {
    "title": "reduce",
    "category": "Collection",
    "description": "Runs $fun function on each element of the $coll, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value.",
    "returns": {
      "type": "any"
    },
    "args": {
      "fun": {
        "type": "function"
      },
      "coll": {
        "type": "collection"
      },
      "initial": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "fun",
          "initial"
        ]
      }
    ],
    "examples": [
      "reduce([1, 2, 3], +, 0)",
      "reduce([], +, 0)",
      "reduce({ a: 1, b: 2 }, +, 0)",
      "\\nreduce(\\n  [1, 2, 3, 4, 5, 6, 7, 8, 9],\\n  (result, value) -> result + (even?(value) ? value : 0),\\n  0)"
    ]
  },
  "reducei": {
    "title": "reducei",
    "category": "Collection",
    "description": "Runs $fun function on each element of the $coll, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.",
    "returns": {
      "type": "any"
    },
    "args": {
      "coll": {
        "type": "collection"
      },
      "fun": {
        "type": "function",
        "description": "The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index."
      },
      "initial": {
        "type": "any",
        "description": "The initial value to use as the accumulator."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "fun",
          "initial"
        ]
      }
    ],
    "examples": [
      "reducei([1, 2, 3], (acc, x, i) -> acc + x + i, 0)",
      "reducei(\\"Albert\\", (acc, x, i) -> acc ++ x ++ i, \\"\\")",
      "reducei({ a: 1, b: 2 }, -> $1 ++ $3, \\"\\")"
    ]
  },
  "reduce-right": {
    "title": "reduce-right",
    "category": "Collection",
    "description": "Runs $fun function on each element of the $coll (starting from the last item), passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value.",
    "returns": {
      "type": "any"
    },
    "args": {
      "fun": {
        "type": "function"
      },
      "coll": {
        "type": "collection"
      },
      "initial": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "fun",
          "initial"
        ]
      }
    ],
    "examples": [
      "reduce-right([\\"A\\", \\"B\\", \\"C\\"], str, \\"\\")",
      "reduce-right({ a: 1, b: 2 }, +, 0)"
    ]
  },
  "reducei-right": {
    "title": "reducei-right",
    "category": "Collection",
    "description": "Runs $fun function on each element of the $coll (starting from the last item), passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the $coll is a single value. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.",
    "returns": {
      "type": "any"
    },
    "args": {
      "coll": {
        "type": "collection"
      },
      "fun": {
        "type": "function",
        "description": "The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index."
      },
      "initial": {
        "type": "any",
        "description": "The initial value to use as the accumulator."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "fun",
          "initial"
        ]
      }
    ],
    "examples": [
      "reducei-right([1, 2, 3], (acc, x, i) -> acc + x + i, 0)",
      "reducei-right(\\"Albert\\", (acc, x, i) -> acc ++ x ++ i, \\"\\")",
      "reducei-right({ a: 1, b: 2 }, -> $1 ++ $3, \\"\\")"
    ]
  },
  "reductions": {
    "title": "reductions",
    "category": "Collection",
    "description": "Returns an array of the intermediate values of the reduction (see \`reduce\`) of $coll by $fun.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "fun": {
        "type": "function"
      },
      "coll": {
        "type": "collection"
      },
      "initial": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "fun",
          "initial"
        ]
      }
    ],
    "examples": [
      "reductions([1, 2, 3], +, 0)",
      "reductions([1, 2, 3], +, 10)",
      "reductions([], +, 0)",
      "reductions({ a: 1, b: 2 }, +, 0)",
      "\\nreductions(\\n  [1, 2, 3, 4, 5, 6, 7, 8, 9],\\n  (result, value) -> result + (even?(value) ? value : 0),\\n  0\\n)"
    ]
  },
  "reductionsi": {
    "title": "reductionsi",
    "category": "Collection",
    "description": "Returns an array of the intermediate values of the reduction (see \`reduce\`) of $coll by $fun. The function is called for each element in the collection, and it should take three arguments: the accumulator, the element itself, and the index.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "coll": {
        "type": "collection"
      },
      "fun": {
        "type": "function",
        "description": "The function to call for each element in the collection. The function should take three arguments: the accumulator, the element itself, and the index."
      },
      "initial": {
        "type": "any",
        "description": "The initial value to use as the accumulator."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "fun",
          "initial"
        ]
      }
    ],
    "examples": [
      "reductionsi([1, 2, 3], (acc, x, i) -> acc + x + i, 0)",
      "reductionsi(\\"Albert\\", (acc, x, i) -> acc ++ x ++ i, \\"\\")",
      "reductionsi({ a: 1, b: 2 }, -> $1 ++ $3, \\"\\")"
    ]
  },
  "get": {
    "title": "get",
    "category": "Collection",
    "description": "Returns value in $a mapped at $b.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": [
          "string",
          "integer"
        ]
      },
      "not-found": {
        "type": "any",
        "description": "Default value to return if $b is not found."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "not-found"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3] get 1",
      "{ a: 1 } get \\"a\\"",
      "\\"Albert\\" get \\"3\\"",
      "\\nget(\\n  [1, 2, 3],\\n  1, // Optional comma after last argument\\n)",
      "\\nget(\\n  [],\\n  1\\n)",
      "\\nget(\\n  [],\\n  1,\\n  \\"default\\"\\n)",
      "\\nget(\\n  { a: 1 },\\n  \\"a\\"\\n)",
      "\\nget(\\n  { a: 1 },\\n  \\"b\\"\\n)",
      "\\nget(\\n  { a: 1 },\\n  \\"b\\",\\n  \\"default\\"\\n)",
      "\\nget(\\n  null,\\n  \\"a\\"\\n)",
      "\\nget(\\n  null,\\n  \\"b\\",\\n  \\"default\\"\\n)"
    ],
    "_isOperator": true
  },
  "get-in": {
    "title": "get-in",
    "category": "Collection",
    "description": "Returns the value in a nested collection, where $b is an array of keys. Returns $not-found if the key is not present. If $not-found is not set, \`null\` is returned.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "array"
      },
      "not-found": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "not-found"
        ]
      }
    ],
    "examples": [
      "\\nget-in(\\n  [[1, 2, 3], [4, { a: \\"Kalle\\" }, 6]],\\n  [1, 1, \\"a\\", 0]\\n)",
      "\\nget-in(\\n  [[1, 2, 3], [4, { a: \\"Kalle\\" }, 6]],\\n  [1, 1, \\"b\\", 0]\\n)",
      "\\nget-in(\\n  [[1, 2, 3], [4, { a: \\"Kalle\\" }, 6]],\\n  [1, 1, \\"b\\", 0],\\n  \\"Lisa\\"\\n)"
    ],
    "_isOperator": true
  },
  "count": {
    "title": "count",
    "category": "Collection",
    "description": "Returns number of elements in $coll.",
    "returns": {
      "type": "number"
    },
    "args": {
      "coll": {
        "type": [
          "collection",
          "null"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll"
        ]
      }
    ],
    "examples": [
      "count([1, 2, 3])",
      "count([])",
      "count({ a: 1 })",
      "count(\\"\\")",
      "count(\\"Albert\\")",
      "count(null)"
    ]
  },
  "contains?": {
    "title": "contains?",
    "category": "Collection",
    "description": "Returns \`true\` if $a contains $b, otherwise returns \`false\`. For strings, it checks if substring is included.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": [
          "collection",
          "null"
        ]
      },
      "b": {
        "type": [
          "string",
          "integer"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3] contains? 1",
      "null contains? 1",
      "{ a: 1, b: 2 } contains? \\"a\\"",
      "\\ncontains?(\\n  [],\\n  1\\n)",
      "\\ncontains?(\\n  [1],\\n  1\\n)",
      "\\ncontains?(\\n  [1, 2, 3],\\n  1\\n)",
      "\\ncontains?(\\n  {},\\n  \\"a\\"\\n)",
      "\\ncontains?(\\n  { a: 1, b: 2 },\\n  \\"a\\"\\n)"
    ],
    "_isOperator": true
  },
  "assoc": {
    "title": "assoc",
    "category": "Collection",
    "description": "\\nAdd or replace the value of element $key to $value in $coll. Repeated for all key-value pairs in $kvs.\\nIf $coll is an 'array', $key must be \`number\` satisfying \`0 <=\` $key \`<= length\`.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "coll": {
        "type": "collection"
      },
      "key": {
        "type": [
          "string",
          "number"
        ]
      },
      "value": {
        "type": "any"
      },
      "kvs": {
        "type": "any",
        "description": "Key-value pairs to associate.",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "key",
          "value"
        ]
      },
      {
        "argumentNames": [
          "coll",
          "key",
          "value",
          "kvs"
        ]
      }
    ],
    "examples": [
      "\\nassoc(\\n  [1, 2, 3],\\n  1,\\n  \\"Two\\"\\n)",
      "\\nassoc(\\n  [1, 2, 3],\\n  3,\\n  \\"Four\\"\\n)",
      "\\nassoc(\\n  { a: 1, b: 2 },\\n  \\"a\\",\\n  \\"One\\")",
      "\\nassoc(\\n  { a: 1, b: 2 },\\n  \\"c\\",\\n  \\"Three\\")",
      "\\nassoc(\\n  \\"Albert\\",\\n  6,\\n  \\"a\\")"
    ]
  },
  "assoc-in": {
    "title": "assoc-in",
    "category": "Collection",
    "description": "\\nAssociates a value in the nested collection $coll, where $ks is an array of keys and $value is the new value.\\n\\nIf any levels do not exist, objects will be created - and the corresponding keys must be of type string.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "coll": {
        "type": "collection"
      },
      "ks": {
        "type": [
          "number",
          "string"
        ],
        "array": true
      },
      "value": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "ks",
          "value"
        ]
      }
    ],
    "examples": [
      "\\nassoc-in(\\n  {},\\n  [\\"a\\", \\"b\\", \\"c\\"],\\n  \\"Albert\\"\\n)",
      "\\nassoc-in(\\n  [1, 2, [1, 2, 3]],\\n  [2, 1],\\n  \\"Albert\\"\\n)",
      "\\nassoc-in(\\n  [1, 2, { name: \\"albert\\" }],\\n  [2, \\"name\\", 0],\\n  \\"A\\"\\n)"
    ]
  },
  "update": {
    "title": "update",
    "category": "Collection",
    "description": "\\nUpdates a value in the $coll collection, where $key is a key. $fun is a function\\nthat will take the old value and any supplied $fun-args and\\nreturn the new value.\\nIf the key does not exist, \`null\` is passed as the old value.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "coll": {
        "type": "collection"
      },
      "key": {
        "type": [
          "string",
          "number"
        ]
      },
      "fun": {
        "type": "function"
      },
      "fun-args": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "value",
          "fun"
        ]
      },
      {
        "argumentNames": [
          "coll",
          "value",
          "fun",
          "fun-args"
        ]
      }
    ],
    "examples": [
      "\\nlet x = { a: 1, b: 2 };\\nupdate(x, \\"a\\", inc)",
      "\\nlet x = { a: 1, b: 2 };\\nupdate(\\n  x,\\n  \\"c\\",\\n  val -> null?(val) ? 0 : inc(val)\\n)"
    ]
  },
  "update-in": {
    "title": "update-in",
    "category": "Collection",
    "description": "Updates a value in the $coll collection, where $ks is an array of\\nkeys and $fun is a function that will take the old value and\\nany supplied $fun-args and return the new value. If any levels do not exist,\\nobjects will be created - and the corresponding keys must be of type string.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "coll": {
        "type": "collection"
      },
      "ks": {
        "type": "array"
      },
      "fun": {
        "type": "function"
      },
      "fun-args": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll",
          "ks",
          "fun"
        ]
      },
      {
        "argumentNames": [
          "coll",
          "ks",
          "fun",
          "fun-args"
        ]
      }
    ],
    "examples": [
      "\\nupdate-in(\\n  { a: [1, 2, 3] },\\n  [\\"a\\", 1],\\n  -> null?($) ? 0 : inc($)\\n)",
      "\\nupdate-in(\\n  { a: { foo: \\"bar\\"} },\\n  [\\"a\\", \\"foo\\"],\\n  -> null?($) ? \\"?\\" : \\"!\\"\\n)",
      "\\nupdate-in(\\n  { a: { foo: \\"bar\\"} },\\n  [\\"a\\", \\"baz\\"],\\n  -> null?($) ? \\"?\\" : \\"!\\"\\n)",
      "\\nupdate-in(\\n  { a: [1, 2, 3] },\\n  [\\"a\\", 1],\\n  *,\\n  10,\\n  10,\\n  10,\\n)"
    ]
  },
  "++": {
    "title": "++",
    "category": "Collection",
    "description": "Concatenates collections into one collection.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "collection"
      },
      "colls": {
        "type": "collection",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a"
        ]
      },
      {
        "argumentNames": [
          "a",
          "colls"
        ]
      }
    ],
    "examples": [
      "\\"Albert\\" ++ \\" \\" ++ \\"Mojir\\"",
      "\\"Albert\\" ++ \\"Mojir\\"",
      "++(\\"Albert\\", \\"-\\", \\"Mojir\\")",
      "++(\\"Albert\\")",
      "++(\\"A\\", \\"l\\", \\"b\\", \\"e\\", \\"r\\", \\"t\\")",
      "++([1, 2], [3, 4])",
      "++([], [3, 4])",
      "++([1, 2], [])",
      "++([1, 2], [3, 4], [5, 6])",
      "++([])",
      "++({ a: 1, b: 2 }, { b: 1, c: 2 })",
      "++({}, { a: 1 })"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "not-empty": {
    "title": "not-empty",
    "category": "Collection",
    "description": "Returns \`null\` if $coll is empty or \`null\`, otherwise $coll.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "coll": {
        "type": [
          "collection",
          "null"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "coll"
        ]
      }
    ],
    "examples": [
      "not-empty([])",
      "not-empty([1, 2, 3])",
      "not-empty({})",
      "not-empty({ a: 2 })",
      "not-empty(\\"\\")",
      "not-empty(\\"Albert\\")",
      "not-empty(null)"
    ]
  },
  "every?": {
    "title": "every?",
    "category": "Collection",
    "description": "Returns \`true\` if all entries in $a pass the test implemented by $b, otherwise returns \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3] every? number?",
      "[1, 2, 3] every? even?",
      "\\nevery?(\\n  [\\"Albert\\", \\"Mojir\\", 160, [1, 2]],\\n  string?,\\n)",
      "\\nevery?(\\n  [50, 100, 150, 200],\\n  -> $ > 10,\\n)",
      "\\nevery?(\\n  [],\\n  number?\\n)",
      "\\nevery?(\\n  \\"\\",\\n  number?\\n)",
      "\\nevery?(\\n  {},\\n  number?\\n)",
      "\\nevery?(\\n  { a: 2, b: 4},\\n  -> even?(second($))\\n)",
      "\\nevery?(\\n  { a: 2, b: 3 },\\n  -> even?(second($))\\n)"
    ],
    "_isOperator": true
  },
  "any?": {
    "title": "any?",
    "category": "Collection",
    "description": "Returns \`true\` if any element in $a pass the test implemented by $b, otherwise returns \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "\\nany?(\\n  [\\"Albert\\", \\"Mojir\\", 160, [1, 2]],\\n  string?\\n)",
      "\\nany?(\\n  [50, 100, 150, 200],\\n  x -> x > 10\\n)",
      "\\nany?(\\n  [],\\n  number?\\n)",
      "\\nany?(\\n  \\"\\",\\n  number?\\n)",
      "\\nany?(\\n  {},\\n  number?\\n)",
      "\\nany?(\\n  { a: 2, b: 3 },\\n  -> even?(second($))\\n)",
      "\\nany?(\\n  { a: 1, b: 3 },\\n  -> even?(second($))\\n)"
    ],
    "_isOperator": true
  },
  "not-any?": {
    "title": "not-any?",
    "category": "Collection",
    "description": "Returns \`false\` if any element in $a pass the test implemented by $b, otherwise returns \`true\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "\\nnot-any?(\\n  [\\"Albert\\", \\"Mojir\\", 160, [1, 2]],\\n  string?\\n)",
      "\\nnot-any?(\\n  [50, 100, 150, 200],\\n  x -> x > 10\\n)",
      "\\nnot-any?(\\n  [],\\n  number?\\n)",
      "\\nnot-any?(\\n  \\"\\",\\n  number?\\n)",
      "\\nnot-any?(\\n  {},\\n  number?\\n)",
      "\\nnot-any?(\\n  { a: 2, b: 3 },\\n  -> even?(second($))\\n)",
      "\\nnot-any?(\\n  { a: 1, b: 3 },\\n  -> even?(second($))\\n)"
    ],
    "_isOperator": true
  },
  "not-every?": {
    "title": "not-every?",
    "category": "Collection",
    "description": "Returns \`true\` if at least one element in $a does not pass the test implemented by $b, otherwise returns \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "\\nnot-every?(\\n  [\\"Albert\\", \\"Mojir\\", 160, [1, 2]],\\n  string?\\n)",
      "\\nnot-every?(\\n  [50, 100, 150, 200],\\n  x -> x > 10\\n)",
      "\\nnot-every?(\\n  [],\\n  number?\\n)",
      "\\nnot-every?(\\n  \\"\\",\\n  number?\\n)",
      "\\nnot-every?(\\n  {},\\n  number?\\n)",
      "\\nnot-every?(\\n  { a: 2, b: 4 },\\n  -> even?(second($))\\n)",
      "\\nnot-every?(\\n  { a: 2, b: 3 },\\n  -> even?(second($))\\n)"
    ],
    "_isOperator": true
  },
  "range": {
    "title": "range",
    "category": "Array",
    "description": "$range creates an array with a range of numbers from $a to $b (exclusive), by $step.\\n\\n$a defaults to 0.\\n$step defaults to 1.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "a": {
        "type": "number"
      },
      "b": {
        "type": "number"
      },
      "step": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "step"
        ]
      }
    ],
    "examples": [
      "range(4)",
      "range(1, 4)",
      "1 range 10",
      "range(0.4, 4.9)",
      "\\nrange(\\n  0.25, // start value\\n  1,    // end value (exclusive)\\n  0.25, // step value\\n)"
    ],
    "_isOperator": true
  },
  "repeat": {
    "title": "repeat",
    "category": "Array",
    "description": "Returns an array with $a repeated $b times.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "repeat(10, 3)",
      "repeat(10, 0)",
      "\\"Albert\\" repeat 5"
    ],
    "_isOperator": true
  },
  "flatten": {
    "title": "flatten",
    "category": "Array",
    "description": "Takes a nested array $x and flattens it.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "x": {
        "type": [
          "array",
          "any"
        ],
        "description": "If $x is not an array, \`[ ]\` is returned."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "flatten([1, 2, [3, 4], 5])",
      "\\nlet foo = \\"bar\\";\\nflatten([\\n  1,\\n  \\" 2 A \\",\\n  [foo, [4, [\\"ABC\\"]]],\\n  6,\\n])"
    ],
    "noOperatorDocumentation": true
  },
  "mapcat": {
    "title": "mapcat",
    "category": "Array",
    "description": "Returns the result of applying concat to the result of applying map to $fun and $colls.",
    "returns": {
      "type": "collection"
    },
    "args": {
      "a": {
        "type": "collection"
      },
      "b": {
        "type": "function"
      },
      "colls": {
        "type": "collection",
        "array": true
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "colls",
          "fun"
        ]
      }
    ],
    "examples": [
      "[[3, 2, 1, 0], [6, 5, 4], [9, 8, 7]] mapcat reverse",
      "mapcat([[3, 2, 1, 0], [6, 5, 4], [9, 8, 7]], reverse)",
      "[[3, 2, 1, 0,], [6, 5, 4,], [9, 8, 7]] mapcat reverse",
      "\\nlet foo = (n) -> {\\n  [n - 1, n, n + 1]\\n};\\n[1, 2, 3] mapcat foo",
      "\\nmapcat(\\n  [[1, 2], [2, 2], [2, 3]],\\n  -> $ remove even?\\n)"
    ],
    "_isOperator": true
  },
  "moving-fn": {
    "title": "moving-fn",
    "category": "Array",
    "description": "Returns the result of applying $fn to each moving window of size $windowSize in $arr.",
    "returns": {
      "type": "array"
    },
    "args": {
      "arr": {
        "type": "array"
      },
      "windowSize": {
        "type": "number",
        "description": "The size of the moving window."
      },
      "fn": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "arr",
          "windowSize",
          "fn"
        ]
      }
    ],
    "examples": [
      "let v = import(\\"Vector\\"); moving-fn([1, 2, 3], 2, v.sum)",
      "let v = import(\\"Vector\\"); moving-fn([1, 2, 3], 1, v.sum)",
      "let v = import(\\"Vector\\"); moving-fn([1, 2, 3], 3, v.sum)"
    ]
  },
  "running-fn": {
    "title": "running-fn",
    "category": "Array",
    "description": "Returns the result of applying $b to each element of $a.",
    "returns": {
      "type": "array"
    },
    "args": {
      "a": {
        "type": "array"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let v = import(\\"Vector\\"); running-fn([1, 2, 3], v.sum)",
      "let v = import(\\"Vector\\"); running-fn([1, 2, 3], v.max)",
      "let v = import(\\"Vector\\"); running-fn([1, 2, 3], v.min)"
    ],
    "_isOperator": true
  },
  "nth": {
    "title": "nth",
    "category": "Sequence",
    "description": "Accesses element $n of $seq. Accessing out-of-bounds indices returns $not-found, if present, else \`null\`.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "integer"
      },
      "seq": {
        "type": [
          "sequence",
          "null"
        ]
      },
      "n": {
        "type": "integer"
      },
      "not-found": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "n"
        ]
      },
      {
        "argumentNames": [
          "seq",
          "n",
          "not-found"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3] nth 1",
      "\\"A string\\" nth 3",
      "nth([1, 2, 3], 1)",
      "nth([1, 2, 3], 3)",
      "nth([1, 2, 3], -1)",
      "nth([1, 2, 3], 3, 99)",
      "nth(\\"A string\\", 1)",
      "nth(\\"A string\\", 3)",
      "nth(\\"A string\\", -3)",
      "nth(\\"A string\\", 30, \\"X\\")",
      "nth(null, 1)",
      "nth(null, 1, \\"Default value\\")"
    ],
    "_isOperator": true
  },
  "first": {
    "title": "first",
    "category": "Sequence",
    "description": "Returns the first element of $seq. If $seq is empty or \`null\`, \`null\` is returned.",
    "returns": {
      "type": "any"
    },
    "args": {
      "seq": {
        "type": [
          "sequence",
          "null"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "first([\\"Albert\\", \\"Mojir\\", 160, [1, 2]])",
      "first([])",
      "first(null)"
    ]
  },
  "last": {
    "title": "last",
    "category": "Sequence",
    "description": "Returns the last element of $seq. If $seq is empty, \`null\` is returned.",
    "returns": {
      "type": "any"
    },
    "args": {
      "seq": {
        "type": [
          "sequence",
          "null"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "last([\\"Albert\\", \\"Mojir\\", 160, [1, 2]])",
      "last([1, 2])",
      "last([1])",
      "last([])",
      "last(null)"
    ]
  },
  "pop": {
    "title": "pop",
    "category": "Sequence",
    "description": "Returns a copy of $seq with last element removed. If $seq is empty \`null\` is returned.",
    "returns": {
      "type": [
        "sequence",
        "null"
      ],
      "rest": true
    },
    "args": {
      "seq": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "pop([1, 2, 3])",
      "pop([])"
    ]
  },
  "position": {
    "title": "position",
    "category": "Sequence",
    "description": "Returns the index of the first elements that passes the test implemented by $fun. If no element was found, \`null\` is returned.",
    "returns": {
      "type": [
        "number",
        "null"
      ]
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": [
          "sequence",
          "null"
        ]
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "fun"
        ]
      }
    ],
    "examples": [
      "\\nposition(\\n  [\\"Albert\\", \\"Mojir\\", 160, [1, 2]],\\n  string?\\n)",
      "\\nposition(\\n  [5, 10, 15, 20],\\n  -> $ > 10\\n)",
      "\\nposition(\\n  [5, 10, 15, 20],\\n  -> $ > 100\\n)",
      "\\nposition(\\n  null,\\n  -> $ > 100\\n)"
    ],
    "_isOperator": true
  },
  "index-of": {
    "title": "index-of",
    "category": "Sequence",
    "description": "Returns the index of $x in $seq. If element is not present in $seq \`null\` is returned.",
    "returns": {
      "type": [
        "number",
        "null"
      ]
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "any"
      },
      "seq": {
        "type": [
          "sequence",
          "null"
        ]
      },
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "x"
        ]
      }
    ],
    "examples": [
      "[[1], [2], [1], [2]] index-of [1]",
      "index-of([\\"Albert\\", \\"Mojir\\", 160, [1, 2]], \\"Mojir\\")",
      "index-of([5, 10, 15, 20], 15)",
      "index-of([5, 10, 15, 20], 1)",
      "index-of(null, 1)"
    ],
    "_isOperator": true
  },
  "last-index-of": {
    "title": "last-index-of",
    "category": "Sequence",
    "description": "Returns the last index of $x in $seq. If element is not present in $seq \`null\` is returned.",
    "returns": {
      "type": [
        "number",
        "null"
      ]
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "any"
      },
      "seq": {
        "type": [
          "sequence",
          "null"
        ]
      },
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "x"
        ]
      }
    ],
    "examples": [
      "[[1], [2], [1], [2]] last-index-of [1]",
      "last-index-of([\\"Albert\\", \\"Mojir\\", 160, [1, 2]], \\"Mojir\\")",
      "last-index-of([5, 10, 15, 20, 15], 15)",
      "last-index-of([5, 10, 15, 20], 1)",
      "last-index-of(null, 1)"
    ],
    "_isOperator": true
  },
  "push": {
    "title": "push",
    "category": "Sequence",
    "description": "Returns copy of $seq with $values added to the end of it.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "any"
      },
      "seq": {
        "type": "sequence"
      },
      "values": {
        "type": "any",
        "rest": true,
        "description": "At least one."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "values"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3] push 4",
      "\\"Albert\\" push \\"!\\"",
      "push([1, 2, 3], 4)",
      "push([1, 2, 3], 4, 5, 6)",
      "\\nlet l = [1, 2, 3];\\npush(l, 4);\\nl"
    ],
    "_isOperator": true
  },
  "rest": {
    "title": "rest",
    "category": "Sequence",
    "description": "If $seq is an array, returns a new array with all but the first element from $seq.\\nIf $seq has less than two elements, an empty array is returned.\\nFor string $seq returns all but the first characters in $seq.",
    "returns": {
      "type": [
        "sequence",
        "null"
      ]
    },
    "args": {
      "seq": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "rest([\\"Albert\\", \\"Mojir\\", 160, [1, 2]])",
      "rest([\\"Albert\\"])",
      "rest([])",
      "rest(\\"Albert\\")",
      "rest(\\"A\\",)",
      "rest(\\"\\")"
    ]
  },
  "next": {
    "title": "next",
    "category": "Sequence",
    "description": "If $seq is an array, returns a new array with all but the first element from $seq. If $seq has less than two elements, \`null\` is returned. For string $seq returns all but the first characters in $seq. If length of string $seq is less than two, \`null\` is returned.",
    "returns": {
      "type": [
        "sequence",
        "null"
      ]
    },
    "args": {
      "seq": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "next([\\"Albert\\", \\"Mojir\\", 160, [1, 2]])",
      "next([\\"Albert\\"])",
      "next([])",
      "next(\\"Albert\\")",
      "next(\\"A\\",)",
      "next(\\"\\")"
    ]
  },
  "reverse": {
    "title": "reverse",
    "category": "Sequence",
    "description": "If $seq is an array, creates a new array with the elements from $seq in reversed order. If $seq is a string, returns new reversed string.",
    "returns": {
      "type": [
        "sequence",
        "null"
      ]
    },
    "args": {
      "seq": {
        "type": [
          "sequence",
          "null"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "reverse([\\"Albert\\", \\"Mojir\\", 160, [1, 2]])",
      "reverse([])",
      "reverse(\\"Albert\\")",
      "reverse(null)"
    ]
  },
  "second": {
    "title": "second",
    "category": "Sequence",
    "description": "Returns the second element of $seq. If $seq has less than two elements or is \`null\`, \`null\` is returned.",
    "returns": {
      "type": "any"
    },
    "args": {
      "seq": {
        "type": [
          "sequence",
          "null"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "second([\\"Albert\\", \\"Mojir\\", 160, [1, 2]])",
      "second([1])",
      "second([])",
      "second(null)"
    ]
  },
  "shift": {
    "title": "shift",
    "category": "Sequence",
    "description": "Returns a copy of $seq with first element removed. If $seq is empty \`null\` is returned.",
    "returns": {
      "type": [
        "sequence",
        "null"
      ]
    },
    "args": {
      "seq": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "shift([1, 2, 3])",
      "shift([])"
    ]
  },
  "slice": {
    "title": "slice",
    "category": "Sequence",
    "description": "Returns a copy of a portion of $seq from index $start (inclusive) to $stop (exclusive).",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "integer"
      },
      "seq": {
        "type": "sequence",
        "rest": true
      },
      "start": {
        "type": "integer",
        "description": "Defaults to \`0\`."
      },
      "stop": {
        "type": "integer",
        "description": "Defaults lenght of sequence + 1."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      },
      {
        "argumentNames": [
          "seq",
          "start"
        ]
      },
      {
        "argumentNames": [
          "seq",
          "start",
          "stop"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3, 4, 5] slice 2",
      "slice([1, 2, 3, 4, 5], 2, 4)",
      "slice([1, 2, 3, 4, 5], 2)"
    ],
    "_isOperator": true
  },
  "splice": {
    "title": "splice",
    "category": "Sequence",
    "description": "Returns a a spliced array. Removes $deleteCount elements from $seq starting at $start and replaces them with $items. If $start is negative, it is counting from the end of the array.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "seq": {
        "type": "sequence",
        "rest": true
      },
      "start": {
        "type": "integer"
      },
      "deleteCount": {
        "type": "integer"
      },
      "items": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "start",
          "deleteCount"
        ]
      },
      {
        "argumentNames": [
          "seq",
          "start",
          "deleteCount",
          "items"
        ]
      }
    ],
    "examples": [
      "splice([1, 2, 3, 4, 5], 2, 2, \\"x\\")",
      "splice([1, 2, 3, 4, 5], -2, 1, \\"x\\")",
      "splice(\\"Albert\\", 2, 2, \\"fo\\")"
    ]
  },
  "some": {
    "title": "some",
    "category": "Sequence",
    "description": "Returns the first element that passes the test implemented by $fun. I no element was found, \`null\` is returned.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": [
          "sequence",
          "null"
        ]
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "fun"
        ]
      }
    ],
    "examples": [
      "\\nsome(\\n  [\\"Albert\\", \\"Mojir\\", 160, [1, 2]],\\n  string?\\n)",
      "\\nsome(\\n  [5, 10, 15, 20],\\n  -> $ > 10\\n)",
      "\\nsome(\\n  [1, 2, 3, 4],\\n  -> $ > 10\\n)",
      "\\nsome(\\n  [],\\n  -> $ > 10\\n)",
      "\\nsome(\\n  null,\\n  -> $ > 10\\n)"
    ],
    "_isOperator": true
  },
  "sort": {
    "title": "sort",
    "category": "Sequence",
    "description": "Returns a new sequence with the elements from $seq sorted according to $fun. If no $fun is supplied, builtin \`compare\` will be used.",
    "returns": {
      "type": "any",
      "rest": true
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": "sequence"
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      },
      {
        "argumentNames": [
          "seq",
          "fun"
        ]
      }
    ],
    "examples": [
      "[3, 1, 2] sort (a, b) -> b - a",
      "sort([3, 1, 2])",
      "\\nsort(\\n  [3, 1, 2],\\n  (a, b) -> cond case a < b then -1 case a > b then 1 case true then -1 end\\n)",
      "\\nsort(\\n  [3, 1, 2],\\n  (a, b) -> cond case a > b then -1 case a < b then 1 case true then -1 end\\n)"
    ],
    "_isOperator": true
  },
  "sort-by": {
    "title": "sort-by",
    "category": "Sequence",
    "description": "Returns a sorted sequence of the items in $seq, where the sort order is determined by comparing \`(keyfn item)\`. If no $comparer is supplied, uses builtin \`compare\`.",
    "returns": {
      "type": "any",
      "rest": true
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": "sequence"
      },
      "keyfn": {
        "type": "function"
      },
      "comparer": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "keyfn"
        ]
      },
      {
        "argumentNames": [
          "seq",
          "keyfn",
          "comparer"
        ]
      }
    ],
    "examples": [
      "[\\"Albert\\", \\"Mojir\\", \\"Nina\\"] sort-by count",
      "sort-by([\\"Albert\\", \\"Mojir\\", \\"Nina\\"], count)",
      "sort-by(\\"Albert\\", lower-case, -> $2 compare $1)"
    ],
    "_isOperator": true
  },
  "take": {
    "title": "take",
    "category": "Sequence",
    "description": "Constructs a new array/string with the $n first elements from $seq.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "integer"
      },
      "n": {
        "type": "integer"
      },
      "seq": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "n"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3, 4, 5] take 3",
      "take([1, 2, 3, 4, 5], 3)",
      "take([1, 2, 3, 4, 5], 0)",
      "take(\\"Albert\\", 2)",
      "take(\\"Albert\\", 50)"
    ],
    "_isOperator": true
  },
  "take-last": {
    "title": "take-last",
    "category": "Sequence",
    "description": "Constructs a new array with the $n last elements from $seq.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "integer"
      },
      "n": {
        "type": "integer"
      },
      "seq": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n",
          "seq"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3, 4, 5] take-last 3",
      "take-last([1, 2, 3, 4, 5], 3)",
      "take-last([1, 2, 3, 4, 5], 0)"
    ],
    "_isOperator": true
  },
  "take-while": {
    "title": "take-while",
    "category": "Sequence",
    "description": "Returns the members of $seq in order, stopping before the first one for which \`predicate\` returns a falsy value.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": "sequence"
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "fun"
        ]
      }
    ],
    "examples": [
      "\\ntake-while(\\n  [1, 2, 3, 2, 1],\\n  -> $ < 3\\n)",
      "\\ntake-while(\\n  [1, 2, 3, 2, 1],\\n  -> $ > 3\\n)"
    ],
    "_isOperator": true
  },
  "drop": {
    "title": "drop",
    "category": "Sequence",
    "description": "Constructs a new array/string with the $n first elements dropped from $seq.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "integer"
      },
      "seq": {
        "type": "sequence"
      },
      "n": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "n"
        ]
      }
    ],
    "examples": [
      "drop([1, 2, 3, 4, 5], 3)",
      "drop([1, 2, 3, 4, 5], 0)",
      "drop(\\"Albert\\", 2)",
      "drop(\\"Albert\\", 50)"
    ],
    "_isOperator": true
  },
  "drop-last": {
    "title": "drop-last",
    "category": "Sequence",
    "description": "Constructs a new array with the $n last elements dropped from $seq.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "integer"
      },
      "seq": {
        "type": "sequence"
      },
      "n": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "n"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3, 4, 5] drop-last 3",
      "drop-last([1, 2, 3, 4, 5], 3)",
      "drop-last([1, 2, 3, 4, 5], 0)"
    ],
    "_isOperator": true
  },
  "drop-while": {
    "title": "drop-while",
    "category": "Sequence",
    "description": "Returns the members of $seq in order, skipping the fist elements for witch the \`predicate\` returns a truethy value.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": "sequence"
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "fun"
        ]
      }
    ],
    "examples": [
      "\\ndrop-while(\\n  [1, 2, 3, 2, 1],\\n  -> $ < 3\\n)",
      "\\ndrop-while(\\n  [1, 2, 3, 2, 1],\\n  -> $ > 3\\n)"
    ],
    "_isOperator": true
  },
  "unshift": {
    "title": "unshift",
    "category": "Sequence",
    "description": "Returns copy of $seq with $values added to the beginning.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "any"
      },
      "seq": {
        "type": "sequence"
      },
      "values": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "values"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3] unshift 4",
      "unshift([1, 2, 3], 4)",
      "unshift([1, 2, 3], 4, 5, 6)",
      "\\nlet l = [1, 2, 3];\\nunshift(l, 4);\\nl"
    ],
    "_isOperator": true
  },
  "distinct": {
    "title": "distinct",
    "category": "Sequence",
    "description": "Returns a copy of $seq with no duplicates.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "seq": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "distinct([[1], [2], [3], [1], [3], [5]])",
      "distinct([1, 2, 3, 1, 3, 5])",
      "distinct(\\"Albert Mojir\\")",
      "distinct([])",
      "distinct(\\"\\")"
    ]
  },
  "remove": {
    "title": "remove",
    "category": "Sequence",
    "description": "Returns a new sequence of items in $seq for witch \`pred(item)\` returns a falsy value.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": "sequence"
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "fun"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3, 1, 3, 5] remove odd?",
      "remove([1, 2, 3, 1, 3, 5], even?)",
      "remove(\\"Albert Mojir\\", -> \\"aoueiyAOUEIY\\" contains? $)"
    ],
    "_isOperator": true
  },
  "remove-at": {
    "title": "remove-at",
    "category": "Sequence",
    "description": "Returns a new sequence of all items in $seq except item at position $n. If $n is negative, it is counting from the end of the sequence.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "integer"
      },
      "seq": {
        "type": "sequence"
      },
      "n": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "n"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3, 1, 3, 5] remove-at 2",
      "\\"Albert\\" remove-at -2",
      "remove-at([1, 2, 3, 1, 3, 5], 0)",
      "remove-at([1, 2, 3, 1, 3, 5], -1)",
      "remove-at(\\"Albert Mojir\\", 6)"
    ],
    "_isOperator": true
  },
  "split-at": {
    "title": "split-at",
    "category": "Sequence",
    "description": "Returns a pair of sequence \`[take(pos input), drop(pos input)]\`.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "integer"
      },
      "seq": {
        "type": "sequence"
      },
      "n": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "n"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3, 4, 5] split-at 2",
      "\\"Albert\\" split-at -2",
      "split-at([1, 2, 3, 4, 5], -2)",
      "split-at(\\"Albert\\", 2)"
    ],
    "_isOperator": true
  },
  "split-with": {
    "title": "split-with",
    "category": "Sequence",
    "description": "Returns a pair of sequences \`[take-while(input, fun), drop-while(input, fun)]\`.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": "sequence"
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "fun"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3, 4, 5] split-with odd?",
      "split-with([1, 2, 3, 4, 5], -> $ > 3)",
      "split-with(\\"Albert\\", -> $ <= \\"o\\")"
    ],
    "_isOperator": true
  },
  "frequencies": {
    "title": "frequencies",
    "category": "Sequence",
    "description": "Returns an object from distinct items in $seq to the number of times they appear. Note that all items in $seq must be valid object keys i.e. strings.",
    "returns": {
      "type": "object"
    },
    "args": {
      "seq": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq"
        ]
      }
    ],
    "examples": [
      "frequencies([\\"Albert\\", \\"Mojir\\", \\"Nina\\", \\"Mojir\\"])",
      "frequencies(\\"Pneumonoultramicroscopicsilicovolcanoconiosis\\")"
    ]
  },
  "group-by": {
    "title": "group-by",
    "category": "Sequence",
    "description": "Returns an object of the elements of $seq keyed by the result of $fun on each element. The value at each key will be an array of the corresponding elements.",
    "returns": {
      "type": "object"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": "sequence"
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "fun"
        ]
      }
    ],
    "examples": [
      "[{ name: \\"Albert\\" }, { name: \\"Albert\\" }, { name: \\"Mojir\\" }] group-by \\"name\\"",
      "group-by([{name: \\"Albert\\"}, {name: \\"Albert\\"}, {name: \\"Mojir\\"}], \\"name\\")",
      "group-by(\\"Albert Mojir\\", -> \\"aoueiAOUEI\\" contains? $ ? \\"vowel\\" : \\"other\\")"
    ],
    "_isOperator": true
  },
  "partition": {
    "title": "partition",
    "category": "Sequence",
    "description": "Returns an array of sequences of $n items each, at offsets $step apart. If $step is not supplied, defaults to $n. If a $pad array is supplied, use its elements as necessary to complete last partition upto $n items. In case there are not enough padding elements, return a partition with less than $n items.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "number"
      },
      "seq": {
        "type": "sequence"
      },
      "n": {
        "type": "number"
      },
      "step": {
        "type": "number"
      },
      "pad": {
        "type": "array"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "n"
        ]
      },
      {
        "argumentNames": [
          "seq",
          "n",
          "step"
        ]
      },
      {
        "argumentNames": [
          "seq",
          "n",
          "step",
          "pad"
        ]
      }
    ],
    "examples": [
      "range(20) partition 4",
      "partition(range(20), 4)",
      "partition(range(22), 4)",
      "partition(range(20), 4, 6)",
      "partition(range(20), 4, 3)",
      "partition(range(20), 3, 6, [\\"a\\"])",
      "partition(range(20), 4, 6, [\\"a\\"])",
      "partition(range(20), 4, 6, [\\"a\\", \\"b\\", \\"c\\", \\"d\\"])",
      "partition([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"], 3, 1)",
      "partition([1, 2, 3, 4], 10)",
      "partition([1, 2, 3, 4], 10, 10)",
      "partition([1, 2, 3, 4], 10, 10, [])",
      "partition([1, 2, 3, 4], 10, 10, null)",
      "partition(\\"superfragilistic\\", 5)",
      "partition(\\"superfragilistic\\", 5, 5, null)",
      "let foo = [5, 6, 7, 8]; partition(foo, 2, 1, foo)"
    ],
    "_isOperator": true
  },
  "partition-all": {
    "title": "partition-all",
    "category": "Sequence",
    "description": "Returns an array of sequences like partition, but may include partitions with fewer than n items at the end.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "number"
      },
      "seq": {
        "type": "sequence"
      },
      "n": {
        "type": "number"
      },
      "step": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "n"
        ]
      },
      {
        "argumentNames": [
          "seq",
          "n",
          "step"
        ]
      }
    ],
    "examples": [
      "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] partition-all 4",
      "partition-all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4)",
      "partition([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 4)",
      "partition-all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 2, 4)"
    ],
    "_isOperator": true
  },
  "partition-by": {
    "title": "partition-by",
    "category": "Sequence",
    "description": "Applies $fun to each value in $seq, splitting it each time $fun returns a new value. Returns an array of sequences.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "function"
      },
      "seq": {
        "type": "sequence"
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "fun"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3, 4, 5] partition-by odd?",
      "partition-by([1, 2, 3, 4, 5], -> $ == 3)",
      "partition-by([1, 1, 1, 2, 2, 3, 3], odd?)",
      "partition-by(\\"Leeeeeerrroyyy\\", identity)"
    ],
    "_isOperator": true
  },
  "ends-with?": {
    "title": "ends-with?",
    "category": "Sequence",
    "description": "Returns \`true\` if $seq ends with $suffix, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "sequence"
      },
      "seq": {
        "type": "sequence"
      },
      "suffix": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "suffix"
        ]
      }
    ],
    "examples": [
      "[[1], [2], [3], [4], [5]] starts-with? [5]",
      "[[1], [2], [3], [4], [5]] starts-with? 5",
      "ends-with?([1, 2, 3, 4, 5], 5)",
      "ends-with?([1, 2, 3, 4, 5], [5])",
      "ends-with?(\\"Albert\\", \\"rt\\")",
      "ends-with?(\\"Albert\\", \\"RT\\")"
    ],
    "_isOperator": true
  },
  "starts-with?": {
    "title": "starts-with?",
    "category": "Sequence",
    "description": "Returns \`true\` if $seq starts with $prefix, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "sequence"
      },
      "seq": {
        "type": "sequence"
      },
      "prefix": {
        "type": "sequence"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "prefix"
        ]
      }
    ],
    "examples": [
      "[[1], [2], [3], [4], [5]] starts-with? [1]",
      "starts-with?([1, 2, 3, 4, 5], 1)",
      "starts-with?([1, 2, 3, 4, 5], [1])",
      "starts-with?(\\"Albert\\", \\"Al\\")",
      "starts-with?(\\"Albert\\", \\"al\\")"
    ],
    "_isOperator": true
  },
  "interleave": {
    "title": "interleave",
    "category": "Sequence",
    "description": "Returns a sequence of the first item from each of the $seqs, then the second item from each of the $seqs, until all items from the shortest seq are exhausted.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "sequence"
      },
      "seqs": {
        "type": "sequence",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seqs"
        ]
      }
    ],
    "examples": [
      "[1, 2, 3] interleave [4, 5, 6]",
      "\\"Albert\\" interleave \\".,.,.,\\"",
      "interleave([1, 2, 3], [4, 5, 6])",
      "interleave([1, 2, 3], [4, 5, 6], [7, 8, 9])",
      "interleave([1, 2, 3], [4, 5, 6], [7, 8])",
      "interleave([1, 2, 3], [4, 5, 6], [7])",
      "interleave([1, 2, 3], [4, 5, 6], [])",
      "interleave([1, 2, 3], [])",
      "interleave([])"
    ],
    "_isOperator": true
  },
  "interpose": {
    "title": "interpose",
    "category": "Sequence",
    "description": "Returns a sequence of the elements of $seq separated by $separator. If $seq is a string, the separator must be a string.",
    "returns": {
      "type": "sequence"
    },
    "args": {
      "a": {
        "type": "sequence"
      },
      "b": {
        "type": "any"
      },
      "seq": {
        "type": "sequence"
      },
      "separator": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "seq",
          "separator"
        ]
      }
    ],
    "examples": [
      "\\"Albert\\" interpose \\"-\\"",
      "interpose([1, 2, 3, 4, 5], \\"a\\")",
      "interpose([\\"Albert\\", \\"Mojir\\", \\"Nina\\"], \\", \\")",
      "interpose(\\"Albert\\", \\".\\")"
    ],
    "_isOperator": true
  },
  "inc": {
    "title": "inc",
    "category": "Math",
    "description": "The \`inc\` function increments its argument by 1, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it increases each element by 1 while preserving the original structure.",
    "returns": {
      "type": "number"
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "inc(0)",
      "inc(1)",
      "inc(100.1)",
      "inc([1, 2, 3])",
      "inc([[1, 2], [3, 4]])"
    ]
  },
  "dec": {
    "title": "dec",
    "category": "Math",
    "description": "The \`dec\` function decrements its argument by 1, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it decreases each element by 1 while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "dec(0)",
      "dec(1)",
      "dec(100.1)",
      "dec([1, 2, 3])",
      "dec([[1, 2], [3, 4]])"
    ]
  },
  "+": {
    "title": "+",
    "category": "Math",
    "description": "The \`+\` function performs addition of numbers and element-wise addition of \`vectors\` and \`matrices\` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it adds the scalar to each element of the collection.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "a": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "b": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "xs": {
        "type": [
          "number",
          "vector",
          "matrix"
        ],
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "xs"
        ]
      }
    ],
    "examples": [
      "1 + 2",
      "1 + 20 + 30",
      "+(1, 2, 3, 4)",
      "+()",
      "+(1)",
      "[1, 2, 3] + 2",
      "[1, 2, 3] + [4, 5, 6]",
      "[[1, 2, 3], [4, 5, 6]] + [[7, 8, 9], [10, 11, 12]]",
      "[[1, 2, 3], [4, 5, 6]] + 2"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "*": {
    "title": "*",
    "category": "Math",
    "description": "The \`*\` function performs multiplication of \`numbers\` and element-wise multiplication of \`vectors\` and \`matrices\` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it multiplies each element of the collection by the scalar.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "a": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "b": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "xs": {
        "type": [
          "number",
          "vector",
          "matrix"
        ],
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "xs"
        ]
      }
    ],
    "examples": [
      "6 * 7",
      "-1 * 4",
      "*(4, 7)",
      "*(1, 2, 3, 4, 5)",
      "*()",
      "*(8)",
      "[1, 2, 3] * 2",
      "[1, 2, 3] * [4, 5, 6]",
      "[[1, 2, 3], [4, 5, 6]] * [[7, 8, 9], [10, 11, 12]]",
      "[[1, 2, 3], [4, 5, 6]] * 2"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "/": {
    "title": "/",
    "category": "Math",
    "description": "The \`/\` function performs division of \`numbers\` and element-wise division of \`vectors\` and \`matrices\` of compatible dimensions, returning the same type as its inputs. When used with mixed types, it divides each element of the collection by the scalar.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "a": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "b": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "xs": {
        "type": [
          "number",
          "vector",
          "matrix"
        ],
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "xs"
        ]
      }
    ],
    "examples": [
      "12 / 100",
      "-1 / 4",
      "/(7, 4)",
      "/(1, 2, 4, 8)",
      "/()",
      "/(8)",
      "[1, 2, 3] / 2",
      "[1, 2, 3] / [4, 5, 6]",
      "[[1, 2, 3], [4, 5, 6]] / [[7, 8, 9], [10, 11, 12]]",
      "[[1, 2, 3], [4, 5, 6]] / 2"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "-": {
    "title": "-",
    "category": "Math",
    "description": "Computes difference between first value and sum of the rest. When called with only one argument, it does negation.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "a": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "b": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "xs": {
        "type": [
          "number",
          "vector",
          "matrix"
        ],
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "xs"
        ]
      }
    ],
    "examples": [
      "50 - 8",
      "1 - 1 - 1",
      "-()",
      "-(4, 2)",
      "-(4, 3, 2, 1,)",
      "[1, 2, 3] - 2",
      "[1, 2, 3] - [4, 5, 6]",
      "[[1, 2, 3], [4, 5, 6]] - [[7, 8, 9], [10, 11, 12]]",
      "[[1, 2, 3], [4, 5, 6]] - 2"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "quot": {
    "title": "quot",
    "category": "Math",
    "description": "The \`quot\` function performs integer division truncated toward zero, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\` of compatible dimensions. When used with mixed types, it applies integer division between each element of the collection and the scalar.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "a": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "b": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "quot(5, 3)",
      "quot(5.2, 3.1)",
      "quot(-5, 3)",
      "5 quot -3",
      "-5 quot -3",
      "quot(5, 0)",
      "quot(0, 5)",
      "[1, 2, 3] quot 2",
      "2 quot [1, 2, 3]",
      "quot([1, 2, 3], [4, 5, 6])",
      "[[1, 2, 3], [4, 5, 6]] quot [[7, 8, 9], [10, 11, 12]]",
      "quot([[1, 2, 3], [4, 5, 6]], 2)",
      "[[1, 2, 3], [4, 5, 6]] quot [[7, 8, 9], [10, 11, 12]]"
    ],
    "_isOperator": true
  },
  "mod": {
    "title": "mod",
    "category": "Math",
    "description": "The \`mod\` function computes the modulo of division with the same sign as the divisor, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\` of compatible dimensions. When used with mixed types, it applies the modulo operation between each element of the collection and the scalar.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "a": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "b": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "mod(5, 3)",
      "mod(5.2, 3.1)",
      "mod(-5, 3)",
      "5 mod -3",
      "-5 mod -3",
      "[1, 2, 3] mod 2",
      "2 mod [1, 2, 3]",
      "mod([1, 2, 3], [4, 5, 6])",
      "[[1, 2, 3], [4, 5, 6]] mod [[7, 8, 9], [10, 11, 12]]",
      "mod([[1, 2, 3], [4, 5, 6]], 2)"
    ],
    "_isOperator": true
  },
  "%": {
    "title": "%",
    "category": "Math",
    "description": "The \`%\` function computes the remainder of division with the same sign as the dividend, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\` of compatible dimensions. When used with mixed types, it applies the remainder operation between each element of the collection and the scalar.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "a": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "b": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "5 % 3",
      "5.2 % 3.1",
      "-5 % 3",
      "%(5, -3)",
      "%(-5, -3)",
      "[1, 2, 3] % 2",
      "2 % [1, 2, 3]",
      "%([1, 2, 3], [4, 5, 6])",
      "[[1, 2, 3], [4, 5, 6]] % [[7, 8, 9], [10, 11, 12]]",
      "%([[1, 2, 3], [4, 5, 6]], 2)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "sqrt": {
    "title": "sqrt",
    "category": "Math",
    "description": "The \`sqrt\` function calculates the square root of \`numbers\` and computes element-wise square roots of \`vectors\` and \`matrices\`. When applied to collections, it returns the square root of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "sqrt(0)",
      "sqrt(9)",
      "sqrt(2)",
      "sqrt(0)",
      "sqrt(9)",
      "sqrt(2)",
      "sqrt([1, 4, 9])",
      "sqrt([[1, 4], [9, 16]])"
    ]
  },
  "cbrt": {
    "title": "cbrt",
    "category": "Math",
    "description": "The \`cbrt\` function calculates the cube root of \`numbers\` and computes element-wise cube roots of \`vectors\` and \`matrices\`. When applied to collections, it returns the cube root of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "cbrt(0)",
      "cbrt(27)",
      "cbrt(2)",
      "cbrt(1)",
      "cbrt(0)",
      "cbrt(27)",
      "cbrt(2)",
      "cbrt(1)",
      "cbrt([1, 8, 27])",
      "cbrt([[1, 8], [27, 64]])"
    ]
  },
  "^": {
    "title": "^",
    "category": "Math",
    "description": "The ^ function computes exponentiation, raising the first argument to the power of the second, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\` of compatible dimensions. When used with mixed types, it applies the power operation between each element of the collection and the scalar.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "a": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "b": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "2 ^ 3",
      "2 ^ 0",
      "2 ^ -3",
      "^(-2, 3)",
      "^(-2, -3)",
      "[1, 2, 3] ^ 2",
      "2 ^ [1, 2, 3]",
      "^([1, 2, 3], [4, 5, 6])",
      "[[1, 2, 3], [4, 5, 6]] ^ [[7, 8, 9], [10, 11, 12]]",
      "^([[1, 2, 3], [4, 5, 6]], 2)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "round": {
    "title": "round",
    "category": "Math",
    "description": "The \`round\` function rounds a \`number\` to the nearest \`integer\` or to a specified number of \`decimal\` places, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it rounds each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "a": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "round(2)",
      "round(2.49)",
      "round(2.5)",
      "round(-2.49)",
      "round(-2.5)",
      "round(-2.501)",
      "round(1.23456789, 4)",
      "1.123456789 round 2",
      "round([1.23456789, 2.3456789], 1)",
      "[1.23456789, 2.3456789] round 4",
      "[[1.23456789, 2.3456789], [3.456789, 4.56789]] round 4",
      "round([[1.23456789, 2.3456789], [3.456789, 4.56789]], 2)"
    ],
    "_isOperator": true
  },
  "trunc": {
    "title": "trunc",
    "category": "Math",
    "description": "The \`trunc\` function truncates \`numbers\` toward zero (removing decimal portions without rounding), working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it truncates each element while preserving the original structure.",
    "returns": {
      "type": [
        "integer",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "trunc(2)",
      "trunc(2.49)",
      "trunc(2.5)",
      "trunc(-2.49)",
      "trunc(-2.5)",
      "trunc(-2.501)",
      "trunc([1.23456789, 2.3456789])",
      "trunc([[1.23456789, 2.3456789], [3.456789, 4.56789]])"
    ]
  },
  "floor": {
    "title": "floor",
    "category": "Math",
    "description": "The \`floor\` function returns the largest \`integer\` less than or equal to a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the floor of each element while preserving the original structure.",
    "returns": {
      "type": [
        "integer",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "floor(2)",
      "floor(2.49)",
      "floor(2.5)",
      "floor(-2.49)",
      "floor(-2.5)",
      "floor(-2.501)",
      "floor([1.23456789, 2.3456789])",
      "floor([[1.23456789, 2.3456789], [3.456789, 4.56789]])"
    ]
  },
  "ceil": {
    "title": "ceil",
    "category": "Math",
    "description": "The \`ceil\` function returns the smallest \`integer\` greater than or equal to a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the ceiling of each element while preserving the original structure.",
    "returns": {
      "type": [
        "integer",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "ceil(2)",
      "ceil(2.49)",
      "ceil(2.5)",
      "ceil(-2.49)",
      "ceil(-2.5)",
      "ceil(-2.501)",
      "ceil([1.23456789, 2.3456789])",
      "ceil([[1.23456789, 2.3456789], [3.456789, 4.56789]])"
    ]
  },
  "min": {
    "title": "min",
    "category": "Math",
    "description": "Returns the smallest number of the arguments.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "number"
      },
      "b": {
        "type": "number"
      },
      "xs": {
        "type": "number",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "xs"
        ]
      }
    ],
    "examples": [
      "2 min 3",
      "min(2, 0, 1)",
      "min(2, -1, 1)",
      "min(2.5)",
      "12 min 14"
    ],
    "_isOperator": true
  },
  "max": {
    "title": "max",
    "category": "Math",
    "description": "Returns the largest number of the arguments.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "number"
      },
      "b": {
        "type": "number"
      },
      "xs": {
        "type": "number",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "xs"
        ]
      }
    ],
    "examples": [
      " 2 max 3",
      "max(2, 0, 1)",
      "max(2, -1, 1)",
      "max(2, 0.5)",
      "4 max 2"
    ],
    "_isOperator": true
  },
  "abs": {
    "title": "abs",
    "category": "Math",
    "description": "The abs function returns the absolute value (magnitude) of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the absolute value of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "abs(-2.3)",
      "abs(0)",
      "abs(2.5)",
      "abs([1, -2, 3])",
      "abs([[1, -2], [3, -4]])"
    ]
  },
  "sign": {
    "title": "sign",
    "category": "Math",
    "description": "The \`sign\` function returns the \`sign** of a **number\` (-1 for negative, 0 for zero, 1 for positive), working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the sign of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "sign(-2.3)",
      "sign(-0)",
      "sign(0)",
      "sign(12312)",
      "sign([1, -2, 3])",
      "sign([[1, -2], [3, -4]])"
    ]
  },
  "ln": {
    "title": "ln",
    "category": "Math",
    "description": "The \`ln\` function computes the natural logarithm (base \`e\`) of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the natural logarithm of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "ln(0.01)",
      "ln(2.5)",
      "ln(E)",
      "ln([1, 2, 3])",
      "ln([[1, 2], [3, 4]])"
    ]
  },
  "log2": {
    "title": "log2",
    "category": "Math",
    "description": "The \`log2\` function computes the base \`2\` logarithm of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the base-2 logarithm of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "log2(0.01)",
      "log2(2 ^ 12)",
      "log2(2.5)",
      "log2([1, 2, 3])",
      "log2([[1, 2], [3, 4]])"
    ]
  },
  "log10": {
    "title": "log10",
    "category": "Math",
    "description": "The \`log10\` function computes the base \`10\` logarithm of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the base-10 logarithm of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "log10(0.01)",
      "log10(10 ^ 12)",
      "log10(2.5)",
      "log10([1, 2, 3])",
      "log10([[1, 2], [3, 4]])"
    ]
  },
  "sin": {
    "title": "sin",
    "category": "Math",
    "description": "The \`sin\` function computes the sine of an angle (in radians), working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the sine of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "sin(0)",
      "sin(1)",
      "sin(PI)",
      "sin(-0.5)",
      "sin([1, 2, 3])",
      "sin([[1, 2], [3, 4]])"
    ]
  },
  "asin": {
    "title": "asin",
    "category": "Math",
    "description": "The \`asin\` function computes the arcsine (inverse sine) of a \`number\` in radians, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the arcsine of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "asin(0)",
      "asin(1)",
      "asin(-0.5)",
      "asin([1, 2, 3])",
      "asin([[1, 2], [3, 4]])"
    ]
  },
  "sinh": {
    "title": "sinh",
    "category": "Math",
    "description": "The \`sinh\` function computes the hyperbolic sine of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the hyperbolic sine of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "sinh(0)",
      "sinh(1)",
      "sinh(-0.5)",
      "sinh([0.1, 0.2, 0.3])",
      "sinh([[0.1, 0.2], [0.3, 0.4]])"
    ]
  },
  "asinh": {
    "title": "asinh",
    "category": "Math",
    "description": "The \`asinh\` function computes the inverse hyperbolic sine of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the inverse hyperbolic sine of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "asinh(10)",
      "asinh(90)",
      "asinh (50)",
      "asinh([10, 20, 30])",
      "asinh([[10, 20], [30, 40]])"
    ]
  },
  "cos": {
    "title": "cos",
    "category": "Math",
    "description": "The \`cos\` function computes the cosine of an angle (in radians), working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the cosine of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "cos(0)",
      "cos(1)",
      "cos(PI)",
      "cos(-0.5)",
      "cos([1, 2, 3])",
      "cos([[1, 2], [3, 4]])"
    ]
  },
  "acos": {
    "title": "acos",
    "category": "Math",
    "description": "The \`acos\` function computes the arccosine (inverse cosine) of a \`number\` in radians, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the arccosine of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "acos(0)",
      "acos(1)",
      "acos(-0.5)",
      "acos([0.1, 0.2, 0.3])",
      "acos([[0.1, 0.2], [0.3, 0.4]])"
    ]
  },
  "cosh": {
    "title": "cosh",
    "category": "Math",
    "description": "The \`cosh\` function computes the hyperbolic cosine of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the hyperbolic cosine of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "cosh(0)",
      "cosh(1)",
      "cosh(-0.5)",
      "cosh([0.1, 0.2, 0.3])",
      "cosh([[0.1, 0.2], [0.3, 0.4]])"
    ]
  },
  "acosh": {
    "title": "acosh",
    "category": "Math",
    "description": "The \`acosh\` function computes the inverse hyperbolic cosine of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the inverse hyperbolic cosine of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "acosh(1)",
      "acosh(2)",
      "acosh(100)",
      "acosh(50)",
      "acosh([1, 2, 3])",
      "acosh([[1, 2], [3, 4]])"
    ]
  },
  "tan": {
    "title": "tan",
    "category": "Math",
    "description": "The \`tan\` function computes the tangent of an angle (in radians), working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the tangent of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "tan(0)",
      "tan(1)",
      "tan(PI)",
      "tan(-0.5)",
      "tan([1, 2, 3])",
      "tan([[1, 2], [3, 4]])"
    ]
  },
  "atan": {
    "title": "atan",
    "category": "Math",
    "description": "The \`atan\` function computes the arctangent (inverse tangent) of a \`number\` in radians, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the arctangent of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "atan(0)",
      "atan(1)",
      "atan(-0.5)",
      "atan([0.1, 0.2, 0.3])",
      "atan([[0.1, 0.2], [0.3, 0.4]])"
    ]
  },
  "tanh": {
    "title": "tanh",
    "category": "Math",
    "description": "The \`tanh\` function computes the hyperbolic tangent of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the hyperbolic tangent of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "tanh(0)",
      "tanh(1)",
      "tanh(-0.5)",
      "tanh(50)"
    ]
  },
  "atanh": {
    "title": "atanh",
    "category": "Math",
    "description": "The \`atanh\` function computes the inverse hyperbolic tangent of a \`number\`, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it returns the inverse hyperbolic tangent of each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "atanh(0)",
      "atanh(0.9)",
      "atanh(-0.5)",
      "atanh([0.1, 0.2, 0.3])",
      "atanh([[0.1, 0.2], [0.3, 0.4]])"
    ]
  },
  "to-rad": {
    "title": "to-rad",
    "category": "Math",
    "description": "The \`to-rad\` function converts an angle from degrees to radians, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it converts each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "to-rad(0)",
      "to-rad(90)",
      "to-rad(180)",
      "to-rad(360)",
      "to-rad([0, 90, 180])",
      "to-rad([[0, 90], [180, 360]])"
    ]
  },
  "to-deg": {
    "title": "to-deg",
    "category": "Math",
    "description": "The \`to-deg\` function converts an angle from radians to degrees, working on \`numbers\` and element-wise on \`vectors\` and \`matrices\`. When applied to collections, it converts each element while preserving the original structure.",
    "returns": {
      "type": [
        "number",
        "vector",
        "matrix"
      ]
    },
    "args": {
      "x": {
        "type": [
          "number",
          "vector",
          "matrix"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "to-deg(0)",
      "to-deg(PI)",
      "to-deg(PI / 2)",
      "to-deg(3 * PI / 2)",
      "to-deg([0, PI, PI / 2])",
      "to-deg([[0, PI], [PI / 2, 3 * PI / 2]])"
    ]
  },
  "|>": {
    "title": "|>",
    "category": "Functional",
    "description": "Takes a value $a and a function $b, and returns the result of applying $b to $a.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "\\n1 |> inc |> inc",
      "range(10)\\n  |> map(_, -> $ ^ 2) // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\\n  |> filter(_, odd?)  // [1, 9, 25, 49, 81]\\n  |> reduce(_, +, 0)  // 165\\n  |> sqrt             // 12.84523257866513\\n  |> round(_, 2)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "apply": {
    "title": "apply",
    "category": "Functional",
    "description": "Call supplied function $fun with specified arguments $args.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "function"
      },
      "b": {
        "type": "array"
      },
      "fun": {
        "type": "function"
      },
      "args": {
        "type": "array"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun",
          "args"
        ]
      }
    ],
    "examples": [
      "\\napply(+, [1, 2, 3])",
      "\\napply(\\n  (x, y) -> sqrt(x ^ 2 + y ^ 2),\\n  [3, 4]\\n)",
      "\\n(x, y) -> sqrt(x ^ 2 + y ^ 2) apply [3, 4]"
    ],
    "_isOperator": true
  },
  "identity": {
    "title": "identity",
    "category": "Functional",
    "description": "Returns $x.",
    "returns": {
      "type": "any"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "identity(1)",
      "identity(\\"Albert\\")",
      "identity({ a: 1 })",
      "identity(null)"
    ]
  },
  "comp": {
    "title": "comp",
    "category": "Functional",
    "description": "Takes a variable number of functions and returns a function that is the composition of those.\\n\\n  The returned function takes a variable number of arguments,\\n  applies the rightmost function to the args,\\n  the next function (right-to-left) to the result, etc.",
    "returns": {
      "type": "function"
    },
    "args": {
      "a": {
        "type": "function"
      },
      "b": {
        "type": "function"
      },
      "fns": {
        "type": "function",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fns"
        ]
      }
    ],
    "examples": [
      "\\nlet negative-quotient = comp(-, /);\\nnegative-quotient(9, 3)",
      "\\nlet x = { bar: { foo: 42 } };\\ncomp(\\"foo\\", \\"bar\\")(x)"
    ],
    "_isOperator": true
  },
  "constantly": {
    "title": "constantly",
    "category": "Functional",
    "description": "Returns a function that takes any number of arguments and always returns $x.",
    "returns": {
      "type": "function"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "\\nlet always-true = constantly(true);\\nalways-true(9, 3)"
    ]
  },
  "juxt": {
    "title": "juxt",
    "category": "Functional",
    "description": "Takes one or many function and returns a function that is the juxtaposition of those functions.\\nThe returned function takes a variable number of args,\\nand returns a vector containing the result of applying each function to the args (left-to-right).",
    "returns": {
      "type": "function"
    },
    "args": {
      "a": {
        "type": "function"
      },
      "b": {
        "type": "function"
      },
      "fun": {
        "type": "function"
      },
      "fns": {
        "type": "function",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun"
        ]
      },
      {
        "argumentNames": [
          "fun",
          "fns"
        ]
      }
    ],
    "examples": [
      "\\njuxt(+, *, min, max)(\\n  3,\\n  4,\\n  6,\\n)",
      "\\njuxt(\\"a\\", \\"b\\")(\\n  {\\n    a: 1,\\n    b: 2,\\n    c: 3,\\n    d: 4\\n  }\\n)",
      "\\njuxt(+, *, min, max) apply range(1, 11)"
    ],
    "_isOperator": true
  },
  "complement": {
    "title": "complement",
    "category": "Functional",
    "description": "Takes a function $fun and returns a new function that takes the same arguments as f, has the same effects, if any, and returns the opposite truth value.",
    "returns": {
      "type": "function"
    },
    "args": {
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun"
        ]
      }
    ],
    "examples": [
      "complement(>)(1, 3)",
      "complement(<)(1, 3)",
      "complement(+)(1, 3)",
      "complement(+)(0, 0)"
    ]
  },
  "every-pred": {
    "title": "every-pred",
    "category": "Functional",
    "description": "\\nTakes a number of predicates and returns a function that returns \`true\` if all predicates\\nreturn a truthy value against all of its arguments, else it returns \`false\`.",
    "returns": {
      "type": "function"
    },
    "args": {
      "fun": {
        "type": "function"
      },
      "fns": {
        "type": "function",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun"
        ]
      },
      {
        "argumentNames": [
          "fun",
          "fns"
        ]
      }
    ],
    "examples": [
      "\\nevery-pred(string?, -> count($) > 3)(\\n  \\"Albert\\",\\n  \\"Mojir\\"\\n)",
      "\\n(string? every-pred -> count($) > 3)(\\n  \\"Albert\\",\\n  \\"M\\"\\n)"
    ],
    "noOperatorDocumentation": true
  },
  "some-pred": {
    "title": "some-pred",
    "category": "Functional",
    "description": "Takes a number of \`predicates\` and returns a function that returns \`true\` if at least one of the \`predicates\` return a truthy \`true\` value against at least one of its arguments, else it returns \`false\`.",
    "returns": {
      "type": "function"
    },
    "args": {
      "fun": {
        "type": "function"
      },
      "fns": {
        "type": "function",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun"
        ]
      },
      {
        "argumentNames": [
          "fun",
          "fns"
        ]
      }
    ],
    "examples": [
      "some-pred(string?, -> count($) > 3)(\\"Albert\\", \\"Mojir\\")",
      "some-pred(string?, -> count($) > 3)(\\"a\\", \\"M\\")",
      "some-pred(string?, -> count($) > 3)(\\"a\\", [1, 2, 3])",
      "some-pred(string?, -> count($) > 3)([1, 2, 3], [2])"
    ],
    "noOperatorDocumentation": true
  },
  "fnull": {
    "title": "fnull",
    "category": "Functional",
    "description": "Takes a function $fun, and returns a function that calls $fun, replacing a null argument to the corresponding argument.",
    "returns": {
      "type": "function"
    },
    "args": {
      "a": {
        "type": "function"
      },
      "b": {
        "type": "any"
      },
      "fun": {
        "type": "function"
      },
      "arg": {
        "type": "any"
      },
      "args": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun",
          "arg"
        ]
      },
      {
        "argumentNames": [
          "fun",
          "arg",
          "args"
        ]
      }
    ],
    "examples": [
      "fnull(inc, 0)(1)",
      "fnull(inc, 0)(null)",
      "(inc fnull 0)(null)",
      "fnull(+, 1, 2)(null, 0)",
      "fnull(+, 1, 2)(0, null)",
      "fnull(+, 1, 2)(null, null)",
      "fnull(+, 1, 2)(null, null, 3, 4)"
    ],
    "_isOperator": true
  },
  "doc": {
    "title": "doc",
    "category": "Meta",
    "description": "Returns documentation string of the $fun.",
    "returns": {
      "type": "string"
    },
    "args": {
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun"
        ]
      }
    ],
    "examples": [
      "doc(+)",
      "\\nlet add = (x, y) -> {\\n  \\"\\"\\"\\n  Adds two numbers.\\n  Args:\\n    x: First number.\\n    y: Second number.\\n  Returns:\\n    Sum of x and y.\\n  \\"\\"\\"\\n  x + y;\\n};\\n\\ndoc(add)"
    ]
  },
  "arity": {
    "title": "arity",
    "category": "Meta",
    "description": "Returns arity of the $fun. The arity is an object with the properties: \`min\` and \`max\`. If the function has fixed arity, \`min\` and \`max\` are equal to the number of required parameters. If no restrictions apply, empty object is returned.",
    "returns": {
      "type": "object"
    },
    "args": {
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun"
        ]
      }
    ],
    "examples": [
      "arity(+)",
      "arity(defined?)",
      "\\nlet add = (x, y = 0) -> {\\n  x + y;\\n};\\n\\narity(add)",
      "\\nlet foo = (k, ...x) -> {\\n  k + x;\\n};\\n  arity(foo)"
    ]
  },
  "==": {
    "title": "==",
    "category": "Misc",
    "description": "Returns \`true\` if all \`values\` are structaul equal to each other, otherwise result is \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "x": {
        "type": "any"
      },
      "ys": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      },
      {
        "argumentNames": [
          "x",
          "ys"
        ]
      }
    ],
    "examples": [
      "1 == 1",
      "[1, 2] == [1, 2]",
      "\\n{\\n a: 1,\\n b: 2,\\n} == {\\n b: 2,\\n a: 1,\\n}",
      "==(1, 1)",
      "==(1.01, 1)",
      "==(\\"1\\", 1)",
      "==(\\"2\\", \\"2\\", \\"2\\", \\"2\\")",
      "==(2, 2, 1, 2)",
      "==([1, 2], [1, 2])",
      "==({ a: 1, b: 2 }, { b: 2, a: 1 })"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "": {
    "title": "",
    "category": "Misc",
    "description": "Returns \`true\` if all \`values\` are not equal to each other, otherwise result is \`false\`. \`( a b c)\` is same as \`(! (== a b c))\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "x": {
        "type": "any"
      },
      "ys": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      },
      {
        "argumentNames": [
          "x",
          "ys"
        ]
      }
    ],
    "examples": [
      "1  2",
      "3  3",
      "(3)",
      "(3, 3, 2)",
      "(\\"3\\", \\"2\\", \\"1\\", \\"0\\",)",
      "(0, -0)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "identical?": {
    "title": "identical?",
    "category": "Misc",
    "description": "Returns true if $a and $b are referential equal.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "identical?({ a: 10, b: 20 }, { b: 20, a: 10 })",
      "identical?([1, true, null], [1, true, null])",
      "identical?(0.3, 0.1 + 0.2)"
    ],
    "_isOperator": true
  },
  ">": {
    "title": ">",
    "category": "Misc",
    "description": "Returns \`true\` if $x and $ys are in decreasing order, \`false\` otherwise.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": [
          "number",
          "string"
        ]
      },
      "b": {
        "type": [
          "number",
          "string"
        ]
      },
      "x": {
        "type": [
          "number",
          "string"
        ]
      },
      "ys": {
        "type": [
          "number",
          "string"
        ],
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      },
      {
        "argumentNames": [
          "x",
          "ys"
        ]
      }
    ],
    "examples": [
      ">(1, 0)",
      ">(1.01, 1)",
      ">(1, 1)",
      ">(4, 3, 2, 1)",
      ">(3, 2, 2, 1)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "<": {
    "title": "<",
    "category": "Misc",
    "description": "Returns \`true\` if $x and $ys are in increasing order, \`false\` otherwise.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": [
          "number",
          "string"
        ]
      },
      "b": {
        "type": [
          "number",
          "string"
        ]
      },
      "x": {
        "type": [
          "number",
          "string"
        ]
      },
      "ys": {
        "type": [
          "number",
          "string"
        ],
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      },
      {
        "argumentNames": [
          "x",
          "ys"
        ]
      }
    ],
    "examples": [
      "<(0, 1)",
      "<(1, 1.01)",
      "<(1, 1)",
      "<(1, 2, 2, 3)",
      "<(\\"a\\", \\"b\\")"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  ">=": {
    "title": ">=",
    "category": "Misc",
    "description": "Returns \`true\` if $x and $ys are in non increasing order, \`false\` otherwise.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": [
          "number",
          "string"
        ]
      },
      "b": {
        "type": [
          "number",
          "string"
        ]
      },
      "x": {
        "type": [
          "number",
          "string"
        ]
      },
      "ys": {
        "type": [
          "number",
          "string"
        ],
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      },
      {
        "argumentNames": [
          "x",
          "ys"
        ]
      }
    ],
    "examples": [
      "1 >= 1",
      "0 >= 1",
      ">=(1, 0)",
      ">=(1.01, 1)",
      ">=(1, 1)",
      ">=(4, 3, 2, 1)",
      ">=(3, 2, 2, 1)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "<=": {
    "title": "<=",
    "category": "Misc",
    "description": "Returns \`true\` if $x and $ys are in non decreasing order, \`false\` otherwise.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": [
          "number",
          "string"
        ]
      },
      "b": {
        "type": [
          "number",
          "string"
        ]
      },
      "x": {
        "type": [
          "number",
          "string"
        ]
      },
      "ys": {
        "type": [
          "number",
          "string"
        ],
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      },
      {
        "argumentNames": [
          "x",
          "ys"
        ]
      }
    ],
    "examples": [
      "1 <= 1",
      "<=(0, 1)",
      "<=(1, 1.01)",
      "<=(1, 1)",
      "<=(1, 2, 3, 4)",
      "<=(1, 2, 2, 3)"
    ],
    "_isOperator": true,
    "_prefereOperator": true
  },
  "!": {
    "title": "!",
    "category": "Misc",
    "description": "Computes logical negation. Note that any other $x than \`false\`, \`0\`, \`null\` and \`''\` is truthy.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "!(3)",
      "!(true)",
      "!(\\"A string\\")",
      "!(0)",
      "!(false)",
      "!(null)",
      "!(\\"\\")"
    ]
  },
  "epoch->iso-date": {
    "title": "epoch->iso-date",
    "category": "Misc",
    "description": "Returns IOS date time string from \`ms\` (milliseconds elapsed since the UNIX epoch).",
    "returns": {
      "type": "string"
    },
    "args": {
      "ms": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "ms"
        ]
      }
    ],
    "examples": [
      "epoch->iso-date(1649756230899)",
      "epoch->iso-date(0)"
    ]
  },
  "iso-date->epoch": {
    "title": "iso-date->epoch",
    "category": "Misc",
    "description": "Returns milliseconds elapsed since the UNIX epoch to \`iso\`.",
    "returns": {
      "type": "number"
    },
    "args": {
      "iso": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "iso"
        ]
      }
    ],
    "examples": [
      "iso-date->epoch(\\"2022-04-12T09:37:10.899Z\\")",
      "iso-date->epoch(\\"1980-01-01\\")"
    ]
  },
  "write!": {
    "title": "write!",
    "category": "Misc",
    "description": "It logs the $values and then returns the last argument. If called with no arguments \`null\` is returned.",
    "returns": {
      "type": "any"
    },
    "args": {
      "values": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "values"
        ]
      }
    ],
    "examples": [
      "write!(\\"A string\\")",
      "write!(100, \\"items\\")",
      "write!(object(\\"a\\", 10))",
      "write!([\\"a\\", \\"b\\", \\"c\\"])",
      "write!(#\\"^start\\")",
      "write!(null, true, false)"
    ],
    "noOperatorDocumentation": true
  },
  "boolean": {
    "title": "boolean",
    "category": "Misc",
    "description": "Coerces $x to boolean.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "boolean(0)",
      "boolean(1)",
      "boolean(null)",
      "boolean(\\"Albert\\")"
    ]
  },
  "compare": {
    "title": "compare",
    "category": "Misc",
    "description": "Compares two values. Returns \`-1\` if $a < $b, \`1\` if $a > $b and \`0\` if $a and $b have the same sort order.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": [
          "number",
          "string"
        ]
      },
      "b": {
        "type": [
          "number",
          "string"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "compare(0, 1)",
      "compare(0, 0)",
      "compare(1, 0)",
      "compare(\\"Albert\\", \\"Mojir\\")"
    ],
    "_isOperator": true
  },
  "json-parse": {
    "title": "json-parse",
    "category": "Misc",
    "description": "Returns \`JSON.parse(\`$x\`)\`.",
    "returns": {
      "type": "any"
    },
    "args": {
      "x": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "json-parse(\\"[1, 2, 3]\\")"
    ]
  },
  "json-stringify": {
    "title": "json-stringify",
    "category": "Misc",
    "description": "Returns \`JSON.stringify(\`$x\`)\`. If second argument is provided, returns \`JSON.stringify(\`$x\`, null, \`$indent\`)\`.",
    "returns": {
      "type": "string"
    },
    "args": {
      "x": {
        "type": "any"
      },
      "indent": {
        "type": "integer",
        "description": "Number of spaces to use for indentation."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      },
      {
        "argumentNames": [
          "x",
          "indent"
        ]
      }
    ],
    "examples": [
      "json-stringify([1, 2, 3])",
      "json-stringify({ a: { b: 10 }}, 2)"
    ],
    "noOperatorDocumentation": true
  },
  "import": {
    "title": "import",
    "category": "Misc",
    "description": "Imports namespace functions. Use a namespace name (e.g., \\"Vector\\") to import all functions as an object, or a fully qualified name (e.g., \\"Vector.mean\\") to import a single function directly.",
    "returns": {
      "type": "any"
    },
    "args": {
      "path": {
        "type": "string",
        "description": "The namespace path to import. Can be a namespace name (e.g., \\"Vector\\", \\"Grid\\") or a fully qualified function name (e.g., \\"Vector.mean\\", \\"Grid.row\\")."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "path"
        ]
      }
    ],
    "examples": [
      "let v = import(\\"Vector\\"); v.mean([1, 2, 3, 4])",
      "let sum = import(\\"Vector.sum\\"); sum([1, 2, 3])",
      "let g = import(\\"Grid\\"); g.row([[1, 2], [3, 4]], 0)"
    ]
  },
  "keys": {
    "title": "keys",
    "category": "Object",
    "description": "Returns array of all keys in $obj.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "obj": {
        "type": "object"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "obj"
        ]
      }
    ],
    "examples": [
      "keys({})",
      "keys({ x: 10, y: true, z: \\"A string\\" })",
      "keys(object(\\"x\\", 10, \\"y\\", true, \\"z\\", \\"A string\\"))"
    ]
  },
  "vals": {
    "title": "vals",
    "category": "Object",
    "description": "Returns array of all values in $obj.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "obj": {
        "type": "object"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "obj"
        ]
      }
    ],
    "examples": [
      "vals({})",
      "vals({ x: 10, y: true, z: \\"A string\\" })",
      "vals(object(\\"x\\", 10, \\"y\\", true, \\"z\\", \\"A string\\"))"
    ]
  },
  "entries": {
    "title": "entries",
    "category": "Object",
    "description": "Returns nested array of all key - value pairs in $obj.",
    "returns": {
      "type": "array"
    },
    "args": {
      "obj": {
        "type": "object"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "obj"
        ]
      }
    ],
    "examples": [
      "entries({})",
      "entries({ x: 10, y: true, z: \\"A string\\" })",
      "entries(object(\\"x\\", 10, \\"y\\", true, \\"z\\", \\"A string\\"))"
    ]
  },
  "find": {
    "title": "find",
    "category": "Object",
    "description": "Returns entry (key-value pair) for $key, or \`null\` if $key not present in $obj.",
    "returns": {
      "type": [
        "array",
        "null"
      ]
    },
    "args": {
      "a": {
        "type": "object"
      },
      "b": {
        "type": "string"
      },
      "obj": {
        "type": "object"
      },
      "key": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "obj",
          "key"
        ]
      }
    ],
    "examples": [
      "{ a: 1, \\"b\\": 2 } find \\"a\\"",
      "find(object(\\"a\\", 1, \\"b\\", 2), \\"b\\")",
      "find(object(\\"a\\", 1, \\"b\\", 2), \\"c\\")"
    ],
    "_isOperator": true
  },
  "dissoc": {
    "title": "dissoc",
    "category": "Object",
    "description": "Return shallow copy of $obj with $key deleted.",
    "returns": {
      "type": "object"
    },
    "args": {
      "a": {
        "type": "object"
      },
      "b": {
        "type": "string"
      },
      "obj": {
        "type": "object"
      },
      "key": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "obj",
          "key"
        ]
      }
    ],
    "examples": [
      "{ x: 10, y: 20 } dissoc \\"y\\"",
      "dissoc({ x: 10, y: 20 }, \\"x\\")",
      "dissoc({ x: 10 }, \\"y\\")",
      "\\nlet o = { a: 5 };\\ndissoc(o, \\"a\\");\\no"
    ],
    "_isOperator": true
  },
  "merge": {
    "title": "merge",
    "category": "Object",
    "description": "Returns a new object created by merging together all arguments.\\n\\nIf two keys appears in more than one object the value from the last object is used.\\nIf no arguments are provided \`null\` is returned.",
    "returns": {
      "type": "object"
    },
    "args": {
      "a": {
        "type": "object"
      },
      "b": {
        "type": "object"
      },
      "objs": {
        "type": "object",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "objs"
        ]
      }
    ],
    "examples": [
      "{ x: 10 } merge { y: 20 }",
      "merge(object(\\"x\\", 10), object(\\"y\\", 20))",
      "merge(object(\\"x\\", 10), object(\\"x\\", 15, \\"y\\", 20))"
    ],
    "_isOperator": true
  },
  "merge-with": {
    "title": "merge-with",
    "category": "Object",
    "description": "\\nReturns a new object created by merging together all arguments.\\nIf two keys appears in more than one object $fun is used to calculate the new value.\\n\\nIf no arguments are provided \`null\` is returned.",
    "returns": {
      "type": "object"
    },
    "args": {
      "objs": {
        "type": "object",
        "rest": true
      },
      "fun": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "objs",
          "fun"
        ]
      }
    ],
    "examples": [
      "merge-with(object(\\"x\\", 10), object(\\"y\\", 20), +)",
      "merge-with(object(\\"x\\", 10), object(\\"x\\", 15, \\"y\\", 20), +)",
      "merge-with({ x: 10 }, { x: 20 }, { x: 30 }, { x: 40 }, -)"
    ],
    "noOperatorDocumentation": true
  },
  "zipmap": {
    "title": "zipmap",
    "category": "Object",
    "description": "Returns a new object created by mapping $a to $b.",
    "returns": {
      "type": "object"
    },
    "args": {
      "a": {
        "type": "array"
      },
      "b": {
        "type": "array"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "[\\"a\\", \\"b\\", \\"c\\"] zipmap [1, 2, 3]",
      "zipmap([\\"a\\", \\"b\\", \\"c\\"], [10, null, [1, 2, 3]])",
      "zipmap([\\"a\\", \\"b\\", \\"c\\"], [1])",
      "zipmap([], [10, null, [1, 2, 3]])"
    ],
    "_isOperator": true
  },
  "select-keys": {
    "title": "select-keys",
    "category": "Object",
    "description": "Returns an object containing only those entries in $a whose key is in $b.",
    "returns": {
      "type": "object"
    },
    "args": {
      "a": {
        "type": "object"
      },
      "b": {
        "type": "array"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "{ a: 1, b: 2, c: 3 } select-keys [\\"a\\", \\"b\\"]",
      "select-keys({ a: 1, b: 2, c: 3 }, [\\"a\\", \\"b\\"])",
      "select-keys({ a: 1 }, [\\"a\\", \\"b\\"])"
    ],
    "_isOperator": true
  },
  "function?": {
    "title": "function?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is a function, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "function?(+)",
      "function?(/)",
      "function?((x, y) -> x + y)",
      "function?(false)",
      "function?(\\"false\\")",
      "function?([1, 2, 3])"
    ]
  },
  "string?": {
    "title": "string?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is a string, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "string?(\\"\\")",
      "string?(\\"A string\\")",
      "string?(true ? \\"A string\\" : false)",
      "string?(false)",
      "string?([1, 2, 3])",
      "string?(100)"
    ]
  },
  "number?": {
    "title": "number?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is a number, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "number?(0)",
      "number?(2)",
      "number?(-0.12)",
      "number?(false)",
      "number?([1, 2, 3])",
      "number?(\\"A string\\")"
    ]
  },
  "integer?": {
    "title": "integer?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is an integer, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "integer?(0)",
      "integer?(-12)",
      "integer?(42)",
      "integer?(10.1)",
      "integer?((x, y) -> x + y)",
      "integer?(false)",
      "integer?(\\"false\\")",
      "integer?([1, 2, 3])"
    ]
  },
  "boolean?": {
    "title": "boolean?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is a \`boolean\`, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "boolean?(true)",
      "boolean?(false)",
      "boolean?([1, 2, 3])",
      "boolean?(0)",
      "boolean?(\\"A string\\")"
    ]
  },
  "null?": {
    "title": "null?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is \`null\`, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "null?(null)",
      "null?(false)",
      "null?([1, 2, 3])",
      "null?(0)",
      "null?(\\"A string\\")"
    ]
  },
  "zero?": {
    "title": "zero?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is \`0\`, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "zero?(0)",
      "zero?(-0.0)",
      "zero?(1)",
      "zero?(0.1)"
    ]
  },
  "pos?": {
    "title": "pos?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is greater than \`0\`, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "pos?(0)",
      "pos?(-0.0)",
      "pos?(1)",
      "pos?(-0.1)"
    ]
  },
  "neg?": {
    "title": "neg?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is less than \`0\`, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "neg?(0)",
      "neg?(-0.0)",
      "neg?(1)",
      "neg?(-0.1)"
    ]
  },
  "even?": {
    "title": "even?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is even, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "even?(0)",
      "even?(-0.0)",
      "even?(-1)",
      "even?(2.1)"
    ]
  },
  "odd?": {
    "title": "odd?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is odd, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "odd?(1.0)",
      "odd?(1.001)",
      "odd?(-1)",
      "odd?(2.1)"
    ]
  },
  "array?": {
    "title": "array?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is an array, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "array?([])",
      "array?([1, 2, 3])",
      "array?(object(\\"a\\", 10))",
      "array?(42)",
      "array?(10.1)",
      "array?((x, y) -> x + y)"
    ]
  },
  "coll?": {
    "title": "coll?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is a Coll i.e. an array, an object or a string, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "coll?([])",
      "coll?([1, 2, 3])",
      "coll?(object(\\"a\\", 10))",
      "coll?(\\"Albert\\")",
      "coll?(42)",
      "coll?(10.1)",
      "coll?((x, y) -> x + y)"
    ]
  },
  "seq?": {
    "title": "seq?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is a Seq i.e. an array or a string, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "seq?([])",
      "seq?([1, 2, 3])",
      "seq?(object(\\"a\\", 10))",
      "seq?(\\"Albert\\")",
      "seq?(42)",
      "seq?(10.1)",
      "seq?((x, y) -> x + y)"
    ]
  },
  "object?": {
    "title": "object?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is an object, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "object?(object(\\"a\\", 10))",
      "object?(42)",
      "object?(10.1)",
      "object?((x, y) -> x + y)",
      "object?(#\\"^start\\")",
      "object?(\\"false\\")",
      "object?([1, 2, 3])"
    ]
  },
  "regexp?": {
    "title": "regexp?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is a regexp, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "regexp?(regexp(\\"^start\\"))",
      "regexp?(#\\"^start\\")",
      "regexp?(-12)",
      "regexp?({})",
      "regexp?(10.1)",
      "regexp?((x, y) -> x + y)",
      "regexp?(false)",
      "regexp?(\\"false\\")",
      "regexp?([1, 2, 3])"
    ]
  },
  "finite?": {
    "title": "finite?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is finite, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "finite?(1.0)",
      "finite?(1 / 0)",
      "finite?(-1 / 0)"
    ]
  },
  "positive-infinity?": {
    "title": "positive-infinity?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x equals positive infinity, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "positive-infinity?(1.0)",
      "positive-infinity?(1 / 0)",
      "positive-infinity?(-1 / 0)"
    ]
  },
  "negative-infinity?": {
    "title": "negative-infinity?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x equals negative infinity, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "negative-infinity?(1.0)",
      "negative-infinity?(1 / 0)",
      "negative-infinity?(-1 / 0)"
    ]
  },
  "true?": {
    "title": "true?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is \`true\`, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "true?(false)",
      "true?(true)",
      "true?(1)",
      "true?(0)"
    ]
  },
  "false?": {
    "title": "false?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is \`true\`, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "false?(false)",
      "false?(true)",
      "false?(1)",
      "false?(0)"
    ]
  },
  "empty?": {
    "title": "empty?",
    "category": "Predicate",
    "description": "Returns \`true\` if $x is empty or \`null\`, otherwise \`false\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": [
          "collection",
          "string",
          "null"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "empty?([])",
      "empty?([1, 2, 3])",
      "empty?({})",
      "empty?({ a: 2 })",
      "empty?(\\"\\")",
      "empty?(\\"Albert\\")",
      "empty?(null)"
    ]
  },
  "not-empty?": {
    "title": "not-empty?",
    "category": "Predicate",
    "description": "Returns \`false\` if $x is empty or \`null\`, otherwise \`true\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "x": {
        "type": [
          "collection",
          "string",
          "null"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "x"
        ]
      }
    ],
    "examples": [
      "not-empty?([])",
      "not-empty?([1, 2, 3])",
      "not-empty?({})",
      "not-empty?({ a: 2 })",
      "not-empty?(\\"\\")",
      "not-empty?(\\"Albert\\")",
      "not-empty?(null)"
    ]
  },
  "vector?": {
    "title": "vector?",
    "category": "Predicate",
    "description": "Checks if a value is a \`vector\`. A \`vector\` is an array of \`numbers\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "value": {
        "type": "any",
        "description": "The value to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value"
        ]
      }
    ],
    "examples": [
      "vector?(1)",
      "vector?([1, 2, 3])",
      "vector?([1, 2, \\"3\\"])"
    ]
  },
  "matrix?": {
    "title": "matrix?",
    "category": "Predicate",
    "description": "Checks if a value is a \`matrix\`. A \`matrix\` is an array of arrays of \`numbers\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "value": {
        "type": "any",
        "description": "The value to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value"
        ]
      }
    ],
    "examples": [
      "matrix?(1)",
      "matrix?([1, 2, 3])",
      "matrix?([[1, 2], [3, 4]])",
      "matrix?([[1, 2], [3, \\"4\\"]])",
      "matrix?([[1, 2], [3]])"
    ]
  },
  "grid?": {
    "title": "grid?",
    "category": "Predicate",
    "description": "Checks if a \`value\` is a \`grid\`. A \`grid\` is an \`array\` of \`arrays\` where all inner \`arrays\` have the same length.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "value": {
        "type": "any",
        "description": "The value to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value"
        ]
      }
    ],
    "examples": [
      "grid?(\\"1\\")",
      "grid?([\\"1\\", 2, 3])",
      "grid?([[\\"1\\", 2], [3, 4]])",
      "grid?([[\\"1\\", 2], [3, \\"4\\"]])",
      "grid?([[\\"1\\", 2], [3]])"
    ]
  },
  "regexp": {
    "title": "regexp",
    "category": "Regular expression",
    "description": "Creates a RegExp from $pattern and $flags.",
    "returns": {
      "type": "regexp"
    },
    "args": {
      "pattern": {
        "type": "string"
      },
      "flags": {
        "type": "string",
        "description": "Optional flags for the regular expression. Possible values are the same as Javascript RegExp takes."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "pattern"
        ]
      },
      {
        "argumentNames": [
          "pattern",
          "flags"
        ]
      }
    ],
    "examples": [
      "regexp(\\"^\\\\s*(.*)$\\")",
      "#\\"^\\\\s*(.*)$\\"",
      "regexp(\\"albert\\", \\"ig\\")",
      "#\\"albert\\"ig"
    ],
    "noOperatorDocumentation": true
  },
  "match": {
    "title": "match",
    "category": "Regular expression",
    "description": "Matches $b against regular expression $a.\\nIf $b is a string and matches the regular expression, a \`match\`-array is returned, otherwise \`null\` is returned.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "a": {
        "type": "regexp"
      },
      "b": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "match(\\"  A string\\", regexp(\\"^\\\\\\\\s*(.*)$\\"))",
      "match(\\"  A string\\", #\\"^\\\\s*(.*)$\\")",
      "match(\\"My name is Albert\\", #\\"albert\\"i)",
      "match(\\"My name is Ben\\", #\\"albert\\"i)",
      "match(null, #\\"albert\\"i)",
      "match(1, #\\"albert\\"i)",
      "match({}, #\\"albert\\"i)"
    ],
    "_isOperator": true
  },
  "replace": {
    "title": "replace",
    "category": "Regular expression",
    "description": "Returns a new string with first match of regular expression $b replaced by $x.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "a": {
        "type": "string"
      },
      "b": {
        "type": [
          "regexp",
          "string"
        ]
      },
      "x": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b",
          "x"
        ]
      }
    ],
    "examples": [
      "replace(\\"Duck duck\\", \\"u\\", \\"i\\")",
      "replace(\\"Duck duck\\", #\\"u\\", \\"i\\")",
      "replace(\\"abcABC\\", regexp(\\"a\\", \\"i\\"), \\"-\\")",
      "replace(\\"abcABC\\", regexp(\\"a\\", \\"gi\\"), \\"-\\")",
      "replace(\\"abcABC\\", #\\"a\\"i, \\"-\\")",
      "replace(\\"abcABC\\", #\\"a\\"gi, \\"-\\")"
    ]
  },
  "replace-all": {
    "title": "replace-all",
    "category": "Regular expression",
    "description": "Returns a new string with all matches of regular expression $b replaced by $x.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "a": {
        "type": "string"
      },
      "b": {
        "type": [
          "regexp",
          "string"
        ]
      },
      "x": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b",
          "x"
        ]
      }
    ],
    "examples": [
      "replace-all(\\"Duck duck\\", \\"u\\", \\"i\\")",
      "replace-all(\\"Duck duck\\", regexp(\\"u\\"), \\"i\\")",
      "replace-all(\\"abcABC\\", regexp(\\"a\\", \\"i\\"), \\"-\\")",
      "replace-all(\\"abcABC\\", regexp(\\"a\\", \\"gi\\"), \\"-\\")",
      "replace-all(\\"abcABC\\", #\\"a\\"i, \\"-\\")",
      "replace-all(\\"abcABC\\", #\\"a\\"gi, \\"-\\")"
    ]
  },
  "string-repeat": {
    "title": "string-repeat",
    "category": "String",
    "description": "Repeates $s $n times.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "string"
      },
      "b": {
        "type": "integer"
      },
      "s": {
        "type": "string"
      },
      "n": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s",
          "n"
        ]
      }
    ],
    "examples": [
      "\\"*\\" string-repeat 10",
      "string-repeat(\\"*\\", 10)",
      "string-repeat(\\"***\\", 0)"
    ],
    "_isOperator": true
  },
  "str": {
    "title": "str",
    "category": "String",
    "description": "Concatenats $values into one string. If \`value\` equals \`null\` empty string is returned.",
    "returns": {
      "type": "string"
    },
    "args": {
      "values": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "values"
        ]
      }
    ],
    "examples": [
      "str(\\"A string\\", \\", and another string\\", \\" ...and more\\")",
      "str(\\"Just one string\\")",
      "str()",
      "str(0, false, true, null, #\\"^kalle\\", [1, 2, 3], {a: \\"a\\"})"
    ],
    "noOperatorDocumentation": true
  },
  "number": {
    "title": "number",
    "category": "String",
    "description": "Parses $s to a number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "number(\\"10\\")",
      "number(\\"010\\")",
      "number(\\"-1.01\\")"
    ]
  },
  "from-char-code": {
    "title": "from-char-code",
    "category": "String",
    "description": "Return character for code point $code.",
    "returns": {
      "type": "string"
    },
    "args": {
      "code": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "code"
        ]
      }
    ],
    "examples": [
      "from-char-code(65)",
      "from-char-code(0)"
    ]
  },
  "to-char-code": {
    "title": "to-char-code",
    "category": "String",
    "description": "Return code point for first character in $c.",
    "returns": {
      "type": "number"
    },
    "args": {
      "c": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "c"
        ]
      }
    ],
    "examples": [
      "to-char-code(\\"A\\")",
      "to-char-code(\\"Albert\\")"
    ]
  },
  "lower-case": {
    "title": "lower-case",
    "category": "String",
    "description": "Returns $s converted to lower case.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "lower-case(\\"Albert\\")",
      "lower-case(\\"\\")"
    ]
  },
  "upper-case": {
    "title": "upper-case",
    "category": "String",
    "description": "Returns $s converted to upper case.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "upper-case(\\"Albert\\")",
      "upper-case(\\"\\")"
    ]
  },
  "trim": {
    "title": "trim",
    "category": "String",
    "description": "Returns a new string with leading and trailing whitespaces removed.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "trim(\\"  Albert  \\")",
      "trim(\\"   \\")",
      "trim(\\"\\")"
    ]
  },
  "trim-left": {
    "title": "trim-left",
    "category": "String",
    "description": "Returns a new string with leading whitespaces removed.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "trim-left(\\"  Albert  \\")",
      "trim-left(\\"   \\")",
      "trim-left(\\"\\")"
    ]
  },
  "trim-right": {
    "title": "trim-right",
    "category": "String",
    "description": "Returns a new string with trailing whitespaces removed.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "trim-right(\\"  Albert  \\")",
      "trim-right(\\"   \\")",
      "trim-right(\\"\\")"
    ]
  },
  "join": {
    "title": "join",
    "category": "String",
    "description": "Returns a new string by concatenating all of the elements in $arr, separated by $delimiter.",
    "returns": {
      "type": "string"
    },
    "args": {
      "a": {
        "type": "array"
      },
      "b": {
        "type": "string"
      },
      "arr": {
        "type": "array"
      },
      "delimiter": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "arr",
          "delimiter"
        ]
      }
    ],
    "examples": [
      "map([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], str) join \\", \\"",
      "([0, 1, 2, 3, 4, 5, 6, 7, 8, 9] map str) join \\", \\"",
      "join([\\"Albert\\", 10], \\", \\")",
      "join([\\"Albert\\", \\"Mojir\\"], \\" \\")",
      "join(map([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], str), \\", \\")"
    ],
    "_isOperator": true
  },
  "split": {
    "title": "split",
    "category": "String",
    "description": "Divides $s into an array of substrings. The division is done by searching for \`delimiter\`. If \`limit\` as provided, at most \`limit\` number of substrings are returned.",
    "returns": {
      "type": "string"
    },
    "args": {
      "a": {
        "type": "string"
      },
      "b": {
        "type": "string"
      },
      "s": {
        "type": "string"
      },
      "delimiter": {
        "type": "string"
      },
      "limit": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s",
          "delimiter"
        ]
      },
      {
        "argumentNames": [
          "s",
          "delimiter",
          "limit"
        ]
      }
    ],
    "examples": [
      "\\"Albert Mojir\\" split \\" \\"",
      "split(\\"Albert Mojir\\", \\" \\")",
      "split(\\"abcdefghijklmnopqrstuvw\\", #\\"[aoueiy]\\")",
      "split(\\"0123456789\\", \\"\\")",
      "split(\\"0123456789\\", \\"\\", 5) map number"
    ],
    "_isOperator": true
  },
  "split-lines": {
    "title": "split-lines",
    "category": "String",
    "description": "Divides $s into an array of substrings, each representing a line.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "split-lines(\\"Albert\\nMojir\\n\\")",
      "split-lines(\\"Albert\\n\\nMojir\\")",
      "split-lines(\\"Albert\\nMojir\\n\\n\\")",
      "split-lines(\\"\\")"
    ]
  },
  "pad-left": {
    "title": "pad-left",
    "category": "String",
    "description": "Pads from the start of $s with \`padString\` (multiple times, if needed) until the resulting string reaches the given $length.",
    "returns": {
      "type": "string"
    },
    "args": {
      "a": {
        "type": "string"
      },
      "b": {
        "type": "integer"
      },
      "s": {
        "type": "string"
      },
      "length": {
        "type": "integer"
      },
      "padString": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s",
          "length"
        ]
      },
      {
        "argumentNames": [
          "s",
          "length",
          "padString"
        ]
      }
    ],
    "examples": [
      "\\"Albert\\" pad-left 20",
      "pad-left(\\"Albert\\", 20)",
      "pad-left(\\"Albert\\", 20, \\"-*-\\")",
      "pad-left(\\"Albert\\", 5)",
      "pad-left(\\"Albert\\", -1)"
    ],
    "_isOperator": true
  },
  "pad-right": {
    "title": "pad-right",
    "category": "String",
    "description": "Pads from the start of $s with \`padString\` (multiple times, if needed) until the resulting string reaches the given \`length\`.",
    "returns": {
      "type": "string"
    },
    "args": {
      "a": {
        "type": "string"
      },
      "b": {
        "type": "integer"
      },
      "s": {
        "type": "string"
      },
      "length": {
        "type": "integer"
      },
      "padString": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s",
          "length"
        ]
      },
      {
        "argumentNames": [
          "s",
          "length",
          "padString"
        ]
      }
    ],
    "examples": [
      "\\"Albert\\" pad-right 20",
      "pad-right(\\"Albert\\", 20)",
      "pad-right(\\"Albert\\", 20, \\"-*-\\")",
      "pad-right(\\"Albert\\", 5)",
      "pad-right(\\"Albert\\", -1)"
    ],
    "_isOperator": true
  },
  "template": {
    "title": "template",
    "category": "String",
    "description": "Applies placeholders to a string. Support for basic pluralization - see examples. If pluralization is used, first placeholder must be a number.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      },
      "params": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s",
          "params"
        ]
      }
    ],
    "examples": [
      "template(\\"Hi, $1 and $2\\", \\"Carl\\", \\"Larry\\")",
      "template(\\"Hi $1, $2, $3, $4, $5, $6, $7, $8 and $9\\", \\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\", \\"G\\", \\"H\\", \\"I\\")",
      "template(\\"$1 book||||$1 books\\", 0)",
      "template(\\"$1 book||||$1 books\\", 1)",
      "template(\\"$1 book||||$1 books\\", 2)",
      "template(\\"No book||||$1 book||||$1 books\\", 0)",
      "template(\\"No book||||$1 book||||$1 books\\", 1)",
      "template(\\"No book||||$1 book||||$1 books\\", 10)",
      "template(\\"No book||||One book||||Two books||||Three books||||$1 books\\", 0)",
      "template(\\"No book||||One book||||Two books||||Three books||||$1 books\\", 1)",
      "template(\\"No book||||One book||||Two books||||Three books||||$1 books\\", 2)",
      "template(\\"No book||||One book||||Two books||||Three books||||$1 books\\", 3)",
      "template(\\"No book||||One book||||Two books||||Three books||||$1 books\\", 4)"
    ],
    "noOperatorDocumentation": true
  },
  "encode-base64": {
    "title": "encode-base64",
    "category": "String",
    "description": "Returns a Base64 encoded string from $s.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "encode-base64(\\"Albert\\")"
    ]
  },
  "decode-base64": {
    "title": "decode-base64",
    "category": "String",
    "description": "Returns a Base64 decoded string from $base64string.",
    "returns": {
      "type": "string"
    },
    "args": {
      "base64string": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "base64string"
        ]
      }
    ],
    "examples": [
      "decode-base64(\\"QWxiZXJ0IPCfkLs=\\")"
    ]
  },
  "encode-uri-component": {
    "title": "encode-uri-component",
    "category": "String",
    "description": "Returns an escaped \`URI\` string.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "encode-uri-component(\\"Hi everyone!?\\")"
    ]
  },
  "decode-uri-component": {
    "title": "decode-uri-component",
    "category": "String",
    "description": "Returns an un-escaped \`URI\` string.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "decode-uri-component(\\"Hi%20everyone!%3F%20%F0%9F%91%8D\\")"
    ]
  },
  "capitalize": {
    "title": "capitalize",
    "category": "String",
    "description": "Returns $s with the first character converted to uppercase and the rest to lowercase.",
    "returns": {
      "type": "string"
    },
    "args": {
      "s": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "capitalize(\\"albert\\")",
      "capitalize(\\"ALBERT\\")",
      "capitalize(\\"aLBERT\\")",
      "capitalize(\\"\\")"
    ]
  },
  "blank?": {
    "title": "blank?",
    "category": "String",
    "description": "Returns true if $s is null or only contains whitespace characters.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "s": {
        "type": [
          "string",
          "null"
        ]
      }
    },
    "variants": [
      {
        "argumentNames": [
          "s"
        ]
      }
    ],
    "examples": [
      "blank?(\\"\\")",
      "blank?(null)",
      "blank?(\\"\\n\\")",
      "blank?(\\" \\")",
      "blank?(\\".\\")"
    ]
  },
  "&&": {
    "title": "&&",
    "category": "Special expression",
    "description": "\\nComputes logical \`and\`. Evaluation of expressions starts from left.\\nAs soon as an \`expression\` evaluates to a falsy value, the result is returned.\\n\\nIf all expressions evaluate to truthy values, the value of the last expression is returned.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "c": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "c"
        ]
      }
    ],
    "examples": [
      "true && 1",
      "&&(1, 1)",
      "&&(3 > 2, \\"string\\")",
      "&&(3 < 2, \\"string\\")",
      "&&(true, true, true, true)",
      "&&(true, true, 0, true)"
    ],
    "_isOperator": true
  },
  "||": {
    "title": "||",
    "category": "Special expression",
    "description": "\\n  Computes logical \`or\`. Evaluation of expressions evaluation starts from left.\\n  As soon as a \`expression\` evaluates to a truthy value, the result is returned.\\n\\n  If all expressions evaluate to falsy values, the value of the last expression is returned.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "c": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "c"
        ]
      }
    ],
    "examples": [
      "false || 1",
      "||(1, 1)",
      "||(3 > 2, \\"string\\")",
      "||(3 < 2, \\"string\\")",
      "||(false, false, false, true)",
      "||(1, 2, 3, 4)"
    ],
    "_isOperator": true
  },
  "array": {
    "title": "array",
    "category": "Special expression",
    "description": "Makes new array from $values.",
    "returns": {
      "type": "any",
      "array": true
    },
    "args": {
      "values": {
        "type": "any",
        "rest": true
      }
    },
    "variants": [
      {
        "argumentNames": [
          "values"
        ]
      }
    ],
    "examples": [
      "array(1, 2, 3)",
      "array(array(null, false, true))",
      "[]",
      "[1, 2, 3]",
      "[1, 2, ...[3, 4, 5], 6]",
      "[[null, false, true]]",
      "[1, 2, 3][1]"
    ],
    "noOperatorDocumentation": true,
    "_isOperator": true
  },
  "cond": {
    "title": "cond",
    "category": "Special expression",
    "description": "Used for branching. \`cond-branches\` are tested sequentially from the top. If no branch is tested truthy, \`null\` is returned.",
    "customVariants": [
      "cond cond-branch cond-branch ... end"
    ],
    "details": [
      [
        "cond-branch",
        "case test then body",
        "A branch of the cond expression."
      ],
      [
        "test",
        "expression",
        "The condition to test."
      ],
      [
        "body",
        "expressions",
        "The expressions to evaluate if the test is truthy."
      ]
    ],
    "examples": [
      "\\ncond\\n  case false then write!(\\"FALSE\\")\\n  case true then write!(\\"TRUE\\")\\nend",
      "\\ncond\\n  case false then write!(\\"FALSE\\")\\n  case null then write!(\\"null\\")\\nend ?? write!(\\"TRUE\\")",
      "\\ncond\\n  case false then write!(\\"FALSE\\")\\n  case null then write!(\\"null\\")\\nend ?? write!(\\"TRUE\\")"
    ]
  },
  "block": {
    "title": "block",
    "category": "Special expression",
    "description": "Evaluates \`body\`. Resulting value is the value of the last expression.",
    "customVariants": [
      "{ body }"
    ],
    "details": [
      [
        "body",
        "expressions",
        "The expressions to evaluate."
      ]
    ],
    "examples": [
      "\\n{\\n  let a = 1 + 2 + 3 + 4;\\n  let b = -> $ * ( $ + 1 );\\n  b(a)\\n}"
    ]
  },
  "doseq": {
    "title": "doseq",
    "category": "Special expression",
    "description": "Iterates over \`bindings\`, evaluates \`body\` for each \`binding\` and returns \`null\`. This is useful for side effects.",
    "customVariants": [
      "doseq (...binding) -> body"
    ],
    "details": [
      [
        "binding",
        "loop-var in collection [...let-binding] [where whereExpr] [while whileExp]",
        "A doseq loop binding"
      ],
      [
        "loop-var",
        "symbol",
        "The name of the loop variable."
      ],
      [
        "collection",
        "any",
        "The collection to iterate over."
      ],
      [
        "let-binding",
        "let binding",
        "A let binding to create a local variable."
      ],
      [
        "whereExpr",
        "expression",
        "An expression that must evaluate to truthy for the loop body to be executed."
      ],
      [
        "whileExp",
        "expression",
        "An expression that must evaluate to truthy for the loop to continue."
      ],
      [
        "body",
        "expressions",
        "The expressions to evaluate for each iteration of the loop."
      ]
    ],
    "returns": {
      "type": "null"
    },
    "examples": [
      "\\ndoseq (i in [1, 2, 3]) -> write!(i * 2)\\n      "
    ]
  },
  "for": {
    "title": "for",
    "category": "Special expression",
    "description": "Iterates over \`bindings\`, evaluates \`body\` for each \`binding\` and returns an \`array\` of results.",
    "customVariants": [
      "for (...binding) -> body"
    ],
    "details": [
      [
        "binding",
        "loop-var in collection [...let-binding] [where whereExpr] [while whileExp]",
        "A for loop binding"
      ],
      [
        "loop-var",
        "symbol",
        "The name of the loop variable."
      ],
      [
        "collection",
        "any",
        "The collection to iterate over."
      ],
      [
        "let-binding",
        "let binding",
        "A let binding to create a local variable."
      ],
      [
        "whereExpr",
        "expression",
        "An expression that must evaluate to truthy for the loop body to be executed."
      ],
      [
        "whileExp",
        "expression",
        "An expression that must evaluate to truthy for the loop to continue."
      ],
      [
        "body",
        "expressions",
        "The expressions to evaluate for each iteration of the loop."
      ]
    ],
    "returns": {
      "type": "any",
      "array": true
    },
    "examples": [
      "\\nfor (i in [1, 2, 3]) -> i * 2\\n      ",
      "\\nfor (\\n  i in range(10) let ii = i ^ 2 while ii < 40 when ii % 3 == 0,\\n  j in range(10) when j % 2 == 1\\n) -> ii + j\\n      "
    ]
  },
  "if": {
    "title": "if",
    "category": "Special expression",
    "description": "Either \`true-expr\` or \`false-expr\` branch is taken. \`true-expr\` is selected when $test is truthy. If $test is falsy \`false-expr\` is executed, if no \`false-expr\` exists, \`null\` is returned.",
    "customVariants": [
      "if test then true-expr else false-expr",
      "if test then true-expr"
    ],
    "details": [
      [
        "test",
        "expression",
        "The condition to test."
      ],
      [
        "true-expr",
        "expression",
        "The expression to evaluate if the test is truthy."
      ],
      [
        "false-expr",
        "expression",
        "The expression to evaluate if the test is falsy."
      ]
    ],
    "examples": [
      "\\nif true then\\n  write!(\\"TRUE\\")\\nelse\\n  write!(\\"FALSE\\")\\nend",
      "if false then write!(\\"TRUE\\") else write!(\\"FALSE\\") end",
      "if true then write!(\\"TRUE\\") end",
      "if false then write!(\\"TRUE\\") end"
    ]
  },
  "let": {
    "title": "let",
    "category": "Special expression",
    "description": "\\n  Binds local variables s to \`value\`. \`value\` can be any expression. The scope of the variables is the body of the let expression.",
    "customVariants": [
      "let s = value;"
    ],
    "details": [
      [
        "s",
        "symbol",
        "The name of the variable to bind."
      ],
      [
        "value",
        "any",
        "The value to bind to the variable."
      ]
    ],
    "examples": [
      "\\nlet a = 1 + 2 + 3 + 4;\\nlet b = -> $ * ( $ + 1 );\\nwrite!(\\"a\\", a, \\"b\\", b)"
    ]
  },
  "object": {
    "title": "object",
    "category": "Special expression",
    "description": "Constructs a new object. Object members are created from the $kvps key-value pairs. Requires an even number of arguments.",
    "returns": {
      "type": "object"
    },
    "args": {
      "kvps": {
        "type": "any",
        "rest": true,
        "description": "key - value pairs, where key is a string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "kvps"
        ]
      }
    ],
    "examples": [
      "object()",
      "\\nlet default = {\\n  type: \\"Person\\",\\n  name: \\"John Doe\\",\\n  age: 42\\n};\\n\\n{\\n  ...default,\\n  name: \\"Lisa\\"\\n}",
      "object(\\"x\\", 10, \\"y\\", true, \\"z\\", \\"A string\\")",
      "{}",
      "{ a: 1, b: 2 }"
    ],
    "noOperatorDocumentation": true,
    "_isOperator": true
  },
  "recur": {
    "title": "recur",
    "category": "Special expression",
    "description": "Recursevly calls enclosing function or loop with its evaluated \`recur-args\`.",
    "customVariants": [
      "recur(...recur-args)"
    ],
    "examples": [
      "\\nlet foo = (n) -> {\\n  write!(n);\\n  if !(zero?(n)) then\\n    recur(n - 1)\\n  end\\n};\\nfoo(3)",
      "\\n(n -> {\\n  write!(n);\\n  if !(zero?(n)) then\\n    recur(n - 1)\\n  end\\n})(3)",
      "\\nloop (n = 3) -> {\\n  write!(n);\\n  if !(zero?(n)) then\\n    recur(n - 1)\\n  end\\n}"
    ]
  },
  "switch": {
    "title": "switch",
    "category": "Special expression",
    "description": "Used for branching. \`switch-branches\` are tested sequentially from the top against \`value\`. If no branch is tested truthy, \`null\` is returned.",
    "customVariants": [
      "switch value switch-branch switch-branch ... end"
    ],
    "details": [
      [
        "value",
        "any",
        "The value to test."
      ],
      [
        "switch-branch",
        "case test then body",
        "A branch of the switch expression."
      ],
      [
        "test",
        "expression",
        "The condition to test."
      ],
      [
        "body",
        "expressions",
        "The expressions to evaluate if the test is truthy."
      ]
    ],
    "examples": [
      "\\nswitch 1\\n  case 1 then write!(\\"One\\")\\n  case 2 then write!(\\"Two\\")\\nend",
      "\\nswitch 2\\n  case 1 then write!(\\"One\\")\\n  case 2 then write!(\\"Two\\")\\nend",
      "\\nswitch 3\\n  case 1 then write!(\\"One\\")\\n  case 2 then write!(\\"Two\\")\\nend"
    ]
  },
  "throw": {
    "title": "throw",
    "category": "Special expression",
    "description": "Throws \`UserDefinedError\` with message set to $expr evaluated. $expr must evaluate to a string.",
    "returns": {
      "type": "never"
    },
    "args": {
      "expr": {
        "type": "any"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "expr"
        ]
      }
    ],
    "examples": [
      "try throw(\\"You shall not pass!\\") catch(error) \\"Error: \\" ++ error.message end",
      "try throw(slice(\\"You shall not pass!\\", 0, 3)) catch(error) \\"Error: \\" ++ error.message end"
    ]
  },
  "try": {
    "title": "try",
    "category": "Special expression",
    "description": "Executes \`try-body\`. If that throws, the \`catch-body\` gets executed. See examples for details.",
    "customVariants": [
      "try { try-body } catch { catch-body }",
      "try { try-body } catch(error) { catch-body }"
    ],
    "details": [
      [
        "try-body",
        "expressions",
        "The expressions to try."
      ],
      [
        "error",
        "symbol",
        "The error variable to bind."
      ],
      [
        "catch-body",
        "expression",
        "The expressions to evaluate if the try-body throws an error."
      ]
    ],
    "examples": [
      "\\ntry\\n  2 / 4\\ncatch\\n  \\"Oops!\\"\\nend",
      "\\ntry\\n  foo()\\ncatch(error)\\n  \\"Error: \\" ++ error.message\\nend",
      "\\ntry\\n  foo()\\ncatch\\n  42\\nend"
    ]
  },
  "unless": {
    "title": "unless",
    "category": "Special expression",
    "description": "Either \`true-expr\` or \`false-expr\` branch is taken. \`true-expr\` is selected when $test is falsy. If $test is truthy \`false-expr\` is executed, if no \`false-expr\` exists, \`null\` is returned.",
    "customVariants": [
      "unless test then true-expr else false-expr end",
      "unless test true-expr end"
    ],
    "details": [
      [
        "test",
        "expression",
        "The condition to test."
      ],
      [
        "true-expr",
        "expression",
        "The expressions to evaluate if the test is falsy."
      ],
      [
        "false-expr",
        "expression",
        "The expressions to evaluate if the test is truthy."
      ]
    ],
    "examples": [
      "\\nunless true then\\n  write!(\\"TRUE\\")\\nelse\\n  write!(\\"FALSE\\")\\nend",
      "unless false then write!(\\"TRUE\\") else write!(\\"FALSE\\") end",
      "unless true then write!(\\"TRUE\\") end",
      "unless false then write!(\\"TRUE\\") end"
    ]
  },
  "-short-regexp": {
    "shorthand": true,
    "title": "#&quot;pattern&quot;",
    "category": "Shorthand",
    "description": "Shorthand for \`regexp(pattern)\`. Only difference is that escaping is not needed.",
    "examples": [
      "#\\"^\\\\s*(.*)$\\"",
      "#\\"albert\\"ig"
    ],
    "seeAlso": [
      "regexp"
    ]
  },
  "-short-fn": {
    "shorthand": true,
    "title": "-> expression",
    "category": "Shorthand",
    "description": "\\nShorthand for \`(args, ...) -> expression\`.\\n\`$1, $2, $3, ...\` are shorthand for the first, second, third, ... argument.\\n\\nYou can reference the first argument using either \`$1\` or \`$\`.\\nHowever, please note that \`$1\` and \`$\` are mutually exclusive and cannot be used simultaneously.\\nE.g. \`#(* $ $1)\` is not valid.",
    "examples": [
      "-> $1 + $2",
      "(-> $ * $)(9)"
    ]
  },
  "-type-number": {
    "datatype": true,
    "title": "number",
    "category": "Datatype",
    "description": "A \`number\`",
    "examples": [
      "42",
      "3.14"
    ]
  },
  "-type-string": {
    "datatype": true,
    "title": "string",
    "category": "Datatype",
    "description": "A \`string\`",
    "examples": [
      "\\"hello\\"",
      "\\"\\""
    ]
  },
  "-type-object": {
    "datatype": true,
    "title": "object",
    "category": "Datatype",
    "description": "An \`object\`, a collection of key-value pairs where keys are \`strings\`",
    "examples": [
      "{}",
      "{ a: 1, b: 2}"
    ]
  },
  "-type-array": {
    "datatype": true,
    "title": "array",
    "category": "Datatype",
    "description": "An \`array\`",
    "examples": [
      "[]",
      "[1, 2, 3]",
      "[\\"a\\", null, true]"
    ]
  },
  "-type-vector": {
    "datatype": true,
    "title": "vector",
    "category": "Datatype",
    "description": "An \`array\` of \`numbers\`",
    "examples": [
      "[]",
      "[1, 2, 3]"
    ]
  },
  "-type-matrix": {
    "datatype": true,
    "title": "matrix",
    "category": "Datatype",
    "description": "A \`matrix\`, a two-dimensional \`array\` with \`numbers\` where each row has the same number of columns. A \`matrix\` is also a \`grid\`.",
    "examples": [
      "[[]]",
      "[[1, 2], [3, 4]]",
      "[[1, 2], [3, 4], [5, 6]]"
    ]
  },
  "-type-grid": {
    "datatype": true,
    "title": "grid",
    "category": "Datatype",
    "description": "A \`grid\`, a two-dimensional \`array\` where each row has the same number of columns",
    "examples": [
      "[[]]",
      "[[1, 2], [3, 4]]",
      "[[\\"a\\", \\"b\\"], [3, 4], [5, 6]]"
    ]
  },
  "-type-boolean": {
    "datatype": true,
    "title": "boolean",
    "category": "Datatype",
    "description": "A \`boolean\`",
    "examples": [
      "true",
      "false"
    ]
  },
  "-type-function": {
    "datatype": true,
    "title": "function",
    "category": "Datatype",
    "description": "A \`function\`",
    "examples": [
      "x -> x + 1",
      "(a, b, c) -> (a + b) * c",
      "() -> 42",
      "-> $1 + $2"
    ]
  },
  "-type-integer": {
    "datatype": true,
    "title": "integer",
    "category": "Datatype",
    "description": "An \`integer\`",
    "examples": [
      "42",
      "-42"
    ]
  },
  "-type-any": {
    "datatype": true,
    "title": "any",
    "category": "Datatype",
    "description": "\`Any\` value",
    "examples": [
      "42",
      "\\"hello\\"",
      "true",
      "null"
    ]
  },
  "-type-null": {
    "datatype": true,
    "title": "null",
    "category": "Datatype",
    "description": "The value \`null\`",
    "examples": [
      "null"
    ]
  },
  "-type-collection": {
    "datatype": true,
    "title": "collection",
    "category": "Datatype",
    "description": "A collection, an \`object\`, an \`array\` or a \`string\`",
    "examples": [
      "{ foo: 42 }",
      "[1, 2, 3]",
      "\\"hello\\""
    ]
  },
  "-type-sequence": {
    "datatype": true,
    "title": "sequence",
    "category": "Datatype",
    "description": "A sequence, an \`array\` or a \`string\`",
    "examples": [
      "[1, 2, 3]",
      "\\"hello\\""
    ]
  },
  "-type-regexp": {
    "datatype": true,
    "title": "regexp",
    "category": "Datatype",
    "description": "A regular expression",
    "examples": [
      "regexp(\\"^\\\\\\\\s*(.*)$\\")",
      "#\\"albert\\"ig"
    ]
  },
  "-type-never": {
    "datatype": true,
    "title": "never",
    "category": "Datatype",
    "description": "A value that can never be created",
    "examples": [
      "\\n// throw(\\"error\\") will never return a value\\ntry throw(\\"error\\") catch \\"never\\" end"
    ]
  },
  "Assert.assert": {
    "title": "Assert.assert",
    "category": "Assert",
    "description": "If $value is falsy it throws \`AssertionError\` with $message. If no $message is provided, message is set to $value.",
    "returns": {
      "type": "any"
    },
    "args": {
      "value": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value"
        ]
      },
      {
        "argumentNames": [
          "value",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert } = import(\\"Assert\\");\\ntry assert(0, \\"Expected a positive value\\") catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert=": {
    "title": "Assert.assert=",
    "category": "Assert",
    "description": "If $a is not structural equal to $b it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert= } = import(\\"Assert\\");\\ntry assert=({ \\"a\\": 1 }, { \\"a\\": 2 }, \\"Expected equal values\\") catch (e) e.message end",
      "let { assert= } = import(\\"Assert\\");\\ntry assert=({ \\"a\\": 1 }, { \\"a\\": 2 }) catch (e) e.message end",
      "let { assert= } = import(\\"Assert\\");\\ntry assert=({ \\"a\\": 1 }, { \\"a\\": 1 }) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert!=": {
    "title": "Assert.assert!=",
    "category": "Assert",
    "description": "If $a is the same as $b it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert!= } = import(\\"Assert\\");\\ntry assert!=(0, 0, \\"Expected different values\\") catch (e) e.message end",
      "let { assert!= } = import(\\"Assert\\");\\ntry assert!=(0, 0) catch (e) e.message end",
      "let { assert!= } = import(\\"Assert\\");\\ntry 0 assert!= 0 catch (e) e.message end",
      "let { assert!= } = import(\\"Assert\\");\\ntry assert!=(0, 1) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-gt": {
    "title": "Assert.assert-gt",
    "category": "Assert",
    "description": "If $a is not greater than $b it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-gt } = import(\\"Assert\\");\\ntry assert-gt(0, 1, \\"Expected greater value\\") catch (e) e.message end",
      "let { assert-gt } = import(\\"Assert\\");\\ntry assert-gt(0, 0) catch (e) e.message end",
      "let { assert-gt } = import(\\"Assert\\");\\ntry assert-gt(1, 0) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-gte": {
    "title": "Assert.assert-gte",
    "category": "Assert",
    "description": "If $a is less than $b it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-gte } = import(\\"Assert\\");\\ntry assert-gte(0, 1, \\"Expected greater value\\") catch (e) e.message end",
      "let { assert-gte } = import(\\"Assert\\");\\ntry assert-gte(0, 1) catch (e) e.message end",
      "let { assert-gte } = import(\\"Assert\\");\\ntry assert-gte(1, 1) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-lt": {
    "title": "Assert.assert-lt",
    "category": "Assert",
    "description": "If $a is not less than $b it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-lt } = import(\\"Assert\\");\\ntry assert-lt(1, 0, \\"Expected smaller value value\\") catch (e) e.message end",
      "let { assert-lt } = import(\\"Assert\\");\\ntry assert-lt(1, 1) catch (e) e.message end",
      "let { assert-lt } = import(\\"Assert\\");\\ntry assert-lt(0, 1) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-lte": {
    "title": "Assert.assert-lte",
    "category": "Assert",
    "description": "If $a is grater than $b it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "a": {
        "type": "any"
      },
      "b": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      },
      {
        "argumentNames": [
          "a",
          "b",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-lte } = import(\\"Assert\\");\\ntry assert-lte(1, 0, \\"Expected smaller value value\\") catch (e) e.message end",
      "let { assert-lte } = import(\\"Assert\\");\\ntry assert-lte(1, 0) catch (e) e.message end",
      "let { assert-lte } = import(\\"Assert\\");\\ntry assert-lte(1, 1) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-true": {
    "title": "Assert.assert-true",
    "category": "Assert",
    "description": "If $value is not \`true\` it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "value": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value"
        ]
      },
      {
        "argumentNames": [
          "value",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-true } = import(\\"Assert\\");\\ntry assert-true(false, \\"Expected true\\") catch (e) e.message end",
      "let { assert-true } = import(\\"Assert\\");\\ntry assert-true(false) catch (e) e.message end",
      "let { assert-true } = import(\\"Assert\\");\\ntry assert-true(true) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-false": {
    "title": "Assert.assert-false",
    "category": "Assert",
    "description": "If $value is not \`false\` it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "value": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value"
        ]
      },
      {
        "argumentNames": [
          "value",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-false } = import(\\"Assert\\");\\ntry assert-false(true, \\"Expected false\\") catch (e) e.message end",
      "let { assert-false } = import(\\"Assert\\");\\ntry assert-false(true) catch (e) e.message end",
      "let { assert-false } = import(\\"Assert\\");\\ntry assert-false(false) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-truthy": {
    "title": "Assert.assert-truthy",
    "category": "Assert",
    "description": "If $value is not \`truthy\` it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "value": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value"
        ]
      },
      {
        "argumentNames": [
          "value",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy(false, \\"Expected truthy\\") catch (e) e.message end",
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy(false) catch (e) e.message end",
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy(0) catch (e) e.message end",
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy(null) catch (e) e.message end",
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy(\\"\\") catch (e) e.message end",
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy(true) catch (e) e.message end",
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy(1) catch (e) e.message end",
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy(\\"x\\") catch (e) e.message end",
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy([]) catch (e) e.message end",
      "let { assert-truthy } = import(\\"Assert\\");\\ntry assert-truthy(nd) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-falsy": {
    "title": "Assert.assert-falsy",
    "category": "Assert",
    "description": "If $value is not \`falsy\` it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "value": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value"
        ]
      },
      {
        "argumentNames": [
          "value",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-falsy } = import(\\"Assert\\");\\ntry assert-falsy(true, \\"Expected falsy\\") catch (e) e.message end",
      "let { assert-falsy } = import(\\"Assert\\");\\ntry assert-falsy(\\"x\\") catch (e) e.message end",
      "let { assert-falsy } = import(\\"Assert\\");\\ntry assert-falsy([]) catch (e) e.message end",
      "let { assert-falsy } = import(\\"Assert\\");\\ntry assert-falsy(nd) catch (e) e.message end",
      "let { assert-falsy } = import(\\"Assert\\");\\ntry assert-falsy(1) catch (e) e.message end",
      "let { assert-falsy } = import(\\"Assert\\");\\ntry assert-falsy(false) catch (e) e.message end",
      "let { assert-falsy } = import(\\"Assert\\");\\ntry assert-falsy(0) catch (e) e.message end",
      "let { assert-falsy } = import(\\"Assert\\");\\ntry assert-falsy(null) catch (e) e.message end",
      "let { assert-falsy } = import(\\"Assert\\");\\ntry assert-falsy(\\"\\") catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-null": {
    "title": "Assert.assert-null",
    "category": "Assert",
    "description": "If $value is not \`null\` it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "value": {
        "type": "any"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value"
        ]
      },
      {
        "argumentNames": [
          "value",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-null } = import(\\"Assert\\");\\ntry assert-null(null) catch (e) e.message end",
      "let { assert-null } = import(\\"Assert\\");\\ntry assert-null(true, \\"Expected null\\") catch (e) e.message end",
      "let { assert-null } = import(\\"Assert\\");\\ntry assert-null(\\"x\\") catch (e) e.message end",
      "let { assert-null } = import(\\"Assert\\");\\ntry assert-null([]) catch (e) e.message end",
      "let { assert-null } = import(\\"Assert\\");\\ntry assert-null(nd) catch (e) e.message end",
      "let { assert-null } = import(\\"Assert\\");\\ntry assert-null(1) catch (e) e.message end",
      "let { assert-null } = import(\\"Assert\\");\\ntry assert-null(false) catch (e) e.message end",
      "let { assert-null } = import(\\"Assert\\");\\ntry assert-null(0) catch (e) e.message end",
      "let { assert-null } = import(\\"Assert\\");\\ntry assert-null(\\"\\") catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-throws": {
    "title": "Assert.assert-throws",
    "category": "Assert",
    "description": "If $fun does not throw, it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "fun": {
        "type": "function"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun"
        ]
      },
      {
        "argumentNames": [
          "fun",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-throws } = import(\\"Assert\\");\\nassert-throws(-> throw(\\"Error\\"))",
      "let { assert-throws } = import(\\"Assert\\");\\ntry assert-throws(-> identity(\\"Error\\")) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-throws-error": {
    "title": "Assert.assert-throws-error",
    "category": "Assert",
    "description": "If $fun does not throw $error-message, it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "fun": {
        "type": "function"
      },
      "error-message": {
        "type": "string"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "value",
          "error-message"
        ]
      },
      {
        "argumentNames": [
          "value",
          "error-message",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-throws-error } = import(\\"Assert\\");\\ntry assert-throws-error(-> throw(\\"Error\\"), \\"Error\\") catch (e) e.message end",
      "let { assert-throws-error } = import(\\"Assert\\");\\ntry assert-throws-error(-> identity(\\"Error\\"), \\"Error\\") catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Assert.assert-not-throws": {
    "title": "Assert.assert-not-throws",
    "category": "Assert",
    "description": "If $fun throws, it throws \`AssertionError\`.",
    "returns": {
      "type": "null"
    },
    "args": {
      "fun": {
        "type": "function"
      },
      "message": {
        "type": "string"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "fun"
        ]
      },
      {
        "argumentNames": [
          "fun",
          "message"
        ]
      }
    ],
    "examples": [
      "let { assert-not-throws } = import(\\"Assert\\");\\ntry assert-not-throws(-> identity(\\"Error\\")) catch (e) e.message end",
      "let { assert-not-throws } = import(\\"Assert\\");\\ntry assert-not-throws(-> throw(\\"Error\\")) catch (e) e.message end"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.every?": {
    "title": "Grid.every?",
    "category": "Grid",
    "description": "Checks if all elements in a grid satisfy a predicate. Returns true only if the predicate returns true for every element in the grid.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "// Using \\"as\\" alias because \\"every?\\" shadows a builtin function\\nlet { every? as grid-every? } = import(\\"Grid\\");\\ngrid-every?([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], string?)",
      "// Using \\"as\\" alias because \\"every?\\" shadows a builtin function\\nlet { every? as grid-every? } = import(\\"Grid\\");\\ngrid-every?([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n], string?)",
      "// Using \\"as\\" alias because \\"every?\\" shadows a builtin function\\nlet { every? as grid-every? } = import(\\"Grid\\");\\ngrid-every?([\\n  [1, 2],\\n  [3, 4],\\n], string?)"
    ]
  },
  "Grid.some?": {
    "title": "Grid.some?",
    "category": "Grid",
    "description": "Checks if any element in a grid satisfies a predicate. Returns true if the predicate returns true for at least one element in the grid.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { some? } = import(\\"Grid\\");\\nsome?([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], string?)",
      "let { some? } = import(\\"Grid\\");\\nsome?([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n], string?)",
      "let { some? } = import(\\"Grid\\");\\nsome?([\\n  [1, 2],\\n  [3, 4],\\n], string?)"
    ]
  },
  "Grid.every-row?": {
    "title": "Grid.every-row?",
    "category": "Grid",
    "description": "Checks if all rows in a grid satisfy a predicate. Returns true only if the predicate returns true for every row in the grid.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { every-row? } = import(\\"Grid\\");\\nevery-row?([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], -> string?($[0]))",
      "let { every-row? } = import(\\"Grid\\");\\nevery-row?([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n], -> string?($[0]))",
      "let { every-row? } = import(\\"Grid\\");\\nevery-row?([\\n  [1, 2],\\n  [3, 4],\\n], -> string?($[0]))"
    ]
  },
  "Grid.some-row?": {
    "title": "Grid.some-row?",
    "category": "Grid",
    "description": "Checks if any row in a grid satisfies a predicate. Returns true if the predicate returns true for at least one row in the grid.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { some-row? } = import(\\"Grid\\");\\nsome-row?([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], -> $ contains? \\"Albert\\")",
      "let { some-row? } = import(\\"Grid\\");\\nsome-row?([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n], -> $ contains? \\"Albert\\")",
      "let { some-row? } = import(\\"Grid\\");\\nsome-row?([\\n  [1, 2],\\n  [3, 4],\\n], -> $ contains? \\"Albert\\")"
    ]
  },
  "Grid.every-col?": {
    "title": "Grid.every-col?",
    "category": "Grid",
    "description": "Checks if all columns in a grid satisfy a predicate. Returns true only if the predicate returns true for every column in the grid.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { every-col? } = import(\\"Grid\\");\\nevery-col?([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], -> string?($[0]))",
      "let { every-col? } = import(\\"Grid\\");\\nevery-col?([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n], -> string?($[0]))",
      "let { every-col? } = import(\\"Grid\\");\\nevery-col?([\\n  [1, 2],\\n  [3, 4],\\n], -> string?($[0]))"
    ]
  },
  "Grid.some-col?": {
    "title": "Grid.some-col?",
    "category": "Grid",
    "description": "Checks if any column in a grid satisfies a predicate. Returns true if the predicate returns true for at least one column in the grid.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { some-col? } = import(\\"Grid\\");\\nsome-col?([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], -> $ contains? \\"Albert\\")",
      "let { some-col? } = import(\\"Grid\\");\\nsome-col?([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n], -> $ contains? \\"Albert\\")",
      "let { some-col? } = import(\\"Grid\\");\\nsome-col?([\\n  [1, 2],\\n  [3, 4],\\n], -> $ contains? \\"Albert\\")"
    ]
  },
  "Grid.row": {
    "title": "Grid.row",
    "category": "Grid",
    "description": "Returns the row at index $a in the grid $b.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { row } = import(\\"Grid\\");\\nrow([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 0)",
      "let { row } = import(\\"Grid\\");\\nrow([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1)",
      "let { row } = import(\\"Grid\\");\\nrow([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 2)"
    ]
  },
  "Grid.col": {
    "title": "Grid.col",
    "category": "Grid",
    "description": "Returns the column at index $a in the grid $b.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { col } = import(\\"Grid\\");\\ncol([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 0)",
      "let { col } = import(\\"Grid\\");\\ncol([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1)",
      "let { col } = import(\\"Grid\\");\\ncol([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 2)"
    ]
  },
  "Grid.shape": {
    "title": "Grid.shape",
    "category": "Grid",
    "description": "Returns the shape of the grid \`g\` as a \`vector\` of two numbers, where the first number is the number of rows and the second number is the number of columns.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to get the shape of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { shape } = import(\\"Grid\\");\\nshape([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])",
      "let { shape } = import(\\"Grid\\");\\nshape([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n])",
      "let { shape } = import(\\"Grid\\");\\nshape([\\n  [1, 2],\\n  [3, 4],\\n])"
    ]
  },
  "Grid.fill": {
    "title": "Grid.fill",
    "category": "Grid",
    "description": "Creates a grid of the specified size, filled with the specified value.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "rows": {
        "type": "integer",
        "description": "The number of rows in the grid."
      },
      "cols": {
        "type": "integer",
        "description": "The number of columns in the grid."
      },
      "value": {
        "type": "any",
        "description": "The value to fill the grid with."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "rows",
          "cols",
          "value"
        ]
      }
    ],
    "examples": [
      "let { fill } = import(\\"Grid\\");\\nfill(2, 3, 0)",
      "let { fill } = import(\\"Grid\\");\\nfill(2, 3, \\"x\\")"
    ]
  },
  "Grid.generate": {
    "title": "Grid.generate",
    "category": "Grid",
    "description": "Generates a grid of the specified size, where each element is generated by the provided function.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "rows": {
        "type": "number",
        "description": "The number of rows in the grid."
      },
      "cols": {
        "type": "number",
        "description": "The number of columns in the grid."
      },
      "fn": {
        "type": "function",
        "description": "The function to generate the grid. It takes two arguments: the row index and the column index."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "rows",
          "cols",
          "fn"
        ]
      }
    ],
    "examples": [
      "let { generate } = import(\\"Grid\\");\\ngenerate(3, 3, (i, j) -> i + j)"
    ]
  },
  "Grid.reshape": {
    "title": "Grid.reshape",
    "category": "Grid",
    "description": "Reshapes the grid \`a\` into a new grid with the specified number of rows \`b\`. The number of columns is automatically calculated based on the total number of elements in the grid.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { reshape } = import(\\"Grid\\");\\nreshape([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n], 2)"
    ]
  },
  "Grid.transpose": {
    "title": "Grid.transpose",
    "category": "Grid",
    "description": "Transposes the grid \`g\`, swapping its rows and columns.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to transpose."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { transpose } = import(\\"Grid\\");\\ntranspose([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])",
      "let { transpose } = import(\\"Grid\\");\\ntranspose([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n])",
      "let { transpose } = import(\\"Grid\\");\\ntranspose([\\n  [1, 2],\\n  [3, 4],\\n])"
    ]
  },
  "Grid.flip-h": {
    "title": "Grid.flip-h",
    "category": "Grid",
    "description": "Flips the grid \`g\` horizontally.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to flip horizontally."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { flip-h } = import(\\"Grid\\");\\nflip-h([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])",
      "let { flip-h } = import(\\"Grid\\");\\nflip-h([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n])",
      "let { flip-h } = import(\\"Grid\\");\\nflip-h([\\n  [1, 2],\\n  [3, 4],\\n])"
    ]
  },
  "Grid.flip-v": {
    "title": "Grid.flip-v",
    "category": "Grid",
    "description": "Flips the grid \`g\` vertically.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to flip vertically."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { flip-v } = import(\\"Grid\\");\\nflip-v([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])",
      "let { flip-v } = import(\\"Grid\\");\\nflip-v([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n])",
      "let { flip-v } = import(\\"Grid\\");\\nflip-v([\\n  [1, 2],\\n  [3, 4],\\n])"
    ]
  },
  "Grid.rotate": {
    "title": "Grid.rotate",
    "category": "Grid",
    "description": "Rotates the grid \`g\` by the specified angle. The angle is given in terms of 90-degree rotations. Positive values rotate the grid clockwise, while negative values rotate it counterclockwise.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { rotate } = import(\\"Grid\\");\\nrotate([\\n  [1, 2],\\n  [3, 4],\\n], 1)",
      "let { rotate } = import(\\"Grid\\");\\nrotate([\\n  [1, 2],\\n  [3, 4],\\n], 2)",
      "let { rotate } = import(\\"Grid\\");\\nrotate([\\n  [1, 2],\\n  [3, 4],\\n], 3)",
      "let { rotate } = import(\\"Grid\\");\\nrotate([\\n  [1, 2],\\n  [3, 4],\\n], 4)",
      "let { rotate } = import(\\"Grid\\");\\nrotate([\\n  [1, 2],\\n  [3, 4],\\n], -1)",
      "let { rotate } = import(\\"Grid\\");\\nrotate([\\n  [1, 2],\\n  [3, 4],\\n], -2)",
      "let { rotate } = import(\\"Grid\\");\\nrotate([\\n  [1, 2],\\n  [3, 4],\\n], -3)"
    ]
  },
  "Grid.reverse-rows": {
    "title": "Grid.reverse-rows",
    "category": "Grid",
    "description": "Reverses the order of rows in the grid \`g\`.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to reverse rows."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { reverse-rows } = import(\\"Grid\\");\\nreverse-rows([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])",
      "let { reverse-rows } = import(\\"Grid\\");\\nreverse-rows([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n])",
      "let { reverse-rows } = import(\\"Grid\\");\\nreverse-rows([\\n  [1, 2],\\n  [3, 4],\\n])"
    ]
  },
  "Grid.reverse-cols": {
    "title": "Grid.reverse-cols",
    "category": "Grid",
    "description": "Reverses the order of columns in the grid \`g\`.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to reverse columns."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { reverse-cols } = import(\\"Grid\\");\\nreverse-cols([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])",
      "let { reverse-cols } = import(\\"Grid\\");\\nreverse-cols([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n])",
      "let { reverse-cols } = import(\\"Grid\\");\\nreverse-cols([\\n  [1, 2],\\n  [3, 4],\\n])"
    ]
  },
  "Grid.slice": {
    "title": "Grid.slice",
    "category": "Grid",
    "description": "Slices the grid \`g\` from the starting index \`begin\` to the optional ending index \`stop\`. The slice is inclusive of the starting index and exclusive of the ending index.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to slice."
      },
      "begin": {
        "type": "vector",
        "description": "The starting index of the slice as a vector of two numbers: \`[row, col]\`."
      },
      "stop": {
        "type": "vector",
        "description": "Optional ending index of the slice as a vector of two numbers: \`[row, col]\`."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "begin"
        ]
      },
      {
        "argumentNames": [
          "g",
          "begin",
          "stop"
        ]
      }
    ],
    "examples": [
      "// Using \\"as\\" alias because \\"slice\\" shadows a builtin function\\nlet { slice as grid-slice } = import(\\"Grid\\");\\ngrid-slice([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], [1, 1], [2, 2])",
      "// Using \\"as\\" alias because \\"slice\\" shadows a builtin function\\nlet { slice as grid-slice } = import(\\"Grid\\");\\ngrid-slice([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], [1, 1])"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.slice-rows": {
    "title": "Grid.slice-rows",
    "category": "Grid",
    "description": "Slices rows of the grid \`g\` from the starting index \`begin\` to the optional ending index \`stop\`. The slice is inclusive of the starting index and exclusive of the ending index.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to slice."
      },
      "begin": {
        "type": "number",
        "description": "The starting index of the slice."
      },
      "stop": {
        "type": "number",
        "description": "Optional ending index of the slice."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "begin"
        ]
      },
      {
        "argumentNames": [
          "g",
          "begin",
          "stop"
        ]
      }
    ],
    "examples": [
      "let { slice-rows } = import(\\"Grid\\");\\nslice-rows([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1, 2)",
      "let { slice-rows } = import(\\"Grid\\");\\nslice-rows([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1)"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.slice-cols": {
    "title": "Grid.slice-cols",
    "category": "Grid",
    "description": "Slices columns of the grid \`g\` from the starting index \`begin\` to the optional ending index \`stop\`. The slice is inclusive of the starting index and exclusive of the ending index.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to slice."
      },
      "begin": {
        "type": "number",
        "description": "The starting index of the slice."
      },
      "stop": {
        "type": "number",
        "description": "Optional ending index of the slice."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "begin"
        ]
      },
      {
        "argumentNames": [
          "g",
          "begin",
          "stop"
        ]
      }
    ],
    "examples": [
      "let { slice-cols } = import(\\"Grid\\");\\nslice-cols([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1, 2)",
      "let { slice-cols } = import(\\"Grid\\");\\nslice-cols([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1)"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.splice-rows": {
    "title": "Grid.splice-rows",
    "category": "Grid",
    "description": "Splices rows of the grid \`g\` starting from the index \`begin\`. Deletes \`deleteCount\` rows and inserts the specified \`items\` at that position.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to splice."
      },
      "begin": {
        "type": "number",
        "description": "The starting index of the splice."
      },
      "deleteCount": {
        "type": "number",
        "description": "The number of rows to delete."
      },
      "items": {
        "type": "array",
        "rest": true,
        "description": "The rows to insert."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "begin",
          "deleteCount"
        ]
      },
      {
        "argumentNames": [
          "g",
          "begin",
          "deleteCount",
          "items"
        ]
      }
    ],
    "examples": [
      "let { splice-rows } = import(\\"Grid\\");\\nsplice-rows([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1, 2)",
      "let { splice-rows } = import(\\"Grid\\");\\nsplice-rows([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1, 1, [\\"Nazanin\\", \\"mother\\", 40])"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.splice-cols": {
    "title": "Grid.splice-cols",
    "category": "Grid",
    "description": "Splices columns of the grid \`g\` starting from the index \`begin\`. Deletes \`deleteCount\` columns and inserts the specified \`items\` at that position.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to splice."
      },
      "begin": {
        "type": "number",
        "description": "The starting index of the splice."
      },
      "deleteCount": {
        "type": "number",
        "description": "The number of columns to delete."
      },
      "items": {
        "type": "array",
        "rest": true,
        "description": "The columns to insert."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "begin",
          "deleteCount"
        ]
      },
      {
        "argumentNames": [
          "g",
          "begin",
          "deleteCount",
          "items"
        ]
      }
    ],
    "examples": [
      "let { splice-cols } = import(\\"Grid\\");\\nsplice-cols([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1, 2)",
      "let { splice-cols } = import(\\"Grid\\");\\nsplice-cols([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], 1, 1, [\\"f\\", \\"m\\", \\"s\\"])"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.concat-rows": {
    "title": "Grid.concat-rows",
    "category": "Grid",
    "description": "Concatenates two grids \`a\` and \`b\` by rows. The number of columns in both grids must be the same.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "grid"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { concat-rows } = import(\\"Grid\\");\\nconcat-rows([\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n], [\\n  [1, 2],\\n  [3, 4],\\n])"
    ]
  },
  "Grid.concat-cols": {
    "title": "Grid.concat-cols",
    "category": "Grid",
    "description": "Concatenates two grids \`a\` and \`b\` by columns. The number of rows in both grids must be the same.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "grid"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { concat-cols } = import(\\"Grid\\");\\nconcat-cols([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], [\\n  [\\"Albert\\", \\"father\\"],\\n  [\\"Nina\\", \\"mother\\"],\\n  [\\"Kian\\", \\"son\\"],\\n])"
    ]
  },
  "Grid.map": {
    "title": "Grid.map",
    "category": "Grid",
    "description": "Maps a function \`a\` over each element of the grid \`b\`, returning a new grid with the results.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "// Using \\"as\\" alias because \\"map\\" shadows a builtin function\\nlet { map as grid-map } = import(\\"Grid\\");\\ngrid-map([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], str)"
    ]
  },
  "Grid.mapi": {
    "title": "Grid.mapi",
    "category": "Grid",
    "description": "Maps a function \`a\` over each element of the grid \`b\`, passing the row and column index as additional arguments to the function.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "a": {
        "type": "grid"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "// Using \\"as\\" alias because \\"mapi\\" shadows a builtin function\\nlet { mapi as grid-mapi } = import(\\"Grid\\");\\ngrid-mapi([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], -> $1 ++ \\"(\\" ++ $2 ++ \\", \\" ++ $3 ++ \\")\\")"
    ]
  },
  "Grid.reduce": {
    "title": "Grid.reduce",
    "category": "Grid",
    "description": "Reduces the grid \`a\` using the function \`b\`, returning a single value.",
    "returns": {
      "type": "any"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to reduce."
      },
      "fn": {
        "type": "function",
        "description": "The function to reduce the grid. It takes two arguments: the accumulator and the current element."
      },
      "initial-value": {
        "type": "any",
        "description": "The initial value for the accumulator."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "fn",
          "initial-value"
        ]
      }
    ],
    "examples": [
      "// Using \\"as\\" alias because \\"reduce\\" shadows a builtin function\\nlet { reduce as grid-reduce } = import(\\"Grid\\");\\ngrid-reduce([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], ++, \\"\\")"
    ]
  },
  "Grid.reducei": {
    "title": "Grid.reducei",
    "category": "Grid",
    "description": "Reduces the grid \`a\` using the function \`b\`, passing the row and column indices as additional arguments to the function.",
    "returns": {
      "type": "any"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to reduce."
      },
      "fn": {
        "type": "function",
        "description": "The function to reduce the grid. It takes four arguments: the accumulator, the current element, the row index, and the column index."
      },
      "initial-value": {
        "type": "any",
        "description": "The initial value for the accumulator."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "fn",
          "initial-value"
        ]
      }
    ],
    "examples": [
      "// Using \\"as\\" alias because \\"reducei\\" shadows a builtin function\\nlet { reducei as grid-reducei } = import(\\"Grid\\");\\ngrid-reducei([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], ++, \\"\\")"
    ]
  },
  "Grid.push-rows": {
    "title": "Grid.push-rows",
    "category": "Grid",
    "description": "Pushes the specified rows into the grid \`g\` and returns the new grid.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to push rows into."
      },
      "rows": {
        "type": "array",
        "rest": true,
        "description": "The rows to push into the grid."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "rows"
        ]
      }
    ],
    "examples": [
      "let { push-rows } = import(\\"Grid\\");\\npush-rows([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], [\\"Nazanin\\", \\"mother\\", 40])"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.unshift-rows": {
    "title": "Grid.unshift-rows",
    "category": "Grid",
    "description": "Unshifts the specified rows into the grid \`g\` and returns the new grid.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to unshift rows into."
      },
      "rows": {
        "type": "array",
        "rest": true,
        "description": "The rows to unshift into the grid."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "rows"
        ]
      }
    ],
    "examples": [
      "let { unshift-rows } = import(\\"Grid\\");\\nunshift-rows([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], [\\"Nazanin\\", \\"mother\\", 40])"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.pop-row": {
    "title": "Grid.pop-row",
    "category": "Grid",
    "description": "Pops the last row from the grid \`g\` and returns the new grid.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to pop a row from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { pop-row } = import(\\"Grid\\");\\npop-row([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])"
    ]
  },
  "Grid.shift-row": {
    "title": "Grid.shift-row",
    "category": "Grid",
    "description": "Shifts the first row from the grid \`g\` and returns the new grid.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to shift a row from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { shift-row } = import(\\"Grid\\");\\nshift-row([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])"
    ]
  },
  "Grid.push-cols": {
    "title": "Grid.push-cols",
    "category": "Grid",
    "description": "Pushes the specified columns into the grid \`g\` and returns the new grid.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to push columns into."
      },
      "cols": {
        "type": "array",
        "rest": true,
        "description": "The columns to push into the grid."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "cols"
        ]
      }
    ],
    "examples": [
      "let { push-cols } = import(\\"Grid\\");\\npush-cols([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], [\\"f\\", \\"m\\", \\"s\\"])"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.unshift-cols": {
    "title": "Grid.unshift-cols",
    "category": "Grid",
    "description": "Unshifts the specified columns into the grid \`g\` and returns the new grid.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to unshift columns into."
      },
      "cols": {
        "type": "array",
        "rest": true,
        "description": "The columns to unshift into the grid."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g",
          "cols"
        ]
      }
    ],
    "examples": [
      "let { unshift-cols } = import(\\"Grid\\");\\nunshift-cols([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n], [\\"f\\", \\"m\\", \\"s\\"])"
    ],
    "noOperatorDocumentation": true
  },
  "Grid.pop-col": {
    "title": "Grid.pop-col",
    "category": "Grid",
    "description": "Pops the last column from the grid \`g\` and returns the new grid.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to pop a column from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { pop-col } = import(\\"Grid\\");\\npop-col([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])"
    ]
  },
  "Grid.shift-col": {
    "title": "Grid.shift-col",
    "category": "Grid",
    "description": "Shifts the first column from the grid \`g\` and returns the new grid.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "g": {
        "type": "grid",
        "description": "The grid to shift a column from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "g"
        ]
      }
    ],
    "examples": [
      "let { shift-col } = import(\\"Grid\\");\\nshift-col([\\n  [\\"Albert\\", \\"father\\", 10],\\n  [\\"Nina\\", \\"mother\\", 20],\\n  [\\"Kian\\", \\"son\\", 30],\\n])"
    ]
  },
  "Grid.from-array": {
    "title": "Grid.from-array",
    "category": "Grid",
    "description": "Creates a grid from a flat array with specified dimensions. The array is reshaped into the specified number of rows, and the number of columns is automatically calculated based on the total number of elements in the array.",
    "returns": {
      "type": "grid"
    },
    "args": {
      "a": {
        "type": "array"
      },
      "b": {
        "type": "number"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { from-array } = import(\\"Grid\\");\\nfrom-array([1, 2, 3, 4], 2)",
      "let { from-array } = import(\\"Grid\\");\\nfrom-array([1, 2, 3, 4], 4)"
    ]
  },
  "Random.random!": {
    "title": "Random.random!",
    "category": "Random",
    "description": "Returns a random number between 0 and 1.",
    "returns": {
      "type": "number"
    },
    "args": {},
    "variants": [
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { random! } = import(\\"Random\\"); random!()"
    ]
  },
  "Random.random-int!": {
    "title": "Random.random-int!",
    "category": "Random",
    "description": "Returns a random integer between min and max (exclusive).",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer",
        "description": "The minimum value."
      },
      "b": {
        "type": "integer",
        "description": "The maximum value (exclusive)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { random-int! } = import(\\"Random\\"); random-int!(0, 10)",
      "let { random-int! } = import(\\"Random\\"); random-int!(1, 100)"
    ]
  },
  "Random.random-int-inclusive!": {
    "title": "Random.random-int-inclusive!",
    "category": "Random",
    "description": "Returns a random integer between min and max (inclusive).",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer",
        "description": "The minimum value."
      },
      "b": {
        "type": "integer",
        "description": "The maximum value (inclusive)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { random-int-inclusive! } = import(\\"Random\\"); random-int-inclusive!(0, 10)"
    ]
  },
  "Random.random-float!": {
    "title": "Random.random-float!",
    "category": "Random",
    "description": "Returns a random float between min and max.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "number",
        "description": "The minimum value."
      },
      "b": {
        "type": "number",
        "description": "The maximum value."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { random-float! } = import(\\"Random\\"); random-float!(0, 10)",
      "let { random-float! } = import(\\"Random\\"); random-float!(1, 100)"
    ]
  },
  "Random.random-boolean!": {
    "title": "Random.random-boolean!",
    "category": "Random",
    "description": "Returns a random boolean.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "prob": {
        "type": "number",
        "description": "The probability of returning true (between 0 and 1)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "prob"
        ]
      }
    ],
    "examples": [
      "let { random-boolean! } = import(\\"Random\\"); random-boolean!()",
      "let { random-boolean! } = import(\\"Random\\"); random-boolean!(0.99)"
    ]
  },
  "Random.random-item!": {
    "title": "Random.random-item!",
    "category": "Random",
    "description": "Returns a random item from the array.",
    "returns": {
      "type": "any"
    },
    "args": {
      "a": {
        "type": "array",
        "description": "The array to sample from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a"
        ]
      }
    ],
    "examples": [
      "let { random-item! } = import(\\"Random\\"); random-item!([1, 2, 3, 4, 5])",
      "let { random-item! } = import(\\"Random\\"); random-item!([\\"apple\\", \\"banana\\", \\"cherry\\"])"
    ]
  },
  "Random.random-sample!": {
    "title": "Random.random-sample!",
    "category": "Random",
    "description": "Returns a random sample of n items from the array.",
    "returns": {
      "type": "array"
    },
    "args": {
      "a": {
        "type": "array",
        "description": "The array to sample from."
      },
      "b": {
        "type": "integer",
        "description": "The number of items to sample."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { random-sample! } = import(\\"Random\\"); random-sample!([1, 2, 3, 4, 5], 3)",
      "let { random-sample! } = import(\\"Random\\"); random-sample!([\\"apple\\", \\"banana\\", \\"cherry\\"], 10)"
    ]
  },
  "Random.random-sample-unique!": {
    "title": "Random.random-sample-unique!",
    "category": "Random",
    "description": "Returns a random sample of n unique items from the array.",
    "returns": {
      "type": "array"
    },
    "args": {
      "a": {
        "type": "array",
        "description": "The array to sample from."
      },
      "b": {
        "type": "integer",
        "description": "The number of items to sample."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { random-sample-unique! } = import(\\"Random\\"); random-sample-unique!([1, 2, 3, 4, 5], 3)",
      "let { random-sample-unique! } = import(\\"Random\\"); random-sample-unique!([\\"apple\\", \\"banana\\", \\"cherry\\"], 2)"
    ]
  },
  "Random.shuffle!": {
    "title": "Random.shuffle!",
    "category": "Random",
    "description": "Returns a shuffled version of the array.",
    "returns": {
      "type": "array"
    },
    "args": {
      "a": {
        "type": "array",
        "description": "The array to shuffle."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a"
        ]
      }
    ],
    "examples": [
      "let { shuffle! } = import(\\"Random\\"); shuffle!([1, 2, 3, 4, 5])",
      "let { shuffle! } = import(\\"Random\\"); shuffle!([\\"apple\\", \\"banana\\", \\"cherry\\"])"
    ]
  },
  "Random.random-normal!": {
    "title": "Random.random-normal!",
    "category": "Random",
    "description": "Returns a random number from a normal distribution with the given mean and standard deviation.",
    "returns": {
      "type": "number"
    },
    "args": {
      "mean": {
        "type": "number",
        "description": "The mean of the normal distribution."
      },
      "stdDev": {
        "type": "number",
        "description": "The standard deviation of the normal distribution."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "mean",
          "stdDev"
        ]
      }
    ],
    "examples": [
      "let { random-normal! } = import(\\"Random\\"); random-normal!(0, 1)",
      "let { random-normal! } = import(\\"Random\\"); random-normal!(5, 2)"
    ],
    "noOperatorDocumentation": true
  },
  "Random.random-exponential!": {
    "title": "Random.random-exponential!",
    "category": "Random",
    "description": "Returns a random number from an exponential distribution with the given rate parameter.",
    "returns": {
      "type": "number"
    },
    "args": {
      "lambda": {
        "type": "number",
        "description": "The rate parameter of the exponential distribution."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "lambda"
        ]
      }
    ],
    "examples": [
      "let { random-exponential! } = import(\\"Random\\"); random-exponential!(1)",
      "let { random-exponential! } = import(\\"Random\\"); random-exponential!(0.5)"
    ]
  },
  "Random.random-binomial!": {
    "title": "Random.random-binomial!",
    "category": "Random",
    "description": "Returns a random number from a binomial distribution with the given number of trials and probability of success.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number of trials."
      },
      "p": {
        "type": "number",
        "description": "The probability of success on each trial."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n",
          "p"
        ]
      }
    ],
    "examples": [
      "let { random-binomial! } = import(\\"Random\\"); random-binomial!(10, 0.5)",
      "let { random-binomial! } = import(\\"Random\\"); random-binomial!(20, 0.3)"
    ],
    "noOperatorDocumentation": true
  },
  "Random.random-poisson!": {
    "title": "Random.random-poisson!",
    "category": "Random",
    "description": "Returns a random number from a Poisson distribution with the given rate parameter.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "lambda": {
        "type": "number",
        "description": "The rate parameter of the Poisson distribution."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "lambda"
        ]
      }
    ],
    "examples": [
      "let { random-poisson! } = import(\\"Random\\"); random-poisson!(1)",
      "let { random-poisson! } = import(\\"Random\\"); random-poisson!(5)"
    ]
  },
  "Random.random-gamma!": {
    "title": "Random.random-gamma!",
    "category": "Random",
    "description": "Returns a random number from a gamma distribution with the given shape and scale parameters.",
    "returns": {
      "type": "number"
    },
    "args": {
      "shape": {
        "type": "number",
        "description": "The shape parameter of the gamma distribution."
      },
      "scale": {
        "type": "number",
        "description": "The scale parameter of the gamma distribution."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "shape",
          "scale"
        ]
      }
    ],
    "examples": [
      "let { random-gamma! } = import(\\"Random\\"); random-gamma!(2, 2)",
      "let { random-gamma! } = import(\\"Random\\"); random-gamma!(5, 1)"
    ],
    "noOperatorDocumentation": true
  },
  "Random.random-pareto!": {
    "title": "Random.random-pareto!",
    "category": "Random",
    "description": "Returns a random number from a Pareto distribution with the given shape parameter.",
    "returns": {
      "type": "number"
    },
    "args": {
      "alpha": {
        "type": "number",
        "description": "The shape parameter of the Pareto distribution."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "alpha"
        ]
      }
    ],
    "examples": [
      "let { random-pareto! } = import(\\"Random\\"); random-pareto!(1)",
      "let { random-pareto! } = import(\\"Random\\"); random-pareto!(2)"
    ]
  },
  "Random.uuid!": {
    "title": "Random.uuid!",
    "category": "Random",
    "description": "Returns a random UUID v4 (Universally Unique Identifier).",
    "returns": {
      "type": "string"
    },
    "args": {},
    "variants": [
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { uuid! } = import(\\"Random\\"); uuid!()"
    ]
  },
  "Random.random-char!": {
    "title": "Random.random-char!",
    "category": "Random",
    "description": "Returns a random character from the given string.",
    "returns": {
      "type": "string"
    },
    "args": {
      "charSet": {
        "type": "string",
        "description": "The string to sample from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "charSet"
        ]
      }
    ],
    "examples": [
      "let { random-char! } = import(\\"Random\\"); random-char!(\\"abcde\\")",
      "let { random-char! } = import(\\"Random\\"); random-char!(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\")"
    ]
  },
  "Random.random-string!": {
    "title": "Random.random-string!",
    "category": "Random",
    "description": "Returns a random string of the given length from the given string.",
    "returns": {
      "type": "string"
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the random string."
      },
      "charSet": {
        "type": "string",
        "description": "The string to sample from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length",
          "charSet"
        ]
      }
    ],
    "examples": [
      "let { random-string! } = import(\\"Random\\"); random-string!(10, \\"abcde\\")",
      "let { random-string! } = import(\\"Random\\"); random-string!(5, \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\")"
    ],
    "noOperatorDocumentation": true
  },
  "Random.random-id!": {
    "title": "Random.random-id!",
    "category": "Random",
    "description": "Returns a random ID of the given length.",
    "returns": {
      "type": "string"
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the random ID."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { random-id! } = import(\\"Random\\"); random-id!(10)",
      "let { random-id! } = import(\\"Random\\"); random-id!(5)"
    ]
  },
  "Random.random-color!": {
    "title": "Random.random-color!",
    "category": "Random",
    "description": "Returns a random color in hex format.",
    "returns": {
      "type": "string"
    },
    "args": {},
    "variants": [
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { random-color! } = import(\\"Random\\"); random-color!()"
    ]
  },
  "Vector.monotonic?": {
    "title": "Vector.monotonic?",
    "category": "Vector",
    "description": "Checks if a vector is monotonic.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { monotonic? } = import(\\"Vector\\");\\nmonotonic?([1, 2, 3])",
      "let { monotonic? } = import(\\"Vector\\");\\nmonotonic?([1, 2, 2, 3])",
      "let { monotonic? } = import(\\"Vector\\");\\nmonotonic?([3, 2, 1])",
      "let { monotonic? } = import(\\"Vector\\");\\nmonotonic?([3, 2, 1, 1])",
      "let { monotonic? } = import(\\"Vector\\");\\nmonotonic?([3, 2, 1, 2])",
      "let { monotonic? } = import(\\"Vector\\");\\nmonotonic?([1])",
      "let { monotonic? } = import(\\"Vector\\");\\nmonotonic?([])"
    ]
  },
  "Vector.strictly-monotonic?": {
    "title": "Vector.strictly-monotonic?",
    "category": "Vector",
    "description": "Checks if a vector is strictly monotonic.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { strictly-monotonic? } = import(\\"Vector\\");\\nstrictly-monotonic?([1, 2, 3])",
      "let { strictly-monotonic? } = import(\\"Vector\\");\\nstrictly-monotonic?([1, 2, 2, 3])",
      "let { strictly-monotonic? } = import(\\"Vector\\");\\nstrictly-monotonic?([3, 2, 1])",
      "let { strictly-monotonic? } = import(\\"Vector\\");\\nstrictly-monotonic?([3, 2, 1, 1])",
      "let { strictly-monotonic? } = import(\\"Vector\\");\\nstrictly-monotonic?([3, 2, 1, 2])",
      "let { strictly-monotonic? } = import(\\"Vector\\");\\nstrictly-monotonic?([1])",
      "let { strictly-monotonic? } = import(\\"Vector\\");\\nstrictly-monotonic?([])"
    ]
  },
  "Vector.increasing?": {
    "title": "Vector.increasing?",
    "category": "Vector",
    "description": "Checks if a vector is increasing.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { increasing? } = import(\\"Vector\\");\\nincreasing?([1, 2, 3])",
      "let { increasing? } = import(\\"Vector\\");\\nincreasing?([1, 2, 2, 3])",
      "let { increasing? } = import(\\"Vector\\");\\nincreasing?([3, 2, 1])",
      "let { increasing? } = import(\\"Vector\\");\\nincreasing?([3, 2, 1, 1])",
      "let { increasing? } = import(\\"Vector\\");\\nincreasing?([3, 2, 1, 2])",
      "let { increasing? } = import(\\"Vector\\");\\nincreasing?([1])",
      "let { increasing? } = import(\\"Vector\\");\\nincreasing?([])"
    ]
  },
  "Vector.decreasing?": {
    "title": "Vector.decreasing?",
    "category": "Vector",
    "description": "Checks if a vector is decreasing.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { decreasing? } = import(\\"Vector\\");\\ndecreasing?([1, 2, 3])",
      "let { decreasing? } = import(\\"Vector\\");\\ndecreasing?([1, 2, 2, 3])",
      "let { decreasing? } = import(\\"Vector\\");\\ndecreasing?([3, 2, 1])",
      "let { decreasing? } = import(\\"Vector\\");\\ndecreasing?([3, 2, 1, 1])",
      "let { decreasing? } = import(\\"Vector\\");\\ndecreasing?([3, 2, 1, 2])",
      "let { decreasing? } = import(\\"Vector\\");\\ndecreasing?([1])",
      "let { decreasing? } = import(\\"Vector\\");\\ndecreasing?([])"
    ]
  },
  "Vector.strictly-increasing?": {
    "title": "Vector.strictly-increasing?",
    "category": "Vector",
    "description": "Checks if a vector is strictly increasing.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { strictly-increasing? } = import(\\"Vector\\");\\nstrictly-increasing?([1, 2, 3])",
      "let { strictly-increasing? } = import(\\"Vector\\");\\nstrictly-increasing?([1, 2, 2, 3])",
      "let { strictly-increasing? } = import(\\"Vector\\");\\nstrictly-increasing?([3, 2, 1])",
      "let { strictly-increasing? } = import(\\"Vector\\");\\nstrictly-increasing?([3, 2, 1, 1])",
      "let { strictly-increasing? } = import(\\"Vector\\");\\nstrictly-increasing?([3, 2, 1, 2])",
      "let { strictly-increasing? } = import(\\"Vector\\");\\nstrictly-increasing?([1])",
      "let { strictly-increasing? } = import(\\"Vector\\");\\nstrictly-increasing?([])"
    ]
  },
  "Vector.strictly-decreasing?": {
    "title": "Vector.strictly-decreasing?",
    "category": "Vector",
    "description": "Checks if a vector is strictly decreasing.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { strictly-decreasing? } = import(\\"Vector\\");\\nstrictly-decreasing?([1, 2, 3])",
      "let { strictly-decreasing? } = import(\\"Vector\\");\\nstrictly-decreasing?([1, 2, 2, 3])",
      "let { strictly-decreasing? } = import(\\"Vector\\");\\nstrictly-decreasing?([3, 2, 1])",
      "let { strictly-decreasing? } = import(\\"Vector\\");\\nstrictly-decreasing?([3, 2, 1, 1])",
      "let { strictly-decreasing? } = import(\\"Vector\\");\\nstrictly-decreasing?([3, 2, 1, 2])",
      "let { strictly-decreasing? } = import(\\"Vector\\");\\nstrictly-decreasing?([1])",
      "let { strictly-decreasing? } = import(\\"Vector\\");\\nstrictly-decreasing?([])"
    ]
  },
  "Vector.mode": {
    "title": "Vector.mode",
    "category": "Vector",
    "description": "Returns the mode of all elements in the vector.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to calculate the mode of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { mode } = import(\\"Vector\\");\\nmode([1, 2, 3])",
      "let { mode } = import(\\"Vector\\");\\nmode([1, 2, -3, 1])",
      "let { mode } = import(\\"Vector\\");\\nmode([2, 2, 3, 3, 4])",
      "let { mode } = import(\\"Vector\\");\\nmode([2, 2, 3, 3])",
      "let { mode } = import(\\"Vector\\");\\nmode([1, 2, 3, 2, 1, 2])"
    ]
  },
  "Vector.min-index": {
    "title": "Vector.min-index",
    "category": "Vector",
    "description": "Returns the index of the minimum value of all elements in the vector.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Non emtpy vector to calculate the minimum index of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { min-index } = import(\\"Vector\\");\\nmin-index([1, 2, 3])",
      "let { min-index } = import(\\"Vector\\");\\nmin-index([1, 1, 2, 3, 3])",
      "let { min-index } = import(\\"Vector\\");\\nmin-index([1, 2, -3])",
      "let { min-index } = import(\\"Vector\\");\\nmin-index([1, 2, 3, 4])",
      "let { min-index } = import(\\"Vector\\");\\nmin-index([1, 2, -3, 4])"
    ]
  },
  "Vector.max-index": {
    "title": "Vector.max-index",
    "category": "Vector",
    "description": "Returns the index of the maximum value of all elements in the vector.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Non emtpy vector to calculate the maximum index of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { max-index } = import(\\"Vector\\");\\nmax-index([1, 2, 3])",
      "let { max-index } = import(\\"Vector\\");\\nmax-index([1, 1, 2, 3, 3])",
      "let { max-index } = import(\\"Vector\\");\\nmax-index([1, 2, -3])",
      "let { max-index } = import(\\"Vector\\");\\nmax-index([1, 2, 3, 4])",
      "let { max-index } = import(\\"Vector\\");\\nmax-index([1, 2, -3, 4])"
    ]
  },
  "Vector.sort-indices": {
    "title": "Vector.sort-indices",
    "category": "Vector",
    "description": "Returns the indices of the elements in the vector sorted in ascending order.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Non emtpy vector to calculate the sorted indices of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { sort-indices } = import(\\"Vector\\");\\nsort-indices([1, 2, 3])",
      "let { sort-indices } = import(\\"Vector\\");\\nsort-indices([1, 1, 2, 3, 3])",
      "let { sort-indices } = import(\\"Vector\\");\\nsort-indices([1, 2, -3])",
      "let { sort-indices } = import(\\"Vector\\");\\nsort-indices([1, 2, 3, 4])",
      "let { sort-indices } = import(\\"Vector\\");\\nsort-indices([1, 2, -3, 4])"
    ]
  },
  "Vector.count-values": {
    "title": "Vector.count-values",
    "category": "Vector",
    "description": "Counts the number of occurrences of each value in the vector.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Vector to count the values of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { count-values } = import(\\"Vector\\");\\ncount-values([1, 2, 3])",
      "let { count-values } = import(\\"Vector\\");\\ncount-values([1, 1, 2, 3, 3])",
      "let { count-values } = import(\\"Vector\\");\\ncount-values([1, 2, -3])",
      "let { count-values } = import(\\"Vector\\");\\ncount-values([1, 2, 2, 1, 3, 2, 4, 2, 1, 2, 2, 1, 3, 2, 4])"
    ]
  },
  "Vector.linspace": {
    "title": "Vector.linspace",
    "category": "Vector",
    "description": "Generates a vector of evenly spaced numbers between two values.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "start": {
        "type": "number",
        "description": "The starting value."
      },
      "stop": {
        "type": "number",
        "description": "The ending value."
      },
      "n": {
        "type": "integer",
        "description": "The number of values to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start",
          "stop",
          "n"
        ]
      }
    ],
    "examples": [
      "let { linspace } = import(\\"Vector\\");\\nlinspace(0, 10, 6)",
      "let { linspace } = import(\\"Vector\\");\\nlinspace(10, 20, 25)"
    ]
  },
  "Vector.ones": {
    "title": "Vector.ones",
    "category": "Vector",
    "description": "Generates a vector of ones.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the vector."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { ones } = import(\\"Vector\\");\\nones(5)",
      "let { ones } = import(\\"Vector\\");\\nones(10)",
      "let { ones } = import(\\"Vector\\");\\nones(0)"
    ]
  },
  "Vector.zeros": {
    "title": "Vector.zeros",
    "category": "Vector",
    "description": "Generates a vector of zeros.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the vector."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { zeros } = import(\\"Vector\\");\\nzeros(5)",
      "let { zeros } = import(\\"Vector\\");\\nzeros(10)",
      "let { zeros } = import(\\"Vector\\");\\nzeros(0)"
    ]
  },
  "Vector.fill": {
    "title": "Vector.fill",
    "category": "Vector",
    "description": "Generates a vector filled with a number.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the vector."
      },
      "value": {
        "type": "number",
        "description": "The value to fill the vector with."
      },
      "a": {
        "type": "number"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length",
          "value"
        ]
      }
    ],
    "examples": [
      "let { fill } = import(\\"Vector\\");\\nfill(5, PI)",
      "let { fill } = import(\\"Vector\\");\\nfill(10, -1)"
    ]
  },
  "Vector.generate": {
    "title": "Vector.generate",
    "category": "Vector",
    "description": "Generates a vector of numbers based on a function.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the vector."
      },
      "func": {
        "type": "function",
        "description": "A function that takes an index and returns a number."
      },
      "a": {
        "type": "number"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length",
          "func"
        ]
      }
    ],
    "examples": [
      "let { generate } = import(\\"Vector\\");\\ngenerate(5, -> $ * 2)",
      "let { generate } = import(\\"Vector\\");\\ngenerate(10, -> $ + 1)",
      "let { generate } = import(\\"Vector\\");\\ngenerate(0, -> $ + 1)"
    ]
  },
  "Vector.cumsum": {
    "title": "Vector.cumsum",
    "category": "Vector",
    "description": "Calculates the cumulative sum of a vector.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to calculate the cumulative sum of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { cumsum } = import(\\"Vector\\");\\ncumsum([1, 2, 3])",
      "let { cumsum } = import(\\"Vector\\");\\ncumsum([1, 2, -3])",
      "let { cumsum } = import(\\"Vector\\");\\ncumsum([])"
    ]
  },
  "Vector.cumprod": {
    "title": "Vector.cumprod",
    "category": "Vector",
    "description": "Calculates the cumulative product of a vector.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to calculate the cumulative product of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { cumprod } = import(\\"Vector\\");\\ncumprod([1, 2, 3])",
      "let { cumprod } = import(\\"Vector\\");\\ncumprod([1, 2, -3, 0, 10])",
      "let { cumprod } = import(\\"Vector\\");\\ncumprod([])"
    ]
  },
  "Vector.quartiles": {
    "title": "Vector.quartiles",
    "category": "Vector",
    "description": "Calculates the quartiles of a vector. Returns an array containing the first, second (median), and third quartiles.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to calculate the quartiles of. Minimum length is 4."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { quartiles } = import(\\"Vector\\");\\nquartiles([1, 2, 3, 4])",
      "let { quartiles } = import(\\"Vector\\");\\nquartiles([5, 4, 3, 2, 1, 2, 3, 4, 5])",
      "let { quartiles } = import(\\"Vector\\");\\nquartiles(range(1, 1000))",
      "let { quartiles, generate } = import(\\"Vector\\");\\nquartiles(generate(1000, -> 1e6 / ($ + 1) ^ 2))",
      "let { quartiles, generate } = import(\\"Vector\\");\\nquartiles(generate(1000, -> ln($ + 1)))"
    ]
  },
  "Vector.percentile": {
    "title": "Vector.percentile",
    "category": "Vector",
    "description": "Calculates the percentile of a vector. Returns the value at the specified percentile.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The non empty vector to calculate the percentile of."
      },
      "percentile": {
        "type": "number",
        "description": "The percentile to calculate. Must be between 0 and 1."
      },
      "a": {
        "type": "number"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "percentile"
        ]
      }
    ],
    "examples": [
      "let { percentile } = import(\\"Vector\\");\\npercentile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 35)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 0)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 10)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 20)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 30)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 40)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 50)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 60)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 70)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 80)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 90)",
      "let { percentile } = import(\\"Vector\\");\\npercentile(range(100) ^ 0.5, 100)"
    ]
  },
  "Vector.quantile": {
    "title": "Vector.quantile",
    "category": "Vector",
    "description": "Calculates the quantile of a vector. Returns the value at the specified quantile.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The non empty vector to calculate the quantile of."
      },
      "quantile": {
        "type": "number",
        "description": "The quantile to calculate. Must be between 0 and 1."
      },
      "a": {
        "type": "number"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "quantile"
        ]
      }
    ],
    "examples": [
      "let { quantile } = import(\\"Vector\\");\\nquantile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0.35)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0.1)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0.2)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0.3)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0.4)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0.5)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0.6)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0.7)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0.8)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 0.9)",
      "let { quantile } = import(\\"Vector\\");\\nquantile(range(100) ^ 0.5, 1)"
    ]
  },
  "Vector.histogram": {
    "title": "Vector.histogram",
    "category": "Vector",
    "description": "Creates a histogram from a numeric \`array\` by dividing the data range into the specified number of bins. Returns an \`array\` of \`[binStart, binEnd, count]\` tuples representing each bin's range and the number of values within it. Handles empty arrays, identical values, and properly places maximum values in the last bin.",
    "returns": {
      "type": "array",
      "array": true
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The numeric array to create a histogram from."
      },
      "bins": {
        "type": "integer",
        "description": "The number of bins to divide the data range into."
      },
      "a": {
        "type": "number"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "bins"
        ]
      }
    ],
    "examples": [
      "let { histogram } = import(\\"Vector\\");\\nhistogram([1, 2, 2, 3, 2, 6, 4, 3, 2, 4, 1, 3, 2, 9], 3)",
      "let { histogram } = import(\\"Vector\\");\\nhistogram([1, 2, 3, 4, 5], 5)",
      "let { histogram } = import(\\"Vector\\");\\nhistogram([1, 2, 3, 4, 5], 10)",
      "let { histogram } = import(\\"Vector\\");\\nhistogram([1, 2, 3, 4, 5], 1)"
    ]
  },
  "Vector.ecdf": {
    "title": "Vector.ecdf",
    "category": "Vector",
    "description": "Calculates the empirical cumulative distribution function value for a given threshold in a non empty dataset. Returns the proportion of values in the \`array\` that are less than or equal to the specified threshold.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The numeric array to calculate the ECDF from."
      },
      "threshold": {
        "type": "number",
        "description": "The threshold value to calculate the ECDF for."
      },
      "a": {
        "type": "number"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "threshold"
        ]
      }
    ],
    "examples": [
      "let { ecdf } = import(\\"Vector\\");\\necdf([1, 2, 2, 3, 2, 6, 4, 3, 2, 4, 1, 3, 2, 9, 10, 12], 5)",
      "let { ecdf } = import(\\"Vector\\");\\necdf([1, 2, 3, 4, 5], 3)",
      "let { ecdf } = import(\\"Vector\\");\\necdf([1, 2, 3, 4, 5], 0)",
      "let { ecdf } = import(\\"Vector\\");\\necdf([1, 2, 3, 4, 5], 10)",
      "let { ecdf } = import(\\"Vector\\");\\necdf([1, 2, 3, 4, 5], 2)"
    ]
  },
  "Vector.outliers?": {
    "title": "Vector.outliers?",
    "category": "Vector",
    "description": "Checks if the \`vector\` contains outliers based on the interquartile range (IQR) method. Returns \`true\` if outliers are present, \`false\` otherwise.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to check for outliers."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { outliers? } = import(\\"Vector\\");\\noutliers?([1, 2, 3])",
      "let { outliers? } = import(\\"Vector\\");\\noutliers?([1, 2, -3])",
      "let { outliers? } = import(\\"Vector\\");\\noutliers?([1, 2, 3, 2, 4, 120])"
    ]
  },
  "Vector.outliers": {
    "title": "Vector.outliers",
    "category": "Vector",
    "description": "Identifies outliers in the \`vector\` based on the interquartile range (IQR) method. Returns an array of outlier values.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to check for outliers."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { outliers } = import(\\"Vector\\");\\noutliers([1, 2, 3])",
      "let { outliers } = import(\\"Vector\\");\\noutliers([1, 2, -3])",
      "let { outliers } = import(\\"Vector\\");\\noutliers([1, 2, 3, 2, 4, 120])"
    ]
  },
  "Vector.bincount": {
    "title": "Vector.bincount",
    "category": "Vector",
    "description": "counts occurrences of each \`integer\` in a vector, returning an array where index \`i\` contains the count of value \`i\`, with optional **minimum size** and **weights parameters**.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to count occurrences in."
      },
      "minSize": {
        "type": "integer",
        "description": "Optional minimum size of the output array."
      },
      "weights": {
        "type": "number",
        "array": true,
        "description": "Optional weights for each element in the vector."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "minSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "minSize",
          "weights"
        ]
      }
    ],
    "examples": [
      "let { bincount } = import(\\"Vector\\");\\nbincount([1, 2, 3])",
      "let { bincount } = import(\\"Vector\\");\\nbincount([1, 2, 2, 3, 3])"
    ],
    "noOperatorDocumentation": true
  },
  "Vector.winsorize": {
    "title": "Vector.winsorize",
    "category": "Vector",
    "description": "Limits extreme values in a \`vector\` by replacing values below the **lower quantile** and above the **upper quantile** with the values at those quantiles. The function takes a \`vector\` of values and **quantile thresholds** (between 0 and 1), with the upper quantile. Winsorization reduces the influence of outliers while preserving the overall distribution shape, making statistical analyses more robust.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to winsorize."
      },
      "lower-quantile": {
        "type": "number",
        "description": "The lower quantile threshold (between 0 and 1)."
      },
      "upper-quantile": {
        "type": "number",
        "description": "Optional Upper quantile threshold (between 0 and 1). Defaults to \`(1 - lower-quantile)\` if \`lower-quantile <= 0.5\` otherwise \`1\`."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "lower-quantile"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "lower-quantile",
          "upper-quantile"
        ]
      }
    ],
    "examples": [
      "let { winsorize } = import(\\"Vector\\");\\nwinsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25)",
      "let { winsorize } = import(\\"Vector\\");\\nwinsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25, 0.75)",
      "let { winsorize } = import(\\"Vector\\");\\nwinsorize([2, 5, 8, 10, 15, 18, 20, 35, 60, 100], 0.25, 0.5)"
    ],
    "noOperatorDocumentation": true
  },
  "Vector.mse": {
    "title": "Vector.mse",
    "category": "Vector",
    "description": "Calculates the **Mean Squared Error (MSE)** between two vectors. Returns the average of the squared differences between corresponding elements.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "The first vector."
      },
      "b": {
        "type": "vector",
        "description": "The second vector."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { mse } = import(\\"Vector\\");\\nmse([1, 2, 3], [1, 2, 3])",
      "let { mse } = import(\\"Vector\\");\\nmse([1, 2, 3], [4, 5, 6])",
      "let { mse } = import(\\"Vector\\");\\nmse([1, 2, 3], [2, 2, 2])",
      "let { mse } = import(\\"Vector\\");\\nmse([1, 2], [3, 3])",
      "let { mse } = import(\\"Vector\\");\\nmse([1], [3])"
    ]
  },
  "Vector.rmse": {
    "title": "Vector.rmse",
    "category": "Vector",
    "description": "Calculates the **Root Mean Squared Error (RMSE)** between two vectors. Returns the square root of the average of the squared differences between corresponding elements.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "The first vector."
      },
      "b": {
        "type": "vector",
        "description": "The second vector."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { rmse } = import(\\"Vector\\");\\nrmse([1, 2, 3], [1, 2, 3])",
      "let { rmse } = import(\\"Vector\\");\\nrmse([1, 2, 3], [4, 5, 6])",
      "let { rmse } = import(\\"Vector\\");\\nrmse([1, 2, 3], [2, 2, 2])",
      "let { rmse } = import(\\"Vector\\");\\nrmse([1, 2], [3, 3])",
      "let { rmse } = import(\\"Vector\\");\\nrmse([1], [3])"
    ]
  },
  "Vector.mae": {
    "title": "Vector.mae",
    "category": "Vector",
    "description": "Calculates the **Mean Absolute Error (MAE)** between two vectors. Returns the average of the absolute differences between corresponding elements.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "The first vector."
      },
      "b": {
        "type": "vector",
        "description": "The second vector."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { mae } = import(\\"Vector\\");\\nmae([1, 2, 3], [1, 2, 3])",
      "let { mae } = import(\\"Vector\\");\\nmae([1, 2, 3], [4, 5, 6])",
      "let { mae } = import(\\"Vector\\");\\nmae([1, 2, 3], [2, 2, 2])",
      "let { mae } = import(\\"Vector\\");\\nmae([1, 2], [3, 3])",
      "let { mae } = import(\\"Vector\\");\\nmae([1], [3])"
    ]
  },
  "Vector.smape": {
    "title": "Vector.smape",
    "category": "Vector",
    "description": "Calculates the **Symmetric Mean Absolute Percentage Error (SMAPE)** between two vectors. Returns the average of the absolute percentage differences between corresponding elements.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "The first vector."
      },
      "b": {
        "type": "vector",
        "description": "The second vector."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { smape } = import(\\"Vector\\");\\nsmape([1, 2, 3], [1, 2, 3])",
      "let { smape } = import(\\"Vector\\");\\nsmape([1, 2, 3], [4, 5, 6])",
      "let { smape } = import(\\"Vector\\");\\nsmape([1, 2, 3], [2, 2, 2])",
      "let { smape } = import(\\"Vector\\");\\nsmape([1, 2], [3, 3])",
      "let { smape } = import(\\"Vector\\");\\nsmape([1], [3])"
    ]
  },
  "Vector.mean": {
    "title": "Vector.mean",
    "category": "Vector",
    "description": "Returns the \`mean\` of all elements in the \`vector\`.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`mean\` of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { mean } = import(\\"Vector\\");\\nmean([1, 2, 3])",
      "let { mean } = import(\\"Vector\\");\\nmean([1, 2, -3])"
    ]
  },
  "Vector.moving-mean": {
    "title": "Vector.moving-mean",
    "category": "Vector",
    "description": "Returns the **moving mean** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving mean** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-mean } = import(\\"Vector\\");\\nmoving-mean([1, 2, 3, 4, 5], 3)",
      "let { moving-mean } = import(\\"Vector\\");\\nmoving-mean([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-mean": {
    "title": "Vector.centered-moving-mean",
    "category": "Vector",
    "description": "Returns the **centered moving mean** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving mean** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the centered moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-mean } = import(\\"Vector\\");\\ncentered-moving-mean([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-mean } = import(\\"Vector\\");\\ncentered-moving-mean([1, 2, 3, 4, 5], 3, 0, 10)",
      "let { centered-moving-mean } = import(\\"Vector\\");\\ncentered-moving-mean([1, 2, 3, 4, 5], 3, 10)"
    ]
  },
  "Vector.running-mean": {
    "title": "Vector.running-mean",
    "category": "Vector",
    "description": "Returns the **running mean** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running mean** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-mean } = import(\\"Vector\\");\\nrunning-mean([1, 2, 3, 4, 5])"
    ]
  },
  "Vector.geometric-mean": {
    "title": "Vector.geometric-mean",
    "category": "Vector",
    "description": "Returns the \`geometric mean\` of all elements in the \`vector\`.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`geometric mean\` of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { geometric-mean } = import(\\"Vector\\");\\ngeometric-mean([1, 2, 3])",
      "let { geometric-mean } = import(\\"Vector\\");\\ngeometric-mean([1, 2, 9])"
    ]
  },
  "Vector.moving-geometric-mean": {
    "title": "Vector.moving-geometric-mean",
    "category": "Vector",
    "description": "Returns the **moving geometric mean** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving geometric mean** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-geometric-mean } = import(\\"Vector\\");\\nmoving-geometric-mean([1, 2, 3, 4, 5], 3)",
      "let { moving-geometric-mean } = import(\\"Vector\\");\\nmoving-geometric-mean([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-geometric-mean": {
    "title": "Vector.centered-moving-geometric-mean",
    "category": "Vector",
    "description": "Returns the **centered moving geometric mean** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving geometric mean** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the centered moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-geometric-mean } = import(\\"Vector\\");\\ncentered-moving-geometric-mean([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-geometric-mean } = import(\\"Vector\\");\\ncentered-moving-geometric-mean([1, 2, 3, 4, 5], 3, 0, 10)",
      "let { centered-moving-geometric-mean } = import(\\"Vector\\");\\ncentered-moving-geometric-mean([1, 2, 3, 4, 5], 3, 10)"
    ]
  },
  "Vector.running-geometric-mean": {
    "title": "Vector.running-geometric-mean",
    "category": "Vector",
    "description": "Returns the **running geometric mean** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running geometric mean** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-geometric-mean } = import(\\"Vector\\");\\nrunning-geometric-mean([1, 2, 3, 4, 5])"
    ]
  },
  "Vector.harmonic-mean": {
    "title": "Vector.harmonic-mean",
    "category": "Vector",
    "description": "Returns the \`harmonic mean\` of all elements in the \`vector\`.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`harmonic mean\` of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { harmonic-mean } = import(\\"Vector\\");\\nharmonic-mean([1, 2, 3])",
      "let { harmonic-mean } = import(\\"Vector\\");\\nharmonic-mean([1, 2, 9])"
    ]
  },
  "Vector.moving-harmonic-mean": {
    "title": "Vector.moving-harmonic-mean",
    "category": "Vector",
    "description": "Returns the **moving harmonic mean** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving harmonic mean** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-harmonic-mean } = import(\\"Vector\\");\\nmoving-harmonic-mean([1, 2, 3, 4, 5], 3)",
      "let { moving-harmonic-mean } = import(\\"Vector\\");\\nmoving-harmonic-mean([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-harmonic-mean": {
    "title": "Vector.centered-moving-harmonic-mean",
    "category": "Vector",
    "description": "Returns the **centered moving harmonic mean** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving harmonic mean** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the centered moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-harmonic-mean } = import(\\"Vector\\");\\ncentered-moving-harmonic-mean([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-harmonic-mean } = import(\\"Vector\\");\\ncentered-moving-harmonic-mean([1, 2, 3, 4, 5], 3, 0, 10)",
      "let { centered-moving-harmonic-mean } = import(\\"Vector\\");\\ncentered-moving-harmonic-mean([1, 2, 3, 4, 5], 3, 10)"
    ]
  },
  "Vector.running-harmonic-mean": {
    "title": "Vector.running-harmonic-mean",
    "category": "Vector",
    "description": "Returns the **running harmonic mean** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running harmonic mean** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-harmonic-mean } = import(\\"Vector\\");\\nrunning-harmonic-mean([1, 2, 3, 4, 5])"
    ]
  },
  "Vector.median": {
    "title": "Vector.median",
    "category": "Vector",
    "description": "Returns the median of all elements in the vector.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to calculate the median of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { median } = import(\\"Vector\\");\\nmedian([1, 2, 3])",
      "let { median } = import(\\"Vector\\");\\nmedian([1, 2, -3])",
      "let { median } = import(\\"Vector\\");\\nmedian([1, 2, 3, 4])",
      "let { median } = import(\\"Vector\\");\\nmedian([1, 2, -3, 4])"
    ]
  },
  "Vector.moving-median": {
    "title": "Vector.moving-median",
    "category": "Vector",
    "description": "Returns the **moving median** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving median** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-median } = import(\\"Vector\\");\\nmoving-median([1, 2, 3, 4, 5], 3)",
      "let { moving-median } = import(\\"Vector\\");\\nmoving-median([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-median": {
    "title": "Vector.centered-moving-median",
    "category": "Vector",
    "description": "Returns the **centered moving median** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving median** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the centered moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-median } = import(\\"Vector\\");\\ncentered-moving-median([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-median } = import(\\"Vector\\");\\ncentered-moving-median([1, 2, 3, 4, 5], 3, 0, 10)",
      "let { centered-moving-median } = import(\\"Vector\\");\\ncentered-moving-median([1, 2, 3, 4, 5], 3, 10)"
    ]
  },
  "Vector.running-median": {
    "title": "Vector.running-median",
    "category": "Vector",
    "description": "Returns the **running median** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running median** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-median } = import(\\"Vector\\");\\nrunning-median([1, 2, 3, 4, 5])"
    ]
  },
  "Vector.sum": {
    "title": "Vector.sum",
    "category": "Vector",
    "description": "Returns the sum of all elements in the vector.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to sum."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { sum } = import(\\"Vector\\");\\nsum([1, 2, 3])",
      "let { sum } = import(\\"Vector\\");\\nsum([1, 2, -3])"
    ]
  },
  "Vector.moving-sum": {
    "title": "Vector.moving-sum",
    "category": "Vector",
    "description": "Returns the **moving sum** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving sum** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-sum } = import(\\"Vector\\");\\nmoving-sum([1, 2, 3, 4, 5], 3)",
      "let { moving-sum } = import(\\"Vector\\");\\nmoving-sum([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-sum": {
    "title": "Vector.centered-moving-sum",
    "category": "Vector",
    "description": "Returns the **centered moving sum** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving sum** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the centered moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-sum } = import(\\"Vector\\");\\ncentered-moving-sum([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-sum } = import(\\"Vector\\");\\ncentered-moving-sum([1, 2, 3, 4, 5], 3, 0, 0)",
      "let { centered-moving-sum } = import(\\"Vector\\");\\ncentered-moving-sum([1, 2, 3, 4, 5], 3, 10)"
    ]
  },
  "Vector.running-sum": {
    "title": "Vector.running-sum",
    "category": "Vector",
    "description": "Returns the **running sum** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running sum** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-sum } = import(\\"Vector\\");\\nrunning-sum([1, 2, 3])",
      "let { running-sum } = import(\\"Vector\\");\\nrunning-sum([1, -2, -3])"
    ]
  },
  "Vector.prod": {
    "title": "Vector.prod",
    "category": "Vector",
    "description": "Returns the \`product\` of all elements in the \`vector\`.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`product\` of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { prod } = import(\\"Vector\\");\\nprod([1, 2, 3])",
      "let { prod } = import(\\"Vector\\");\\nprod([1, 2, -3])"
    ]
  },
  "Vector.moving-prod": {
    "title": "Vector.moving-prod",
    "category": "Vector",
    "description": "Returns the **moving product** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving product** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-prod } = import(\\"Vector\\");\\nmoving-prod([1, 2, 3, 4, 5], 3)",
      "let { moving-prod } = import(\\"Vector\\");\\nmoving-prod([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-prod": {
    "title": "Vector.centered-moving-prod",
    "category": "Vector",
    "description": "Returns the **centered moving product** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving product** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-prod } = import(\\"Vector\\");\\ncentered-moving-prod([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-prod } = import(\\"Vector\\");\\ncentered-moving-prod([1, 2, 3, 4, 5], 3, 0, 0)"
    ]
  },
  "Vector.running-prod": {
    "title": "Vector.running-prod",
    "category": "Vector",
    "description": "Returns the **running product** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running product** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-prod } = import(\\"Vector\\");\\nrunning-prod([1, 2, 3, 4, 5])",
      "let { running-prod } = import(\\"Vector\\");\\nrunning-prod([1, -2, -3])"
    ]
  },
  "Vector.min": {
    "title": "Vector.min",
    "category": "Vector",
    "description": "Returns the minimum value of all elements in the vector.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Non emtpy vector to calculate the minimum of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "// Using \\"as\\" alias because \\"min\\" shadows a builtin function\\nlet { min as vec-min } = import(\\"Vector\\");\\nvec-min([1, 2, 3])",
      "// Using \\"as\\" alias because \\"min\\" shadows a builtin function\\nlet { min as vec-min } = import(\\"Vector\\");\\nvec-min([1, 1, 2, 3, 3])",
      "// Using \\"as\\" alias because \\"min\\" shadows a builtin function\\nlet { min as vec-min } = import(\\"Vector\\");\\nvec-min([1, 2, -3])",
      "// Using \\"as\\" alias because \\"min\\" shadows a builtin function\\nlet { min as vec-min } = import(\\"Vector\\");\\nvec-min([1, 2, 3, 4])",
      "// Using \\"as\\" alias because \\"min\\" shadows a builtin function\\nlet { min as vec-min } = import(\\"Vector\\");\\nvec-min([1, 2, -3, 4])"
    ]
  },
  "Vector.moving-min": {
    "title": "Vector.moving-min",
    "category": "Vector",
    "description": "Returns the **moving minimum** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving minimum** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-min } = import(\\"Vector\\");\\nmoving-min([1, 2, 3, 4, 5], 3)",
      "let { moving-min } = import(\\"Vector\\");\\nmoving-min([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-min": {
    "title": "Vector.centered-moving-min",
    "category": "Vector",
    "description": "Returns the **centered moving minimum** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving minimum** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-min } = import(\\"Vector\\");\\ncentered-moving-min([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-min } = import(\\"Vector\\");\\ncentered-moving-min([1, 2, 3, 4, 5], 3, 0, 100)",
      "let { centered-moving-min } = import(\\"Vector\\");\\ncentered-moving-min([1, 2, 3, 4, 5], 3, 0)"
    ]
  },
  "Vector.running-min": {
    "title": "Vector.running-min",
    "category": "Vector",
    "description": "Returns the **running minimum** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running minimum** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-min } = import(\\"Vector\\");\\nrunning-min([1, 2, 3])",
      "let { running-min } = import(\\"Vector\\");\\nrunning-min([1, -2, -3])"
    ]
  },
  "Vector.max": {
    "title": "Vector.max",
    "category": "Vector",
    "description": "Returns the maximum value of all elements in the vector.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Non emtpy vector to calculate the maximum of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "// Using \\"as\\" alias because \\"max\\" shadows a builtin function\\nlet { max as vec-max } = import(\\"Vector\\");\\nvec-max([1, 2, 3])",
      "// Using \\"as\\" alias because \\"max\\" shadows a builtin function\\nlet { max as vec-max } = import(\\"Vector\\");\\nvec-max([1, 1, 2, 3, 3])",
      "// Using \\"as\\" alias because \\"max\\" shadows a builtin function\\nlet { max as vec-max } = import(\\"Vector\\");\\nvec-max([1, 2, -3])",
      "// Using \\"as\\" alias because \\"max\\" shadows a builtin function\\nlet { max as vec-max } = import(\\"Vector\\");\\nvec-max([1, 2, 3, 4])",
      "// Using \\"as\\" alias because \\"max\\" shadows a builtin function\\nlet { max as vec-max } = import(\\"Vector\\");\\nvec-max([1, 2, -3, 4])"
    ]
  },
  "Vector.moving-max": {
    "title": "Vector.moving-max",
    "category": "Vector",
    "description": "Returns the **moving maximum** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving maximum** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-max } = import(\\"Vector\\");\\nmoving-max([1, 2, 3, 4, 5], 3)",
      "let { moving-max } = import(\\"Vector\\");\\nmoving-max([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-max": {
    "title": "Vector.centered-moving-max",
    "category": "Vector",
    "description": "Returns the **centered moving maximum** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving maximum** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-max } = import(\\"Vector\\");\\ncentered-moving-max([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-max } = import(\\"Vector\\");\\ncentered-moving-max([1, 2, 3, 4, 5], 3, 0, 100)",
      "let { centered-moving-max } = import(\\"Vector\\");\\ncentered-moving-max([1, 2, 3, 4, 5], 3, 0)"
    ]
  },
  "Vector.running-max": {
    "title": "Vector.running-max",
    "category": "Vector",
    "description": "Returns the **running maximum** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running maximum** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-max } = import(\\"Vector\\");\\nrunning-max([1, 2, 3])",
      "let { running-max } = import(\\"Vector\\");\\nrunning-max([1, -2, -3])"
    ]
  },
  "Vector.variance": {
    "title": "Vector.variance",
    "category": "Vector",
    "description": "Returns the \`variance\` of all elements in the \`vector\`.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`variance\` of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { variance } = import(\\"Vector\\");\\nvariance([1, 2, 3])",
      "let { variance } = import(\\"Vector\\");\\nvariance([1, 2, -3])"
    ]
  },
  "Vector.moving-variance": {
    "title": "Vector.moving-variance",
    "category": "Vector",
    "description": "Returns the **moving variance** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving variance** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-variance } = import(\\"Vector\\");\\nmoving-variance([1, 2, 3, 4, 5], 3)",
      "let { moving-variance } = import(\\"Vector\\");\\nmoving-variance([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-variance": {
    "title": "Vector.centered-moving-variance",
    "category": "Vector",
    "description": "Returns the **centered moving variance** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving variance** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the centered moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-variance } = import(\\"Vector\\");\\ncentered-moving-variance([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-variance } = import(\\"Vector\\");\\ncentered-moving-variance([1, 2, 3, 4, 5], 3, 1)",
      "let { centered-moving-variance } = import(\\"Vector\\");\\ncentered-moving-variance([1, 2, 3, 4, 5], 3, 1, 5)",
      "let { centered-moving-variance } = import(\\"Vector\\");\\ncentered-moving-variance([1, 2, 3, 4, 5], 3, 0, 6)"
    ]
  },
  "Vector.running-variance": {
    "title": "Vector.running-variance",
    "category": "Vector",
    "description": "Returns the **running variance** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running variance** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-variance } = import(\\"Vector\\");\\nrunning-variance([1, 2, 3, 4, 5])"
    ]
  },
  "Vector.sample-variance": {
    "title": "Vector.sample-variance",
    "category": "Vector",
    "description": "Returns the sample variance of all elements in the vector.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Non emtpy vector to calculate the sample variance of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { sample-variance } = import(\\"Vector\\");\\nsample-variance([1, 2, 3])",
      "let { sample-variance } = import(\\"Vector\\");\\nsample-variance([1, 2, -3])",
      "let { sample-variance } = import(\\"Vector\\");\\nsample-variance([1, 2, 3, 4])",
      "let { sample-variance } = import(\\"Vector\\");\\nsample-variance([1, 2, -3, 4])",
      "let { sample-variance } = import(\\"Vector\\");\\nsample-variance([1, 2, 3, 40, 50])"
    ]
  },
  "Vector.moving-sample-variance": {
    "title": "Vector.moving-sample-variance",
    "category": "Vector",
    "description": "Returns the **moving sample variance** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving sample variance** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-sample-variance } = import(\\"Vector\\");\\nmoving-sample-variance([1, 2, 3, 4, 5], 3)",
      "let { moving-sample-variance } = import(\\"Vector\\");\\nmoving-sample-variance([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-sample-variance": {
    "title": "Vector.centered-moving-sample-variance",
    "category": "Vector",
    "description": "Returns the **centered moving sample variance** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving sample variance** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the centered moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-sample-variance } = import(\\"Vector\\");\\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-sample-variance } = import(\\"Vector\\");\\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3, 1)",
      "let { centered-moving-sample-variance } = import(\\"Vector\\");\\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3, 1, 5)",
      "let { centered-moving-sample-variance } = import(\\"Vector\\");\\ncentered-moving-sample-variance([1, 2, 3, 4, 5], 3, 0, 6)"
    ]
  },
  "Vector.running-sample-variance": {
    "title": "Vector.running-sample-variance",
    "category": "Vector",
    "description": "Returns the **running sample variance** of the \`vector\`.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running sample variance** of. First element in result is \`null\` since **sample variance** is not defined for a single element."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-sample-variance } = import(\\"Vector\\");\\nrunning-sample-variance([1, 2, 3, 4, 5])"
    ]
  },
  "Vector.stdev": {
    "title": "Vector.stdev",
    "category": "Vector",
    "description": "Returns the standard deviation of all elements in the vector.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Non emtpy vector to calculate the standard deviation of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { stdev } = import(\\"Vector\\");\\nstdev([1, 2, 3])",
      "let { stdev } = import(\\"Vector\\");\\nstdev([1, 2, -3])",
      "let { stdev } = import(\\"Vector\\");\\nstdev([1, 2, 3, 4])",
      "let { stdev } = import(\\"Vector\\");\\nstdev([1, 2, -3, 4])",
      "let { stdev } = import(\\"Vector\\");\\nstdev([1, 2, 3, 40, 50])"
    ]
  },
  "Vector.moving-stdev": {
    "title": "Vector.moving-stdev",
    "category": "Vector",
    "description": "Returns the **moving standard deviation** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving standard deviation** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-stdev } = import(\\"Vector\\");\\nmoving-stdev([1, 2, 3, 4, 5], 3)",
      "let { moving-stdev } = import(\\"Vector\\");\\nmoving-stdev([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-stdev": {
    "title": "Vector.centered-moving-stdev",
    "category": "Vector",
    "description": "Returns the **centered moving standard deviation** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving standard deviation** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the centered moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-stdev } = import(\\"Vector\\");\\ncentered-moving-stdev([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-stdev } = import(\\"Vector\\");\\ncentered-moving-stdev([1, 2, 3, 4, 5], 3, 1)",
      "let { centered-moving-stdev } = import(\\"Vector\\");\\ncentered-moving-stdev([1, 2, 3, 4, 5], 3, 1, 5)",
      "let { centered-moving-stdev } = import(\\"Vector\\");\\ncentered-moving-stdev([1, 2, 3, 4, 5], 3, 0, 6)"
    ]
  },
  "Vector.running-stdev": {
    "title": "Vector.running-stdev",
    "category": "Vector",
    "description": "Returns the **running standard deviation** of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running standard deviation** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-stdev } = import(\\"Vector\\");\\nrunning-stdev([1, 2, 3, 4, 5])"
    ]
  },
  "Vector.sample-stdev": {
    "title": "Vector.sample-stdev",
    "category": "Vector",
    "description": "Returns the sample standard deviation of all elements in the vector.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Non emtpy vector to calculate the sample standard deviation of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { sample-stdev } = import(\\"Vector\\");\\nsample-stdev([1, 2, 3])",
      "let { sample-stdev } = import(\\"Vector\\");\\nsample-stdev([1, 2, -3])",
      "let { sample-stdev } = import(\\"Vector\\");\\nsample-stdev([1, 2, 3, 4])",
      "let { sample-stdev } = import(\\"Vector\\");\\nsample-stdev([1, 2, -3, 4])",
      "let { sample-stdev } = import(\\"Vector\\");\\nsample-stdev([1, 2, 3, 40, 50])"
    ]
  },
  "Vector.moving-sample-stdev": {
    "title": "Vector.moving-sample-stdev",
    "category": "Vector",
    "description": "Returns the **moving sample standard deviation** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving sample standard deviation** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-sample-stdev } = import(\\"Vector\\");\\nmoving-sample-stdev([1, 2, 3, 4, 5], 3)",
      "let { moving-sample-stdev } = import(\\"Vector\\");\\nmoving-sample-stdev([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-sample-stdev": {
    "title": "Vector.centered-moving-sample-stdev",
    "category": "Vector",
    "description": "Returns the **centered moving sample standard deviation** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving sample standard deviation** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the centered moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-sample-stdev } = import(\\"Vector\\");\\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-sample-stdev } = import(\\"Vector\\");\\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 1)",
      "let { centered-moving-sample-stdev } = import(\\"Vector\\");\\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 1, 5)",
      "let { centered-moving-sample-stdev } = import(\\"Vector\\");\\ncentered-moving-sample-stdev([1, 2, 3, 4, 5], 3, 0, 6)"
    ]
  },
  "Vector.running-sample-stdev": {
    "title": "Vector.running-sample-stdev",
    "category": "Vector",
    "description": "Returns the **running sample standard deviation** of the \`vector\`.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running sample standard deviation** of. First element in result is \`null\` since **sample standard deviation** is not defined for a single element."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-sample-stdev } = import(\\"Vector\\");\\nrunning-sample-stdev([1, 2, 3, 4, 5])"
    ]
  },
  "Vector.iqr": {
    "title": "Vector.iqr",
    "category": "Vector",
    "description": "Calculates the **interquartile range** of a \`vector\`. Returns the difference between the third and first quartiles.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **interquartile range** of. Minimum length is 4."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { iqr } = import(\\"Vector\\");\\niqr([1, 2, 3, 4])",
      "let { iqr } = import(\\"Vector\\");\\niqr([5, 4, 3, 2, 1, 2, 3, 4, 5])",
      "let { iqr } = import(\\"Vector\\");\\niqr(range(1, 1000))",
      "let { iqr, generate } = import(\\"Vector\\");\\niqr(generate(1000, -> 1e6 / ($ + 1) ^ 2))",
      "let { iqr, generate } = import(\\"Vector\\");\\niqr(generate(1000, -> ln($ + 1)))"
    ]
  },
  "Vector.moving-iqr": {
    "title": "Vector.moving-iqr",
    "category": "Vector",
    "description": "Calculates the **moving interquartile range** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving interquartile range** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-iqr } = import(\\"Vector\\");\\nmoving-iqr([1, 2, 4, 7, 11, 16], 4)",
      "let { moving-iqr } = import(\\"Vector\\");\\nmoving-iqr([1, 2, 4, 7, 11, 16], 5)",
      "let { moving-iqr } = import(\\"Vector\\");\\nmoving-iqr([1, 2, 4, 7, 11, 16], 6)"
    ]
  },
  "Vector.centered-moving-iqr": {
    "title": "Vector.centered-moving-iqr",
    "category": "Vector",
    "description": "Calculates the **centered moving interquartile range** of a \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving interquartile range** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-iqr } = import(\\"Vector\\");\\ncentered-moving-iqr([1, 2, 4, 7, 11, 16], 4)",
      "let { centered-moving-iqr } = import(\\"Vector\\");\\ncentered-moving-iqr([1, 2, 4, 7, 11, 16], 4, 0, 0)"
    ]
  },
  "Vector.running-iqr": {
    "title": "Vector.running-iqr",
    "category": "Vector",
    "description": "Calculates the **running interquartile range** of a \`vector\`. First three element in result is \`null\` since **running interquartile range** is not defined for less than four elements.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running interquartile range** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-iqr } = import(\\"Vector\\");\\nrunning-iqr([1, 2, 3, 4, 5, 6])",
      "let { running-iqr } = import(\\"Vector\\");\\nrunning-iqr([-1, -2, -3, 1, 2, 3])"
    ]
  },
  "Vector.span": {
    "title": "Vector.span",
    "category": "Vector",
    "description": "Returns the difference between the maximum and minimum values in a vector.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The vector to calculate the span of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { span } = import(\\"Vector\\");\\nspan([1, 2, 3])",
      "let { span } = import(\\"Vector\\");\\nspan([1, 1, 2, 3, 3])",
      "let { span } = import(\\"Vector\\");\\nspan([1, 2, -3])"
    ]
  },
  "Vector.moving-span": {
    "title": "Vector.moving-span",
    "category": "Vector",
    "description": "Calculates the **moving span** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving span** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-span } = import(\\"Vector\\");\\nmoving-span([1, 2, 4, 7, 11, 16], 4)",
      "let { moving-span } = import(\\"Vector\\");\\nmoving-span([1, 2, 4, 7, 11, 16], 5)",
      "let { moving-span } = import(\\"Vector\\");\\nmoving-span([1, 2, 4, 7, 11, 16], 6)"
    ]
  },
  "Vector.centered-moving-span": {
    "title": "Vector.centered-moving-span",
    "category": "Vector",
    "description": "Calculates the **centered moving span** of a \`vector\` with a given window size. The result is padded with \`leftPadding\` on the left and right.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving span** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "The value to pad the result with on the left."
      },
      "rightPadding": {
        "type": "number",
        "description": "The value to pad the result with on the right."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-span } = import(\\"Vector\\");\\ncentered-moving-span([1, 2, 4, 7, 11, 16], 4)",
      "let { centered-moving-span } = import(\\"Vector\\");\\ncentered-moving-span([1, 2, 4, 7, 11, 16], 3, 0, 100)"
    ]
  },
  "Vector.running-span": {
    "title": "Vector.running-span",
    "category": "Vector",
    "description": "Calculates the **running span** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running span** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-span } = import(\\"Vector\\");\\nrunning-span([1, 2, 4])"
    ]
  },
  "Vector.skewness": {
    "title": "Vector.skewness",
    "category": "Vector",
    "description": "Calculates the **skewness** of a \`vector\`. Returns the third standardized moment.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **skewness** of. Minimum length is 3."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { skewness } = import(\\"Vector\\");\\nskewness([1, 2, 3, 6, 20])",
      "let { skewness } = import(\\"Vector\\");\\nskewness([1, 2, 2, 3])"
    ]
  },
  "Vector.moving-skewness": {
    "title": "Vector.moving-skewness",
    "category": "Vector",
    "description": "Calculates the **moving skewness** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving skewness** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-skewness } = import(\\"Vector\\");\\nmoving-skewness([1, 2, 4, 7, 11, 16], 4)",
      "let { moving-skewness } = import(\\"Vector\\");\\nmoving-skewness([1, 2, 4, 7, 11, 16], 5)"
    ]
  },
  "Vector.centered-moving-skewness": {
    "title": "Vector.centered-moving-skewness",
    "category": "Vector",
    "description": "Calculates the **centered moving skewness** of a \`vector\` with a given window size and padding.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving skewness** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-skewness } = import(\\"Vector\\");\\ncentered-moving-skewness([1, 2, 4, 7, 11, 16], 4)",
      "let { centered-moving-skewness } = import(\\"Vector\\");\\ncentered-moving-skewness([1, 2, 4, 7, 11, 16], 4, 0, 0)"
    ]
  },
  "Vector.running-skewness": {
    "title": "Vector.running-skewness",
    "category": "Vector",
    "description": "Calculates the **running skewness** of a \`vector\` with a given window size. First two element in result is \`null\` since **running skewness** is not defined for less than three elements.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running skewness** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-skewness } = import(\\"Vector\\");\\nrunning-skewness([1, 2, 4, 7, 11])"
    ]
  },
  "Vector.sample-skewness": {
    "title": "Vector.sample-skewness",
    "category": "Vector",
    "description": "Calculates the **sample skewness** of a \`vector\`. Returns the third standardized moment.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **sample skewness** of. Minimum length is 3."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { sample-skewness } = import(\\"Vector\\");\\nsample-skewness([1, 2, 3, 6, 20])",
      "let { sample-skewness } = import(\\"Vector\\");\\nsample-skewness([1, 2, 2, 3])"
    ]
  },
  "Vector.moving-sample-skewness": {
    "title": "Vector.moving-sample-skewness",
    "category": "Vector",
    "description": "Calculates the **moving sample skewness** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving sample skewness** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-sample-skewness } = import(\\"Vector\\");\\nmoving-sample-skewness([1, 2, 4, 7, 11, 16], 4)",
      "let { moving-sample-skewness } = import(\\"Vector\\");\\nmoving-sample-skewness([1, 2, 4, 7, 11, 16], 5)"
    ]
  },
  "Vector.centered-moving-sample-skewness": {
    "title": "Vector.centered-moving-sample-skewness",
    "category": "Vector",
    "description": "Calculates the **centered moving sample skewness** of a \`vector\` with a given window size and padding.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving sample skewness** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-sample-skewness } = import(\\"Vector\\");\\ncentered-moving-sample-skewness([1, 2, 4, 7, 11, 16], 4)",
      "let { centered-moving-sample-skewness } = import(\\"Vector\\");\\ncentered-moving-sample-skewness([1, 2, 4, 7, 11, 16], 3, 0, 100)"
    ]
  },
  "Vector.running-sample-skewness": {
    "title": "Vector.running-sample-skewness",
    "category": "Vector",
    "description": "Calculates the **running sample skewness** of a \`vector\` with a given window size. First two element in result is \`null\` since **running sample skewness** is not defined for less than three elements.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running sample skewness** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-sample-skewness } = import(\\"Vector\\");\\nrunning-sample-skewness([1, 2, 4, 7, 11])"
    ]
  },
  "Vector.excess-kurtosis": {
    "title": "Vector.excess-kurtosis",
    "category": "Vector",
    "description": "Calculates the **excess kurtosis** of a \`vector\`. Returns the third standardized moment.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **excess kurtosis** of. Minimum length is 3."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { excess-kurtosis } = import(\\"Vector\\");\\nexcess-kurtosis([1, 2, 3, 6, 20])",
      "let { excess-kurtosis } = import(\\"Vector\\");\\nexcess-kurtosis([1, 2, 2, 3])"
    ]
  },
  "Vector.moving-excess-kurtosis": {
    "title": "Vector.moving-excess-kurtosis",
    "category": "Vector",
    "description": "Calculates the **moving excess kurtosis** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving excess kurtosis** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-excess-kurtosis } = import(\\"Vector\\");\\nmoving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)",
      "let { moving-excess-kurtosis } = import(\\"Vector\\");\\nmoving-excess-kurtosis([1, 2, 4, 7, 11, 16], 5)"
    ]
  },
  "Vector.centered-moving-excess-kurtosis": {
    "title": "Vector.centered-moving-excess-kurtosis",
    "category": "Vector",
    "description": "Calculates the **centered moving excess kurtosis** of a \`vector\` with a given window size and padding.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving excess kurtosis** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-excess-kurtosis } = import(\\"Vector\\");\\ncentered-moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)",
      "let { centered-moving-excess-kurtosis } = import(\\"Vector\\");\\ncentered-moving-excess-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 0)"
    ]
  },
  "Vector.running-excess-kurtosis": {
    "title": "Vector.running-excess-kurtosis",
    "category": "Vector",
    "description": "Calculates the **running excess kurtosis** of a \`vector\` with a given window size. First two element in result is \`null\` since **running excess kurtosis** is not defined for less than three elements.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running excess kurtosis** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-excess-kurtosis } = import(\\"Vector\\");\\nrunning-excess-kurtosis([1, 2, 4, 7, 11])"
    ]
  },
  "Vector.kurtosis": {
    "title": "Vector.kurtosis",
    "category": "Vector",
    "description": "Calculates the **kurtosis** of a \`vector\`. Returns the third standardized moment.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **kurtosis** of. Minimum length is 3."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { kurtosis } = import(\\"Vector\\");\\nkurtosis([1, 2, 3, 6, 20])",
      "let { kurtosis } = import(\\"Vector\\");\\nkurtosis([1, 2, 2, 3])"
    ]
  },
  "Vector.moving-kurtosis": {
    "title": "Vector.moving-kurtosis",
    "category": "Vector",
    "description": "Calculates the **moving kurtosis** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving kurtosis** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-kurtosis } = import(\\"Vector\\");\\nmoving-kurtosis([1, 2, 4, 7, 11, 16], 4)",
      "let { moving-kurtosis } = import(\\"Vector\\");\\nmoving-kurtosis([1, 2, 4, 7, 11, 16], 5)"
    ]
  },
  "Vector.centered-moving-kurtosis": {
    "title": "Vector.centered-moving-kurtosis",
    "category": "Vector",
    "description": "Calculates the **centered moving kurtosis** of a \`vector\` with a given window size and padding.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving kurtosis** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-kurtosis } = import(\\"Vector\\");\\ncentered-moving-kurtosis([1, 2, 4, 7, 11, 16], 4)",
      "let { centered-moving-kurtosis } = import(\\"Vector\\");\\ncentered-moving-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 0)"
    ]
  },
  "Vector.running-kurtosis": {
    "title": "Vector.running-kurtosis",
    "category": "Vector",
    "description": "Calculates the **running kurtosis** of a \`vector\` with a given window size. First two element in result is \`null\` since **running kurtosis** is not defined for less than three elements.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running kurtosis** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-kurtosis } = import(\\"Vector\\");\\nrunning-kurtosis([1, 2, 4, 7, 11])"
    ]
  },
  "Vector.sample-excess-kurtosis": {
    "title": "Vector.sample-excess-kurtosis",
    "category": "Vector",
    "description": "Calculates the **sample excess kurtosis** of a \`vector\`. Returns the third standardized moment.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **sample excess kurtosis** of. Minimum length is 3."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { sample-excess-kurtosis } = import(\\"Vector\\");\\nsample-excess-kurtosis([1, 2, 3, 6, 20])",
      "let { sample-excess-kurtosis } = import(\\"Vector\\");\\nsample-excess-kurtosis([1, 2, 2, 3])"
    ]
  },
  "Vector.moving-sample-excess-kurtosis": {
    "title": "Vector.moving-sample-excess-kurtosis",
    "category": "Vector",
    "description": "Calculates the **moving sample excess kurtosis** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving sample excess kurtosis** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-sample-excess-kurtosis } = import(\\"Vector\\");\\nmoving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)",
      "let { moving-sample-excess-kurtosis } = import(\\"Vector\\");\\nmoving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 5)"
    ]
  },
  "Vector.centered-moving-sample-excess-kurtosis": {
    "title": "Vector.centered-moving-sample-excess-kurtosis",
    "category": "Vector",
    "description": "Calculates the **centered moving sample excess kurtosis** of a \`vector\` with a given window size and padding.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving sample excess kurtosis** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-sample-excess-kurtosis } = import(\\"Vector\\");\\ncentered-moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4)",
      "let { centered-moving-sample-excess-kurtosis } = import(\\"Vector\\");\\ncentered-moving-sample-excess-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 100)"
    ]
  },
  "Vector.running-sample-excess-kurtosis": {
    "title": "Vector.running-sample-excess-kurtosis",
    "category": "Vector",
    "description": "Calculates the **running sample excess kurtosis** of a \`vector\` with a given window size. First two element in result is \`null\` since **running sample excess kurtosis** is not defined for less than three elements.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running sample excess kurtosis** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-sample-excess-kurtosis } = import(\\"Vector\\");\\nrunning-sample-excess-kurtosis([1, 2, 4, 7, 11])"
    ]
  },
  "Vector.sample-kurtosis": {
    "title": "Vector.sample-kurtosis",
    "category": "Vector",
    "description": "Calculates the **sample kurtosis** of a \`vector\`. Returns the third standardized moment.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **sample kurtosis** of. Minimum length is 3."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { sample-kurtosis } = import(\\"Vector\\");\\nsample-kurtosis([1, 2, 3, 6, 20])",
      "let { sample-kurtosis } = import(\\"Vector\\");\\nsample-kurtosis([1, 2, 2, 3])"
    ]
  },
  "Vector.moving-sample-kurtosis": {
    "title": "Vector.moving-sample-kurtosis",
    "category": "Vector",
    "description": "Calculates the **moving sample kurtosis** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving sample kurtosis** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-sample-kurtosis } = import(\\"Vector\\");\\nmoving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4)",
      "let { moving-sample-kurtosis } = import(\\"Vector\\");\\nmoving-sample-kurtosis([1, 2, 4, 7, 11, 16], 5)"
    ]
  },
  "Vector.centered-moving-sample-kurtosis": {
    "title": "Vector.centered-moving-sample-kurtosis",
    "category": "Vector",
    "description": "Calculates the **centered moving sample kurtosis** of a \`vector\` with a given window size and padding.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving sample kurtosis** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-sample-kurtosis } = import(\\"Vector\\");\\ncentered-moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4)",
      "let { centered-moving-sample-kurtosis } = import(\\"Vector\\");\\ncentered-moving-sample-kurtosis([1, 2, 4, 7, 11, 16], 4, 0, 100)"
    ]
  },
  "Vector.running-sample-kurtosis": {
    "title": "Vector.running-sample-kurtosis",
    "category": "Vector",
    "description": "Calculates the **running sample kurtosis** of a \`vector\` with a given window size. First two element in result is \`null\` since **running sample kurtosis** is not defined for less than three elements.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running sample kurtosis** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-sample-kurtosis } = import(\\"Vector\\");\\nrunning-sample-kurtosis([1, 2, 4, 7, 11])"
    ]
  },
  "Vector.rms": {
    "title": "Vector.rms",
    "category": "Vector",
    "description": "Calculates the **root mean square** of a \`vector\`. Returns the square root of the average of the squares of the elements.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **root mean square** of. Minimum length is 1."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { rms } = import(\\"Vector\\");\\nrms([1, 2, 3, 4])",
      "let { rms } = import(\\"Vector\\");\\nrms([5, 4, 3, 2, 1])",
      "let { rms } = import(\\"Vector\\");\\nrms(range(1, 1000))",
      "let { rms, generate } = import(\\"Vector\\");\\nrms(generate(1000, -> 1e6 / ($ + 1) ^ 2))",
      "let { rms, generate } = import(\\"Vector\\");\\nrms(generate(1000, -> ln($ + 1)))"
    ]
  },
  "Vector.moving-rms": {
    "title": "Vector.moving-rms",
    "category": "Vector",
    "description": "Calculates the **moving root mean square** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving root mean square** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-rms } = import(\\"Vector\\");\\nmoving-rms([1, 2, 4, 7, 11, 16], 4)",
      "let { moving-rms } = import(\\"Vector\\");\\nmoving-rms([1, 2, 4, 7, 11, 16], 5)",
      "let { moving-rms } = import(\\"Vector\\");\\nmoving-rms([1, 2, 4, 7, 11, 16], 6)"
    ]
  },
  "Vector.centered-moving-rms": {
    "title": "Vector.centered-moving-rms",
    "category": "Vector",
    "description": "Calculates the **centered moving root mean square** of a \`vector\` with a given window size and padding value.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving root mean square** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-rms } = import(\\"Vector\\");\\ncentered-moving-rms([1, 2, 4, 7, 11, 16], 4)",
      "let { centered-moving-rms } = import(\\"Vector\\");\\ncentered-moving-rms([1, 2, 4, 7, 11, 16], 5, 0)",
      "let { centered-moving-rms } = import(\\"Vector\\");\\ncentered-moving-rms([1, 2, 4, 7, 11, 16], 6, 0, 0)"
    ]
  },
  "Vector.running-rms": {
    "title": "Vector.running-rms",
    "category": "Vector",
    "description": "Calculates the **running root mean square** of a \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running root mean square** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-rms } = import(\\"Vector\\");\\nrunning-rms([1, 2, 3, 4, 5, 6])",
      "let { running-rms } = import(\\"Vector\\");\\nrunning-rms([1, -3, 2])",
      "let { running-rms } = import(\\"Vector\\");\\nrunning-rms([-1, -2, -3])",
      "let { running-rms } = import(\\"Vector\\");\\nrunning-rms([0])"
    ]
  },
  "Vector.mad": {
    "title": "Vector.mad",
    "category": "Vector",
    "description": "Returns the \`mean absolute deviation\` of all elements in the \`vector\`.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`mean absolute deviation\` of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { mad } = import(\\"Vector\\");\\nmad([1, 2, 3])",
      "let { mad } = import(\\"Vector\\");\\nmad([1, 2, -3])"
    ]
  },
  "Vector.moving-mad": {
    "title": "Vector.moving-mad",
    "category": "Vector",
    "description": "Returns the \`moving mean absolute deviation\` of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`moving mean absolute deviation\` of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-mad } = import(\\"Vector\\");\\nmoving-mad([1, 2, 3, 4, 5], 3)",
      "let { moving-mad } = import(\\"Vector\\");\\nmoving-mad([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-mad": {
    "title": "Vector.centered-moving-mad",
    "category": "Vector",
    "description": "Returns the \`centered moving mean absolute deviation\` of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`centered moving mean absolute deviation\` of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-mad } = import(\\"Vector\\");\\ncentered-moving-mad([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-mad } = import(\\"Vector\\");\\ncentered-moving-mad([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.running-mad": {
    "title": "Vector.running-mad",
    "category": "Vector",
    "description": "Returns the \`running mean absolute deviation\` of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`running mean absolute deviation\` of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-mad } = import(\\"Vector\\");\\nrunning-mad([1, 2, 3])",
      "let { running-mad } = import(\\"Vector\\");\\nrunning-mad([1, 2, -3])"
    ]
  },
  "Vector.medad": {
    "title": "Vector.medad",
    "category": "Vector",
    "description": "Returns the \`median absolute deviation\` of all elements in the \`vector\`.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`median absolute deviation\` of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { medad } = import(\\"Vector\\");\\nmedad([1, 2, 3])",
      "let { medad } = import(\\"Vector\\");\\nmedad([1, 2, -3])"
    ]
  },
  "Vector.moving-medad": {
    "title": "Vector.moving-medad",
    "category": "Vector",
    "description": "Returns the \`moving median absolute deviation\` of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`moving median absolute deviation\` of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-medad } = import(\\"Vector\\");\\nmoving-medad([1, 2, 3, 4, 5], 3)",
      "let { moving-medad } = import(\\"Vector\\");\\nmoving-medad([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.centered-moving-medad": {
    "title": "Vector.centered-moving-medad",
    "category": "Vector",
    "description": "Returns the \`centered moving median absolute deviation\` of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`centered moving median absolute deviation\` of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-medad } = import(\\"Vector\\");\\ncentered-moving-medad([1, 2, 3, 4, 5], 3)",
      "let { centered-moving-medad } = import(\\"Vector\\");\\ncentered-moving-medad([1, 2, 3, 4, 5], 5)"
    ]
  },
  "Vector.running-medad": {
    "title": "Vector.running-medad",
    "category": "Vector",
    "description": "Returns the \`running median absolute deviation\` of the \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the \`running median absolute deviation\` of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-medad } = import(\\"Vector\\");\\nrunning-medad([1, 2, 3])",
      "let { running-medad } = import(\\"Vector\\");\\nrunning-medad([1, 2, -3])"
    ]
  },
  "Vector.gini-coefficient": {
    "title": "Vector.gini-coefficient",
    "category": "Vector",
    "description": "Returns the **gini coefficient** of all elements in the \`vector\`.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **gini coefficient** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { gini-coefficient } = import(\\"Vector\\");\\ngini-coefficient([1, 2, 3])",
      "let { gini-coefficient } = import(\\"Vector\\");\\ngini-coefficient([1, 1, 3])"
    ]
  },
  "Vector.moving-gini-coefficient": {
    "title": "Vector.moving-gini-coefficient",
    "category": "Vector",
    "description": "Returns the **moving gini coefficient** of the \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving gini coefficient** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-gini-coefficient } = import(\\"Vector\\");\\nmoving-gini-coefficient([1, 2, 3], 2)",
      "let { moving-gini-coefficient } = import(\\"Vector\\");\\nmoving-gini-coefficient([1, 1, 3], 2)"
    ]
  },
  "Vector.centered-moving-gini-coefficient": {
    "title": "Vector.centered-moving-gini-coefficient",
    "category": "Vector",
    "description": "Returns the **centered moving gini coefficient** of the \`vector\` with a given window size.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving gini coefficient** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-gini-coefficient } = import(\\"Vector\\");\\ncentered-moving-gini-coefficient([1, 2, 3], 2)",
      "let { centered-moving-gini-coefficient } = import(\\"Vector\\");\\ncentered-moving-gini-coefficient([1, 1, 3], 2)"
    ]
  },
  "Vector.running-gini-coefficient": {
    "title": "Vector.running-gini-coefficient",
    "category": "Vector",
    "description": "Returns the **running gini coefficient** of the \`vector\`.",
    "returns": {
      "type": "array"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running gini coefficient** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-gini-coefficient } = import(\\"Vector\\");\\nrunning-gini-coefficient([1, 2, 3])",
      "let { running-gini-coefficient } = import(\\"Vector\\");\\nrunning-gini-coefficient([1, 1, 3])"
    ]
  },
  "Vector.entropy": {
    "title": "Vector.entropy",
    "category": "Vector",
    "description": "Calculates the **entropy** of a \`vector\`. The entropy is a measure of the uncertainty associated with a random variable.",
    "returns": {
      "type": "number"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **entropy** of. Minimum length is 1."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { entropy } = import(\\"Vector\\");\\nentropy([1, 1, 2, 3, 3, 3])",
      "let { entropy } = import(\\"Vector\\");\\nentropy([1, 2, 3])",
      "let { entropy } = import(\\"Vector\\");\\nentropy([1, 2, 2, 3])",
      "let { entropy } = import(\\"Vector\\");\\nentropy([0])",
      "let { entropy } = import(\\"Vector\\");\\nentropy([1])",
      "let { entropy } = import(\\"Vector\\");\\nentropy([1, 2])"
    ]
  },
  "Vector.moving-entropy": {
    "title": "Vector.moving-entropy",
    "category": "Vector",
    "description": "Calculates the **moving entropy** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **moving entropy** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      }
    ],
    "examples": [
      "let { moving-entropy } = import(\\"Vector\\");\\nmoving-entropy([1, 1, 2, 3, 3, 3], 4)",
      "let { moving-entropy } = import(\\"Vector\\");\\nmoving-entropy([1, 1, 2, 3, 3, 3], 3)",
      "let { moving-entropy } = import(\\"Vector\\");\\nmoving-entropy([1, 2], 2)"
    ]
  },
  "Vector.centered-moving-entropy": {
    "title": "Vector.centered-moving-entropy",
    "category": "Vector",
    "description": "Calculates the **centered moving entropy** of a \`vector\` with a given window size.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **centered moving entropy** of."
      },
      "windowSize": {
        "type": "integer",
        "description": "The size of the moving window."
      },
      "leftPadding": {
        "type": "number",
        "description": "Optional value to use for padding. Default is \`null\`."
      },
      "rightPadding": {
        "type": "number",
        "description": "Optional value to use for right padding. Default is \`null\`."
      },
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "windowSize"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding"
        ]
      },
      {
        "argumentNames": [
          "vector",
          "windowSize",
          "leftPadding",
          "rightPadding"
        ]
      }
    ],
    "examples": [
      "let { centered-moving-entropy } = import(\\"Vector\\");\\ncentered-moving-entropy([1, 1, 2, 3, 3, 3], 4)",
      "let { centered-moving-entropy } = import(\\"Vector\\");\\ncentered-moving-entropy([1, 1, 2, 3, 3, 3], 3)",
      "let { centered-moving-entropy } = import(\\"Vector\\");\\ncentered-moving-entropy([1, 2], 2)"
    ]
  },
  "Vector.running-entropy": {
    "title": "Vector.running-entropy",
    "category": "Vector",
    "description": "Calculates the **running entropy** of a \`vector\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "The \`vector\` to calculate the **running entropy** of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { running-entropy } = import(\\"Vector\\");\\nrunning-entropy([1, 1, 2, 3, 3, 3])",
      "let { running-entropy } = import(\\"Vector\\");\\nrunning-entropy([1, 2])"
    ]
  },
  "Linear-Algebra.rotate2d": {
    "title": "Linear-Algebra.rotate2d",
    "category": "Linear Algebra",
    "description": "Rotates a 2D vector by a given angle in radians.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "Vector to rotate."
      },
      "b": {
        "type": "number",
        "description": "Angle in b."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { rotate2d } = import(\\"Linear-Algebra\\");\\nrotate2d([1, 0], PI / 2)",
      "let { rotate2d } = import(\\"Linear-Algebra\\");\\nrotate2d([0, 1], PI)"
    ]
  },
  "Linear-Algebra.rotate3d": {
    "title": "Linear-Algebra.rotate3d",
    "category": "Linear Algebra",
    "description": "Rotates a 3D vector around a given axis by a given angle in radians.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to rotate."
      },
      "axis": {
        "type": "vector",
        "description": "Axis of rotation."
      },
      "radians": {
        "type": "number",
        "description": "Angle in radians."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v",
          "axis",
          "radians"
        ]
      }
    ],
    "examples": [
      "let { rotate3d } = import(\\"Linear-Algebra\\");\\nrotate3d([1, 0, 0], [0, 1, 0], PI / 2)",
      "let { rotate3d } = import(\\"Linear-Algebra\\");\\nrotate3d([0, 1, 0], [1, 0, 0], PI)"
    ]
  },
  "Linear-Algebra.reflect": {
    "title": "Linear-Algebra.reflect",
    "category": "Linear Algebra",
    "description": "Reflects a vector across a given axis.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "Vector to reflect."
      },
      "b": {
        "type": "vector",
        "description": "Axis of reflection."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { reflect } = import(\\"Linear-Algebra\\");\\nreflect([1, 2], [0, 1])",
      "let { reflect } = import(\\"Linear-Algebra\\");\\nreflect([1, 2, 3], [0, 0, 1])"
    ]
  },
  "Linear-Algebra.refract": {
    "title": "Linear-Algebra.refract",
    "category": "Linear Algebra",
    "description": "Refracts a vector across a given axis.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "Vector to refract."
      },
      "axis": {
        "type": "vector",
        "description": "Axis of refraction."
      },
      "eta": {
        "type": "number",
        "description": "Refraction index."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector",
          "axis",
          "eta"
        ]
      }
    ],
    "examples": [
      "let { refract } = import(\\"Linear-Algebra\\");\\nrefract([1, 2], [0, 1], 1.5)",
      "let { refract } = import(\\"Linear-Algebra\\");\\nrefract([1, 2, 3], [0, 0, 1], 1.5)"
    ]
  },
  "Linear-Algebra.lerp": {
    "title": "Linear-Algebra.lerp",
    "category": "Linear Algebra",
    "description": "Performs linear interpolation between two vectors.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "Start vector."
      },
      "b": {
        "type": "vector",
        "description": "End vector."
      },
      "t": {
        "type": "number",
        "description": "Interpolation factor (0 to 1)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b",
          "t"
        ]
      }
    ],
    "examples": [
      "let { lerp } = import(\\"Linear-Algebra\\");\\nlerp([1, 2], [3, 4], 0.5)",
      "let { lerp } = import(\\"Linear-Algebra\\");\\nlerp([1, 2], [3, 4], 2)",
      "let { lerp } = import(\\"Linear-Algebra\\");\\nlerp([1, 2], [3, 4], -1)",
      "let { lerp } = import(\\"Linear-Algebra\\");\\nlerp([1, 2, 3], [4, 5, 6], 0.25)"
    ]
  },
  "Linear-Algebra.dot": {
    "title": "Linear-Algebra.dot",
    "category": "Linear Algebra",
    "description": "Calculates the dot product of two vectors. The result is a scalar.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "First vector."
      },
      "b": {
        "type": "vector",
        "description": "Second vector."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { dot } = import(\\"Linear-Algebra\\");\\ndot([1, 2], [3, 4])",
      "let { dot } = import(\\"Linear-Algebra\\");\\ndot([1, 2, 3], [4, 5, 6])"
    ]
  },
  "Linear-Algebra.cross": {
    "title": "Linear-Algebra.cross",
    "category": "Linear Algebra",
    "description": "Calculates the cross product of two 3D vectors. The result is a vector perpendicular to both input vectors.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "First vector (3D)."
      },
      "b": {
        "type": "vector",
        "description": "Second vector (3D)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { cross } = import(\\"Linear-Algebra\\");\\ncross([1, 2, 3], [4, 5, 6])",
      "let { cross } = import(\\"Linear-Algebra\\");\\ncross([1, 0, 0], [0, 1, 0])",
      "let { cross } = import(\\"Linear-Algebra\\");\\ncross([0, 0, 1], [1, 0, 0])",
      "let { cross } = import(\\"Linear-Algebra\\");\\ncross([1, 2, 3], [0, 0, 0])",
      "let { cross } = import(\\"Linear-Algebra\\");\\ncross([0, 0, 0], [1, 2, 3])"
    ]
  },
  "Linear-Algebra.normalize-minmax": {
    "title": "Linear-Algebra.normalize-minmax",
    "category": "Linear Algebra",
    "description": "Normalizes the vector using min-max normalization. The result is a vector with values between 0 and 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to normalize."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { normalize-minmax } = import(\\"Linear-Algebra\\");\\nnormalize-minmax([1, 2, 3])",
      "let { normalize-minmax } = import(\\"Linear-Algebra\\");\\nnormalize-minmax([1, 2, -3])",
      "let { normalize-minmax } = import(\\"Linear-Algebra\\");\\nnormalize-minmax([1, 2, 3, 4])",
      "let { normalize-minmax } = import(\\"Linear-Algebra\\");\\nnormalize-minmax([1, 2, -3, 4])",
      "let { normalize-minmax } = import(\\"Linear-Algebra\\");\\nnormalize-minmax([1, 2, 3, 40, 50])"
    ]
  },
  "Linear-Algebra.normalize-robust": {
    "title": "Linear-Algebra.normalize-robust",
    "category": "Linear Algebra",
    "description": "Normalizes the vector using robust normalization. The result is a vector with median 0 and median absolute deviation 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to normalize."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { normalize-robust } = import(\\"Linear-Algebra\\");\\nnormalize-robust([1, 2, 3])",
      "let { normalize-robust } = import(\\"Linear-Algebra\\");\\nnormalize-robust([1, 2, -3])",
      "let { normalize-robust } = import(\\"Linear-Algebra\\");\\nnormalize-robust([1, 2, 3, 4])",
      "let { normalize-robust } = import(\\"Linear-Algebra\\");\\nnormalize-robust([1, 2, -3, 4])",
      "let { normalize-robust } = import(\\"Linear-Algebra\\");\\nnormalize-robust([1, 2, 3, 40, 50])"
    ]
  },
  "Linear-Algebra.normalize-zscore": {
    "title": "Linear-Algebra.normalize-zscore",
    "category": "Linear Algebra",
    "description": "Normalizes the vector using z-score normalization. The result is a vector with mean 0 and standard deviation 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to normalize."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { normalize-zscore } = import(\\"Linear-Algebra\\");\\nnormalize-zscore([1, 2, 3])",
      "let { normalize-zscore } = import(\\"Linear-Algebra\\");\\nnormalize-zscore([1, 2, -3])",
      "let { normalize-zscore } = import(\\"Linear-Algebra\\");\\nnormalize-zscore([1, 2, 3, 4])",
      "let { normalize-zscore } = import(\\"Linear-Algebra\\");\\nnormalize-zscore([1, 2, -3, 4])",
      "let { normalize-zscore } = import(\\"Linear-Algebra\\");\\nnormalize-zscore([1, 2, 3, 40, 50])"
    ]
  },
  "Linear-Algebra.normalize-l1": {
    "title": "Linear-Algebra.normalize-l1",
    "category": "Linear Algebra",
    "description": "Normalizes the vector using L1 normalization. The result is a vector with L1 norm equal to 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to normalize."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { normalize-l1 } = import(\\"Linear-Algebra\\");\\nnormalize-l1([1, 2, 3])",
      "let { normalize-l1 } = import(\\"Linear-Algebra\\");\\nnormalize-l1([1, 2, -3])",
      "let { normalize-l1 } = import(\\"Linear-Algebra\\");\\nnormalize-l1([1, 2, 3, 4])",
      "let { normalize-l1 } = import(\\"Linear-Algebra\\");\\nnormalize-l1([1, 2, -3, 4])",
      "let { normalize-l1 } = import(\\"Linear-Algebra\\");\\nnormalize-l1([1, 2, 3, 40, 50])"
    ]
  },
  "Linear-Algebra.normalize-l2": {
    "title": "Linear-Algebra.normalize-l2",
    "category": "Linear Algebra",
    "description": "Normalizes the vector using L2 normalization. The result is a vector with L2 norm equal to 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to normalize."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { normalize-l2 } = import(\\"Linear-Algebra\\");\\nnormalize-l2([1, 2, 3])",
      "let { normalize-l2 } = import(\\"Linear-Algebra\\");\\nnormalize-l2([1, 2, 3])",
      "let { normalize-l2 } = import(\\"Linear-Algebra\\");\\nnormalize-l2([1, 2, -3])",
      "let { normalize-l2 } = import(\\"Linear-Algebra\\");\\nnormalize-l2([1, 2, 3, 4])",
      "let { normalize-l2 } = import(\\"Linear-Algebra\\");\\nnormalize-l2([1, 2, -3, 4])",
      "let { normalize-l2 } = import(\\"Linear-Algebra\\");\\nnormalize-l2([1, 2, 3, 40, 50])"
    ]
  },
  "Linear-Algebra.normalize-log": {
    "title": "Linear-Algebra.normalize-log",
    "category": "Linear Algebra",
    "description": "Normalizes the vector using natural log normalization. The result is a vector with log-transformed values.",
    "returns": {
      "type": "number"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to normalize."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { normalize-log } = import(\\"Linear-Algebra\\");\\nnormalize-log([1, 2, 3])",
      "let { normalize-log } = import(\\"Linear-Algebra\\");\\nnormalize-log([1, 2, 3, 4])",
      "let { normalize-log } = import(\\"Linear-Algebra\\");\\nnormalize-log([1, 2, 3, 40, 50])"
    ]
  },
  "Linear-Algebra.angle": {
    "title": "Linear-Algebra.angle",
    "category": "Linear Algebra",
    "description": "Calculates the \`angle\` between two vectors in radians.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { angle } = import(\\"Linear-Algebra\\");\\nangle([1, 0], [0, 1])",
      "let { angle } = import(\\"Linear-Algebra\\");\\nangle([1, 0, 1], [0, 1, 0])"
    ]
  },
  "Linear-Algebra.projection": {
    "title": "Linear-Algebra.projection",
    "category": "Linear Algebra",
    "description": "Calculates the **projection** of vector \`a\` onto vector \`b\`.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { projection } = import(\\"Linear-Algebra\\");\\nprojection([1, 2], [3, 4])",
      "let { projection } = import(\\"Linear-Algebra\\");\\nprojection([1, 2, 3], [4, 5, 6])"
    ]
  },
  "Linear-Algebra.orthogonal?": {
    "title": "Linear-Algebra.orthogonal?",
    "category": "Linear Algebra",
    "description": "Checks if two vectors are **orthogonal**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { orthogonal? } = import(\\"Linear-Algebra\\");\\northogonal?([1, 0], [0, 1])",
      "let { orthogonal? } = import(\\"Linear-Algebra\\");\\northogonal?([1, 0, 1], [0, 1, 0])",
      "let { orthogonal? } = import(\\"Linear-Algebra\\");\\northogonal?([1, 2], [2, -1])"
    ]
  },
  "Linear-Algebra.parallel?": {
    "title": "Linear-Algebra.parallel?",
    "category": "Linear Algebra",
    "description": "Checks if two vectors are **parallel**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { parallel? } = import(\\"Linear-Algebra\\");\\nparallel?([1, 2], [2, 4])",
      "let { parallel? } = import(\\"Linear-Algebra\\");\\nparallel?([1, 2], [-2, -4])",
      "let { parallel? } = import(\\"Linear-Algebra\\");\\nparallel?([1, 2, 3], [2, 4, 6])",
      "let { parallel? } = import(\\"Linear-Algebra\\");\\nparallel?([1, 2], [3, 4])"
    ]
  },
  "Linear-Algebra.collinear?": {
    "title": "Linear-Algebra.collinear?",
    "category": "Linear Algebra",
    "description": "Checks if two vectors are **collinear**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { collinear? } = import(\\"Linear-Algebra\\");\\ncollinear?([1, 2], [2, 4])",
      "let { collinear? } = import(\\"Linear-Algebra\\");\\ncollinear?([1, 2], [-2, -4])",
      "let { collinear? } = import(\\"Linear-Algebra\\");\\ncollinear?([1, 2, 3], [2, 4, 6])"
    ]
  },
  "Linear-Algebra.cosine-similarity": {
    "title": "Linear-Algebra.cosine-similarity",
    "category": "Linear Algebra",
    "description": "Calculates the **cosine similarity** between two vectors. The result is a value between -1 and 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { cosine-similarity } = import(\\"Linear-Algebra\\");\\ncosine-similarity([1, 2], [3, 4])",
      "let { cosine-similarity } = import(\\"Linear-Algebra\\");\\ncosine-similarity([1, 2, 3], [4, 5, 6])",
      "let { cosine-similarity } = import(\\"Linear-Algebra\\");\\ncosine-similarity([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.euclidean-distance": {
    "title": "Linear-Algebra.euclidean-distance",
    "category": "Linear Algebra",
    "description": "Calculates the **Euclidean distance** between two vectors. The result is a non-negative number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { euclidean-distance } = import(\\"Linear-Algebra\\");\\neuclidean-distance([1, 2], [3, 4])",
      "let { euclidean-distance } = import(\\"Linear-Algebra\\");\\neuclidean-distance([1, 2, 3], [4, 5, 6])",
      "let { euclidean-distance } = import(\\"Linear-Algebra\\");\\neuclidean-distance([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.euclidean-norm": {
    "title": "Linear-Algebra.euclidean-norm",
    "category": "Linear Algebra",
    "description": "Calculates the **Euclidean norm** (L2 norm) of a vector. The result is a non-negative number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to calculate the norm for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { euclidean-norm } = import(\\"Linear-Algebra\\");\\neuclidean-norm([1, 2])",
      "let { euclidean-norm } = import(\\"Linear-Algebra\\");\\neuclidean-norm([3, 4])",
      "let { euclidean-norm } = import(\\"Linear-Algebra\\");\\neuclidean-norm([1, 2, 3])"
    ]
  },
  "Linear-Algebra.manhattan-distance": {
    "title": "Linear-Algebra.manhattan-distance",
    "category": "Linear Algebra",
    "description": "Calculates the **Manhattan distance** between two vectors. The result is a non-negative number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { manhattan-distance } = import(\\"Linear-Algebra\\");\\nmanhattan-distance([1, 2], [3, 4])",
      "let { manhattan-distance } = import(\\"Linear-Algebra\\");\\nmanhattan-distance([1, 2, 3], [4, 5, 6])",
      "let { manhattan-distance } = import(\\"Linear-Algebra\\");\\nmanhattan-distance([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.manhattan-norm": {
    "title": "Linear-Algebra.manhattan-norm",
    "category": "Linear Algebra",
    "description": "Calculates the **Manhattan norm** (L1 norm) of a vector. The result is a non-negative number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to calculate the norm for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { manhattan-norm } = import(\\"Linear-Algebra\\");\\nmanhattan-norm([1, 2])",
      "let { manhattan-norm } = import(\\"Linear-Algebra\\");\\nmanhattan-norm([3, 4])",
      "let { manhattan-norm } = import(\\"Linear-Algebra\\");\\nmanhattan-norm([1, 2, 3])"
    ]
  },
  "Linear-Algebra.hamming-distance": {
    "title": "Linear-Algebra.hamming-distance",
    "category": "Linear Algebra",
    "description": "Calculates the **Hamming distance** between two vectors. The result is a non-negative integer.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { hamming-distance } = import(\\"Linear-Algebra\\");\\nhamming-distance([1, 2], [3, 4])",
      "let { hamming-distance } = import(\\"Linear-Algebra\\");\\nhamming-distance([1, 2, 3], [4, 5, 6])",
      "let { hamming-distance } = import(\\"Linear-Algebra\\");\\nhamming-distance([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.hamming-norm": {
    "title": "Linear-Algebra.hamming-norm",
    "category": "Linear Algebra",
    "description": "Calculates the **Hamming norm** of a vector. The result is a non-negative integer.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to calculate the norm for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { hamming-norm } = import(\\"Linear-Algebra\\");\\nhamming-norm([1, 2])",
      "let { hamming-norm } = import(\\"Linear-Algebra\\");\\nhamming-norm([3, 4])",
      "let { hamming-norm } = import(\\"Linear-Algebra\\");\\nhamming-norm([1, 2, 3])"
    ]
  },
  "Linear-Algebra.chebyshev-distance": {
    "title": "Linear-Algebra.chebyshev-distance",
    "category": "Linear Algebra",
    "description": "Calculates the **Chebyshev distance** between two vectors. The result is a non-negative number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { chebyshev-distance } = import(\\"Linear-Algebra\\");\\nchebyshev-distance([1, 2], [3, 4])",
      "let { chebyshev-distance } = import(\\"Linear-Algebra\\");\\nchebyshev-distance([1, 2, 3], [4, 5, 6])",
      "let { chebyshev-distance } = import(\\"Linear-Algebra\\");\\nchebyshev-distance([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.chebyshev-norm": {
    "title": "Linear-Algebra.chebyshev-norm",
    "category": "Linear Algebra",
    "description": "Calculates the **Chebyshev norm** of a vector. The result is a non-negative number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "Vector to calculate the norm for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { chebyshev-norm } = import(\\"Linear-Algebra\\");\\nchebyshev-norm([1, 2])",
      "let { chebyshev-norm } = import(\\"Linear-Algebra\\");\\nchebyshev-norm([3, 4])",
      "let { chebyshev-norm } = import(\\"Linear-Algebra\\");\\nchebyshev-norm([1, 2, 3])"
    ]
  },
  "Linear-Algebra.minkowski-distance": {
    "title": "Linear-Algebra.minkowski-distance",
    "category": "Linear Algebra",
    "description": "Calculates the **Minkowski distance** between two vectors. The result is a non-negative number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      },
      "p": {
        "type": "number",
        "description": "Order of the norm (p)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b",
          "p"
        ]
      }
    ],
    "examples": [
      "let { minkowski-distance } = import(\\"Linear-Algebra\\");\\nminkowski-distance([1, 2], [3, 4], 2)",
      "let { minkowski-distance } = import(\\"Linear-Algebra\\");\\nminkowski-distance([1, 2, 3], [4, 5, 6], 3)",
      "let { minkowski-distance } = import(\\"Linear-Algebra\\");\\nminkowski-distance([1, 0], [0, 1], 1)"
    ]
  },
  "Linear-Algebra.minkowski-norm": {
    "title": "Linear-Algebra.minkowski-norm",
    "category": "Linear Algebra",
    "description": "Calculates the **Minkowski norm** of a vector. The result is a non-negative number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "Vector to calculate the norm for."
      },
      "b": {
        "type": "number",
        "description": "Order of the norm (p)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { minkowski-norm } = import(\\"Linear-Algebra\\");\\nminkowski-norm([1, 2], 2)",
      "let { minkowski-norm } = import(\\"Linear-Algebra\\");\\nminkowski-norm([3, 4], 3)",
      "let { minkowski-norm } = import(\\"Linear-Algebra\\");\\nminkowski-norm([1, 2, 3], 4)"
    ]
  },
  "Linear-Algebra.cov": {
    "title": "Linear-Algebra.cov",
    "category": "Linear Algebra",
    "description": "Calculates the **covariance** between two vectors. The result is a number.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { cov } = import(\\"Linear-Algebra\\");\\ncov([1, 2], [3, 4])",
      "let { cov } = import(\\"Linear-Algebra\\");\\ncov([1, 2, 3], [4, 5, 6])",
      "let { cov } = import(\\"Linear-Algebra\\");\\ncov([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.corr": {
    "title": "Linear-Algebra.corr",
    "category": "Linear Algebra",
    "description": "Calculates the **correlation** between two vectors. The result is a number between -1 and 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { corr } = import(\\"Linear-Algebra\\");\\ncorr([1, 2], [3, 4])",
      "let { corr } = import(\\"Linear-Algebra\\");\\ncorr([1, 2, 3], [4, 5, 6])",
      "let { corr } = import(\\"Linear-Algebra\\");\\ncorr([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.spearman-corr": {
    "title": "Linear-Algebra.spearman-corr",
    "category": "Linear Algebra",
    "description": "Calculates the **Spearman rank correlation** between two vectors. The result is a number between -1 and 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { spearman-corr } = import(\\"Linear-Algebra\\");\\nspearman-corr([1, 2], [3, 4])",
      "let { spearman-corr } = import(\\"Linear-Algebra\\");\\nspearman-corr([1, 2, 3], [4, 5, 6])",
      "let { spearman-corr } = import(\\"Linear-Algebra\\");\\nspearman-corr([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.pearson-corr": {
    "title": "Linear-Algebra.pearson-corr",
    "category": "Linear Algebra",
    "description": "Calculates the **Pearson correlation** between two vectors. The result is a number between -1 and 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { pearson-corr } = import(\\"Linear-Algebra\\");\\npearson-corr([1, 2], [3, 4])",
      "let { pearson-corr } = import(\\"Linear-Algebra\\");\\npearson-corr([1, 2, 3], [4, 5, 6])",
      "let { pearson-corr } = import(\\"Linear-Algebra\\");\\npearson-corr([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.kendall-tau": {
    "title": "Linear-Algebra.kendall-tau",
    "category": "Linear Algebra",
    "description": "Calculates the **Kendall Tau** rank correlation coefficient between two vectors. The result is a number between -1 and 1.",
    "returns": {
      "type": "number"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { kendall-tau } = import(\\"Linear-Algebra\\");\\nkendall-tau([1, 2], [3, 4])",
      "let { kendall-tau } = import(\\"Linear-Algebra\\");\\nkendall-tau([1, 2, 3], [4, 5, 6])",
      "let { kendall-tau } = import(\\"Linear-Algebra\\");\\nkendall-tau([1, 0], [0, 1])"
    ]
  },
  "Linear-Algebra.autocorrelation": {
    "title": "Linear-Algebra.autocorrelation",
    "category": "Linear Algebra",
    "description": "Calculates the **autocorrelation** of a vector. The result is a vector of autocorrelation coefficients.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "a": {
        "type": "vector",
        "description": "Vector to calculate the autocorrelation for."
      },
      "b": {
        "type": "integer",
        "description": "Lag value for the autocorrelation."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { autocorrelation } = import(\\"Linear-Algebra\\");\\nautocorrelation([1, 2, 3], -2)",
      "let { autocorrelation } = import(\\"Linear-Algebra\\");\\nautocorrelation([1, 2, 3], -1)",
      "let { autocorrelation } = import(\\"Linear-Algebra\\");\\nautocorrelation([1, 2, 3], 0)",
      "let { autocorrelation } = import(\\"Linear-Algebra\\");\\nautocorrelation([1, 2, 3], 1)",
      "let { autocorrelation } = import(\\"Linear-Algebra\\");\\nautocorrelation([1, 2, 3], 2)"
    ]
  },
  "Linear-Algebra.cross-correlation": {
    "title": "Linear-Algebra.cross-correlation",
    "category": "Linear Algebra",
    "description": "Calculates the **cross-correlation** between two vectors. The result is a vector of cross-correlation coefficients.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "a": {
        "type": "vector"
      },
      "b": {
        "type": "vector"
      },
      "lag": {
        "type": "integer",
        "description": "Lag value for the cross-correlation."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b",
          "lag"
        ]
      }
    ],
    "examples": [
      "let { cross-correlation } = import(\\"Linear-Algebra\\");\\ncross-correlation([1, 2, 3], [4, 5, 6], -2)",
      "let { cross-correlation } = import(\\"Linear-Algebra\\");\\ncross-correlation([1, 2, 3], [4, 5, 6], -1)",
      "let { cross-correlation } = import(\\"Linear-Algebra\\");\\ncross-correlation([1, 2, 3], [4, 5, 6], 0)",
      "let { cross-correlation } = import(\\"Linear-Algebra\\");\\ncross-correlation([1, 2, 3], [4, 5, 6], 1)",
      "let { cross-correlation } = import(\\"Linear-Algebra\\");\\ncross-correlation([1, 2, 3], [4, 5, 6], 2)"
    ]
  },
  "Linear-Algebra.rref": {
    "title": "Linear-Algebra.rref",
    "category": "Linear Algebra",
    "description": "Calculates the **Reduced Row Echelon Form** (RREF) of a matrix.",
    "returns": {
      "type": "matrix"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "Matrix to calculate the RREF for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { rref } = import(\\"Linear-Algebra\\");\\nrref([[1, 2], [3, 4]])",
      "let { rref } = import(\\"Linear-Algebra\\");\\nrref([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
      "let { rref } = import(\\"Linear-Algebra\\");\\nrref([[1, 2, 3], [7, 8, 9], [4, 5, 7]])"
    ]
  },
  "Linear-Algebra.solve": {
    "title": "Linear-Algebra.solve",
    "category": "Linear Algebra",
    "description": "Solves a system of linear equations represented by a matrix and a vector.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "a": {
        "type": "matrix"
      },
      "b": {
        "type": "vector"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { solve } = import(\\"Linear-Algebra\\");\\nsolve([\\n  [2, 1, -1, 1], \\n  [4, 5, -3, 2], \\n  [6, -2, 5, -3], \\n  [8, 3, 2, 4]\\n], [5, 10, 2, 17])",
      "let { solve } = import(\\"Linear-Algebra\\"); solve([[2, 0, 0], [3, 1, 0], [4, 5, 6]], [4, 5, 38])",
      "let { solve } = import(\\"Linear-Algebra\\"); solve([[2, 3], [1, -1]], [8, 2])"
    ]
  },
  "Linear-Algebra.to-polar": {
    "title": "Linear-Algebra.to-polar",
    "category": "Linear Algebra",
    "description": "Converts a 2D vector to polar coordinates.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "vector": {
        "type": "vector",
        "description": "2D Vector to convert."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "vector"
        ]
      }
    ],
    "examples": [
      "let { to-polar } = import(\\"Linear-Algebra\\");\\nto-polar([1, 2])",
      "let { to-polar } = import(\\"Linear-Algebra\\");\\nto-polar([3, 4])"
    ]
  },
  "Linear-Algebra.from-polar": {
    "title": "Linear-Algebra.from-polar",
    "category": "Linear Algebra",
    "description": "Converts polar coordinates to a 2D vector.",
    "returns": {
      "type": "vector"
    },
    "args": {
      "polar": {
        "type": "vector",
        "description": "Polar coordinates to convert."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "polar"
        ]
      }
    ],
    "examples": [
      "let { from-polar } = import(\\"Linear-Algebra\\");\\nfrom-polar([1, PI / 4])",
      "let { from-polar } = import(\\"Linear-Algebra\\");\\nfrom-polar([1, 0])",
      "let { from-polar } = import(\\"Linear-Algebra\\");\\nfrom-polar([1, -PI / 2])"
    ]
  },
  "Matrix.mul": {
    "title": "Matrix.mul",
    "category": "Matrix",
    "description": "Multiplies two \`matrices\` using standard \`matrix\` multiplication based on **dot products** of rows and columns.",
    "returns": {
      "type": "matrix"
    },
    "args": {
      "a": {
        "type": "matrix"
      },
      "b": {
        "type": "matrix"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { mul } = import(\\"Matrix\\");\\nmul([[1, 2], [3, 4]], [[5, 6], [7, 8]])",
      "let { mul } = import(\\"Matrix\\");\\nmul([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]])"
    ]
  },
  "Matrix.det": {
    "title": "Matrix.det",
    "category": "Matrix",
    "description": "Calculates the **determinant** of a square matrix.",
    "returns": {
      "type": "number"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the determinant of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { det } = import(\\"Matrix\\");\\ndet([[1, 2], [3, 4]])",
      "let { det } = import(\\"Matrix\\");\\ndet([[1, 2, 3], [4, 5, 6], [7, 8, 9]])"
    ]
  },
  "Matrix.inv": {
    "title": "Matrix.inv",
    "category": "Matrix",
    "description": "Calculates the **inverse** of a square matrix.",
    "returns": {
      "type": "matrix"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the inverse of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { inv } = import(\\"Matrix\\");\\ninv([[1, 2], [3, 4]])",
      "let { inv } = import(\\"Matrix\\");\\ninv([[1, 2, 3], [4, 5, 7], [7, 8, 10]])"
    ]
  },
  "Matrix.adj": {
    "title": "Matrix.adj",
    "category": "Matrix",
    "description": "Calculates the **adjugate** of a square matrix.",
    "returns": {
      "type": "matrix"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the adjugate of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { adj } = import(\\"Matrix\\");\\nadj([[1, 2], [3, 4]])",
      "let { adj } = import(\\"Matrix\\");\\nadj([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
      "let { adj } = import(\\"Matrix\\");\\nadj([[1, 2, 3], [7, 8, 9], [4, 5, 6]])"
    ]
  },
  "Matrix.cofactor": {
    "title": "Matrix.cofactor",
    "category": "Matrix",
    "description": "Calculates the **cofactor** of a square matrix.",
    "returns": {
      "type": "matrix"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the cofactor of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { cofactor } = import(\\"Matrix\\");\\ncofactor([[1, 2], [3, 4]])",
      "let { cofactor } = import(\\"Matrix\\");\\ncofactor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
      "let { cofactor } = import(\\"Matrix\\");\\ncofactor([[1, 2, 3], [7, 8, 9], [4, 5, 6]])"
    ]
  },
  "Matrix.minor": {
    "title": "Matrix.minor",
    "category": "Matrix",
    "description": "Calculates the **minor** of a square matrix.",
    "returns": {
      "type": "matrix"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the minor of."
      },
      "row": {
        "type": "integer",
        "description": "The row index of the element to calculate the minor for."
      },
      "col": {
        "type": "integer",
        "description": "The column index of the element to calculate the minor for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m",
          "row",
          "col"
        ]
      }
    ],
    "examples": [
      "let { minor } = import(\\"Matrix\\");\\nminor([[1, 2], [3, 4]], 0, 1)",
      "let { minor } = import(\\"Matrix\\");\\nminor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1, 1)"
    ]
  },
  "Matrix.trace": {
    "title": "Matrix.trace",
    "category": "Matrix",
    "description": "Calculates the **trace** of a square matrix.",
    "returns": {
      "type": "number"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the trace of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { trace } = import(\\"Matrix\\");\\ntrace([[1, 2], [3, 4]])",
      "let { trace } = import(\\"Matrix\\");\\ntrace([[1, 2, 3], [4, 5, 6], [7, 8, 9]])"
    ]
  },
  "Matrix.symmetric?": {
    "title": "Matrix.symmetric?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is **symmetric**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for symmetry."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { symmetric? } = import(\\"Matrix\\");\\nsymmetric?([[1, 2], [2, 1]])",
      "let { symmetric? } = import(\\"Matrix\\");\\nsymmetric?([[1, 2, 3], [2, 1, 4], [3, 4, 1]])"
    ]
  },
  "Matrix.triangular?": {
    "title": "Matrix.triangular?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is **triangular**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for triangularity."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { triangular? } = import(\\"Matrix\\");\\ntriangular?([[2, 0], [0, 1]])",
      "let { triangular? } = import(\\"Matrix\\");\\ntriangular?([[1, 2, 3], [0, 4, 5], [0, 0, 6]])"
    ]
  },
  "Matrix.upper-triangular?": {
    "title": "Matrix.upper-triangular?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is **upper triangular**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for upper triangularity."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { upper-triangular? } = import(\\"Matrix\\");\\nupper-triangular?([[1, 2], [0, 3]])",
      "let { upper-triangular? } = import(\\"Matrix\\");\\nupper-triangular?([[1, 2, 3], [0, 4, 5], [0, 0, 6]])"
    ]
  },
  "Matrix.lower-triangular?": {
    "title": "Matrix.lower-triangular?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is **lower triangular**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for lower triangularity."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { lower-triangular? } = import(\\"Matrix\\");\\nlower-triangular?([[1, 0], [2, 3]])",
      "let { lower-triangular? } = import(\\"Matrix\\");\\nlower-triangular?([[1, 0, 0], [2, 3, 0], [4, 5, 6]])"
    ]
  },
  "Matrix.diagonal?": {
    "title": "Matrix.diagonal?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is **diagonal**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for diagonal property."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { diagonal? } = import(\\"Matrix\\");\\ndiagonal?([[1, 0], [0, 2]])",
      "let { diagonal? } = import(\\"Matrix\\");\\ndiagonal?([[1, 0, 0], [0, 2, 0], [0, 0, 3]])",
      "let { diagonal? } = import(\\"Matrix\\");\\ndiagonal?([[1, 0, 0], [2, 2, 2], [0, 0, 3]])"
    ]
  },
  "Matrix.square?": {
    "title": "Matrix.square?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is **square**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for square property."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { square? } = import(\\"Matrix\\");\\nsquare?([[1, 2], [3, 4]])",
      "let { square? } = import(\\"Matrix\\");\\nsquare?([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
      "let { square? } = import(\\"Matrix\\");\\nsquare?([[1, 2, 3], [4, 5, 6]])"
    ]
  },
  "Matrix.orthogonal?": {
    "title": "Matrix.orthogonal?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is **orthogonal**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for **orthogonality**."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { orthogonal? } = import(\\"Matrix\\");\\northogonal?([[1, 0], [0, 1]])",
      "let { orthogonal? } = import(\\"Matrix\\");\\northogonal?([[1, 0], [0, -1]])",
      "let { orthogonal? } = import(\\"Matrix\\");\\northogonal?([[1, 2], [3, 4]])"
    ]
  },
  "Matrix.identity?": {
    "title": "Matrix.identity?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is an **identity matrix**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for identity property."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { identity? } = import(\\"Matrix\\");\\nidentity?([[1, 0], [0, 1]])",
      "let { identity? } = import(\\"Matrix\\");\\nidentity?([[1, 0, 0], [0, 1, 0], [0, 0, 1]])",
      "let { identity? } = import(\\"Matrix\\");\\nidentity?([[1, 0, 0], [0, 1, 0], [0, 0, 0]])"
    ]
  },
  "Matrix.invertible?": {
    "title": "Matrix.invertible?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is **invertible**.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for invertibility."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { invertible? } = import(\\"Matrix\\");\\ninvertible?([[1, 2], [3, 4]])",
      "let { invertible? } = import(\\"Matrix\\");\\ninvertible?([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
      "let { invertible? } = import(\\"Matrix\\");\\ninvertible?([[1, 2], [2, 4]])"
    ]
  },
  "Matrix.hilbert": {
    "title": "Matrix.hilbert",
    "category": "Matrix",
    "description": "Generates a **Hilbert matrix** of size \`n\`.",
    "returns": {
      "type": "matrix"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The size of the Hilbert matrix."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { hilbert } = import(\\"Matrix\\");\\nhilbert(3)",
      "let { hilbert } = import(\\"Matrix\\");\\nhilbert(4)"
    ]
  },
  "Matrix.vandermonde": {
    "title": "Matrix.vandermonde",
    "category": "Matrix",
    "description": "Generates a **Vandermonde matrix** from a vector.",
    "returns": {
      "type": "matrix"
    },
    "args": {
      "v": {
        "type": "vector",
        "description": "The vector to generate the Vandermonde matrix from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "v"
        ]
      }
    ],
    "examples": [
      "let { vandermonde } = import(\\"Matrix\\");\\nvandermonde([1, 2, 3])",
      "let { vandermonde } = import(\\"Matrix\\");\\nvandermonde([1, 0, 1])"
    ]
  },
  "Matrix.band": {
    "title": "Matrix.band",
    "category": "Matrix",
    "description": "Generates a **banded matrix** of size \`n\` with lower band index \`lband\` and upper band index \`uband\`.",
    "returns": {
      "type": "matrix"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The size of the banded matrix."
      },
      "lband": {
        "type": "integer",
        "description": "The lower band index."
      },
      "uband": {
        "type": "integer",
        "description": "The upper band index."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n",
          "lband",
          "uband"
        ]
      }
    ],
    "examples": [
      "let { band } = import(\\"Matrix\\");\\nband(3, 1, 1)",
      "let { band } = import(\\"Matrix\\");\\nband(4, 1, 2)"
    ]
  },
  "Matrix.banded?": {
    "title": "Matrix.banded?",
    "category": "Matrix",
    "description": "Checks if a \`matrix\` is **banded** with lower band index \`lband\` and upper band index \`uband\`.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to check for **banded** property."
      },
      "lband": {
        "type": "integer",
        "description": "The lower band index."
      },
      "uband": {
        "type": "integer",
        "description": "The upper band index."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m",
          "lband",
          "uband"
        ]
      }
    ],
    "examples": [
      "let { banded? } = import(\\"Matrix\\");\\nbanded?([\\n  [1, 1, 1, 0],\\n  [1, 1, 1, 1],\\n  [1, 1, 1, 1],\\n  [0, 1, 1, 1],\\n], 2, 2)",
      "let { banded? } = import(\\"Matrix\\");\\nbanded?([\\n  [1, 1, 1, 0],\\n  [1, 1, 1, 1],\\n  [1, 1, 1, 1],\\n  [0, 1, 1, 1],\\n], 1, 1)"
    ]
  },
  "Matrix.rank": {
    "title": "Matrix.rank",
    "category": "Matrix",
    "description": "Calculates the **rank** of a matrix using **Gaussian elimination**.",
    "returns": {
      "type": "number"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the rank of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { rank } = import(\\"Matrix\\");\\nrank([[1, 0, 0], [0, 1, 0], [0, 0, 1]])",
      "let { rank } = import(\\"Matrix\\");\\nrank([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
      "let { rank } = import(\\"Matrix\\");\\nrank([[2, 4, 6], [3, 6, 9], [4, 8, 12]])"
    ]
  },
  "Matrix.frobenius-norm": {
    "title": "Matrix.frobenius-norm",
    "category": "Matrix",
    "description": "Calculates the **Frobenius norm** of a matrix.",
    "returns": {
      "type": "number"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the Frobenius norm of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { frobenius-norm } = import(\\"Matrix\\");\\nfrobenius-norm([[1, 2], [3, 4]])",
      "let { frobenius-norm } = import(\\"Matrix\\");\\nfrobenius-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])"
    ]
  },
  "Matrix.one-norm": {
    "title": "Matrix.one-norm",
    "category": "Matrix",
    "description": "Calculates the **one-norm** (column norm) of a matrix.",
    "returns": {
      "type": "number"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the one-norm of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { one-norm } = import(\\"Matrix\\");\\none-norm([[1, 2], [3, 4]])",
      "let { one-norm } = import(\\"Matrix\\");\\none-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])"
    ]
  },
  "Matrix.inf-norm": {
    "title": "Matrix.inf-norm",
    "category": "Matrix",
    "description": "Calculates the **infinity norm** of a matrix.",
    "returns": {
      "type": "number"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the infinity norm of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { inf-norm } = import(\\"Matrix\\");\\ninf-norm([[1, 2], [3, 4]])",
      "let { inf-norm } = import(\\"Matrix\\");\\ninf-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])"
    ]
  },
  "Matrix.max-norm": {
    "title": "Matrix.max-norm",
    "category": "Matrix",
    "description": "Calculates the **max norm** of a matrix.",
    "returns": {
      "type": "number"
    },
    "args": {
      "m": {
        "type": "matrix",
        "description": "The \`matrix\` to calculate the max norm of."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "m"
        ]
      }
    ],
    "examples": [
      "let { max-norm } = import(\\"Matrix\\");\\nmax-norm([[1, 2], [3, 4]])",
      "let { max-norm } = import(\\"Matrix\\");\\nmax-norm([[1, 2, 3], [4, 5, 6], [7, 8, 9]])"
    ]
  },
  "Number-Theory.coprime?": {
    "title": "Number-Theory.coprime?",
    "category": "Number Theory",
    "description": "Checks if two numbers are coprime (i.e., their GCD is 1).",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(12, 8)",
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(12, 5)",
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(37, 1)",
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(0, 0)",
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(0, 5)",
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(5, 0)",
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(1, 0)",
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(0, 1)",
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(1, 1)",
      "let { coprime? } = import(\\"Number-Theory\\");\\ncoprime?(2, 3)"
    ]
  },
  "Number-Theory.divisible-by?": {
    "title": "Number-Theory.divisible-by?",
    "category": "Number Theory",
    "description": "Checks if a number is divisible by another number.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { divisible-by? } = import(\\"Number-Theory\\");\\ndivisible-by?(12, 4)",
      "let { divisible-by? } = import(\\"Number-Theory\\");\\ndivisible-by?(12, 5)",
      "let { divisible-by? } = import(\\"Number-Theory\\");\\ndivisible-by?(37, 1)",
      "let { divisible-by? } = import(\\"Number-Theory\\");\\ndivisible-by?(0, 0)",
      "let { divisible-by? } = import(\\"Number-Theory\\");\\ndivisible-by?(0, 5)",
      "let { divisible-by? } = import(\\"Number-Theory\\");\\ndivisible-by?(5, 0)"
    ]
  },
  "Number-Theory.gcd": {
    "title": "Number-Theory.gcd",
    "category": "Number Theory",
    "description": "Calculates the greatest common divisor (GCD) of two numbers.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { gcd } = import(\\"Number-Theory\\");\\ngcd(100, 25)",
      "let { gcd } = import(\\"Number-Theory\\");\\ngcd(37, 1)",
      "let { gcd } = import(\\"Number-Theory\\");\\ngcd(0, 0)",
      "let { gcd } = import(\\"Number-Theory\\");\\ngcd(0, 5)",
      "let { gcd } = import(\\"Number-Theory\\");\\ngcd(5, 0)"
    ]
  },
  "Number-Theory.lcm": {
    "title": "Number-Theory.lcm",
    "category": "Number Theory",
    "description": "Calculates the least common multiple (LCM) of two numbers.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { lcm } = import(\\"Number-Theory\\");\\nlcm(100, 25)",
      "let { lcm } = import(\\"Number-Theory\\");\\nlcm(37, 1)",
      "let { lcm } = import(\\"Number-Theory\\");\\nlcm(0, 5)",
      "let { lcm } = import(\\"Number-Theory\\");\\nlcm(5, 0)"
    ]
  },
  "Number-Theory.multinomial": {
    "title": "Number-Theory.multinomial",
    "category": "Number Theory",
    "description": "Calculates the multinomial coefficient from of a list of numbers representing the sizes of each group.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "args": {
        "type": "integer",
        "rest": true,
        "description": "The numbers representing the sizes of each group."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "args"
        ]
      }
    ],
    "examples": [
      "let { multinomial } = import(\\"Number-Theory\\");\\nmultinomial(5, 2, 3)",
      "let { multinomial } = import(\\"Number-Theory\\");\\nmultinomial(10, 2, 3, 5)"
    ],
    "noOperatorDocumentation": true
  },
  "Number-Theory.amicable?": {
    "title": "Number-Theory.amicable?",
    "category": "Number Theory",
    "description": "Checks if two numbers are amicable (i.e., the sum of the proper divisors of each number equals the other number).",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { amicable? } = import(\\"Number-Theory\\");\\namicable?(220, 284)",
      "let { amicable? } = import(\\"Number-Theory\\");\\namicable?(1184, 1210)",
      "let { amicable? } = import(\\"Number-Theory\\");\\namicable?(2620, 2924)",
      "let { amicable? } = import(\\"Number-Theory\\");\\namicable?(5020, 5564)",
      "let { amicable? } = import(\\"Number-Theory\\");\\namicable?(6232, 6368)"
    ]
  },
  "Number-Theory.euler-totient": {
    "title": "Number-Theory.euler-totient",
    "category": "Number Theory",
    "description": "Calculates the Euler's totient function ((n)) of a number, which counts the integers up to n that are coprime to n.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to calculate the totient for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { euler-totient } = import(\\"Number-Theory\\");\\neuler-totient(1)",
      "let { euler-totient } = import(\\"Number-Theory\\");\\neuler-totient(2)",
      "let { euler-totient } = import(\\"Number-Theory\\");\\neuler-totient(10)",
      "let { euler-totient } = import(\\"Number-Theory\\");\\neuler-totient(20)"
    ]
  },
  "Number-Theory.mobius": {
    "title": "Number-Theory.mobius",
    "category": "Number Theory",
    "description": "Calculates the Mbius function ((n)) of a number, which is used in number theory.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to calculate the Mbius function for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(1)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(2)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(3)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(4)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(6)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(12)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(30)"
    ]
  },
  "Number-Theory.mertens": {
    "title": "Number-Theory.mertens",
    "category": "Number Theory",
    "description": "Calculates the Mertens function (M(n)) of a number, which is the sum of the Mbius function up to n.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to calculate the Mertens function for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(1)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(2)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(3)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(4)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(6)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(12)",
      "let { mobius } = import(\\"Number-Theory\\");\\nmobius(30)"
    ]
  },
  "Number-Theory.sigma": {
    "title": "Number-Theory.sigma",
    "category": "Number Theory",
    "description": "Calculates the sum of divisors function ((n)) of a number, which is the sum of all positive divisors of n.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to calculate the sum of divisors for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { sigma } = import(\\"Number-Theory\\");\\nsigma(1)",
      "let { sigma } = import(\\"Number-Theory\\");\\nsigma(2)",
      "let { sigma } = import(\\"Number-Theory\\");\\nsigma(3)",
      "let { sigma } = import(\\"Number-Theory\\");\\nsigma(4)",
      "let { sigma } = import(\\"Number-Theory\\");\\nsigma(6)",
      "let { sigma } = import(\\"Number-Theory\\");\\nsigma(12)",
      "let { sigma } = import(\\"Number-Theory\\");\\nsigma(30)"
    ]
  },
  "Number-Theory.carmichael-lambda": {
    "title": "Number-Theory.carmichael-lambda",
    "category": "Number Theory",
    "description": "Calculates the Carmichael function ((n)) of a number, which is the smallest positive integer m such that a^m  1 (mod n) for all integers a coprime to n.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to calculate the Carmichael function for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { carmichael-lambda } = import(\\"Number-Theory\\");\\ncarmichael-lambda(1)",
      "let { carmichael-lambda } = import(\\"Number-Theory\\");\\ncarmichael-lambda(2)",
      "let { carmichael-lambda } = import(\\"Number-Theory\\");\\ncarmichael-lambda(3)",
      "let { carmichael-lambda } = import(\\"Number-Theory\\");\\ncarmichael-lambda(4)",
      "let { carmichael-lambda } = import(\\"Number-Theory\\");\\ncarmichael-lambda(6)",
      "let { carmichael-lambda } = import(\\"Number-Theory\\");\\ncarmichael-lambda(12)",
      "let { carmichael-lambda } = import(\\"Number-Theory\\");\\ncarmichael-lambda(30)"
    ]
  },
  "Number-Theory.cartesian-product": {
    "title": "Number-Theory.cartesian-product",
    "category": "Number Theory",
    "description": "Calculates the Cartesian product of two or more sets.",
    "returns": {
      "type": "array",
      "array": true
    },
    "args": {
      "sets": {
        "type": "array",
        "array": true,
        "description": "The input collections to calculate the Cartesian product from."
      },
      "a": {
        "type": "array"
      },
      "b": {
        "type": "array"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "sets"
        ]
      }
    ],
    "examples": [
      "let { cartesian-product } = import(\\"Number-Theory\\");\\ncartesian-product([1, 2], [\\"a\\", \\"b\\"])",
      "let { cartesian-product } = import(\\"Number-Theory\\");\\ncartesian-product([1, 2], [\\"a\\", \\"b\\"], [true, false])",
      "let { cartesian-product } = import(\\"Number-Theory\\");\\ncartesian-product([1, 2, 3], [\\"x\\", \\"y\\", \\"z\\"])"
    ]
  },
  "Number-Theory.perfect-power": {
    "title": "Number-Theory.perfect-power",
    "category": "Number Theory",
    "description": "Returns a tuple of the base and exponent if the number is a perfect power, otherwise returns null.",
    "returns": {
      "type": "array",
      "array": true
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { perfect-power } = import(\\"Number-Theory\\");\\nperfect-power(1)",
      "let { perfect-power } = import(\\"Number-Theory\\");\\nperfect-power(2)",
      "let { perfect-power } = import(\\"Number-Theory\\");\\nperfect-power(4)",
      "let { perfect-power } = import(\\"Number-Theory\\");\\nperfect-power(8)",
      "let { perfect-power } = import(\\"Number-Theory\\");\\nperfect-power(9)",
      "let { perfect-power } = import(\\"Number-Theory\\");\\nperfect-power(16)",
      "let { perfect-power } = import(\\"Number-Theory\\");\\nperfect-power(19)"
    ]
  },
  "Number-Theory.mod-exp": {
    "title": "Number-Theory.mod-exp",
    "category": "Number Theory",
    "description": "Calculates the modular exponentiation of a base raised to an exponent modulo a modulus.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "base": {
        "type": "integer"
      },
      "exponent": {
        "type": "integer"
      },
      "modulus": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "base",
          "exponent",
          "modulus"
        ]
      }
    ],
    "examples": [
      "let { mod-exp } = import(\\"Number-Theory\\");\\nmod-exp(2, 3, 5)",
      "let { mod-exp } = import(\\"Number-Theory\\");\\nmod-exp(3, 4, 7)",
      "let { mod-exp } = import(\\"Number-Theory\\");\\nmod-exp(5, 6, 11)",
      "let { mod-exp } = import(\\"Number-Theory\\");\\nmod-exp(7, 8, 13)"
    ]
  },
  "Number-Theory.mod-inv": {
    "title": "Number-Theory.mod-inv",
    "category": "Number Theory",
    "description": "Calculates the modular multiplicative inverse of a number modulo another number.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "m"
        ]
      }
    ],
    "examples": [
      "let { mod-inv } = import(\\"Number-Theory\\");\\nmod-inv(3, 11)",
      "let { mod-inv } = import(\\"Number-Theory\\");\\nmod-inv(10, 17)",
      "let { mod-inv } = import(\\"Number-Theory\\");\\nmod-inv(5, 13)",
      "let { mod-inv } = import(\\"Number-Theory\\");\\nmod-inv(7, 19)"
    ]
  },
  "Number-Theory.extended-gcd": {
    "title": "Number-Theory.extended-gcd",
    "category": "Number Theory",
    "description": "Calculates the extended greatest common divisor (GCD) of two numbers, returning the GCD and the coefficients of Bzout's identity.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { extended-gcd } = import(\\"Number-Theory\\");\\nextended-gcd(30, 12)",
      "let { extended-gcd } = import(\\"Number-Theory\\");\\nextended-gcd(56, 98)",
      "let { extended-gcd } = import(\\"Number-Theory\\");\\nextended-gcd(101, 10)",
      "let { extended-gcd } = import(\\"Number-Theory\\");\\nextended-gcd(17, 13)"
    ]
  },
  "Number-Theory.chinese-remainder": {
    "title": "Number-Theory.chinese-remainder",
    "category": "Number Theory",
    "description": "Solves a system of simultaneous congruences using the Chinese Remainder Theorem.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "remainders": {
        "type": "integer",
        "array": true,
        "description": "The remainders of the congruences."
      },
      "moduli": {
        "type": "integer",
        "array": true,
        "description": "The moduli of the congruences."
      },
      "a": {
        "type": "array"
      },
      "b": {
        "type": "array"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "remainders",
          "moduli"
        ]
      }
    ],
    "examples": [
      "let { chinese-remainder } = import(\\"Number-Theory\\");\\nchinese-remainder([2, 3], [3, 5])",
      "let { chinese-remainder } = import(\\"Number-Theory\\");\\nchinese-remainder([1, 2], [3, 4])",
      "let { chinese-remainder } = import(\\"Number-Theory\\");\\nchinese-remainder([0, 1], [2, 3])",
      "let { chinese-remainder } = import(\\"Number-Theory\\");\\nchinese-remainder([1, 2, 3], [4, 5, 7])"
    ]
  },
  "Number-Theory.stirling-first": {
    "title": "Number-Theory.stirling-first",
    "category": "Number Theory",
    "description": "Calculates the Stirling numbers of the first kind, which count the number of permutations of n elements with k cycles.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer",
        "description": "The number of elements."
      },
      "b": {
        "type": "integer",
        "description": "The number of cycles."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { stirling-first } = import(\\"Number-Theory\\");\\nstirling-first(5, 2)",
      "let { stirling-first } = import(\\"Number-Theory\\");\\nstirling-first(4, 3)",
      "let { stirling-first } = import(\\"Number-Theory\\");\\nstirling-first(6, 1)",
      "let { stirling-first } = import(\\"Number-Theory\\");\\nstirling-first(7, 4)",
      "let { stirling-first } = import(\\"Number-Theory\\");\\nstirling-first(8, 5)"
    ]
  },
  "Number-Theory.stirling-second": {
    "title": "Number-Theory.stirling-second",
    "category": "Number Theory",
    "description": "Calculates the Stirling numbers of the second kind, which count the number of ways to partition n elements into k non-empty subsets.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer",
        "description": "The number of elements."
      },
      "b": {
        "type": "integer",
        "description": "The number of subsets."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { stirling-second } = import(\\"Number-Theory\\");\\nstirling-second(5, 2)",
      "let { stirling-second } = import(\\"Number-Theory\\");\\nstirling-second(4, 3)",
      "let { stirling-second } = import(\\"Number-Theory\\");\\nstirling-second(6, 1)",
      "let { stirling-second } = import(\\"Number-Theory\\");\\nstirling-second(7, 4)",
      "let { stirling-second } = import(\\"Number-Theory\\");\\nstirling-second(8, 5)"
    ]
  },
  "Number-Theory.abundant-seq": {
    "title": "Number-Theory.abundant-seq",
    "category": "Number Theory",
    "description": "Generates the abundant numbers up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { abundant-seq } = import(\\"Number-Theory\\");\\nabundant-seq(1)",
      "let { abundant-seq } = import(\\"Number-Theory\\");\\nabundant-seq(5)"
    ]
  },
  "Number-Theory.abundant-nth": {
    "title": "Number-Theory.abundant-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the abundant numbers.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the number in the sequence."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { abundant-nth } = import(\\"Number-Theory\\");\\nabundant-nth(1)",
      "let { abundant-nth } = import(\\"Number-Theory\\");\\nabundant-nth(5)"
    ]
  },
  "Number-Theory.abundant?": {
    "title": "Number-Theory.abundant?",
    "category": "Number Theory",
    "description": "Checks if a number is abundant.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { abundant? } = import(\\"Number-Theory\\");\\nabundant?(12)",
      "let { abundant? } = import(\\"Number-Theory\\");\\nabundant?(15)"
    ]
  },
  "Number-Theory.abundant-take-while": {
    "title": "Number-Theory.abundant-take-while",
    "category": "Number Theory",
    "description": "Generates the abundant numbers while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { abundant-take-while } = import(\\"Number-Theory\\");\\nabundant-take-while(-> $ < 100)"
    ]
  },
  "Number-Theory.collatz-seq": {
    "title": "Number-Theory.collatz-seq",
    "category": "Number Theory",
    "description": "Generates the collatz sequence starting from a given integer.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "start": {
        "type": "integer",
        "description": "The starting integer for the collatz sequence."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start"
        ]
      }
    ],
    "examples": [
      "let { collatz-seq } = import(\\"Number-Theory\\");\\ncollatz-seq(3)",
      "let { collatz-seq } = import(\\"Number-Theory\\");\\ncollatz-seq(11)"
    ]
  },
  "Number-Theory.composite-seq": {
    "title": "Number-Theory.composite-seq",
    "category": "Number Theory",
    "description": "Generates the composite sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { composite-seq } = import(\\"Number-Theory\\");\\ncomposite-seq(1)",
      "let { composite-seq } = import(\\"Number-Theory\\");\\ncomposite-seq(2)",
      "let { composite-seq } = import(\\"Number-Theory\\");\\ncomposite-seq(10)"
    ]
  },
  "Number-Theory.composite-nth": {
    "title": "Number-Theory.composite-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the composite sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the composite number to retrieve."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { composite-nth } = import(\\"Number-Theory\\");\\ncomposite-nth(1)",
      "let { composite-nth } = import(\\"Number-Theory\\");\\ncomposite-nth(2)",
      "let { composite-nth } = import(\\"Number-Theory\\");\\ncomposite-nth(10)"
    ]
  },
  "Number-Theory.composite?": {
    "title": "Number-Theory.composite?",
    "category": "Number Theory",
    "description": "Determines if a number is composite.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { composite? } = import(\\"Number-Theory\\");\\ncomposite?(4)",
      "let { composite? } = import(\\"Number-Theory\\");\\ncomposite?(5)",
      "let { composite? } = import(\\"Number-Theory\\");\\ncomposite?(11)"
    ]
  },
  "Number-Theory.composite-take-while": {
    "title": "Number-Theory.composite-take-while",
    "category": "Number Theory",
    "description": "Generates the composite sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { composite-take-while } = import(\\"Number-Theory\\");\\ncomposite-take-while(-> $ < 50)"
    ]
  },
  "Number-Theory.deficient-seq": {
    "title": "Number-Theory.deficient-seq",
    "category": "Number Theory",
    "description": "Generates the deficient numbers up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { deficient-seq } = import(\\"Number-Theory\\");\\ndeficient-seq(1)",
      "let { deficient-seq } = import(\\"Number-Theory\\");\\ndeficient-seq(5)"
    ]
  },
  "Number-Theory.deficient-nth": {
    "title": "Number-Theory.deficient-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the deficient numbers.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the number in the sequence."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { deficient-nth } = import(\\"Number-Theory\\");\\ndeficient-nth(5)",
      "let { deficient-nth } = import(\\"Number-Theory\\");\\ndeficient-nth(12)"
    ]
  },
  "Number-Theory.deficient?": {
    "title": "Number-Theory.deficient?",
    "category": "Number Theory",
    "description": "Checks if a number is deficient.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { deficient? } = import(\\"Number-Theory\\");\\ndeficient?(12)",
      "let { deficient? } = import(\\"Number-Theory\\");\\ndeficient?(15)"
    ]
  },
  "Number-Theory.deficient-take-while": {
    "title": "Number-Theory.deficient-take-while",
    "category": "Number Theory",
    "description": "Generates the deficient numbers while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { deficient-take-while } = import(\\"Number-Theory\\");\\ndeficient-take-while(-> $ < 100)"
    ]
  },
  "Number-Theory.golomb-seq": {
    "title": "Number-Theory.golomb-seq",
    "category": "Number Theory",
    "description": "Generates the Golomb sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { golomb-seq } = import(\\"Number-Theory\\");\\ngolomb-seq(5)",
      "let { golomb-seq } = import(\\"Number-Theory\\");\\ngolomb-seq(20)"
    ]
  },
  "Number-Theory.golomb-nth": {
    "title": "Number-Theory.golomb-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Golomb sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { golomb-nth } = import(\\"Number-Theory\\");\\ngolomb-nth(5)",
      "let { golomb-nth } = import(\\"Number-Theory\\");\\ngolomb-nth(1000)"
    ]
  },
  "Number-Theory.golomb?": {
    "title": "Number-Theory.golomb?",
    "category": "Number Theory",
    "description": "Checks if a number is in the Golomb sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { golomb? } = import(\\"Number-Theory\\");\\ngolomb?(1)",
      "let { golomb? } = import(\\"Number-Theory\\");\\ngolomb?(2)",
      "let { golomb? } = import(\\"Number-Theory\\");\\ngolomb?(3345)",
      "let { golomb? } = import(\\"Number-Theory\\");\\ngolomb?(67867864)"
    ]
  },
  "Number-Theory.golomb-take-while": {
    "title": "Number-Theory.golomb-take-while",
    "category": "Number Theory",
    "description": "Generates the Golomb sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { golomb-take-while } = import(\\"Number-Theory\\");\\ngolomb-take-while(-> $ <= 10)"
    ]
  },
  "Number-Theory.happy-seq": {
    "title": "Number-Theory.happy-seq",
    "category": "Number Theory",
    "description": "Generates the happy sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If not provided, the default is 20 (the maximum length of the pre-calculated happy numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { happy-seq } = import(\\"Number-Theory\\");\\nhappy-seq(1)",
      "let { happy-seq } = import(\\"Number-Theory\\");\\nhappy-seq(2)",
      "let { happy-seq } = import(\\"Number-Theory\\");\\nhappy-seq(20)"
    ]
  },
  "Number-Theory.happy-nth": {
    "title": "Number-Theory.happy-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the happy sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the happy number to return."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { happy-nth } = import(\\"Number-Theory\\");\\nhappy-nth(1)",
      "let { happy-nth } = import(\\"Number-Theory\\");\\nhappy-nth(2)",
      "let { happy-nth } = import(\\"Number-Theory\\");\\nhappy-nth(20)"
    ]
  },
  "Number-Theory.happy?": {
    "title": "Number-Theory.happy?",
    "category": "Number Theory",
    "description": "Determines if a number is a happy number.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { happy? } = import(\\"Number-Theory\\");\\nhappy?(1)",
      "let { happy? } = import(\\"Number-Theory\\");\\nhappy?(2)",
      "let { happy? } = import(\\"Number-Theory\\");\\nhappy?(100)"
    ]
  },
  "Number-Theory.happy-take-while": {
    "title": "Number-Theory.happy-take-while",
    "category": "Number Theory",
    "description": "Generates the happy sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { happy-take-while } = import(\\"Number-Theory\\");\\nhappy-take-while(-> $ < 100)"
    ]
  },
  "Number-Theory.juggler-seq": {
    "title": "Number-Theory.juggler-seq",
    "category": "Number Theory",
    "description": "Generates the Juggler sequence starting from a given integer.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "start": {
        "type": "integer",
        "description": "The starting integer for the Juggler sequence."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start"
        ]
      }
    ],
    "examples": [
      "let { juggler-seq } = import(\\"Number-Theory\\");\\njuggler-seq(3)",
      "let { juggler-seq } = import(\\"Number-Theory\\");\\njuggler-seq(5)"
    ]
  },
  "Number-Theory.look-and-say-seq": {
    "title": "Number-Theory.look-and-say-seq",
    "category": "Number Theory",
    "description": "Generates the Look-and-Say sequence up to a specified length.",
    "returns": {
      "type": "string",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { look-and-say-seq } = import(\\"Number-Theory\\");\\nlook-and-say-seq(5)"
    ]
  },
  "Number-Theory.look-and-say-nth": {
    "title": "Number-Theory.look-and-say-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Look-and-Say sequence.",
    "returns": {
      "type": "string"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term in the sequence."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { look-and-say-nth } = import(\\"Number-Theory\\");\\nlook-and-say-nth(5)"
    ]
  },
  "Number-Theory.look-and-say-take-while": {
    "title": "Number-Theory.look-and-say-take-while",
    "category": "Number Theory",
    "description": "Generates the Look-and-Say sequence while a condition is met.",
    "returns": {
      "type": "string",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes a string and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { look-and-say-take-while } = import(\\"Number-Theory\\");\\nlook-and-say-take-while((term, index) -> count(term) < 10)",
      "let { look-and-say-take-while } = import(\\"Number-Theory\\");\\nlook-and-say-take-while(-> $2 <= 10)"
    ]
  },
  "Number-Theory.look-and-say?": {
    "title": "Number-Theory.look-and-say?",
    "category": "Number Theory",
    "description": "Checks if a string is a valid Look-and-Say term.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "term": {
        "type": "string",
        "description": "The term to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "term"
        ]
      }
    ],
    "examples": [
      "let { look-and-say? } = import(\\"Number-Theory\\");\\nlook-and-say?(\\"111221\\")",
      "let { look-and-say? } = import(\\"Number-Theory\\");\\nlook-and-say?(\\"123\\")"
    ]
  },
  "Number-Theory.lucky-seq": {
    "title": "Number-Theory.lucky-seq",
    "category": "Number Theory",
    "description": "Generates the lucky sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { lucky-seq } = import(\\"Number-Theory\\");\\nlucky-seq(1)",
      "let { lucky-seq } = import(\\"Number-Theory\\");\\nlucky-seq(2)",
      "let { lucky-seq } = import(\\"Number-Theory\\");\\nlucky-seq(20)"
    ]
  },
  "Number-Theory.lucky-nth": {
    "title": "Number-Theory.lucky-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the lucky sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The position in the sequence."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { lucky-nth } = import(\\"Number-Theory\\");\\nlucky-nth(1)",
      "let { lucky-nth } = import(\\"Number-Theory\\");\\nlucky-nth(2)",
      "let { lucky-nth } = import(\\"Number-Theory\\");\\nlucky-nth(20)"
    ]
  },
  "Number-Theory.lucky?": {
    "title": "Number-Theory.lucky?",
    "category": "Number Theory",
    "description": "Checks if a number is a lucky number.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { lucky? } = import(\\"Number-Theory\\");\\nlucky?(4)",
      "let { lucky? } = import(\\"Number-Theory\\");\\nlucky?(7)",
      "let { lucky? } = import(\\"Number-Theory\\");\\nlucky?(33)"
    ]
  },
  "Number-Theory.lucky-take-while": {
    "title": "Number-Theory.lucky-take-while",
    "category": "Number Theory",
    "description": "Generates the lucky sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { lucky-take-while } = import(\\"Number-Theory\\");\\nlucky-take-while(-> $ < 100)"
    ]
  },
  "Number-Theory.padovan-seq": {
    "title": "Number-Theory.padovan-seq",
    "category": "Number Theory",
    "description": "Generates the Padovan sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { padovan-seq } = import(\\"Number-Theory\\");\\npadovan-seq(5)",
      "let { padovan-seq } = import(\\"Number-Theory\\");\\npadovan-seq(10)",
      "let { padovan-seq } = import(\\"Number-Theory\\");\\npadovan-seq(20)"
    ]
  },
  "Number-Theory.padovan-nth": {
    "title": "Number-Theory.padovan-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Padovan sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { padovan-nth } = import(\\"Number-Theory\\");\\npadovan-nth(5)",
      "let { padovan-nth } = import(\\"Number-Theory\\");\\npadovan-nth(10)",
      "let { padovan-nth } = import(\\"Number-Theory\\");\\npadovan-nth(20)"
    ]
  },
  "Number-Theory.padovan?": {
    "title": "Number-Theory.padovan?",
    "category": "Number Theory",
    "description": "Checks if a number is in the Padovan sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { padovan? } = import(\\"Number-Theory\\");\\npadovan?(1)",
      "let { padovan? } = import(\\"Number-Theory\\");\\npadovan?(265)",
      "let { padovan? } = import(\\"Number-Theory\\");\\npadovan?(6)"
    ]
  },
  "Number-Theory.padovan-take-while": {
    "title": "Number-Theory.padovan-take-while",
    "category": "Number Theory",
    "description": "Generates the Padovan sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { padovan-take-while } = import(\\"Number-Theory\\");\\npadovan-take-while(-> $ < 1000)"
    ]
  },
  "Number-Theory.perfect-square-seq": {
    "title": "Number-Theory.perfect-square-seq",
    "category": "Number Theory",
    "description": "Generates the perfect square numbers up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { perfect-square-seq } = import(\\"Number-Theory\\");\\nperfect-square-seq(5)",
      "let { perfect-square-seq } = import(\\"Number-Theory\\");\\nperfect-square-seq(20)"
    ]
  },
  "Number-Theory.perfect-square-nth": {
    "title": "Number-Theory.perfect-square-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the perfect square numbers.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { perfect-square-nth } = import(\\"Number-Theory\\");\\nperfect-square-nth(1)",
      "let { perfect-square-nth } = import(\\"Number-Theory\\");\\nperfect-square-nth(5)"
    ]
  },
  "Number-Theory.perfect-square?": {
    "title": "Number-Theory.perfect-square?",
    "category": "Number Theory",
    "description": "Checks if a number is a perfect square.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { perfect-square? } = import(\\"Number-Theory\\");\\nperfect-square?(16)",
      "let { perfect-square? } = import(\\"Number-Theory\\");\\nperfect-square?(20)"
    ]
  },
  "Number-Theory.perfect-square-take-while": {
    "title": "Number-Theory.perfect-square-take-while",
    "category": "Number Theory",
    "description": "Generates the perfect square numbers while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { perfect-square-take-while } = import(\\"Number-Theory\\");\\nperfect-square-take-while(-> $ <= 100)"
    ]
  },
  "Number-Theory.perfect-cube-seq": {
    "title": "Number-Theory.perfect-cube-seq",
    "category": "Number Theory",
    "description": "Generates the perfect cube numbers up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { perfect-cube-seq } = import(\\"Number-Theory\\");\\nperfect-cube-seq(5)",
      "let { perfect-cube-seq } = import(\\"Number-Theory\\");\\nperfect-cube-seq(20)"
    ]
  },
  "Number-Theory.perfect-cube-nth": {
    "title": "Number-Theory.perfect-cube-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the perfect cube numbers.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { perfect-cube-nth } = import(\\"Number-Theory\\");\\nperfect-cube-nth(1)",
      "let { perfect-cube-nth } = import(\\"Number-Theory\\");\\nperfect-cube-nth(5)"
    ]
  },
  "Number-Theory.perfect-cube?": {
    "title": "Number-Theory.perfect-cube?",
    "category": "Number Theory",
    "description": "Checks if a number is in the perfect cube numbers.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { perfect-cube? } = import(\\"Number-Theory\\");\\nperfect-cube?(7)",
      "let { perfect-cube? } = import(\\"Number-Theory\\");\\nperfect-cube?(8)",
      "let { perfect-cube? } = import(\\"Number-Theory\\");\\nperfect-cube?(9)"
    ]
  },
  "Number-Theory.perfect-cube-take-while": {
    "title": "Number-Theory.perfect-cube-take-while",
    "category": "Number Theory",
    "description": "Generates the perfect cube numbers while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { perfect-cube-take-while } = import(\\"Number-Theory\\");\\nperfect-cube-take-while(-> $ <= 100)"
    ]
  },
  "Number-Theory.perfect-power-seq": {
    "title": "Number-Theory.perfect-power-seq",
    "category": "Number Theory",
    "description": "Generates the perfect power numbers up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { perfect-power-seq } = import(\\"Number-Theory\\");\\nperfect-power-seq(5)",
      "let { perfect-power-seq } = import(\\"Number-Theory\\");\\nperfect-power-seq(20)"
    ]
  },
  "Number-Theory.perfect-power-nth": {
    "title": "Number-Theory.perfect-power-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the perfect power numbers.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { perfect-power-nth } = import(\\"Number-Theory\\");\\nperfect-power-nth(3)",
      "let { perfect-power-nth } = import(\\"Number-Theory\\");\\nperfect-power-nth(15)"
    ]
  },
  "Number-Theory.perfect-power?": {
    "title": "Number-Theory.perfect-power?",
    "category": "Number Theory",
    "description": "Checks if a number is in the perfect power numbers.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { perfect-power? } = import(\\"Number-Theory\\");\\nperfect-power?(7)",
      "let { perfect-power? } = import(\\"Number-Theory\\");\\nperfect-power?(8)",
      "let { perfect-power? } = import(\\"Number-Theory\\");\\nperfect-power?(9)",
      "let { perfect-power? } = import(\\"Number-Theory\\");\\nperfect-power?(10)"
    ]
  },
  "Number-Theory.perfect-power-take-while": {
    "title": "Number-Theory.perfect-power-take-while",
    "category": "Number Theory",
    "description": "Generates the perfect power numbers while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { perfect-power-take-while } = import(\\"Number-Theory\\");\\nperfect-power-take-while(-> $ <= 100)"
    ]
  },
  "Number-Theory.prime-seq": {
    "title": "Number-Theory.prime-seq",
    "category": "Number Theory",
    "description": "Generates the prime sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { prime-seq } = import(\\"Number-Theory\\");\\nprime-seq(1)",
      "let { prime-seq } = import(\\"Number-Theory\\");\\nprime-seq(2)",
      "let { prime-seq } = import(\\"Number-Theory\\");\\nprime-seq(10)"
    ]
  },
  "Number-Theory.prime-nth": {
    "title": "Number-Theory.prime-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the prime sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { prime-nth } = import(\\"Number-Theory\\");\\nprime-nth(1)",
      "let { prime-nth } = import(\\"Number-Theory\\");\\nprime-nth(2)",
      "let { prime-nth } = import(\\"Number-Theory\\");\\nprime-nth(10)"
    ]
  },
  "Number-Theory.prime?": {
    "title": "Number-Theory.prime?",
    "category": "Number Theory",
    "description": "Determines if a number is prime.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { prime? } = import(\\"Number-Theory\\");\\nprime?(1)",
      "let { prime? } = import(\\"Number-Theory\\");\\nprime?(2)",
      "let { prime? } = import(\\"Number-Theory\\");\\nprime?(3)",
      "let { prime? } = import(\\"Number-Theory\\");\\nprime?(4)",
      "let { prime? } = import(\\"Number-Theory\\");\\nprime?(997)",
      "let { prime? } = import(\\"Number-Theory\\");\\nprime?(1001)"
    ]
  },
  "Number-Theory.prime-take-while": {
    "title": "Number-Theory.prime-take-while",
    "category": "Number Theory",
    "description": "Generates the prime sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { prime-take-while } = import(\\"Number-Theory\\");\\nprime-take-while(-> $ < 50)"
    ]
  },
  "Number-Theory.recaman-seq": {
    "title": "Number-Theory.recaman-seq",
    "category": "Number Theory",
    "description": "Generates the Recaman sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { recaman-seq } = import(\\"Number-Theory\\");\\nrecaman-seq(5)",
      "let { recaman-seq } = import(\\"Number-Theory\\");\\nrecaman-seq(10)",
      "let { recaman-seq } = import(\\"Number-Theory\\");\\nrecaman-seq(20)"
    ]
  },
  "Number-Theory.recaman-nth": {
    "title": "Number-Theory.recaman-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Recaman sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { recaman-nth } = import(\\"Number-Theory\\");\\nrecaman-nth(5)",
      "let { recaman-nth } = import(\\"Number-Theory\\");\\nrecaman-nth(10)",
      "let { recaman-nth } = import(\\"Number-Theory\\");\\nrecaman-nth(20)"
    ]
  },
  "Number-Theory.recaman-take-while": {
    "title": "Number-Theory.recaman-take-while",
    "category": "Number Theory",
    "description": "Generates the Recaman sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { recaman-take-while } = import(\\"Number-Theory\\");\\nrecaman-take-while(-> $ < 10)"
    ]
  },
  "Number-Theory.recaman?": {
    "title": "Number-Theory.recaman?",
    "category": "Number Theory",
    "description": "Checks if a number is in the Recaman sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { recaman? } = import(\\"Number-Theory\\");\\nrecaman?(5)",
      "let { recaman? } = import(\\"Number-Theory\\");\\nrecaman?(10)",
      "let { recaman? } = import(\\"Number-Theory\\");\\nrecaman?(20)"
    ]
  },
  "Number-Theory.thue-morse-seq": {
    "title": "Number-Theory.thue-morse-seq",
    "category": "Number Theory",
    "description": "Generates the Thue-Morse sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { thue-morse-seq } = import(\\"Number-Theory\\");\\nthue-morse-seq(5)",
      "let { thue-morse-seq } = import(\\"Number-Theory\\");\\nthue-morse-seq(10)",
      "let { thue-morse-seq } = import(\\"Number-Theory\\");\\nthue-morse-seq(20)"
    ]
  },
  "Number-Theory.thue-morse-nth": {
    "title": "Number-Theory.thue-morse-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Thue-Morse sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term in the sequence."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { thue-morse-nth } = import(\\"Number-Theory\\");\\nthue-morse-nth(5)",
      "let { thue-morse-nth } = import(\\"Number-Theory\\");\\nthue-morse-nth(10)",
      "let { thue-morse-nth } = import(\\"Number-Theory\\");\\nthue-morse-nth(20)"
    ]
  },
  "Number-Theory.thue-morse-take-while": {
    "title": "Number-Theory.thue-morse-take-while",
    "category": "Number Theory",
    "description": "Generates the Thue-Morse sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { thue-morse-take-while } = import(\\"Number-Theory\\");\\nthue-morse-take-while(-> $2 < 10)"
    ]
  },
  "Number-Theory.thue-morse?": {
    "title": "Number-Theory.thue-morse?",
    "category": "Number Theory",
    "description": "Checks if a number is part of the Thue-Morse sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { thue-morse? } = import(\\"Number-Theory\\");\\nthue-morse?(1)",
      "let { thue-morse? } = import(\\"Number-Theory\\");\\nthue-morse?(2)"
    ]
  },
  "Number-Theory.tribonacci-seq": {
    "title": "Number-Theory.tribonacci-seq",
    "category": "Number Theory",
    "description": "Generates the tribonacci sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { tribonacci-seq } = import(\\"Number-Theory\\");\\ntribonacci-seq(1)",
      "let { tribonacci-seq } = import(\\"Number-Theory\\");\\ntribonacci-seq(2)",
      "let { tribonacci-seq } = import(\\"Number-Theory\\");\\ntribonacci-seq(10)"
    ]
  },
  "Number-Theory.tribonacci-take-while": {
    "title": "Number-Theory.tribonacci-take-while",
    "category": "Number Theory",
    "description": "Generates the tribonacci sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { tribonacci-take-while } = import(\\"Number-Theory\\");\\ntribonacci-take-while(-> $ < 100)"
    ]
  },
  "Number-Theory.tribonacci-nth": {
    "title": "Number-Theory.tribonacci-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the tribonacci sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { tribonacci-nth } = import(\\"Number-Theory\\");\\ntribonacci-nth(1)",
      "let { tribonacci-nth } = import(\\"Number-Theory\\");\\ntribonacci-nth(2)",
      "let { tribonacci-nth } = import(\\"Number-Theory\\");\\ntribonacci-nth(10)"
    ]
  },
  "Number-Theory.tribonacci?": {
    "title": "Number-Theory.tribonacci?",
    "category": "Number Theory",
    "description": "Determines if a number is in the tribonacci sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(0)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(1)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(2)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(3)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(4)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(5)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(6)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(7)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(8)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(9)",
      "let { tribonacci? } = import(\\"Number-Theory\\");\\ntribonacci?(10)"
    ]
  },
  "Number-Theory.catalan-seq": {
    "title": "Number-Theory.catalan-seq",
    "category": "Number Theory",
    "description": "Generates the Catalan sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If not provided, the default is 30 (the maximum length of the pre-calculated catalan numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { catalan-seq } = import(\\"Number-Theory\\");\\ncatalan-seq(5)",
      "let { catalan-seq } = import(\\"Number-Theory\\");\\ncatalan-seq(10)",
      "let { catalan-seq } = import(\\"Number-Theory\\");\\ncatalan-seq()"
    ]
  },
  "Number-Theory.catalan-take-while": {
    "title": "Number-Theory.catalan-take-while",
    "category": "Number Theory",
    "description": "Generates the Catalan sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { catalan-take-while } = import(\\"Number-Theory\\");\\ncatalan-take-while(-> $ < 1000)"
    ]
  },
  "Number-Theory.catalan-nth": {
    "title": "Number-Theory.catalan-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Catalan sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { catalan-nth } = import(\\"Number-Theory\\");\\ncatalan-nth(5)",
      "let { catalan-nth } = import(\\"Number-Theory\\");\\ncatalan-nth(10)"
    ]
  },
  "Number-Theory.catalan?": {
    "title": "Number-Theory.catalan?",
    "category": "Number Theory",
    "description": "Determines if a number is in the Catalan sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { catalan? } = import(\\"Number-Theory\\");\\ncatalan?(5)",
      "let { catalan? } = import(\\"Number-Theory\\");\\ncatalan?(10)"
    ]
  },
  "Number-Theory.factorial-seq": {
    "title": "Number-Theory.factorial-seq",
    "category": "Number Theory",
    "description": "Generates the factorial sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If not provided, the default is 19 (the maximum length of the pre-calculated factorial numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { factorial-seq } = import(\\"Number-Theory\\");\\nfactorial-seq(1)",
      "let { factorial-seq } = import(\\"Number-Theory\\");\\nfactorial-seq(2)",
      "let { factorial-seq } = import(\\"Number-Theory\\");\\nfactorial-seq(3)",
      "let { factorial-seq } = import(\\"Number-Theory\\");\\nfactorial-seq(4)",
      "let { factorial-seq } = import(\\"Number-Theory\\");\\nfactorial-seq(5)",
      "let { factorial-seq } = import(\\"Number-Theory\\");\\nfactorial-seq(10)"
    ]
  },
  "Number-Theory.factorial-take-while": {
    "title": "Number-Theory.factorial-take-while",
    "category": "Number Theory",
    "description": "Generates the factorial sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { factorial-take-while } = import(\\"Number-Theory\\");\\nfactorial-take-while(-> $ < 1000)"
    ]
  },
  "Number-Theory.factorial-nth": {
    "title": "Number-Theory.factorial-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the factorial sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { factorial-nth } = import(\\"Number-Theory\\");\\nfactorial-nth(1)",
      "let { factorial-nth } = import(\\"Number-Theory\\");\\nfactorial-nth(2)",
      "let { factorial-nth } = import(\\"Number-Theory\\");\\nfactorial-nth(3)",
      "let { factorial-nth } = import(\\"Number-Theory\\");\\nfactorial-nth(4)",
      "let { factorial-nth } = import(\\"Number-Theory\\");\\nfactorial-nth(5)",
      "let { factorial-nth } = import(\\"Number-Theory\\");\\nfactorial-nth(10)"
    ]
  },
  "Number-Theory.factorial?": {
    "title": "Number-Theory.factorial?",
    "category": "Number Theory",
    "description": "Checks if a number is in the factorial sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(1)",
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(2)",
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(3)",
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(4)",
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(5)",
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(6)",
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(7)",
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(8)",
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(9)",
      "let { factorial? } = import(\\"Number-Theory\\");\\nfactorial?(3628800)"
    ]
  },
  "Number-Theory.fibonacci-seq": {
    "title": "Number-Theory.fibonacci-seq",
    "category": "Number Theory",
    "description": "Generates the fibonacci sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If not provided, the default is 79 (the maximum length of the pre-calculated Fibonacci numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { fibonacci-seq } = import(\\"Number-Theory\\");\\nfibonacci-seq(1)",
      "let { fibonacci-seq } = import(\\"Number-Theory\\");\\nfibonacci-seq(2)",
      "let { fibonacci-seq } = import(\\"Number-Theory\\");\\nfibonacci-seq()"
    ]
  },
  "Number-Theory.fibonacci-take-while": {
    "title": "Number-Theory.fibonacci-take-while",
    "category": "Number Theory",
    "description": "Generates the fibonacci sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { fibonacci-take-while } = import(\\"Number-Theory\\");\\nfibonacci-take-while(-> $ < 100)"
    ]
  },
  "Number-Theory.fibonacci-nth": {
    "title": "Number-Theory.fibonacci-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the fibonacci sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { fibonacci-nth } = import(\\"Number-Theory\\");\\nfibonacci-nth(5)",
      "let { fibonacci-nth } = import(\\"Number-Theory\\");\\nfibonacci-nth(50)"
    ]
  },
  "Number-Theory.fibonacci?": {
    "title": "Number-Theory.fibonacci?",
    "category": "Number Theory",
    "description": "Determines if a number is in the fibonacci sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(0)",
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(1)",
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(2)",
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(3)",
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(4)",
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(5)",
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(6)",
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(7)",
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(8)",
      "let { fibonacci? } = import(\\"Number-Theory\\");\\nfibonacci?(9)"
    ]
  },
  "Number-Theory.lucas-seq": {
    "title": "Number-Theory.lucas-seq",
    "category": "Number Theory",
    "description": "Generates the lucas sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If not provided, the default is 77 (the maximum length of the pre-calculated Lucas numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { lucas-seq } = import(\\"Number-Theory\\");\\nlucas-seq(1)",
      "let { lucas-seq } = import(\\"Number-Theory\\");\\nlucas-seq(2)",
      "let { lucas-seq } = import(\\"Number-Theory\\");\\nlucas-seq()"
    ]
  },
  "Number-Theory.lucas-take-while": {
    "title": "Number-Theory.lucas-take-while",
    "category": "Number Theory",
    "description": "Generates the lucas sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { lucas-take-while } = import(\\"Number-Theory\\");\\nlucas-take-while(-> $ < 100)"
    ]
  },
  "Number-Theory.lucas-nth": {
    "title": "Number-Theory.lucas-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the lucas sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { lucas-nth } = import(\\"Number-Theory\\");\\nlucas-nth(1)",
      "let { lucas-nth } = import(\\"Number-Theory\\");\\nlucas-nth(2)",
      "let { lucas-nth } = import(\\"Number-Theory\\");\\nlucas-nth(10)"
    ]
  },
  "Number-Theory.lucas?": {
    "title": "Number-Theory.lucas?",
    "category": "Number Theory",
    "description": "Determines if a number is in the lucas sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { lucas? } = import(\\"Number-Theory\\");\\nlucas?(1)",
      "let { lucas? } = import(\\"Number-Theory\\");\\nlucas?(2)",
      "let { lucas? } = import(\\"Number-Theory\\");\\nlucas?(10)"
    ]
  },
  "Number-Theory.mersenne-seq": {
    "title": "Number-Theory.mersenne-seq",
    "category": "Number Theory",
    "description": "Generates the Mersenne sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If not provided, the default is 9 (the maximum length of the pre-calculated mersenne numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { mersenne-seq } = import(\\"Number-Theory\\");\\nmersenne-seq(1)",
      "let { mersenne-seq } = import(\\"Number-Theory\\");\\nmersenne-seq(5)",
      "let { mersenne-seq } = import(\\"Number-Theory\\");\\nmersenne-seq()"
    ]
  },
  "Number-Theory.mersenne-take-while": {
    "title": "Number-Theory.mersenne-take-while",
    "category": "Number Theory",
    "description": "Generates the Mersenne sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { mersenne-take-while } = import(\\"Number-Theory\\");\\nmersenne-take-while(-> $ < 1000)"
    ]
  },
  "Number-Theory.mersenne-nth": {
    "title": "Number-Theory.mersenne-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Mersenne sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { mersenne-nth } = import(\\"Number-Theory\\");\\nmersenne-nth(1)",
      "let { mersenne-nth } = import(\\"Number-Theory\\");\\nmersenne-nth(5)"
    ]
  },
  "Number-Theory.mersenne?": {
    "title": "Number-Theory.mersenne?",
    "category": "Number Theory",
    "description": "Checks if a number is in the Mersenne sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { mersenne? } = import(\\"Number-Theory\\");\\nmersenne?(3)",
      "let { mersenne? } = import(\\"Number-Theory\\");\\nmersenne?(4)",
      "let { mersenne? } = import(\\"Number-Theory\\");\\nmersenne?(7)"
    ]
  },
  "Number-Theory.partition-seq": {
    "title": "Number-Theory.partition-seq",
    "category": "Number Theory",
    "description": "Generates the partition numbers up to a specified length. If no length is provided, it defaults to 299 (the maximum length of the pre-calculated partition numbers).",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { partition-seq } = import(\\"Number-Theory\\");\\npartition-seq(1)",
      "let { partition-seq } = import(\\"Number-Theory\\");\\npartition-seq(10)",
      "let { partition-seq } = import(\\"Number-Theory\\");\\npartition-seq()"
    ]
  },
  "Number-Theory.partition-take-while": {
    "title": "Number-Theory.partition-take-while",
    "category": "Number Theory",
    "description": "Generates the partition numbers while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { partition-take-while } = import(\\"Number-Theory\\");\\npartition-take-while(-> $ < 1000)"
    ]
  },
  "Number-Theory.partition-nth": {
    "title": "Number-Theory.partition-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the partition numbers.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the partition number to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { partition-nth } = import(\\"Number-Theory\\");\\npartition-nth(1)",
      "let { partition-nth } = import(\\"Number-Theory\\");\\npartition-nth(5)"
    ]
  },
  "Number-Theory.partition?": {
    "title": "Number-Theory.partition?",
    "category": "Number Theory",
    "description": "Checks if a number is in the partition numbers.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { partition? } = import(\\"Number-Theory\\");\\npartition?(0)",
      "let { partition? } = import(\\"Number-Theory\\");\\npartition?(1)",
      "let { partition? } = import(\\"Number-Theory\\");\\npartition?(2)",
      "let { partition? } = import(\\"Number-Theory\\");\\npartition?(3)",
      "let { partition? } = import(\\"Number-Theory\\");\\npartition?(4)",
      "let { partition? } = import(\\"Number-Theory\\");\\npartition?(5)"
    ]
  },
  "Number-Theory.pell-seq": {
    "title": "Number-Theory.pell-seq",
    "category": "Number Theory",
    "description": "Generates the Pell sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If not provided, the default is 42 (the maximum length of the pre-calculated Pell numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { pell-seq } = import(\\"Number-Theory\\");\\npell-seq(5)",
      "let { pell-seq } = import(\\"Number-Theory\\");\\npell-seq(10)",
      "let { pell-seq } = import(\\"Number-Theory\\");\\npell-seq()"
    ]
  },
  "Number-Theory.pell-take-while": {
    "title": "Number-Theory.pell-take-while",
    "category": "Number Theory",
    "description": "Generates the Pell sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { pell-take-while } = import(\\"Number-Theory\\");\\npell-take-while(-> $ < 1000)"
    ]
  },
  "Number-Theory.pell-nth": {
    "title": "Number-Theory.pell-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Pell sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { pell-nth } = import(\\"Number-Theory\\");\\npell-nth(5)",
      "let { pell-nth } = import(\\"Number-Theory\\");\\npell-nth(10)",
      "let { pell-nth } = import(\\"Number-Theory\\");\\npell-nth(20)"
    ]
  },
  "Number-Theory.pell?": {
    "title": "Number-Theory.pell?",
    "category": "Number Theory",
    "description": "Checks if a number is a Pell number.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { pell? } = import(\\"Number-Theory\\");\\npell?(1)",
      "let { pell? } = import(\\"Number-Theory\\");\\npell?(470832)",
      "let { pell? } = import(\\"Number-Theory\\");\\npell?(10)"
    ]
  },
  "Number-Theory.perfect-seq": {
    "title": "Number-Theory.perfect-seq",
    "category": "Number Theory",
    "description": "Generates the perfect numbers up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If no length is provided, it defaults to 7 (the maximum length of the pre-calculated perfect numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { perfect-seq } = import(\\"Number-Theory\\");\\nperfect-seq(1)",
      "let { perfect-seq } = import(\\"Number-Theory\\");\\nperfect-seq(5)",
      "let { perfect-seq } = import(\\"Number-Theory\\");\\nperfect-seq()"
    ]
  },
  "Number-Theory.perfect-take-while": {
    "title": "Number-Theory.perfect-take-while",
    "category": "Number Theory",
    "description": "Generates the perfect numbers while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { perfect-take-while } = import(\\"Number-Theory\\");\\nperfect-take-while(-> $ < 1000)"
    ]
  },
  "Number-Theory.perfect-nth": {
    "title": "Number-Theory.perfect-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the perfect numbers.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the perfect number to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { perfect-nth } = import(\\"Number-Theory\\");\\nperfect-nth(1)",
      "let { perfect-nth } = import(\\"Number-Theory\\");\\nperfect-nth(5)"
    ]
  },
  "Number-Theory.perfect?": {
    "title": "Number-Theory.perfect?",
    "category": "Number Theory",
    "description": "Checks if a number is in the perfect numbers.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(0)",
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(1)",
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(2)",
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(3)",
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(4)",
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(5)",
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(6)",
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(7)",
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(8)",
      "let { perfect? } = import(\\"Number-Theory\\");\\nperfect?(9)"
    ]
  },
  "Number-Theory.sylvester-seq": {
    "title": "Number-Theory.sylvester-seq",
    "category": "Number Theory",
    "description": "Generates the Sylvester sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If not provided, the default is 6 (the maximum length of the pre-calculated Sylvester numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { sylvester-seq } = import(\\"Number-Theory\\");\\nsylvester-seq(5)",
      "let { sylvester-seq } = import(\\"Number-Theory\\");\\nsylvester-seq()",
      "let { sylvester-seq } = import(\\"Number-Theory\\");\\nsylvester-seq()"
    ]
  },
  "Number-Theory.sylvester-take-while": {
    "title": "Number-Theory.sylvester-take-while",
    "category": "Number Theory",
    "description": "Generates the Sylvester sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { sylvester-take-while } = import(\\"Number-Theory\\");\\nsylvester-take-while(-> $ < 100000)"
    ]
  },
  "Number-Theory.sylvester-nth": {
    "title": "Number-Theory.sylvester-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Sylvester sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { sylvester-nth } = import(\\"Number-Theory\\");\\nsylvester-nth(1)",
      "let { sylvester-nth } = import(\\"Number-Theory\\");\\nsylvester-nth(5)"
    ]
  },
  "Number-Theory.sylvester?": {
    "title": "Number-Theory.sylvester?",
    "category": "Number Theory",
    "description": "Checks if a number is in the Sylvester sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { sylvester? } = import(\\"Number-Theory\\");\\nsylvester?(2)",
      "let { sylvester? } = import(\\"Number-Theory\\");\\nsylvester?(3)",
      "let { sylvester? } = import(\\"Number-Theory\\");\\nsylvester?(6)"
    ]
  },
  "Number-Theory.bell-seq": {
    "title": "Number-Theory.bell-seq",
    "category": "Number Theory",
    "description": "Generates the Bell sequence up to a specified length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate. If not provided, the default is 22 (the maximum length of the pre-calculated bell numbers)."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      },
      {
        "argumentNames": []
      }
    ],
    "examples": [
      "let { bell-seq } = import(\\"Number-Theory\\");\\nbell-seq(5)",
      "let { bell-seq } = import(\\"Number-Theory\\");\\nbell-seq(10)",
      "let { bell-seq } = import(\\"Number-Theory\\");\\nbell-seq()"
    ]
  },
  "Number-Theory.bell-take-while": {
    "title": "Number-Theory.bell-take-while",
    "category": "Number Theory",
    "description": "Generates the Bell sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { bell-take-while } = import(\\"Number-Theory\\");\\nbell-take-while(-> $ < 1000)"
    ]
  },
  "Number-Theory.bell-nth": {
    "title": "Number-Theory.bell-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Bell sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { bell-nth } = import(\\"Number-Theory\\");\\nbell-nth(5)",
      "let { bell-nth } = import(\\"Number-Theory\\");\\nbell-nth(10)"
    ]
  },
  "Number-Theory.bell?": {
    "title": "Number-Theory.bell?",
    "category": "Number Theory",
    "description": "Checks if a number is in the Bell sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { bell? } = import(\\"Number-Theory\\");\\nbell?(1)",
      "let { bell? } = import(\\"Number-Theory\\");\\nbell?(27644437)",
      "let { bell? } = import(\\"Number-Theory\\");\\nbell?(27644436)"
    ]
  },
  "Number-Theory.arithmetic-seq": {
    "title": "Number-Theory.arithmetic-seq",
    "category": "Number Theory",
    "description": "Generates the arithmetic sequence for a given $start, $step, and $length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "start": {
        "type": "number",
        "description": "The starting term of the sequence."
      },
      "step": {
        "type": "number",
        "description": "The common difference of the sequence."
      },
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start",
          "step",
          "length"
        ]
      }
    ],
    "examples": [
      "let { arithmetic-seq } = import(\\"Number-Theory\\");\\narithmetic-seq(3, 2, 2)",
      "let { arithmetic-seq } = import(\\"Number-Theory\\");\\narithmetic-seq(2, 3, 2)",
      "let { arithmetic-seq } = import(\\"Number-Theory\\");\\narithmetic-seq(1, 2, 2)",
      "let { arithmetic-seq } = import(\\"Number-Theory\\");\\narithmetic-seq(1, 1.5, 12)"
    ]
  },
  "Number-Theory.arithmetic-take-while": {
    "title": "Number-Theory.arithmetic-take-while",
    "category": "Number Theory",
    "description": "Generates the arithmetic sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "start": {
        "type": "number",
        "description": "The starting term of the sequence."
      },
      "step": {
        "type": "number",
        "description": "The common difference of the sequence."
      },
      "takeWhile": {
        "type": "function",
        "description": "A function that takes a number and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start",
          "step",
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { arithmetic-take-while } = import(\\"Number-Theory\\");\\narithmetic-take-while(1, 0.25, -> $ < 3)"
    ]
  },
  "Number-Theory.arithmetic-nth": {
    "title": "Number-Theory.arithmetic-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the arithmetic sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "start": {
        "type": "number",
        "description": "The starting term of the sequence."
      },
      "step": {
        "type": "number",
        "description": "The common difference of the sequence."
      },
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start",
          "step",
          "n"
        ]
      }
    ],
    "examples": [
      "let { arithmetic-nth } = import(\\"Number-Theory\\");\\narithmetic-nth(3, 2, 2)",
      "let { arithmetic-nth } = import(\\"Number-Theory\\");\\narithmetic-nth(2, 3, 2)",
      "let { arithmetic-nth } = import(\\"Number-Theory\\");\\narithmetic-nth(1, 2, 2)",
      "let { arithmetic-nth } = import(\\"Number-Theory\\");\\narithmetic-nth(1, 1.5, 12)"
    ]
  },
  "Number-Theory.arithmetic?": {
    "title": "Number-Theory.arithmetic?",
    "category": "Number Theory",
    "description": "Checks if a number is part of the arithmetic sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "start": {
        "type": "number",
        "description": "The starting term of the sequence."
      },
      "step": {
        "type": "number",
        "description": "The common difference of the sequence."
      },
      "n": {
        "type": "integer",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start",
          "step",
          "n"
        ]
      }
    ],
    "examples": [
      "let { arithmetic? } = import(\\"Number-Theory\\");\\narithmetic?(3, 2, 2)",
      "let { arithmetic? } = import(\\"Number-Theory\\");\\narithmetic?(2, 3, 2)",
      "let { arithmetic? } = import(\\"Number-Theory\\");\\narithmetic?(1, 2, 2)",
      "let { arithmetic? } = import(\\"Number-Theory\\");\\narithmetic?(1, 1.5, 12)"
    ]
  },
  "Number-Theory.bernoulli-seq": {
    "title": "Number-Theory.bernoulli-seq",
    "category": "Number Theory",
    "description": "Generates the Bernoulli sequence up to a specified length.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "length"
        ]
      }
    ],
    "examples": [
      "let { bernoulli-seq } = import(\\"Number-Theory\\");\\nbernoulli-seq(5)",
      "let { bernoulli-seq } = import(\\"Number-Theory\\");\\nbernoulli-seq(10)"
    ]
  },
  "Number-Theory.bernoulli-nth": {
    "title": "Number-Theory.bernoulli-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the Bernoulli sequence.",
    "returns": {
      "type": "number"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { bernoulli-nth } = import(\\"Number-Theory\\");\\nbernoulli-nth(5)",
      "let { bernoulli-nth } = import(\\"Number-Theory\\");\\nbernoulli-nth(10)",
      "let { bernoulli-nth } = import(\\"Number-Theory\\");\\nbernoulli-nth(23)"
    ]
  },
  "Number-Theory.bernoulli-take-while": {
    "title": "Number-Theory.bernoulli-take-while",
    "category": "Number Theory",
    "description": "Generates the Bernoulli sequence while a condition is met.",
    "returns": {
      "type": "number",
      "array": true
    },
    "args": {
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { bernoulli-take-while } = import(\\"Number-Theory\\");\\nbernoulli-take-while(-> abs($) < 100)"
    ]
  },
  "Number-Theory.geometric-seq": {
    "title": "Number-Theory.geometric-seq",
    "category": "Number Theory",
    "description": "Generates the geometric sequence for a given $start, $ratio, and $length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "start": {
        "type": "number",
        "description": "The starting term of the sequence."
      },
      "ratio": {
        "type": "number",
        "description": "The common ratio of the sequence."
      },
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start",
          "ratio",
          "length"
        ]
      }
    ],
    "examples": [
      "let { geometric-seq } = import(\\"Number-Theory\\");\\ngeometric-seq(3, 2, 2)",
      "let { geometric-seq } = import(\\"Number-Theory\\");\\ngeometric-seq(2, 3, 2)",
      "let { geometric-seq } = import(\\"Number-Theory\\");\\ngeometric-seq(1, 2, 2)",
      "let { geometric-seq } = import(\\"Number-Theory\\");\\ngeometric-seq(1, 1.5, 12)"
    ]
  },
  "Number-Theory.geometric-take-while": {
    "title": "Number-Theory.geometric-take-while",
    "category": "Number Theory",
    "description": "Generates the geometric sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "start": {
        "type": "number",
        "description": "The starting term of the sequence."
      },
      "ratio": {
        "type": "number",
        "description": "The common ratio of the sequence."
      },
      "takeWhile": {
        "type": "function",
        "description": "A function that takes a number and an index and returns a boolean."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start",
          "ratio",
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { geometric-take-while } = import(\\"Number-Theory\\");\\ngeometric-take-while(1, 1.5, -> $ < 10)"
    ]
  },
  "Number-Theory.geometric-nth": {
    "title": "Number-Theory.geometric-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the geometric sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "start": {
        "type": "number",
        "description": "The starting term of the sequence."
      },
      "ratio": {
        "type": "number",
        "description": "The common ratio of the sequence."
      },
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start",
          "ratio",
          "n"
        ]
      }
    ],
    "examples": [
      "let { geometric-nth } = import(\\"Number-Theory\\");\\ngeometric-nth(3, 2, 2)",
      "let { geometric-nth } = import(\\"Number-Theory\\");\\ngeometric-nth(2, 3, 2)",
      "let { geometric-nth } = import(\\"Number-Theory\\");\\ngeometric-nth(1, 2, 2)",
      "let { geometric-nth } = import(\\"Number-Theory\\");\\ngeometric-nth(1, 1.5, 4)"
    ]
  },
  "Number-Theory.geometric?": {
    "title": "Number-Theory.geometric?",
    "category": "Number Theory",
    "description": "Checks if a number is in the geometric sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "start": {
        "type": "number",
        "description": "The starting term of the sequence."
      },
      "ratio": {
        "type": "number",
        "description": "The common ratio of the sequence."
      },
      "n": {
        "type": "number",
        "description": "The number to check."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "start",
          "ratio",
          "n"
        ]
      }
    ],
    "examples": [
      "let { geometric? } = import(\\"Number-Theory\\");\\ngeometric?(1, 2, 1)",
      "let { geometric? } = import(\\"Number-Theory\\");\\ngeometric?(2, 3, 2)",
      "let { geometric? } = import(\\"Number-Theory\\");\\ngeometric?(3, 2, 2)",
      "let { geometric? } = import(\\"Number-Theory\\");\\ngeometric?(1, 1.5, 2.25)",
      "let { geometric? } = import(\\"Number-Theory\\");\\ngeometric?(1, 1.5, -4)"
    ]
  },
  "Number-Theory.polygonal-seq": {
    "title": "Number-Theory.polygonal-seq",
    "category": "Number Theory",
    "description": "Generates the polygonal sequence for a given number of sides and length.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "sides": {
        "type": "integer",
        "description": "The number of sides of the polygon."
      },
      "length": {
        "type": "integer",
        "description": "The length of the sequence to generate."
      },
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "sides",
          "length"
        ]
      }
    ],
    "examples": [
      "let { polygonal-seq } = import(\\"Number-Theory\\");\\npolygonal-seq(3, 2)",
      "let { polygonal-seq } = import(\\"Number-Theory\\");\\npolygonal-seq(4, 2)",
      "let { polygonal-seq } = import(\\"Number-Theory\\");\\npolygonal-seq(5, 3)",
      "let { polygonal-seq } = import(\\"Number-Theory\\");\\npolygonal-seq(6, 5)",
      "let { polygonal-seq } = import(\\"Number-Theory\\");\\npolygonal-seq(100, 10)"
    ]
  },
  "Number-Theory.polygonal-take-while": {
    "title": "Number-Theory.polygonal-take-while",
    "category": "Number Theory",
    "description": "Generates the polygonal sequence while a condition is met.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "sides": {
        "type": "integer",
        "description": "The number of sides of the polygon."
      },
      "takeWhile": {
        "type": "function",
        "description": "A function that takes an integer and an index and returns a boolean."
      },
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "function"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "sides",
          "takeWhile"
        ]
      }
    ],
    "examples": [
      "let { polygonal-take-while } = import(\\"Number-Theory\\");\\npolygonal-take-while(15, -> $ < 1000)"
    ]
  },
  "Number-Theory.polygonal-nth": {
    "title": "Number-Theory.polygonal-nth",
    "category": "Number Theory",
    "description": "Generates the nth term of the polygonal sequence.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "sides": {
        "type": "integer",
        "description": "The number of sides of the polygon."
      },
      "n": {
        "type": "integer",
        "description": "The index of the term to generate."
      },
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "sides",
          "n"
        ]
      }
    ],
    "examples": [
      "let { polygonal-nth } = import(\\"Number-Theory\\");\\npolygonal-nth(3, 9)",
      "let { polygonal-nth } = import(\\"Number-Theory\\");\\npolygonal-nth(4, 5)",
      "let { polygonal-nth } = import(\\"Number-Theory\\");\\npolygonal-nth(5, 5)"
    ]
  },
  "Number-Theory.polygonal?": {
    "title": "Number-Theory.polygonal?",
    "category": "Number Theory",
    "description": "Checks if a number is in the polygonal sequence.",
    "returns": {
      "type": "boolean"
    },
    "args": {
      "sides": {
        "type": "integer",
        "description": "The number of sides of the polygon."
      },
      "n": {
        "type": "integer",
        "description": "The number to check."
      },
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "sides",
          "n"
        ]
      }
    ],
    "examples": [
      "let { polygonal? } = import(\\"Number-Theory\\");\\npolygonal?(3, 10)",
      "let { polygonal? } = import(\\"Number-Theory\\");\\npolygonal?(3, 9)",
      "let { polygonal? } = import(\\"Number-Theory\\");\\npolygonal?(4, 10000)",
      "let { polygonal? } = import(\\"Number-Theory\\");\\npolygonal?(4, 1000)",
      "let { polygonal? } = import(\\"Number-Theory\\");\\npolygonal?(6, 45)"
    ]
  },
  "Number-Theory.factorial": {
    "title": "Number-Theory.factorial",
    "category": "Number Theory",
    "description": "Calculates the factorial of a number.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to calculate the factorial for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { factorial } = import(\\"Number-Theory\\");\\nfactorial(5)",
      "let { factorial } = import(\\"Number-Theory\\");\\nfactorial(0)",
      "let { factorial } = import(\\"Number-Theory\\");\\nfactorial(10)",
      "let { factorial } = import(\\"Number-Theory\\");\\nfactorial(20)"
    ]
  },
  "Number-Theory.divisors": {
    "title": "Number-Theory.divisors",
    "category": "Number Theory",
    "description": "Returns the divisors of a number.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to find divisors for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { divisors } = import(\\"Number-Theory\\");\\ndivisors(12)",
      "let { divisors } = import(\\"Number-Theory\\");\\ndivisors(100)",
      "let { divisors } = import(\\"Number-Theory\\");\\ndivisors(37)"
    ]
  },
  "Number-Theory.count-divisors": {
    "title": "Number-Theory.count-divisors",
    "category": "Number Theory",
    "description": "Returns the number of divisors of a number.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to count divisors for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { count-divisors } = import(\\"Number-Theory\\");\\ncount-divisors(12)",
      "let { count-divisors } = import(\\"Number-Theory\\");\\ncount-divisors(100)",
      "let { count-divisors } = import(\\"Number-Theory\\");\\ncount-divisors(37)"
    ]
  },
  "Number-Theory.proper-divisors": {
    "title": "Number-Theory.proper-divisors",
    "category": "Number Theory",
    "description": "Returns the proper divisors of a number.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to find proper divisors for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { proper-divisors } = import(\\"Number-Theory\\");\\nproper-divisors(12)",
      "let { proper-divisors } = import(\\"Number-Theory\\");\\nproper-divisors(100)",
      "let { proper-divisors } = import(\\"Number-Theory\\");\\nproper-divisors(37)"
    ]
  },
  "Number-Theory.count-proper-divisors": {
    "title": "Number-Theory.count-proper-divisors",
    "category": "Number Theory",
    "description": "Returns the number of proper divisors of a number.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to count proper divisors for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { count-proper-divisors } = import(\\"Number-Theory\\");\\ncount-proper-divisors(12)",
      "let { count-proper-divisors } = import(\\"Number-Theory\\");\\ncount-proper-divisors(100)",
      "let { count-proper-divisors } = import(\\"Number-Theory\\");\\ncount-proper-divisors(37)"
    ]
  },
  "Number-Theory.combinations": {
    "title": "Number-Theory.combinations",
    "category": "Number Theory",
    "description": "Generates all possible combinations of a specified size from a collection.",
    "returns": {
      "type": "array",
      "array": true
    },
    "args": {
      "set": {
        "type": "array",
        "array": true,
        "description": "The input collection to generate combinations from."
      },
      "n": {
        "type": "integer",
        "description": "The size of each combination."
      },
      "a": {
        "type": "array"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "set",
          "n"
        ]
      }
    ],
    "examples": [
      "let { combinations } = import(\\"Number-Theory\\");\\ncombinations([1, 2, 3], 2)",
      "let { combinations } = import(\\"Number-Theory\\");\\ncombinations([\\"a\\", \\"b\\", \\"c\\"], 2)",
      "let { combinations } = import(\\"Number-Theory\\");\\ncombinations([1, 2, 3], 0)",
      "let { combinations } = import(\\"Number-Theory\\");\\ncombinations([1, 2, 3], 1)",
      "let { combinations } = import(\\"Number-Theory\\");\\ncombinations([1, 2, 3], 3)"
    ]
  },
  "Number-Theory.count-combinations": {
    "title": "Number-Theory.count-combinations",
    "category": "Number Theory",
    "description": "Calculates the number of combinations of n items taken k at a time.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { count-combinations } = import(\\"Number-Theory\\");\\ncount-combinations(5, 3)",
      "let { count-combinations } = import(\\"Number-Theory\\");\\ncount-combinations(10, 2)"
    ]
  },
  "Number-Theory.permutations": {
    "title": "Number-Theory.permutations",
    "category": "Number Theory",
    "description": "Generates all permutations of a collection.",
    "returns": {
      "type": "array",
      "array": true
    },
    "args": {
      "set": {
        "type": "array",
        "array": true,
        "description": "The input collection to generate permutations from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "set"
        ]
      }
    ],
    "examples": [
      "let { permutations } = import(\\"Number-Theory\\");\\npermutations([1, 2, 3])",
      "let { permutations } = import(\\"Number-Theory\\");\\npermutations([\\"a\\", \\"b\\", \\"c\\"])",
      "let { permutations } = import(\\"Number-Theory\\");\\npermutations([1, 2, 3, 4])",
      "let { permutations } = import(\\"Number-Theory\\");\\npermutations([1, 2])",
      "let { permutations } = import(\\"Number-Theory\\");\\npermutations([1])",
      "let { permutations } = import(\\"Number-Theory\\");\\npermutations([])"
    ]
  },
  "Number-Theory.count-permutations": {
    "title": "Number-Theory.count-permutations",
    "category": "Number Theory",
    "description": "Returns the number of permutations of n items taken k at a time.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "a": {
        "type": "integer"
      },
      "b": {
        "type": "integer"
      }
    },
    "variants": [
      {
        "argumentNames": [
          "a",
          "b"
        ]
      }
    ],
    "examples": [
      "let { count-permutations } = import(\\"Number-Theory\\");\\ncount-permutations(5, 3)",
      "let { count-permutations } = import(\\"Number-Theory\\");\\ncount-permutations(10, 2)",
      "let { count-permutations } = import(\\"Number-Theory\\");\\ncount-permutations(10, 10)",
      "let { count-permutations } = import(\\"Number-Theory\\");\\ncount-permutations(10, 0)",
      "let { count-permutations } = import(\\"Number-Theory\\");\\ncount-permutations(10, 1)"
    ]
  },
  "Number-Theory.partitions": {
    "title": "Number-Theory.partitions",
    "category": "Number Theory",
    "description": "Generates all partitions of a number.",
    "returns": {
      "type": "array",
      "array": true
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to partition."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { partitions } = import(\\"Number-Theory\\");\\npartitions(4)",
      "let { partitions } = import(\\"Number-Theory\\");\\npartitions(8)"
    ]
  },
  "Number-Theory.count-partitions": {
    "title": "Number-Theory.count-partitions",
    "category": "Number Theory",
    "description": "Returns the number of partitions of a number.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to count partitions for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { count-partitions } = import(\\"Number-Theory\\");\\ncount-partitions(4)",
      "let { count-partitions } = import(\\"Number-Theory\\");\\ncount-partitions(8)",
      "let { count-partitions } = import(\\"Number-Theory\\");\\ncount-partitions(15)"
    ]
  },
  "Number-Theory.prime-factors": {
    "title": "Number-Theory.prime-factors",
    "category": "Number Theory",
    "description": "Returns the prime factors of a number.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to factor."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { prime-factors } = import(\\"Number-Theory\\");\\nprime-factors(12)",
      "let { prime-factors } = import(\\"Number-Theory\\");\\nprime-factors(100)",
      "let { prime-factors } = import(\\"Number-Theory\\");\\nprime-factors(37)"
    ]
  },
  "Number-Theory.distinct-prime-factors": {
    "title": "Number-Theory.distinct-prime-factors",
    "category": "Number Theory",
    "description": "Returns the distinct prime factors of a number.",
    "returns": {
      "type": "integer",
      "array": true
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to find distinct prime factors for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { distinct-prime-factors } = import(\\"Number-Theory\\");\\ndistinct-prime-factors(12)",
      "let { distinct-prime-factors } = import(\\"Number-Theory\\");\\ndistinct-prime-factors(100)",
      "let { distinct-prime-factors } = import(\\"Number-Theory\\");\\ndistinct-prime-factors(37)"
    ]
  },
  "Number-Theory.count-prime-factors": {
    "title": "Number-Theory.count-prime-factors",
    "category": "Number Theory",
    "description": "Returns the number of prime factors of a number.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to count prime factors for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { count-prime-factors } = import(\\"Number-Theory\\");\\ncount-prime-factors(12)",
      "let { count-prime-factors } = import(\\"Number-Theory\\");\\ncount-prime-factors(100)",
      "let { count-prime-factors } = import(\\"Number-Theory\\");\\ncount-prime-factors(37)"
    ]
  },
  "Number-Theory.count-distinct-prime-factors": {
    "title": "Number-Theory.count-distinct-prime-factors",
    "category": "Number Theory",
    "description": "Returns the number of distinct prime factors of a number.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The number to count distinct prime factors for."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { count-distinct-prime-factors } = import(\\"Number-Theory\\");\\ncount-distinct-prime-factors(12)",
      "let { count-distinct-prime-factors } = import(\\"Number-Theory\\");\\ncount-distinct-prime-factors(100)",
      "let { count-distinct-prime-factors } = import(\\"Number-Theory\\");\\ncount-distinct-prime-factors(37)"
    ]
  },
  "Number-Theory.derangements": {
    "title": "Number-Theory.derangements",
    "category": "Number Theory",
    "description": "Generates all derangements (permutations where no element appears in its original position) of a set.",
    "returns": {
      "type": "array",
      "array": true
    },
    "args": {
      "set": {
        "type": "array",
        "array": true,
        "description": "The input collection to generate derangements from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "set"
        ]
      }
    ],
    "examples": [
      "let { derangements } = import(\\"Number-Theory\\");\\nderangements([1, 2, 3, 4])",
      "let { derangements } = import(\\"Number-Theory\\");\\nderangements([\\"a\\", \\"b\\", \\"c\\"])"
    ]
  },
  "Number-Theory.count-derangements": {
    "title": "Number-Theory.count-derangements",
    "category": "Number Theory",
    "description": "Calculates the number of derangements (permutations where no element appears in its original position) of n items.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The total number of items."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { count-derangements } = import(\\"Number-Theory\\");\\ncount-derangements(4)",
      "let { count-derangements } = import(\\"Number-Theory\\");\\ncount-derangements(5)"
    ]
  },
  "Number-Theory.power-set": {
    "title": "Number-Theory.power-set",
    "category": "Number Theory",
    "description": "Generates the power set of a collection.",
    "returns": {
      "type": "array",
      "array": true
    },
    "args": {
      "set": {
        "type": "any",
        "array": true,
        "description": "The input collection to generate the power set from."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "set"
        ]
      }
    ],
    "examples": [
      "let { power-set } = import(\\"Number-Theory\\");\\npower-set([\\"a\\", \\"b\\", \\"c\\"])",
      "let { power-set } = import(\\"Number-Theory\\");\\npower-set([1, 2])",
      "let { power-set } = import(\\"Number-Theory\\");\\npower-set([1])",
      "let { power-set } = import(\\"Number-Theory\\");\\npower-set([])"
    ]
  },
  "Number-Theory.count-power-set": {
    "title": "Number-Theory.count-power-set",
    "category": "Number Theory",
    "description": "Returns the number of subsets of a set.",
    "returns": {
      "type": "integer"
    },
    "args": {
      "n": {
        "type": "integer",
        "description": "The size of the set."
      }
    },
    "variants": [
      {
        "argumentNames": [
          "n"
        ]
      }
    ],
    "examples": [
      "let { count-power-set } = import(\\"Number-Theory\\");\\ncount-power-set(3)",
      "let { count-power-set } = import(\\"Number-Theory\\");\\ncount-power-set(5)",
      "let { count-power-set } = import(\\"Number-Theory\\");\\ncount-power-set(10)"
    ]
  }
}"
`;
